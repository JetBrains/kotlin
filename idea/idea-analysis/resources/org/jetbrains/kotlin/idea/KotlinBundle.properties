fix.insert.delegation.call=Insert ''{0}()'' call
fix.introduce.non.null.assertion=Add non-null asserted (!!) call
fix.remove.non.null.assertion=Remove unnecessary non-null assertion (!!)
fix.add.annotation.target=Add annotation target
fix.add.const.modifier=Add ''const'' modifier
fix.add.constructor.parameter=Add constructor parameter ''{0}''
fix.make.data.class=Make ''{0}'' a ''data'' class
fix.add.default.constructor=Add default constructor to ''expect'' class
fix.add.explicit.import=Add explicit import
fix.add.function.body=Add function body
fix.add.is.to.when=Add ''is'' before ''{0}''
fix.add.new.line.after.annotations=Add new line after annotations
fix.make.type.parameter.reified=Make {0} reified and {1} inline
fix.add.return.last.expression=Add ''return'' to last expression
fix.add.return.before.expression=Add ''return'' before the expression
fix.add.return.before.lambda.expression=Add ''run'' before the lambda expression
fix.add.semicolon.lambda.expression=Terminate preceding call with semicolon
fix.add.spread.operator.after.sam=Add a spread operator before an array passing as ''vararg''
fix.add.else.branch.when=Add else branch
fix.replace.with.assign.function.call=Replace with ''{0}'' call
fix.assign.to.property=Assign to property
fix.change.mutability.change.to.val=Change ''{0}'' to ''val''
fix.change.type.argument=Change type argument to {0}
fix.change.to.function.invocation=Change to function invocation
fix.change.to.mutable.type=Change type to {0}

fix.change.to.property.access.family.remove=Remove invocation
fix.change.to.property.access.family.change=Change to property access

fix.change.to.labeled.return.family=Change to return with label
fix.change.to.labeled.return.text=Change to ''{0}''

fix.change.suspend.hierarchy.add=Add ''suspend'' modifier to all functions in hierarchy
fix.change.suspend.hierarchy.remove=Remove ''suspend'' modifier from all functions in hierarchy
fix.change.progress.looking.inheritors=Looking for class {0} inheritors…
fix.change.progress.analyzing.class.hierarchy=Analyzing class hierarchy…

fix.change.return.type.family=Change type
fix.change.return.type.text.primary.constructor=Change parameter ''{0}'' type of primary constructor of class ''{1}'' to ''{2}''
fix.change.return.type.text.function=Change parameter ''{0}'' type of function of class ''{1}'' to ''{2}''
fix.change.return.type.lambda=Change lambda expression return type to {0}
fix.change.return.type.remove.explicit.return.type=Remove explicitly specified return type
fix.change.return.type.remove.explicit.return.type.of=Remove explicitly specified return type of {0}
fix.change.return.type.return.type.text=Change return type to ''{0}''
fix.change.return.type.return.type.text.of=Change return type of {0} to ''{1}''
fix.change.return.type.type.text=Change type to ''{0}''
fix.change.return.type.type.text.of=Change type of {0} to ''{1}''
fix.change.return.type.presentation.property=property {0}
fix.change.return.type.presentation.function=function {0}
fix.change.return.type.presentation.enclosing.function=enclosing function
fix.change.return.type.presentation.enclosing=enclosing {0}
fix.change.return.type.presentation.called.function=called function
fix.change.return.type.presentation.accessed=accessed {0}
fix.change.return.type.presentation.called=called {0}
fix.change.return.type.presentation.base=base {0}

fix.cast.expression.family=Cast expression
fix.cast.expression.text=Cast expression ''{0}'' to ''{1}''

fix.change.accessor.family=Change accessor type
fix.change.accessor.getter=Change getter type to {0}
fix.change.accessor.setter.parameter=Change setter parameter type to {0}

fix.create.from.usage.dialog.title=Create from usage

fix.add.remaining.branches=Add remaining branches
fix.add.remaining.branches.with.star.import=Add remaining branches with * import

fix.add.type.annnotation.family=Add type annotation
fix.add.type.annnotation.text=Add type ''{0}'' to parameter ''{1}''

fix.add.tostring.call.family=Add ''toString()'' call
fix.add.tostring.call.text=Add ''toString()'' call
fix.add.tostring.call.text.safe=Add safe ''?.toString()'' call

fix.add.star.projection.family=Add star projections
fix.add.star.projection.text=Add ''{0}''

fix.change.to.star.projection.family=Change to star projection
fix.change.to.star.projection.text=Change type arguments to {0}

fix.change.to.use.spread.operator.family=Change to use spread operator
fix.change.to.use.spread.operator.text=Change ''{0}'' to ''{0}''

fix.change.type.family=Change type
fix.change.type.text=Change type from ''{0}'' to ''{1}''

fix.add.suspend.modifier.function=Make {0} suspend
fix.add.suspend.modifier.function.generic=Make containing function suspend
fix.add.suspend.modifier.receiver=Make {0} type suspend
fix.add.suspend.modifier.receiver.generic=Make receiver type suspend

fix.add.property.to.supertype.family=Add property to supertype
fix.add.property.to.supertype.text=Add ''{0}'' to ''{1}''
fix.add.property.to.supertype.text.generic=Add property to supertype…
fix.add.property.to.supertype.progress=Add property to type
fix.add.property.to.supertype.choose.type=Choose Type

fix.add.function.parameters.change.signature.constructor=Change the signature of constructor ''{0}''
fix.add.function.parameters.change.signature.function=Change the signature of function ''{0}''
fix.add.function.parameters.add.parameter.constructor=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters to constructor {2}
fix.add.function.parameters.add.parameter.function=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters to function {2}
fix.add.function.parameters.add.parameter.generic.constructor=Add parameter to constructor {0}
fix.add.function.parameters.add.parameter.generic.function=Add parameter to function {0}

fix.change.signature.family=Change signature of function/constructor
fix.change.signature.function.family=Change function signature
fix.change.signature.function.text=Change function signature to ''{0}''
fix.change.signature.function.text.generic=Change function signature…
fix.change.signature.function.popup.title=Choose Signature
fix.change.signature.lambda=Change the signature of lambda expression
fix.change.signature.remove.parameter=Remove parameter ''{0}''
fix.change.signature.unavailable=<not available>
fix.change.signature.error=<error>
fix.change.signature.unnamed.parameter=parameter

fix.change.object.to.class=Change ''object'' to ''class''

fix.add.function.supertype.family=Add function to supertype
fix.add.function.supertype.text=Add function to supertype…
fix.add.function.supertype.progress=Add Function to Type
fix.add.function.supertype.choose.type=Choose Type
fix.add.function.supertype.add.to=Add ''{0}'' to ''{1}''

fix.add.generic.upperbound.text=Add ''{0}'' as upper bound for {1}
fix.add.generic.upperbound.family=Add generic upper bound

fix.add.modifier.inline.parameter.family=Add ''{0}'' to parameter
fix.add.modifier.inline.parameter.text=Add ''{0}'' to parameter ''{1}''

fix.add.modifier.inline.function.family=Add ''inline'' to function
fix.add.modifier.inline.function.text=Add ''inline'' to function ''{0}''

fix.add.array.of.type.text=Add {0} wrapper
fix.add.array.of.type.family=Add ''arrayOf'' wrapper

fix.add.loop.label.text.generic=Add label to loop
fix.add.loop.label.text=Add ''{0}'' to {1}

fix.add.modifier.family=Add modifier
fix.add.modifier.text=Make {0} ''{1}''
fix.add.modifier.text.generic=Add ''{0}'' modifier

fix.add.argument.name.family=Add name to argument
fix.add.argument.name.text.generic=Add name to argument…
fix.add.argument.name.text=Add name to argument: {0}
fix.add.argument.name.step.choose.parameter.name=Choose parameter name

fix.change.feature.support.family=Enable/Disable {0} support
fix.change.feature.support.enabled=Enable {0} support
fix.change.feature.support.enabled.warning=Enable {0} support (with warning)
fix.change.feature.support.disabled=Disable {0} support

fix.create.expect.actual=Create expect / actual declaration
fix.create.missing.actual.members=Add missing actual members

fix.create.declaration.error=Can not generate {0}: {1}
fix.create.declaration.error.inaccessible.type=Inaccessible type
fix.create.declaration.error.some.types.inaccessible=Some types are not accessible:

fix.add.annotation.family=Add annotation
fix.add.annotation.text.self=Add ''{0}'' annotation
fix.add.annotation.text.declaration=Add ''{0}'' annotation to {1}
fix.add.annotation.text.containing.class=Add ''{0}'' annotation to containing class {1}

fix.import=Import
fix.import.kind.delegate.accessors=Delegate accessors
fix.import.kind.component.functions=Component functions
fix.import.exclude=Exclude ''{0}'' from auto-import

action.add.import.chooser.title=Imports

goto.super.chooser.function.title=Choose super function
goto.super.chooser.property.title=Choose super property
goto.super.chooser.class.title=Choose super class or interface

inspection.unused.receiver.parameter=Receiver parameter is never used
fix.unused.receiver.parameter.remove=Remove redundant receiver parameter

inspection.migration.title=Code Migration
inspection.migration.profile.name=Migration

options.color.attribute.descriptor.annotation=Annotation//Annotation name
options.color.attribute.descriptor.annotation.attribute.name=Annotation//Annotation attribute name
options.color.attribute.descriptor.builtin.annotation=Keywords//Modifier
options.color.attribute.descriptor.builtin.keyword.val=Keywords//'val'
options.color.attribute.descriptor.builtin.keyword.var=Keywords//'var'
options.color.attribute.descriptor.builtin.keyword=Keywords//Keyword
options.color.attribute.descriptor.string.escape=String//Escape in string and template braces
options.color.attribute.descriptor.closure.braces=Braces and Operators//Lambda expression braces and arrow
options.color.attribute.descriptor.safe.access=Braces and Operators//Safe access dot
options.color.attribute.descriptor.quest=Braces and Operators//Type nullability marker
options.color.attribute.descriptor.exclexcl=Braces and Operators//Non-null assertion
options.color.attribute.descriptor.arrow=Braces and Operators//Arrow
options.color.attribute.descriptor.colon=Braces and Operators//Colon
options.color.attribute.descriptor.double.colon=Braces and Operators//Double colon
options.color.attribute.descriptor.kdoc.comment=Comments//KDoc//KDoc comment
options.color.attribute.descriptor.kdoc.tag=Comments//KDoc//KDoc tag
options.color.attribute.descriptor.kdoc.value=Comments//KDoc//Link in KDoc tag
options.color.attribute.descriptor.object=Classes and Interfaces//Object
options.color.attribute.descriptor.enumEntry=Classes and Interfaces//Enum entry
options.color.attribute.descriptor.typeAlias=Classes and Interfaces//Type alias
options.color.attribute.descriptor.var=Properties and Variables//Var (mutable variable, parameter or property)
options.color.attribute.descriptor.local.variable=Properties and Variables//Local variable or value
options.color.attribute.descriptor.captured.variable=Properties and Variables//Variables and values captured in a closure
options.color.attribute.descriptor.instance.property=Properties and Variables//Instance property
options.color.attribute.descriptor.instance.property.custom.property.declaration=Properties and Variables//Instance property with custom property declarations
options.color.attribute.descriptor.package.property=Properties and Variables//Package-level property
options.color.attribute.descriptor.package.property.custom.property.declaration=Properties and Variables//Package-level property with custom property declarations
options.color.attribute.descriptor.field=Properties and Variables//Backing field variable
options.color.attribute.descriptor.extension.property=Properties and Variables//Extension property
options.color.attribute.descriptor.synthetic.extension.property=Properties and Variables//Synthetic extension property
options.color.attribute.descriptor.dynamic.property=Properties and Variables//Dynamic property
options.color.attribute.descriptor.android.extensions.property=Properties and Variables//Android Extensions synthetic properties
options.color.attribute.descriptor.it=Parameters//Lambda expression default parameter
options.color.attribute.descriptor.fun=Functions//Function declaration
options.color.attribute.descriptor.fun.call=Functions//Function call
options.color.attribute.descriptor.dynamic.fun.call=Functions//Dynamic function call
options.color.attribute.descriptor.package.fun.call=Functions//Package-level function call
options.color.attribute.descriptor.suspend.fun.call=Functions//Suspend function call
options.color.attribute.descriptor.extension.fun.call=Functions//Extension function call
options.color.attribute.descriptor.constructor.call=Functions//Constructor call
options.color.attribute.descriptor.variable.as.function.call=Properties and Variables//Variable as function call
options.color.attribute.descriptor.variable.as.function.like.call=Properties and Variables//Variable as function-like call
options.color.attribute.descriptor.smart.cast=Smart-casts//Smart-cast value
options.color.attribute.descriptor.smart.constant=Smart-casts//Smart constant
options.color.attribute.descriptor.smart.cast.receiver=Smart-casts//Smart-cast implicit receiver
options.color.attribute.descriptor.label=Label

fix.create.from.usage.family=Create from usage
fix.create.from.usage.local.variable=Create local variable ''{0}''

overridden.marker.implementations.multiple=Has implementations
overridden.marker.implementation=Is implemented in <br/>
overridden.marker.overrides.multiple=Is overridden in subclasses
overridden.marker.overrides=Is overridden in <br/>

overridden.marker.implementations.choose.implementation.title=Choose Implementation of {0}
overridden.marker.implementations.choose.implementation.find.usages=Overriding properties of {0}
overridden.marker.overrides.choose.implementation.title=Choose Super Implementation of {0}
overridden.marker.overrides.choose.implementation.find.usages=Super Implementations of {0}

remove.expression = Remove ''{0}''
unwrap.expression = Unwrap ''{0}''
remove.else = Remove else in ''{0}''
unwrap.else = Unwrap else in ''{0}''

override.declaration.x.in.y={0} in {1}
override.declaration.x.implements.y={0} in {1} implements {2} in {3}.
override.declaration.x.overrides.y.in.class.list={0} overrides declarations in the following classes/interfaces: {1} Do you want to {2} the base declarations?

override.declaration.unused.overriding.methods.title=Unused Overriding Members
override.declaration.unused.overriding.methods.description=There are unused members that override methods you delete.
override.declaration.choose.to.delete=Choose the ones you want to be deleted.
override.declaration.member=Member
override.declaration.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?

find.declaration.implementing.methods.checkbox=&Implementing functions
find.declaration.overriding.methods.checkbox=Over&riding functions
find.declaration.implementing.properties.checkbox=&Implementing properties
find.declaration.overriding.properties.checkbox=Over&riding properties
find.declaration.property.readers.checkbox=Readers
find.declaration.property.writers.checkbox=Writers
find.declaration.include.overloaded.methods.checkbox=Include o&verloaded functions and extensions
find.declaration.functions.usages.checkbox=Usages of &functions
find.declaration.properties.usages.checkbox=Usages of &properties
find.declaration.constructor.usages.checkbox=Usages of &constructor
find.declaration.derived.classes.checkbox=&Derived classes
find.declaration.derived.interfaces.checkbox=Derived &interfaces

hierarchy.legend.member.is.defined.in.class=Member is defined in the class
hierarchy.legend.member.defined.in.superclass=Member is not defined in the class but defined in superclass
hierarchy.legend.member.should.be.defined=Member should be defined since the class is not abstract

intention.suppress.family=Suppress Warnings
intention.suppress.text=Suppress ''{0}'' for {1} {2}

kotlin.compiler.option.generate.no.warnings=Report compiler &warnings
kotlin.compiler.option.additional.command.line.parameters=&Additional command line parameters:
kotlin.compiler.option.enable.new.inference.in.ide=Enable new type inference algorithm for IDE analysis

kotlin.compiler.jvm.option.panel.title=Kotlin to JVM

kotlin.compiler.js.option.panel.title=Kotlin to JavaScript
kotlin.compiler.js.option.generate.sourcemaps=Generate &source maps
kotlin.compiler.js.option.output.prefix=File to &prepend to generated code:
kotlin.compiler.js.option.output.postfix=File to append to generated c&ode:
kotlin.compiler.js.option.output.copy.files=&Copy library runtime fileskotlin.compiler.js.option.output.copy.dir=O&utput directory for library &runtime files:

# Android Lint
android.klint.inspections.group.name=Android Lint for Kotlin

# Scratch Files
scratch.run.button=Run Scratch File
scratch.run.from.here.button=Run Scratch From Here
scratch.stop.button=Stop scratch execution
scratch.clear.button=Clear results
scratch.module.combobox=Use classpath of module
scratch.is.repl.checkbox=Use REPL
scratch.is.repl.checkbox.description=Runs in the Kotlin REPL. Executes only the new expressions added to the end of the scratch
scratch.is.interactive.checkbox=Interactive mode
scratch.is.interactive.checkbox.description=Runs after you stop typing for {0} seconds
scratch.make.before.run.checkbox=Make module before Run
scratch.make.before.run.checkbox.description=Make module {0} before running scratch. Only compiled code is reachable from this scope
scratch.inlay.output.mode=Inlay output mode\n\nThe output is shown in the code editor right next to the expression. Well suited for a short single-line output.
scratch.side.panel.output.mode.description=Side panel output mode
scratch.side.panel.output.mode=Side panel output mode\n\nThe output is shown in the separate panel. Useful if the output is long or multi-line.
scratch.inlay.output.mode.description=Inlay output mode

# Code insight
dialog.import.on.paste.title3=Select Import to Remove
copy.paste.reference.notification=<html>{0} {0, choice, 1#import was|2#imports were} added<p><span><a href='show'>Review Added Imports...</a></span></html>

# Experimental features
experimental.ml.completion=ML Completion for Kotlin


plugin.verifier.compatibility.issue.title=Compatibility issue
plugin.verifier.compatibility.issue.message=Installed Kotlin plugin version ({0}) is not compatible with {1}.\nSome functionality may be broken.\n\nPlease reinstall the Kotlin plugin.

plugin.updater.notification.group=Kotlin plugin updates
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=A new version {0} of the Kotlin plugin is available. <b><a href="#">Install</a></b>
plugin.updater.downloading=Downloading plugins
plugin.updater.not.installed=Plugin update was not installed. <a href="#">See the log for more information</a>
plugin.updater.not.installed.misc=Plugin update was not installed: {0}. <a href="#">See the log for more information</a>
plugin.updater.error.check.failed=Kotlin plugin update check failed
plugin.updater.error.unexpected.repository.response=Unexpected plugin repository response
plugin.updater.error.cant.find.plugin.version=Couldn't find plugin version in repository response
plugin.updater.error.custom.repository=Checking custom plugin repository {0} failed

quick.doc.text.enum.ordinal=Enum constant ordinal: {0}
quick.doc.text.tailrec=''tailrec'' marks a function as <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">tail-recursive</a> (allowing the compiler to replace recursion with iteration)
quick.doc.text.lateinit=''lateinit'' allows initializing a <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">not-null property outside of a constructor</a>
quick.doc.no.documentation=No documentation available
quick.doc.section.deprecated=Deprecated:
quick.doc.section.replace.with=Replace with:
quick.doc.section.java.declaration=Java declaration:

action.decompile.java.name=Decompile to Java
action.decompile.busy.text=Kotlin Classfile

action.j2k.name=Convert Java to Kotlin
action.j2k.task.name=Convert files from Java to Kotlin
action.j2k.correction.investigate=Investigate Errors
action.j2k.correction.proceed=Proceed with Conversion
action.j2k.correction.required=Some code in the rest of your project may require corrections after performing this conversion. Do you want to find such code and correct it too?
action.j2k.correction.errors.single=''{0}'' contains syntax errors, the conversion result may be incorrect
action.j2k.correction.errors.multiple=''{0}'' and {1} other Java files contain syntax errors, the conversion result may be incorrect
action.j2k.error.cant.save.result=Failed to save conversion result: {0}
action.j2k.error.cant.find.document=couldn't find document for ''{0}''
action.j2k.error.read.only=file ''{0}'' is read-only
action.j2k.errornothing.to.convert=Nothing to convert:<br>No writable Java files found

formatter.settings.title=Kotlin Formatter Settings

action.generate.functions.already.defined=Functions {0} are already defined for class {1}. Do you want to delete them and proceed?

action.generate.equals.choose.equals=Choose properties to be included in ''equals()''
action.generate.equals.choose.hashcode=Choose properties to be included in ''hashCode()''

action.generate.secondary.constructor.choose.properties=Choose Properties to Initialize by Constructor
action.generate.secondary.constructor.error.already.exists=Constructor already exists

action.generate.test.support.choose.framework=Choose Framework
action.generate.test.support.generate.test.function=Generate test function
action.generate.test.support.choose.test.name=Choose test name:
action.generate.test.support.edit.template=Edit Template
action.generate.test.support.error.no.template.found=No template found for {0}:{1}
action.generate.test.support.error.cant.convert.java.template=Couldn't convert Java template to Kotlin
action.generate.test.support.error.cant.generate.method=Can not generate method: {0}

action.generate.tostring.name=Generate toString()
action.generate.tostring.template.single=Single template
action.generate.tostring.template.multiple=Multiple templates with concatenation
action.generate.tostring.choose.implementation=Choose implementation:
action.generate.tostring.generate.super.call=Generate call to super.toString()

action.new.file.text=Kotlin File/Class
action.new.file.description=Creates new Kotlin file or class
action.new.file.dialog.title=New Kotlin File/Class
action.new.file.dialog.file.title=File
action.new.file.dialog.file.description=Kotlin File
action.new.file.dialog.class.title=Class
action.new.file.dialog.class.description=Kotlin Class
action.new.file.dialog.interface.title=Interface
action.new.file.dialog.interface.description=Kotlin Interface
action.new.file.dialog.enum.title=Enum class
action.new.file.dialog.enum.description=Kotlin Enum
action.new.file.dialog.object.title=Object
action.new.file.dialog.object.description=Kotlin Object
action.new.file.error.empty.name=Name can't be empty
action.new.file.error.empty.name.part=Name can't have empty parts

action.new.script.name=Kotlin Script
action.new.script.description=Creates new Kotlin script
action.new.script.dialog.title=New Kotlin Script
action.new.script.template.name=Kotlin Script

action.new.worksheet.name=Kotlin Worksheet
action.new.worksheet.description=Creates new Kotlin Worksheet
action.new.worksheet.dialog.title=New Kotlin Worksheet
action.new.worksheet.template.name=Kotlin Worksheet

breadcrumbs.tooltip.indexing=Indexing…

copy.paste.resolve.references=Resolve pasted references

type.provider.anonymous.object=anonymous object
type.provider.unknown.type=Type is unknown
type.provider.smart.cast.from=(smart cast from {0})
type.provider.no.expression.found=No expression found

optimize.imports.collect.unused.imports=Collect unused imports
optimize.imports.task.removing.redundant.imports=Removing redundant imports

kdoc.section.title.receiver=Receiver
kdoc.section.title.parameters=Params
kdoc.section.title.returns=Returns
kdoc.section.title.throws=Throws
kdoc.section.title.author=Author
kdoc.section.title.since=Since
kdoc.section.title.samples=Samples
kdoc.section.title.see.also=See Also
kdoc.comment.unresolved=Unresolved

livetemplate.description.main=main() function
livetemplate.description.soutp=Prints function parameter names and values to System.out
livetemplate.description.iter=Iterate over elements of iterable (for-in loop)
livetemplate.description.ifn=Inserts ''if null'' expression
livetemplate.description.inn=Inserts ''if not null'' expression
livetemplate.description.void=Function returning nothing
livetemplate.description.fun0=Function with no parameters
livetemplate.description.fun1=Function with one parameter
livetemplate.description.fun2=Function with two parameters
livetemplate.description.interface=Interface
livetemplate.description.singleton=Singleton
livetemplate.description.closure=Closure (function without name)
livetemplate.description.anonymous=Anonymous class
livetemplate.description.exfun=Extension function
livetemplate.description.exval=Extension read-only property
livetemplate.description.exvar=Extension read-write property

hints.progress.calculating.parameter.info=Calculating parameter info
hints.title.property.type.enabled=Show property type hints
hints.title.property.type.disabled=Do not show property type hints
hints.title.locals.type.enabled=Show local variable type hints
hints.title.locals.type.disabled=Do not show local variable type hints
hints.title.function.type.enabled=Show function return type hints
hints.title.function.type.disabled=Do not show function return type hints
hints.title.parameter.type.enabled=Show parameter type hints
hints.title.parameter.type.disabled=Do not show parameter type hints
hints.title.argument.name.enabled=Show argument name hints
hints.title.argument.name.disabled=Do not show argument name hints
hints.title.return.expression.enabled=Show lambda return expression hints
hints.title.return.expression.disabled=Do not show lambda return expression hints
hints.title.implicit.parameters.enabled=Show hints for implicit receivers and parameters of lambdas
hints.title.implicit.parameters.disabled=Do not show hints for implicit receivers and parameters of lambdas
hints.title.suspend.calls.enabled=Show hints for suspending calls
hints.title.suspend.calls.disabled=Do not show hints for suspending calls

presentation.text.paren=({0})
presentation.text.in.container.paren=(in {0})
presentation.text.in.container={0} in {1}
presentation.text.for.receiver.in.container.paren=(for {0} in {1})
presentation.text.object.in.container=object in {0}

project.view.class.initializer=class initializer
>>>>>>> i18n: Internationalize part of the 'idea' module
