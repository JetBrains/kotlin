package-fragment kotlin

public fun </*0*/ reified T> arrayOfNulls(/*0*/ size: kotlin.Int): kotlin.Array<T?>
public fun kotlin.Any?.identityEquals(/*0*/ other: kotlin.Any?): kotlin.Boolean
public fun kotlin.String?.plus(/*0*/ other: kotlin.Any?): kotlin.String
public fun kotlin.Any?.toString(): kotlin.String

public interface Annotation {
}

public final enum class AnnotationRetention : kotlin.Enum<kotlin.annotation.AnnotationRetention> {
    public enum entry SOURCE : kotlin.annotation.AnnotationRetention {
        /*primary*/ private constructor SOURCE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationRetention): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry BINARY : kotlin.annotation.AnnotationRetention {
        /*primary*/ private constructor BINARY()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationRetention): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry RUNTIME : kotlin.annotation.AnnotationRetention {
        /*primary*/ private constructor RUNTIME()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationRetention): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor AnnotationRetention()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationRetention): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.AnnotationRetention
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.AnnotationRetention>
}

public final enum class AnnotationTarget : kotlin.Enum<kotlin.annotation.AnnotationTarget> {
    public enum entry PACKAGE : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor PACKAGE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry CLASSIFIER : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor CLASSIFIER()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry ANNOTATION_CLASS : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor ANNOTATION_CLASS()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry TYPE_PARAMETER : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor TYPE_PARAMETER()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry PROPERTY : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor PROPERTY()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry FIELD : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor FIELD()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry LOCAL_VARIABLE : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor LOCAL_VARIABLE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry VALUE_PARAMETER : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor VALUE_PARAMETER()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry CONSTRUCTOR : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor CONSTRUCTOR()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry FUNCTION : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor FUNCTION()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry PROPERTY_GETTER : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor PROPERTY_GETTER()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry PROPERTY_SETTER : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor PROPERTY_SETTER()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry TYPE : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor TYPE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry EXPRESSION : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor EXPRESSION()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry FILE : kotlin.annotation.AnnotationTarget {
        /*primary*/ private constructor FILE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor AnnotationTarget()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.AnnotationTarget): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.AnnotationTarget
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.AnnotationTarget>
}

public open class Any {
    /*primary*/ public constructor Any()
}

public final class Array</*0*/ reified T> : kotlin.Cloneable {
    /*primary*/ private constructor Array</*0*/ reified T>()
    public open override /*1*/ fun clone(): kotlin.Array<T>
    public final fun get(/*0*/ index: kotlin.Int): T
    public final fun iterator(): kotlin.Iterator<T>
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: T): kotlin.Unit
    public final fun size(): kotlin.Int
}

public final class Boolean : kotlin.Comparable<kotlin.Boolean> {
    /*primary*/ private constructor Boolean()
    public final fun and(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Boolean): kotlin.Int
    public final fun not(): kotlin.Boolean
    public final fun or(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public final fun xor(/*0*/ other: kotlin.Boolean): kotlin.Boolean
}

public final class BooleanArray : kotlin.Cloneable {
    /*primary*/ public constructor BooleanArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.BooleanArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Boolean
    public final fun iterator(): kotlin.BooleanIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Boolean): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class BooleanIterator : kotlin.Iterator<kotlin.Boolean> {
    /*primary*/ public constructor BooleanIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Boolean
    public abstract fun nextBoolean(): kotlin.Boolean
}

public final class Byte : kotlin.Number, kotlin.Comparable<kotlin.Byte> {
    /*primary*/ private constructor Byte()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Byte
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Byte
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ByteRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ShortRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public companion object Companion : kotlin.IntegerConstants<kotlin.Byte> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Byte
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Byte
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Byte
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Byte
    }
}

public final class ByteArray : kotlin.Cloneable {
    /*primary*/ public constructor ByteArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.ByteArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Byte
    public final fun iterator(): kotlin.ByteIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Byte): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class ByteIterator : kotlin.Iterator<kotlin.Byte> {
    /*primary*/ public constructor ByteIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Byte
    public abstract fun nextByte(): kotlin.Byte
}

public final class ByteProgression : kotlin.Progression<kotlin.Byte> {
    /*primary*/ public constructor ByteProgression(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Byte
        public open override /*1*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Byte
        public open override /*1*/ fun <get-start>(): kotlin.Byte
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ByteIterator
}

internal final class ByteProgressionIterator : kotlin.ByteIterator {
    /*primary*/ public constructor ByteProgressionIterator(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Byte
        private final fun <get-finalElement>(): kotlin.Byte
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Byte
    public open override /*1*/ fun nextByte(): kotlin.Byte
}

public final class ByteRange : kotlin.Range<kotlin.Byte>, kotlin.Progression<kotlin.Byte> {
    /*primary*/ public constructor ByteRange(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte)
    public open override /*2*/ val end: kotlin.Byte
        public open override /*2*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Byte
        public open override /*2*/ fun <get-start>(): kotlin.Byte
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Byte): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ByteIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ByteRange
            public final fun <get-EMPTY>(): kotlin.ByteRange
    }
}

public final class Char : kotlin.Comparable<kotlin.Char> {
    /*primary*/ private constructor Char()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun dec(): kotlin.Char
    public final fun inc(): kotlin.Char
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Char
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Char
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.CharRange
    public open fun toByte(): kotlin.Byte
    public open fun toChar(): kotlin.Char
    public open fun toDouble(): kotlin.Double
    public open fun toFloat(): kotlin.Float
    public open fun toInt(): kotlin.Int
    public open fun toLong(): kotlin.Long
    public open fun toShort(): kotlin.Short

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

public final class CharArray : kotlin.Cloneable {
    /*primary*/ public constructor CharArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.CharArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final fun iterator(): kotlin.CharIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Char): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class CharIterator : kotlin.Iterator<kotlin.Char> {
    /*primary*/ public constructor CharIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Char
    public abstract fun nextChar(): kotlin.Char
}

public final class CharProgression : kotlin.Progression<kotlin.Char> {
    /*primary*/ public constructor CharProgression(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Char
        public open override /*1*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Char
        public open override /*1*/ fun <get-start>(): kotlin.Char
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.CharIterator
}

internal final class CharProgressionIterator : kotlin.CharIterator {
    /*primary*/ public constructor CharProgressionIterator(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Char
        private final fun <get-finalElement>(): kotlin.Char
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Char
    public open override /*1*/ fun nextChar(): kotlin.Char
}

public final class CharRange : kotlin.Range<kotlin.Char>, kotlin.Progression<kotlin.Char> {
    /*primary*/ public constructor CharRange(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char)
    public open override /*2*/ val end: kotlin.Char
        public open override /*2*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Char
        public open override /*2*/ fun <get-start>(): kotlin.Char
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Char): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.CharIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.CharRange
            public final fun <get-EMPTY>(): kotlin.CharRange
    }
}

public interface CharSequence {
    public abstract fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
    public abstract fun length(): kotlin.Int
    public abstract fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence
}

public interface Cloneable {
    protected open fun clone(): kotlin.Any
}

public interface Collection</*0*/ out E> : kotlin.Iterable<E> {
    public abstract fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract fun size(): kotlin.Int
}

public interface Comparable</*0*/ in T> {
    public abstract fun compareTo(/*0*/ other: T): kotlin.Int
}

public final class Double : kotlin.Number, kotlin.Comparable<kotlin.Double> {
    /*primary*/ private constructor Double()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun inc(): kotlin.Double
    public final fun minus(): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun plus(): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.DoubleRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Double
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public companion object Companion : kotlin.FloatingPointConstants<kotlin.Double> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Double
    }
}

public final class DoubleArray : kotlin.Cloneable {
    /*primary*/ public constructor DoubleArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.DoubleArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Double
    public final fun iterator(): kotlin.DoubleIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Double): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class DoubleIterator : kotlin.Iterator<kotlin.Double> {
    /*primary*/ public constructor DoubleIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Double
    public abstract fun nextDouble(): kotlin.Double
}

public final class DoubleProgression : kotlin.Progression<kotlin.Double> {
    /*primary*/ public constructor DoubleProgression(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double, /*2*/ increment: kotlin.Double)
    public open override /*1*/ val end: kotlin.Double
        public open override /*1*/ fun <get-end>(): kotlin.Double
    public open override /*1*/ val increment: kotlin.Double
        public open override /*1*/ fun <get-increment>(): kotlin.Double
    public open override /*1*/ val start: kotlin.Double
        public open override /*1*/ fun <get-start>(): kotlin.Double
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.DoubleIterator
}

internal final class DoubleProgressionIterator : kotlin.DoubleIterator {
    /*primary*/ public constructor DoubleProgressionIterator(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double, /*2*/ increment: kotlin.Double)
    internal final val end: kotlin.Double
        internal final fun <get-end>(): kotlin.Double
    internal final val increment: kotlin.Double
        internal final fun <get-increment>(): kotlin.Double
    private final var next: kotlin.Double
        private final fun <get-next>(): kotlin.Double
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Double): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Double
    public open override /*1*/ fun nextDouble(): kotlin.Double
}

public final class DoubleRange : kotlin.Range<kotlin.Double>, kotlin.Progression<kotlin.Double> {
    /*primary*/ public constructor DoubleRange(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double)
    public open override /*2*/ val end: kotlin.Double
        public open override /*2*/ fun <get-end>(): kotlin.Double
    public open override /*1*/ val increment: kotlin.Double
        public open override /*1*/ fun <get-increment>(): kotlin.Double
    public open override /*2*/ val start: kotlin.Double
        public open override /*2*/ fun <get-start>(): kotlin.Double
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Double): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.DoubleIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.DoubleRange
            public final fun <get-EMPTY>(): kotlin.DoubleRange
    }
}

public abstract class Enum</*0*/ E : kotlin.Enum<E>> : kotlin.Comparable<E> {
    /*primary*/ public constructor Enum</*0*/ E : kotlin.Enum<E>>(/*0*/ name: kotlin.String, /*1*/ ordinal: kotlin.Int)
    public final override /*1*/ fun compareTo(/*0*/ other: E): kotlin.Int
    public final fun name(): kotlin.String
    public final fun ordinal(): kotlin.Int

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

public final class Float : kotlin.Number, kotlin.Comparable<kotlin.Float> {
    /*primary*/ private constructor Float()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun inc(): kotlin.Float
    public final fun minus(): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun plus(): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.FloatRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Float
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public companion object Companion : kotlin.FloatingPointConstants<kotlin.Float> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Float
    }
}

public final class FloatArray : kotlin.Cloneable {
    /*primary*/ public constructor FloatArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.FloatArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Float
    public final fun iterator(): kotlin.FloatIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Float): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class FloatIterator : kotlin.Iterator<kotlin.Float> {
    /*primary*/ public constructor FloatIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Float
    public abstract fun nextFloat(): kotlin.Float
}

public final class FloatProgression : kotlin.Progression<kotlin.Float> {
    /*primary*/ public constructor FloatProgression(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float, /*2*/ increment: kotlin.Float)
    public open override /*1*/ val end: kotlin.Float
        public open override /*1*/ fun <get-end>(): kotlin.Float
    public open override /*1*/ val increment: kotlin.Float
        public open override /*1*/ fun <get-increment>(): kotlin.Float
    public open override /*1*/ val start: kotlin.Float
        public open override /*1*/ fun <get-start>(): kotlin.Float
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.FloatIterator
}

internal final class FloatProgressionIterator : kotlin.FloatIterator {
    /*primary*/ public constructor FloatProgressionIterator(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float, /*2*/ increment: kotlin.Float)
    internal final val end: kotlin.Float
        internal final fun <get-end>(): kotlin.Float
    internal final val increment: kotlin.Float
        internal final fun <get-increment>(): kotlin.Float
    private final var next: kotlin.Float
        private final fun <get-next>(): kotlin.Float
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Float): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Float
    public open override /*1*/ fun nextFloat(): kotlin.Float
}

public final class FloatRange : kotlin.Range<kotlin.Float>, kotlin.Progression<kotlin.Float> {
    /*primary*/ public constructor FloatRange(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float)
    public open override /*2*/ val end: kotlin.Float
        public open override /*2*/ fun <get-end>(): kotlin.Float
    public open override /*1*/ val increment: kotlin.Float
        public open override /*1*/ fun <get-increment>(): kotlin.Float
    public open override /*2*/ val start: kotlin.Float
        public open override /*2*/ fun <get-start>(): kotlin.Float
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Float): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.FloatIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.FloatRange
            public final fun <get-EMPTY>(): kotlin.FloatRange
    }
}

public interface FloatingPointConstants</*0*/ T> {
    public abstract val MAX_VALUE: T
        public abstract fun <get-MAX_VALUE>(): T
    public abstract val MIN_VALUE: T
        public abstract fun <get-MIN_VALUE>(): T
    public abstract val NEGATIVE_INFINITY: T
        public abstract fun <get-NEGATIVE_INFINITY>(): T
    public abstract val NaN: T
        public abstract fun <get-NaN>(): T
    public abstract val POSITIVE_INFINITY: T
        public abstract fun <get-POSITIVE_INFINITY>(): T
}

public interface Function</*0*/ out R> {
}

public final enum class InlineOption : kotlin.Enum<kotlin.InlineOption> {
    public enum entry LOCAL_CONTINUE_AND_BREAK : kotlin.InlineOption {
        /*primary*/ private constructor LOCAL_CONTINUE_AND_BREAK()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry ONLY_LOCAL_RETURN : kotlin.InlineOption {
        /*primary*/ private constructor ONLY_LOCAL_RETURN()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor InlineOption()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.InlineOption
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.InlineOption>
}

public final enum class InlineStrategy : kotlin.Enum<kotlin.InlineStrategy> {
    public enum entry AS_FUNCTION : kotlin.InlineStrategy {
        /*primary*/ private constructor AS_FUNCTION()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry IN_PLACE : kotlin.InlineStrategy {
        /*primary*/ private constructor IN_PLACE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor InlineStrategy()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.InlineStrategy
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.InlineStrategy>
}

public final class Int : kotlin.Number, kotlin.Comparable<kotlin.Int> {
    /*primary*/ private constructor Int()
    public final fun and(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Int
    public final fun inv(): kotlin.Int
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun or(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.IntRange
    public final fun shl(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun shr(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final fun ushr(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun xor(/*0*/ other: kotlin.Int): kotlin.Int

    public companion object Companion : kotlin.IntegerConstants<kotlin.Int> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Int
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Int
    }
}

public final class IntArray : kotlin.Cloneable {
    /*primary*/ public constructor IntArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.IntArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Int
    public final fun iterator(): kotlin.IntIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Int): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class IntIterator : kotlin.Iterator<kotlin.Int> {
    /*primary*/ public constructor IntIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Int
    public abstract fun nextInt(): kotlin.Int
}

public final class IntProgression : kotlin.Progression<kotlin.Int> {
    /*primary*/ public constructor IntProgression(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Int
        public open override /*1*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Int
        public open override /*1*/ fun <get-start>(): kotlin.Int
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.IntIterator
}

internal final class IntProgressionIterator : kotlin.IntIterator {
    /*primary*/ public constructor IntProgressionIterator(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Int
    public open override /*1*/ fun nextInt(): kotlin.Int
}

public final class IntRange : kotlin.Range<kotlin.Int>, kotlin.Progression<kotlin.Int> {
    /*primary*/ public constructor IntRange(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int)
    public open override /*2*/ val end: kotlin.Int
        public open override /*2*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Int
        public open override /*2*/ fun <get-start>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Int): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.IntIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.IntRange
            public final fun <get-EMPTY>(): kotlin.IntRange
    }
}

public interface IntegerConstants</*0*/ T> {
    public abstract val MAX_VALUE: T
        public abstract fun <get-MAX_VALUE>(): T
    public abstract val MIN_VALUE: T
        public abstract fun <get-MIN_VALUE>(): T
}

public interface Iterable</*0*/ out T> {
    public abstract fun iterator(): kotlin.Iterator<T>
}

public interface Iterator</*0*/ out T> {
    public abstract fun hasNext(): kotlin.Boolean
    public abstract fun next(): T
}

public interface List</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun get(/*0*/ index: kotlin.Int): E
    public abstract fun indexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract fun lastIndexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract fun listIterator(): kotlin.ListIterator<E>
    public abstract fun listIterator(/*0*/ index: kotlin.Int): kotlin.ListIterator<E>
    public abstract override /*1*/ fun size(): kotlin.Int
    public abstract fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.List<E>
}

public interface ListIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ fun hasNext(): kotlin.Boolean
    public abstract fun hasPrevious(): kotlin.Boolean
    public abstract override /*1*/ fun next(): T
    public abstract fun nextIndex(): kotlin.Int
    public abstract fun previous(): T
    public abstract fun previousIndex(): kotlin.Int
}

public final class Long : kotlin.Number, kotlin.Comparable<kotlin.Long> {
    /*primary*/ private constructor Long()
    public final fun and(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun inc(): kotlin.Long
    public final fun inv(): kotlin.Long
    public final fun minus(): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun or(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.LongRange
    public final fun shl(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun shr(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Long
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final fun ushr(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun xor(/*0*/ other: kotlin.Long): kotlin.Long

    public companion object Companion : kotlin.IntegerConstants<kotlin.Long> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Long
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Long
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Long
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Long
    }
}

public final class LongArray : kotlin.Cloneable {
    /*primary*/ public constructor LongArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.LongArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Long
    public final fun iterator(): kotlin.LongIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Long): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class LongIterator : kotlin.Iterator<kotlin.Long> {
    /*primary*/ public constructor LongIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Long
    public abstract fun nextLong(): kotlin.Long
}

public final class LongProgression : kotlin.Progression<kotlin.Long> {
    /*primary*/ public constructor LongProgression(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long, /*2*/ increment: kotlin.Long)
    public open override /*1*/ val end: kotlin.Long
        public open override /*1*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public open override /*1*/ val start: kotlin.Long
        public open override /*1*/ fun <get-start>(): kotlin.Long
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.LongIterator
}

internal final class LongProgressionIterator : kotlin.LongIterator {
    /*primary*/ public constructor LongProgressionIterator(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long, /*2*/ increment: kotlin.Long)
    private final val finalElement: kotlin.Long
        private final fun <get-finalElement>(): kotlin.Long
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Long
        internal final fun <get-increment>(): kotlin.Long
    private final var next: kotlin.Long
        private final fun <get-next>(): kotlin.Long
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Long): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Long
    public open override /*1*/ fun nextLong(): kotlin.Long
}

public final class LongRange : kotlin.Range<kotlin.Long>, kotlin.Progression<kotlin.Long> {
    /*primary*/ public constructor LongRange(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long)
    public open override /*2*/ val end: kotlin.Long
        public open override /*2*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public open override /*2*/ val start: kotlin.Long
        public open override /*2*/ fun <get-start>(): kotlin.Long
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Long): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.LongIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.LongRange
            public final fun <get-EMPTY>(): kotlin.LongRange
    }
}

public interface Map</*0*/ K, /*1*/ out V> {
    public abstract fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
    public abstract fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
    public abstract fun entrySet(): kotlin.Set<kotlin.Map.Entry<K, V>>
    public abstract fun get(/*0*/ key: kotlin.Any?): V?
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract fun keySet(): kotlin.Set<K>
    public abstract fun size(): kotlin.Int
    public abstract fun values(): kotlin.Collection<V>

    public interface Entry</*0*/ out K, /*1*/ out V> {
        public abstract fun getKey(): K
        public abstract fun getValue(): V
    }
}

public interface MutableCollection</*0*/ E> : kotlin.Collection<E>, kotlin.MutableIterable<E> {
    public abstract fun add(/*0*/ e: E): kotlin.Boolean
    public abstract fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
}

public interface MutableIterable</*0*/ out T> : kotlin.Iterable<T> {
    public abstract override /*1*/ fun iterator(): kotlin.MutableIterator<T>
}

public interface MutableIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun next(): T
    public abstract fun remove(): kotlin.Unit
}

public interface MutableList</*0*/ E> : kotlin.List<E>, kotlin.MutableCollection<E> {
    public abstract override /*1*/ fun add(/*0*/ e: E): kotlin.Boolean
    public abstract fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public abstract override /*1*/ fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*1*/ fun listIterator(): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun remove(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
    public abstract override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.MutableList<E>
}

public interface MutableListIterator</*0*/ T> : kotlin.ListIterator<T>, kotlin.MutableIterator<T> {
    public abstract fun add(/*0*/ e: T): kotlin.Unit
    public abstract override /*2*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun hasPrevious(): kotlin.Boolean
    public abstract override /*2*/ fun next(): T
    public abstract override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
    public abstract override /*1*/ /*fake_override*/ fun previous(): T
    public abstract override /*1*/ /*fake_override*/ fun previousIndex(): kotlin.Int
    public abstract override /*1*/ fun remove(): kotlin.Unit
    public abstract fun set(/*0*/ e: T): kotlin.Unit
}

public interface MutableMap</*0*/ K, /*1*/ V> : kotlin.Map<K, V> {
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun entrySet(): kotlin.MutableSet<kotlin.MutableMap.MutableEntry<K, V>>
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun keySet(): kotlin.MutableSet<K>
    public abstract fun put(/*0*/ key: K, /*1*/ value: V): V?
    public abstract fun putAll(/*0*/ m: kotlin.Map<out K, V>): kotlin.Unit
    public abstract fun remove(/*0*/ key: kotlin.Any?): V?
    public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
    public abstract override /*1*/ fun values(): kotlin.MutableCollection<V>

    public interface MutableEntry</*0*/ K, /*1*/ V> : kotlin.Map.Entry<K, V> {
        public abstract override /*1*/ /*fake_override*/ fun getKey(): K
        public abstract override /*1*/ /*fake_override*/ fun getValue(): V
        public abstract fun setValue(/*0*/ value: V): V
    }
}

public interface MutableSet</*0*/ E> : kotlin.Set<E>, kotlin.MutableCollection<E> {
    public abstract override /*1*/ fun add(/*0*/ e: E): kotlin.Boolean
    public abstract override /*1*/ fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
}

public final class Nothing {
    /*primary*/ private constructor Nothing()
}

public abstract class Number {
    /*primary*/ public constructor Number()
    public abstract fun toByte(): kotlin.Byte
    public abstract fun toChar(): kotlin.Char
    public abstract fun toDouble(): kotlin.Double
    public abstract fun toFloat(): kotlin.Float
    public abstract fun toInt(): kotlin.Int
    public abstract fun toLong(): kotlin.Long
    public abstract fun toShort(): kotlin.Short
}

public interface Progression</*0*/ out N : kotlin.Any> : kotlin.Iterable<N> {
    public abstract val end: N
        public abstract fun <get-end>(): N
    public abstract val increment: kotlin.Number
        public abstract fun <get-increment>(): kotlin.Number
    public abstract val start: N
        public abstract fun <get-start>(): N
    public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.Iterator<N>
}

public interface PropertyMetadata {
    public abstract val name: kotlin.String
        public abstract fun <get-name>(): kotlin.String
}

public final class PropertyMetadataImpl : kotlin.PropertyMetadata {
    /*primary*/ public constructor PropertyMetadataImpl(/*0*/ name: kotlin.String)
    public open override /*1*/ val name: kotlin.String
        public open override /*1*/ fun <get-name>(): kotlin.String
}

public interface Range</*0*/ T : kotlin.Comparable<T>> {
    public abstract val end: T
        public abstract fun <get-end>(): T
    public abstract val start: T
        public abstract fun <get-start>(): T
    public abstract fun contains(/*0*/ item: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}

public final annotation class ReplaceWith : kotlin.Annotation {
    /*primary*/ public constructor ReplaceWith(/*0*/ expression: kotlin.String, /*1*/ vararg imports: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    internal final val expression: kotlin.String
        internal final fun <get-expression>(): kotlin.String
    internal final val imports: kotlin.Array<out kotlin.String>
        internal final fun <get-imports>(): kotlin.Array<out kotlin.String>
}

public interface Set</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract override /*1*/ fun size(): kotlin.Int
}

public final class Short : kotlin.Number, kotlin.Comparable<kotlin.Short> {
    /*primary*/ private constructor Short()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Short
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Short
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ShortRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ShortRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public companion object Companion : kotlin.IntegerConstants<kotlin.Short> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Short
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Short
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Short
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Short
    }
}

public final class ShortArray : kotlin.Cloneable {
    /*primary*/ public constructor ShortArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.ShortArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Short
    public final fun iterator(): kotlin.ShortIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Short): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class ShortIterator : kotlin.Iterator<kotlin.Short> {
    /*primary*/ public constructor ShortIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Short
    public abstract fun nextShort(): kotlin.Short
}

public final class ShortProgression : kotlin.Progression<kotlin.Short> {
    /*primary*/ public constructor ShortProgression(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Short
        public open override /*1*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Short
        public open override /*1*/ fun <get-start>(): kotlin.Short
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ShortIterator
}

internal final class ShortProgressionIterator : kotlin.ShortIterator {
    /*primary*/ public constructor ShortProgressionIterator(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Short
        private final fun <get-finalElement>(): kotlin.Short
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Short
    public open override /*1*/ fun nextShort(): kotlin.Short
}

public final class ShortRange : kotlin.Range<kotlin.Short>, kotlin.Progression<kotlin.Short> {
    /*primary*/ public constructor ShortRange(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short)
    public open override /*2*/ val end: kotlin.Short
        public open override /*2*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Short
        public open override /*2*/ fun <get-start>(): kotlin.Short
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Short): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ShortIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ShortRange
            public final fun <get-EMPTY>(): kotlin.ShortRange
    }
}

public final class String : kotlin.Comparable<kotlin.String>, kotlin.CharSequence {
    /*primary*/ public constructor String()
    public open override /*1*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.String): kotlin.Int
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public open override /*1*/ fun length(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Any?): kotlin.String
    public open override /*1*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

public open class Throwable {
    /*primary*/ public constructor Throwable(/*0*/ message: kotlin.String? = ..., /*1*/ cause: kotlin.Throwable? = ...)
    public final fun getCause(): kotlin.Throwable?
    public final fun getMessage(): kotlin.String?
    public final fun printStackTrace(): kotlin.Unit
}

public object Unit {
    /*primary*/ private constructor Unit()
}

kotlin.annotation.target(allowedTargets = {AnnotationTarget.ANNOTATION_CLASS}) public final annotation class annotation : kotlin.Annotation {
    /*primary*/ public constructor __annotation(/*0*/ retention: kotlin.AnnotationRetention = ..., /*1*/ repeatable: kotlin.Boolean = ...)
    internal final val repeatable: kotlin.Boolean
        internal final fun <get-repeatable>(): kotlin.Boolean
    internal final val retention: kotlin.AnnotationRetention
        internal final fun <get-retention>(): kotlin.AnnotationRetention
}

kotlin.annotation.target(allowedTargets = {AnnotationTarget.ANNOTATION_CLASS}) public final annotation class data : kotlin.Annotation {
    /*primary*/ public constructor data()
}

kotlin.annotation.target(allowedTargets = {AnnotationTarget.CLASSIFIER, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.PROPERTY_GETTER}) public final annotation class deprecated : kotlin.Annotation {
    /*primary*/ public constructor deprecated(/*0*/ value: kotlin.String, /*1*/ replaceWith: kotlin.ReplaceWith = ...)
    internal final val replaceWith: kotlin.ReplaceWith
        internal final fun <get-replaceWith>(): kotlin.ReplaceWith
    internal final val value: kotlin.String
        internal final fun <get-value>(): kotlin.String
}

kotlin.annotation.target(allowedTargets = {AnnotationTarget.TYPE}) public final annotation class extension : kotlin.Annotation {
    /*primary*/ public constructor extension()
}

public final annotation class inline : kotlin.Annotation {
    /*primary*/ public constructor inline(/*0*/ strategy: kotlin.InlineStrategy = ...)
    public final val strategy: kotlin.InlineStrategy
        public final fun <get-strategy>(): kotlin.InlineStrategy
}

public final annotation class inlineOptions : kotlin.Annotation {
    /*primary*/ public constructor inlineOptions(/*0*/ vararg value: kotlin.InlineOption /*kotlin.Array<out kotlin.InlineOption>*/)
    internal final val value: kotlin.Array<out kotlin.InlineOption>
        internal final fun <get-value>(): kotlin.Array<out kotlin.InlineOption>
}

public final annotation class noinline : kotlin.Annotation {
    /*primary*/ public constructor noinline()
}

kotlin.annotation.target(allowedTargets = {AnnotationTarget.CLASSIFIER, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.PROPERTY, AnnotationTarget.FIELD, AnnotationTarget.LOCAL_VARIABLE, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.TYPE, AnnotationTarget.EXPRESSION, AnnotationTarget.FILE}) public final annotation class suppress : kotlin.Annotation {
    /*primary*/ public constructor suppress(/*0*/ vararg names: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    internal final val names: kotlin.Array<out kotlin.String>
        internal final fun <get-names>(): kotlin.Array<out kotlin.String>
}

kotlin.target(allowedTargets = {AnnotationTarget.FUNCTION}) public final annotation class tailRecursive : kotlin.Annotation {
    /*primary*/ public constructor tailRecursive()
}

kotlin.target(allowedTargets = {AnnotationTarget.CLASSIFIER}) public final annotation class target : kotlin.Annotation {
    /*primary*/ public constructor target(/*0*/ vararg allowedTargets: kotlin.AnnotationTarget /*kotlin.Array<out kotlin.AnnotationTarget>*/)
    internal final val allowedTargets: kotlin.Array<out kotlin.AnnotationTarget>
        internal final fun <get-allowedTargets>(): kotlin.Array<out kotlin.AnnotationTarget>
}
