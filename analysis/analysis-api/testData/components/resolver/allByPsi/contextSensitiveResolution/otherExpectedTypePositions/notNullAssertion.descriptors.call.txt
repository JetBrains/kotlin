KtFile: 'notNullAssertion.kt'
  null

KtPackageDirective(0,0): ''
  null

KtImportList(93,124): 'import kotlin.reflect.KProperty'
  null

KtImportDirective(93,124): 'import kotlin.reflect.KProperty'
  null

KtDotQualifiedExpression(100,124): 'kotlin.reflect.KProperty'
  null

KtDotQualifiedExpression(100,114): 'kotlin.reflect'
  null

KtNameReferenceExpression(100,106): 'kotlin'
  null

KtNameReferenceExpression(107,114): 'reflect'
  null

KtNameReferenceExpression(115,124): 'KProperty'
  null

KtClass(126,349): 'open class MyClass {'
  null

KtDeclarationModifierList(126,130): 'open'
  null

KtClassBody(145,349): '{'
  null

KtObjectDeclaration(151,185): 'object NestedInheritor : MyClass()'
  null

KtSuperTypeList(176,185): 'MyClass()'
  null

KtSuperTypeCallEntry(176,185): 'MyClass()'
  KaSuccessCallInfo:
    call = KaDelegatedConstructorCall:
      argumentMapping = {}
      kind = SUPER_CALL
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass
          symbol = <constructor>(): MyClass
          valueParameters = []
          contextParameters = []
          callableId = null
      typeArgumentsMapping = {}

KtConstructorCalleeExpression(176,183): 'MyClass'
  KaSuccessCallInfo:
    call = KaDelegatedConstructorCall:
      argumentMapping = {}
      kind = SUPER_CALL
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass
          symbol = <constructor>(): MyClass
          valueParameters = []
          contextParameters = []
          callableId = null
      typeArgumentsMapping = {}

KtTypeReference(176,183): 'MyClass'
  null

KtUserType(176,183): 'MyClass'
  null

KtNameReferenceExpression(176,183): 'MyClass'
  KaSuccessCallInfo:
    call = KaDelegatedConstructorCall:
      argumentMapping = {}
      kind = SUPER_CALL
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass
          symbol = <constructor>(): MyClass
          valueParameters = []
          contextParameters = []
          callableId = null
      typeArgumentsMapping = {}

KtValueArgumentList(183,185): '()'
  null

KtObjectDeclaration(191,347): 'companion object {'
  null

KtDeclarationModifierList(191,200): 'companion'
  null

KtClassBody(208,347): '{'
  null

KtProperty(218,254): 'val myClassProp: MyClass = MyClass()'
  null

KtTypeReference(235,242): 'MyClass'
  null

KtUserType(235,242): 'MyClass'
  null

KtNameReferenceExpression(235,242): 'MyClass'
  null

KtCallExpression(245,254): 'MyClass()'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {}
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass
          symbol = <constructor>(): MyClass
          valueParameters = []
          contextParameters = []
          callableId = null
      typeArgumentsMapping = {}

KtNameReferenceExpression(245,252): 'MyClass'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {}
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass
          symbol = <constructor>(): MyClass
          valueParameters = []
          contextParameters = []
          callableId = null
      typeArgumentsMapping = {}

KtValueArgumentList(252,254): '()'
  null

KtProperty(263,290): 'val stringProp: String = ""'
  null

KtTypeReference(279,285): 'String'
  null

KtUserType(279,285): 'String'
  null

KtNameReferenceExpression(279,285): 'String'
  null

KtStringTemplateExpression(288,290): '""'
  null

KtNamedFunction(299,341): 'fun getNestedInheritor() = NestedInheritor'
  null

KtParameterList(321,323): '()'
  null

KtNameReferenceExpression(326,341): 'NestedInheritor'
  null

KtNamedFunction(351,374): 'fun <T>receive(e: T) {}'
  null

KtTypeParameterList(355,358): '<T>'
  null

KtTypeParameter(356,357): 'T'
  null

KtParameterList(365,371): '(e: T)'
  null

KtParameter(366,370): 'e: T'
  null

KtTypeReference(369,370): 'T'
  null

KtUserType(369,370): 'T'
  null

KtNameReferenceExpression(369,370): 'T'
  null

KtBlockExpression(372,374): '{}'
  null

KtProperty(375,421): 'val ClassMemberAlias = MyClass.NestedInheritor'
  null

KtDotQualifiedExpression(398,421): 'MyClass.NestedInheritor'
  null

KtNameReferenceExpression(398,405): 'MyClass'
  null

KtNameReferenceExpression(406,421): 'NestedInheritor'
  null

KtNamedFunction(423,609): 'fun testNotNullAssertion() {'
  null

KtParameterList(447,449): '()'
  null

KtBlockExpression(450,609): '{'
  null

KtCallExpression(456,491): 'receive<MyClass>(NestedInheritor!!)'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          NestedInheritor!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtNameReferenceExpression(456,463): 'receive'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          NestedInheritor!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtTypeArgumentList(463,472): '<MyClass>'
  null

KtTypeProjection(464,471): 'MyClass'
  null

KtTypeReference(464,471): 'MyClass'
  null

KtUserType(464,471): 'MyClass'
  null

KtNameReferenceExpression(464,471): 'MyClass'
  null

KtValueArgumentList(472,491): '(NestedInheritor!!)'
  null

KtValueArgument(473,490): 'NestedInheritor!!'
  null

KtPostfixExpression(473,490): 'NestedInheritor!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          NestedInheritor -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtNameReferenceExpression(473,488): 'NestedInheritor'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: NestedInheritor>

KtOperationReferenceExpression(488,490): '!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          NestedInheritor -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtCallExpression(496,527): 'receive<MyClass>(myClassProp!!)'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          myClassProp!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtNameReferenceExpression(496,503): 'receive'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          myClassProp!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtTypeArgumentList(503,512): '<MyClass>'
  null

KtTypeProjection(504,511): 'MyClass'
  null

KtTypeReference(504,511): 'MyClass'
  null

KtUserType(504,511): 'MyClass'
  null

KtNameReferenceExpression(504,511): 'MyClass'
  null

KtValueArgumentList(512,527): '(myClassProp!!)'
  null

KtValueArgument(513,526): 'myClassProp!!'
  null

KtPostfixExpression(513,526): 'myClassProp!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          myClassProp -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtNameReferenceExpression(513,524): 'myClassProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: myClassProp>

KtOperationReferenceExpression(524,526): '!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          myClassProp -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtCallExpression(532,562): 'receive<MyClass>(stringProp!!)'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          stringProp!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtNameReferenceExpression(532,539): 'receive'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          stringProp!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtTypeArgumentList(539,548): '<MyClass>'
  null

KtTypeProjection(540,547): 'MyClass'
  null

KtTypeReference(540,547): 'MyClass'
  null

KtUserType(540,547): 'MyClass'
  null

KtNameReferenceExpression(540,547): 'MyClass'
  null

KtValueArgumentList(548,562): '(stringProp!!)'
  null

KtValueArgument(549,561): 'stringProp!!'
  null

KtPostfixExpression(549,561): 'stringProp!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          stringProp -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtNameReferenceExpression(549,559): 'stringProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: stringProp>

KtOperationReferenceExpression(559,561): '!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          stringProp -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtCallExpression(567,607): 'receive<MyClass>(getNestedInheritor()!!)'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          getNestedInheritor()!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtNameReferenceExpression(567,574): 'receive'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          getNestedInheritor()!! -> (KaVariableSignature:
            name = e
            receiverType = null
            returnType = ERROR_TYPE
            symbol = e: T
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.Unit
            symbol = /receive(e: T): kotlin.Unit
            valueParameters = [
              KaVariableSignature:
                name = e
                receiverType = null
                returnType = ERROR_TYPE
                symbol = e: T
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /receive
        typeArgumentsMapping = {
          T -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with receive>

KtTypeArgumentList(574,583): '<MyClass>'
  null

KtTypeProjection(575,582): 'MyClass'
  null

KtTypeReference(575,582): 'MyClass'
  null

KtUserType(575,582): 'MyClass'
  null

KtNameReferenceExpression(575,582): 'MyClass'
  null

KtValueArgumentList(583,607): '(getNestedInheritor()!!)'
  null

KtValueArgument(584,606): 'getNestedInheritor()!!'
  null

KtPostfixExpression(584,606): 'getNestedInheritor()!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          getNestedInheritor() -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtCallExpression(584,604): 'getNestedInheritor()'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: getNestedInheritor>

KtNameReferenceExpression(584,602): 'getNestedInheritor'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: getNestedInheritor>

KtValueArgumentList(602,604): '()'
  null

KtOperationReferenceExpression(604,606): '!!'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          getNestedInheritor() -> (KaVariableSignature:
            name = baseExpr
            receiverType = null
            returnType = ERROR_TYPE?
            symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = ERROR_TYPE
            symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
            valueParameters = [
              KaVariableSignature:
                name = baseExpr
                receiverType = null
                returnType = ERROR_TYPE?
                symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
        typeArgumentsMapping = {
          <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (ERROR_TYPE)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with <SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>>

KtNamedFunction(611,917): 'fun testIndexAccess(): Int? {'
  null

KtParameterList(630,632): '()'
  null

KtTypeReference(634,638): 'Int?'
  null

KtNullableType(634,638): 'Int?'
  null

KtUserType(634,637): 'Int'
  null

KtNameReferenceExpression(634,637): 'Int'
  null

KtBlockExpression(639,917): '{'
  null

KtProperty(645,791): 'val map = mapOf<MyClass, Int>(MyClass.myClassProp to 1,  MyClass.stringProp to 2, MyClass.NestedInheritor to 3, MyClass.getNestedInheritor() to 4)'
  null

KtCallExpression(655,791): 'mapOf<MyClass, Int>(MyClass.myClassProp to 1,  MyClass.stringProp to 2, MyClass.NestedInheritor to 3, MyClass.getNestedInheritor() to 4)'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          MyClass.myClassProp to 1 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.stringProp to 2 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.NestedInheritor to 3 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.getNestedInheritor() to 4 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.collections.Map<MyClass, kotlin.Int>
            symbol = kotlin/collections/mapOf(vararg pairs: kotlin.Pair<K, V>): kotlin.collections.Map<K, V>
            valueParameters = [
              KaVariableSignature:
                name = pairs
                receiverType = null
                returnType = kotlin.Pair<MyClass, kotlin.Int>
                symbol = vararg pairs: kotlin.Pair<K, V>
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = kotlin/collections/mapOf
        typeArgumentsMapping = {
          K -> (MyClass),
          V -> (kotlin.Int)
        }
    ]
    diagnostic = ERROR<TYPE_MISMATCH: Type mismatch: inferred type is String but MyClass was expected>

KtNameReferenceExpression(655,660): 'mapOf'
  KaErrorCallInfo:
    candidateCalls = [
      KaSimpleFunctionCall:
        argumentMapping = {
          MyClass.myClassProp to 1 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.stringProp to 2 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.NestedInheritor to 3 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null),
          MyClass.getNestedInheritor() to 4 -> (KaVariableSignature:
            name = pairs
            receiverType = null
            returnType = kotlin.Pair<MyClass, kotlin.Int>
            symbol = vararg pairs: kotlin.Pair<K, V>
            contextParameters = []
            callableId = null)
        }
        isImplicitInvoke = false
        partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
          contextArguments = []
          dispatchReceiver = null
          extensionReceiver = null
          signature = KaFunctionSignature:
            receiverType = null
            returnType = kotlin.collections.Map<MyClass, kotlin.Int>
            symbol = kotlin/collections/mapOf(vararg pairs: kotlin.Pair<K, V>): kotlin.collections.Map<K, V>
            valueParameters = [
              KaVariableSignature:
                name = pairs
                receiverType = null
                returnType = kotlin.Pair<MyClass, kotlin.Int>
                symbol = vararg pairs: kotlin.Pair<K, V>
                contextParameters = []
                callableId = null
            ]
            contextParameters = []
            callableId = kotlin/collections/mapOf
        typeArgumentsMapping = {
          K -> (MyClass),
          V -> (kotlin.Int)
        }
    ]
    diagnostic = ERROR<UNRESOLVED_REFERENCE: OTHER_ERROR with mapOf>

KtTypeArgumentList(660,674): '<MyClass, Int>'
  null

KtTypeProjection(661,668): 'MyClass'
  null

KtTypeReference(661,668): 'MyClass'
  null

KtUserType(661,668): 'MyClass'
  null

KtNameReferenceExpression(661,668): 'MyClass'
  null

KtTypeProjection(670,673): 'Int'
  null

KtTypeReference(670,673): 'Int'
  null

KtUserType(670,673): 'Int'
  null

KtNameReferenceExpression(670,673): 'Int'
  null

KtValueArgumentList(674,791): '(MyClass.myClassProp to 1,  MyClass.stringProp to 2, MyClass.NestedInheritor to 3, MyClass.getNestedInheritor() to 4)'
  null

KtValueArgument(675,699): 'MyClass.myClassProp to 1'
  null

KtBinaryExpression(675,699): 'MyClass.myClassProp to 1'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        1 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp
          isSafeNavigation = false
          type = MyClass
        signature = KaFunctionSignature:
          receiverType = MyClass
          returnType = kotlin.Pair<MyClass, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass),
        B -> (kotlin.Int)
      }

KtDotQualifiedExpression(675,694): 'MyClass.myClassProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = myClassProp
          receiverType = null
          returnType = MyClass
          symbol = val myClassProp: MyClass
          contextParameters = []
          callableId = /MyClass.Companion.myClassProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtNameReferenceExpression(675,682): 'MyClass'
  null

KtNameReferenceExpression(683,694): 'myClassProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = myClassProp
          receiverType = null
          returnType = MyClass
          symbol = val myClassProp: MyClass
          contextParameters = []
          callableId = /MyClass.Companion.myClassProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtOperationReferenceExpression(695,697): 'to'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        1 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp
          isSafeNavigation = false
          type = MyClass
        signature = KaFunctionSignature:
          receiverType = MyClass
          returnType = kotlin.Pair<MyClass, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass),
        B -> (kotlin.Int)
      }

KtConstantExpression(698,699): '1'
  null

KtValueArgument(702,725): 'MyClass.stringProp to 2'
  null

KtBinaryExpression(702,725): 'MyClass.stringProp to 2'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        2 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.stringProp
          isSafeNavigation = false
          type = kotlin.String
        signature = KaFunctionSignature:
          receiverType = kotlin.String
          returnType = kotlin.Pair<kotlin.String, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (kotlin.String),
        B -> (kotlin.Int)
      }

KtDotQualifiedExpression(702,720): 'MyClass.stringProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = stringProp
          receiverType = null
          returnType = kotlin.String
          symbol = val stringProp: kotlin.String
          contextParameters = []
          callableId = /MyClass.Companion.stringProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtNameReferenceExpression(702,709): 'MyClass'
  null

KtNameReferenceExpression(710,720): 'stringProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = stringProp
          receiverType = null
          returnType = kotlin.String
          symbol = val stringProp: kotlin.String
          contextParameters = []
          callableId = /MyClass.Companion.stringProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtOperationReferenceExpression(721,723): 'to'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        2 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.stringProp
          isSafeNavigation = false
          type = kotlin.String
        signature = KaFunctionSignature:
          receiverType = kotlin.String
          returnType = kotlin.Pair<kotlin.String, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (kotlin.String),
        B -> (kotlin.Int)
      }

KtConstantExpression(724,725): '2'
  null

KtValueArgument(727,755): 'MyClass.NestedInheritor to 3'
  null

KtBinaryExpression(727,755): 'MyClass.NestedInheritor to 3'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        3 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.NestedInheritor
          isSafeNavigation = false
          type = MyClass.NestedInheritor
        signature = KaFunctionSignature:
          receiverType = MyClass.NestedInheritor
          returnType = kotlin.Pair<MyClass.NestedInheritor, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass.NestedInheritor),
        B -> (kotlin.Int)
      }

KtDotQualifiedExpression(727,750): 'MyClass.NestedInheritor'
  null

KtNameReferenceExpression(727,734): 'MyClass'
  null

KtNameReferenceExpression(735,750): 'NestedInheritor'
  null

KtOperationReferenceExpression(751,753): 'to'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        3 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.NestedInheritor
          isSafeNavigation = false
          type = MyClass.NestedInheritor
        signature = KaFunctionSignature:
          receiverType = MyClass.NestedInheritor
          returnType = kotlin.Pair<MyClass.NestedInheritor, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass.NestedInheritor),
        B -> (kotlin.Int)
      }

KtConstantExpression(754,755): '3'
  null

KtValueArgument(757,790): 'MyClass.getNestedInheritor() to 4'
  null

KtBinaryExpression(757,790): 'MyClass.getNestedInheritor() to 4'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        4 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.getNestedInheritor()
          isSafeNavigation = false
          type = MyClass.NestedInheritor
        signature = KaFunctionSignature:
          receiverType = MyClass.NestedInheritor
          returnType = kotlin.Pair<MyClass.NestedInheritor, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass.NestedInheritor),
        B -> (kotlin.Int)
      }

KtDotQualifiedExpression(757,785): 'MyClass.getNestedInheritor()'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {}
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass.NestedInheritor
          symbol = /MyClass.Companion.getNestedInheritor(<dispatch receiver>: MyClass.Companion): MyClass.NestedInheritor
          valueParameters = []
          contextParameters = []
          callableId = /MyClass.Companion.getNestedInheritor
      typeArgumentsMapping = {}

KtNameReferenceExpression(757,764): 'MyClass'
  null

KtCallExpression(765,785): 'getNestedInheritor()'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {}
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass.NestedInheritor
          symbol = /MyClass.Companion.getNestedInheritor(<dispatch receiver>: MyClass.Companion): MyClass.NestedInheritor
          valueParameters = []
          contextParameters = []
          callableId = /MyClass.Companion.getNestedInheritor
      typeArgumentsMapping = {}

KtNameReferenceExpression(765,783): 'getNestedInheritor'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {}
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = MyClass.NestedInheritor
          symbol = /MyClass.Companion.getNestedInheritor(<dispatch receiver>: MyClass.Companion): MyClass.NestedInheritor
          valueParameters = []
          contextParameters = []
          callableId = /MyClass.Companion.getNestedInheritor
      typeArgumentsMapping = {}

KtValueArgumentList(783,785): '()'
  null

KtOperationReferenceExpression(786,788): 'to'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        4 -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = kotlin.Int
          symbol = that: B
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.getNestedInheritor()
          isSafeNavigation = false
          type = MyClass.NestedInheritor
        signature = KaFunctionSignature:
          receiverType = MyClass.NestedInheritor
          returnType = kotlin.Pair<MyClass.NestedInheritor, kotlin.Int>
          symbol = kotlin/to(<extension receiver>: A, that: B): kotlin.Pair<A, B>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = kotlin.Int
              symbol = that: B
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/to
      typeArgumentsMapping = {
        A -> (MyClass.NestedInheritor),
        B -> (kotlin.Int)
      }

KtConstantExpression(789,790): '4'
  null

KtReturnExpression(796,819): 'return map[myClassProp]'
  null

KtArrayAccessExpression(803,819): 'map[myClassProp]'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        myClassProp -> (KaVariableSignature:
          name = key
          receiverType = null
          returnType = MyClass
          symbol = key: K
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = map
          isSafeNavigation = false
          type = kotlin.collections.Map<MyClass, kotlin.Int>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Int?
          symbol = kotlin/collections/Map.get(<dispatch receiver>: kotlin.collections.Map<K, V>, key: K): V?
          valueParameters = [
            KaVariableSignature:
              name = key
              receiverType = null
              returnType = MyClass
              symbol = key: K
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/collections/Map.get
      typeArgumentsMapping = {}

KtNameReferenceExpression(803,806): 'map'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaVariableSignature:
          name = map
          receiverType = null
          returnType = kotlin.collections.Map<MyClass, kotlin.Int>
          symbol = val map: kotlin.collections.Map<MyClass, kotlin.Int>
          contextParameters = []
          callableId = null
      simpleAccess = Read
      typeArgumentsMapping = {}

KtContainerNode(806,819): '[myClassProp]'
  null

KtNameReferenceExpression(807,818): 'myClassProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: myClassProp>

KtReturnExpression(824,846): 'return map[stringProp]'
  null

KtArrayAccessExpression(831,846): 'map[stringProp]'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        stringProp -> (KaVariableSignature:
          name = key
          receiverType = null
          returnType = MyClass
          symbol = key: K
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = map
          isSafeNavigation = false
          type = kotlin.collections.Map<MyClass, kotlin.Int>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Int?
          symbol = kotlin/collections/Map.get(<dispatch receiver>: kotlin.collections.Map<K, V>, key: K): V?
          valueParameters = [
            KaVariableSignature:
              name = key
              receiverType = null
              returnType = MyClass
              symbol = key: K
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/collections/Map.get
      typeArgumentsMapping = {}

KtNameReferenceExpression(831,834): 'map'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaVariableSignature:
          name = map
          receiverType = null
          returnType = kotlin.collections.Map<MyClass, kotlin.Int>
          symbol = val map: kotlin.collections.Map<MyClass, kotlin.Int>
          contextParameters = []
          callableId = null
      simpleAccess = Read
      typeArgumentsMapping = {}

KtContainerNode(834,846): '[stringProp]'
  null

KtNameReferenceExpression(835,845): 'stringProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: stringProp>

KtReturnExpression(851,878): 'return map[NestedInheritor]'
  null

KtArrayAccessExpression(858,878): 'map[NestedInheritor]'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        NestedInheritor -> (KaVariableSignature:
          name = key
          receiverType = null
          returnType = MyClass
          symbol = key: K
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = map
          isSafeNavigation = false
          type = kotlin.collections.Map<MyClass, kotlin.Int>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Int?
          symbol = kotlin/collections/Map.get(<dispatch receiver>: kotlin.collections.Map<K, V>, key: K): V?
          valueParameters = [
            KaVariableSignature:
              name = key
              receiverType = null
              returnType = MyClass
              symbol = key: K
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/collections/Map.get
      typeArgumentsMapping = {}

KtNameReferenceExpression(858,861): 'map'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaVariableSignature:
          name = map
          receiverType = null
          returnType = kotlin.collections.Map<MyClass, kotlin.Int>
          symbol = val map: kotlin.collections.Map<MyClass, kotlin.Int>
          contextParameters = []
          callableId = null
      simpleAccess = Read
      typeArgumentsMapping = {}

KtContainerNode(861,878): '[NestedInheritor]'
  null

KtNameReferenceExpression(862,877): 'NestedInheritor'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: NestedInheritor>

KtReturnExpression(883,915): 'return map[getNestedInheritor()]'
  null

KtArrayAccessExpression(890,915): 'map[getNestedInheritor()]'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        getNestedInheritor() -> (KaVariableSignature:
          name = key
          receiverType = null
          returnType = MyClass
          symbol = key: K
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = map
          isSafeNavigation = false
          type = kotlin.collections.Map<MyClass, kotlin.Int>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Int?
          symbol = kotlin/collections/Map.get(<dispatch receiver>: kotlin.collections.Map<K, V>, key: K): V?
          valueParameters = [
            KaVariableSignature:
              name = key
              receiverType = null
              returnType = MyClass
              symbol = key: K
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/collections/Map.get
      typeArgumentsMapping = {}

KtNameReferenceExpression(890,893): 'map'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaVariableSignature:
          name = map
          receiverType = null
          returnType = kotlin.collections.Map<MyClass, kotlin.Int>
          symbol = val map: kotlin.collections.Map<MyClass, kotlin.Int>
          contextParameters = []
          callableId = null
      simpleAccess = Read
      typeArgumentsMapping = {}

KtContainerNode(893,915): '[getNestedInheritor()]'
  null

KtCallExpression(894,914): 'getNestedInheritor()'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: getNestedInheritor>

KtNameReferenceExpression(894,912): 'getNestedInheritor'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: getNestedInheritor>

KtValueArgumentList(912,914): '()'
  null

KtNamedFunction(919,999): 'fun testCallableReference() {'
  null

KtParameterList(944,946): '()'
  null

KtBlockExpression(947,999): '{'
  null

KtProperty(953,997): 'val i150: KProperty<MyClass> = ::myClassProp'
  null

KtTypeReference(963,981): 'KProperty<MyClass>'
  null

KtUserType(963,981): 'KProperty<MyClass>'
  null

KtNameReferenceExpression(963,972): 'KProperty'
  null

KtTypeArgumentList(972,981): '<MyClass>'
  null

KtTypeProjection(973,980): 'MyClass'
  null

KtTypeReference(973,980): 'MyClass'
  null

KtUserType(973,980): 'MyClass'
  null

KtNameReferenceExpression(973,980): 'MyClass'
  null

KtCallableReferenceExpression(984,997): '::myClassProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: myClassProp>

KtNameReferenceExpression(986,997): 'myClassProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: myClassProp>

KtNamedFunction(1001,1101): 'operator fun MyClass.rangeTo(that: MyClass): ClosedFloatingPointRange<MyClass> {'
  null

KtDeclarationModifierList(1001,1009): 'operator'
  null

KtTypeReference(1014,1021): 'MyClass'
  null

KtUserType(1014,1021): 'MyClass'
  null

KtNameReferenceExpression(1014,1021): 'MyClass'
  null

KtParameterList(1029,1044): '(that: MyClass)'
  null

KtParameter(1030,1043): 'that: MyClass'
  null

KtTypeReference(1036,1043): 'MyClass'
  null

KtUserType(1036,1043): 'MyClass'
  null

KtNameReferenceExpression(1036,1043): 'MyClass'
  null

KtTypeReference(1046,1079): 'ClosedFloatingPointRange<MyClass>'
  null

KtUserType(1046,1079): 'ClosedFloatingPointRange<MyClass>'
  null

KtNameReferenceExpression(1046,1070): 'ClosedFloatingPointRange'
  null

KtTypeArgumentList(1070,1079): '<MyClass>'
  null

KtTypeProjection(1071,1078): 'MyClass'
  null

KtTypeReference(1071,1078): 'MyClass'
  null

KtUserType(1071,1078): 'MyClass'
  null

KtNameReferenceExpression(1071,1078): 'MyClass'
  null

KtBlockExpression(1080,1101): '{'
  null

KtReturnExpression(1086,1099): 'return null!!'
  null

KtPostfixExpression(1093,1099): 'null!!'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        null -> (KaVariableSignature:
          name = baseExpr
          receiverType = null
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>?
          symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>
          symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
          valueParameters = [
            KaVariableSignature:
              name = baseExpr
              receiverType = null
              returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>?
              symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
      typeArgumentsMapping = {
        <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (kotlin.ranges.ClosedFloatingPointRange<MyClass>)
      }

KtConstantExpression(1093,1097): 'null'
  null

KtOperationReferenceExpression(1097,1099): '!!'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        null -> (KaVariableSignature:
          name = baseExpr
          receiverType = null
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>?
          symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>
          symbol = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>(baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?): `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`
          valueParameters = [
            KaVariableSignature:
              name = baseExpr
              receiverType = null
              returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>?
              symbol = baseExpr: `<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`?
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = /<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>
      typeArgumentsMapping = {
        <TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE> -> (kotlin.ranges.ClosedFloatingPointRange<MyClass>)
      }

KtNamedFunction(1102,1175): 'operator fun MyClass.contains(that: MyClass): Boolean {'
  null

KtDeclarationModifierList(1102,1110): 'operator'
  null

KtTypeReference(1115,1122): 'MyClass'
  null

KtUserType(1115,1122): 'MyClass'
  null

KtNameReferenceExpression(1115,1122): 'MyClass'
  null

KtParameterList(1131,1146): '(that: MyClass)'
  null

KtParameter(1132,1145): 'that: MyClass'
  null

KtTypeReference(1138,1145): 'MyClass'
  null

KtUserType(1138,1145): 'MyClass'
  null

KtNameReferenceExpression(1138,1145): 'MyClass'
  null

KtTypeReference(1148,1155): 'Boolean'
  null

KtUserType(1148,1155): 'Boolean'
  null

KtNameReferenceExpression(1148,1155): 'Boolean'
  null

KtBlockExpression(1156,1175): '{'
  null

KtReturnExpression(1162,1173): 'return true'
  null

KtConstantExpression(1169,1173): 'true'
  null

KtNamedFunction(1177,1286): 'fun testOverriden(a: Int) {'
  null

KtParameterList(1194,1202): '(a: Int)'
  null

KtParameter(1195,1201): 'a: Int'
  null

KtTypeReference(1198,1201): 'Int'
  null

KtUserType(1198,1201): 'Int'
  null

KtNameReferenceExpression(1198,1201): 'Int'
  null

KtBlockExpression(1203,1286): '{'
  null

KtProperty(1209,1237): 'val a: MyClass = myClassProp'
  null

KtTypeReference(1216,1223): 'MyClass'
  null

KtUserType(1216,1223): 'MyClass'
  null

KtNameReferenceExpression(1216,1223): 'MyClass'
  null

KtNameReferenceExpression(1226,1237): 'myClassProp'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: myClassProp>

KtBinaryExpression(1242,1284): 'a !in MyClass.myClassProp..NestedInheritor'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        a -> (KaVariableSignature:
          name = value
          receiverType = null
          returnType = MyClass
          symbol = value: T
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp..NestedInheritor
          isSafeNavigation = false
          type = kotlin.ranges.ClosedFloatingPointRange<MyClass>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Boolean
          symbol = kotlin/ranges/ClosedFloatingPointRange.contains(<dispatch receiver>: kotlin.ranges.ClosedFloatingPointRange<T>, value: T): kotlin.Boolean
          valueParameters = [
            KaVariableSignature:
              name = value
              receiverType = null
              returnType = MyClass
              symbol = value: T
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/ranges/ClosedFloatingPointRange.contains
      typeArgumentsMapping = {}

KtNameReferenceExpression(1242,1243): 'a'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = null
        signature = KaVariableSignature:
          name = a
          receiverType = null
          returnType = MyClass
          symbol = val a: MyClass
          contextParameters = []
          callableId = null
      simpleAccess = Read
      typeArgumentsMapping = {}

KtOperationReferenceExpression(1244,1247): '!in'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        a -> (KaVariableSignature:
          name = value
          receiverType = null
          returnType = MyClass
          symbol = value: T
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp..NestedInheritor
          isSafeNavigation = false
          type = kotlin.ranges.ClosedFloatingPointRange<MyClass>
        extensionReceiver = null
        signature = KaFunctionSignature:
          receiverType = null
          returnType = kotlin.Boolean
          symbol = kotlin/ranges/ClosedFloatingPointRange.contains(<dispatch receiver>: kotlin.ranges.ClosedFloatingPointRange<T>, value: T): kotlin.Boolean
          valueParameters = [
            KaVariableSignature:
              name = value
              receiverType = null
              returnType = MyClass
              symbol = value: T
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = kotlin/ranges/ClosedFloatingPointRange.contains
      typeArgumentsMapping = {}

KtBinaryExpression(1248,1284): 'MyClass.myClassProp..NestedInheritor'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        NestedInheritor -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = MyClass
          symbol = that: MyClass
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp
          isSafeNavigation = false
          type = MyClass
        signature = KaFunctionSignature:
          receiverType = MyClass
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>
          symbol = /rangeTo(<extension receiver>: MyClass, that: MyClass): kotlin.ranges.ClosedFloatingPointRange<MyClass>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = MyClass
              symbol = that: MyClass
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = /rangeTo
      typeArgumentsMapping = {}

KtDotQualifiedExpression(1248,1267): 'MyClass.myClassProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = myClassProp
          receiverType = null
          returnType = MyClass
          symbol = val myClassProp: MyClass
          contextParameters = []
          callableId = /MyClass.Companion.myClassProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtNameReferenceExpression(1248,1255): 'MyClass'
  null

KtNameReferenceExpression(1256,1267): 'myClassProp'
  KaSuccessCallInfo:
    call = KaSimpleVariableAccessCall:
      isContextSensitive = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = KaExplicitReceiverValue:
          expression = MyClass
          isSafeNavigation = false
          type = MyClass.Companion
        extensionReceiver = null
        signature = KaVariableSignature:
          name = myClassProp
          receiverType = null
          returnType = MyClass
          symbol = val myClassProp: MyClass
          contextParameters = []
          callableId = /MyClass.Companion.myClassProp
      simpleAccess = Read
      typeArgumentsMapping = {}

KtOperationReferenceExpression(1267,1269): '..'
  KaSuccessCallInfo:
    call = KaSimpleFunctionCall:
      argumentMapping = {
        NestedInheritor -> (KaVariableSignature:
          name = that
          receiverType = null
          returnType = MyClass
          symbol = that: MyClass
          contextParameters = []
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        contextArguments = []
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = MyClass.myClassProp
          isSafeNavigation = false
          type = MyClass
        signature = KaFunctionSignature:
          receiverType = MyClass
          returnType = kotlin.ranges.ClosedFloatingPointRange<MyClass>
          symbol = /rangeTo(<extension receiver>: MyClass, that: MyClass): kotlin.ranges.ClosedFloatingPointRange<MyClass>
          valueParameters = [
            KaVariableSignature:
              name = that
              receiverType = null
              returnType = MyClass
              symbol = that: MyClass
              contextParameters = []
              callableId = null
          ]
          contextParameters = []
          callableId = /rangeTo
      typeArgumentsMapping = {}

KtNameReferenceExpression(1269,1284): 'NestedInheritor'
  KaErrorCallInfo:
    candidateCalls = []
    diagnostic = ERROR<UNRESOLVED_REFERENCE: Unresolved reference: NestedInheritor>