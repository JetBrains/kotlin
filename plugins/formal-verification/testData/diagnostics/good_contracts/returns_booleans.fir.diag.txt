/returns_booleans.kt:(121,133): info: Generated Viper text for returns_true:
method pkg$$global$returns_true() returns (ret: Bool)
  ensures true
  ensures ret == true
{
  ret := true
  goto label$ret
  label label$ret
}

/returns_booleans.kt:(268,281): info: Generated Viper text for returns_false:
method pkg$$global$returns_false() returns (ret: Bool)
  ensures true
  ensures ret == false
{
  ret := false
  goto label$ret
  label label$ret
}

/returns_booleans.kt:(418,435): info: Generated Viper text for conditional_basic:
method pkg$$global$conditional_basic(local$b: Bool) returns (ret: Bool)
  ensures ret == true ==> true
  ensures ret == false ==> local$b
{
  ret := true
  goto label$ret
  label label$ret
}

/returns_booleans.kt:(612,636): info: Generated Viper text for binary_logic_expressions:
method pkg$$global$binary_logic_expressions(local$a: Bool, local$b: Bool)
  returns (ret: Bool)
  ensures ret == false ==> local$b && false
  ensures ret == true ==> (true || local$a) && (local$b || true)
{
  ret := true
  goto label$ret
  label label$ret
}

/returns_booleans.kt:(855,866): info: Generated Viper text for logical_not:
method pkg$$global$logical_not(local$b: Bool) returns (ret: Bool)
  ensures ret == true ==> !local$b && local$b
  ensures ret == false ==> local$b || !local$b
{
  ret := false
  goto label$ret
  label label$ret
}

/returns_booleans.kt:(1052,1075): info: Generated Viper text for call_fun_with_contracts:
method pkg$$global$call_fun_with_contracts(local$b: Bool)
  returns (ret: Bool)
  ensures ret == true
{
  var local$a: Bool
  var anonymous$1: Bool
  anonymous$1 := pkg$$global$binary_logic_expressions(local$b, local$b)
  local$a := anonymous$1
  ret := local$a
  goto label$ret
  label label$ret
}

method pkg$$global$binary_logic_expressions(local$a: Bool, local$b: Bool)
  returns (ret: Bool)
  ensures ret == false ==> local$b && false
  ensures ret == true ==> (true || local$a) && (local$b || true)


/returns_booleans.kt:(1268,1281): info: Generated Viper text for isNullOrEmpty:
method pkg$$global$isNullOrEmpty(this: dom$Nullable[Ref])
  returns (ret: Bool)
  ensures ret == false ==> this != (dom$Nullable$null(): dom$Nullable[Ref])
{
  var anonymous$1: Bool
  inhale dom$Type$isSubtype((dom$TypeOf$typeOf(this): dom$Type), dom$Type$special$Nullable(dom$Type$pkg$kotlin$collections$class_Collection()))
  if (this == (dom$Nullable$null(): dom$Nullable[Ref]) &&
  (dom$Nullable$null(): dom$Nullable[dom$Unit]) ==
  (dom$Nullable$null(): dom$Nullable[dom$Unit]) ||
  this != (dom$Nullable$null(): dom$Nullable[Ref]) &&
  (dom$Nullable$null(): dom$Nullable[dom$Unit]) !=
  (dom$Nullable$null(): dom$Nullable[dom$Unit]) &&
  (dom$Casting$cast(this, dom$Type$pkg$kotlin$collections$class_Collection()): Ref) ==
  (dom$Casting$cast((dom$Nullable$null(): dom$Nullable[dom$Unit]), dom$Type$pkg$kotlin$collections$class_Collection()): Ref)) {
    anonymous$1 := true
  } else {
    var anonymous$2: Bool
    anonymous$2 := pkg$kotlin$collections$class_Collection$member_isEmpty((dom$Casting$cast(this,
      dom$Type$pkg$kotlin$collections$class_Collection()): Ref))
    anonymous$1 := anonymous$2
  }
  ret := anonymous$1
  goto label$ret
  label label$ret
}

method pkg$kotlin$collections$class_Collection$member_isEmpty(this: Ref)
  returns (ret: Bool)
