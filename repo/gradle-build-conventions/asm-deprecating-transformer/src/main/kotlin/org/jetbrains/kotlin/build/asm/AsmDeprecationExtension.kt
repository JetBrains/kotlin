/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.build.asm

import com.github.difflib.DiffUtils
import com.github.difflib.UnifiedDiffUtils
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.file.ArchiveOperations
import org.gradle.api.internal.file.archive.ZipEntryConstants.CONSTANT_TIME_FOR_ZIP_ENTRIES
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.util.PatternSet
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.support.serviceOf
import org.jetbrains.org.objectweb.asm.ClassReader
import org.jetbrains.org.objectweb.asm.ClassWriter
import java.io.File
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.util.*
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

/**
 * Allows configuring ad-hoc deprecation of classes included in fat jar generated by a [ShadowJar] task.
 * Context: https://youtrack.jetbrains.com/issue/KT-70251
 */
abstract class AsmDeprecationExtension {
    /**
     * Transforms class FQN-like pattern to file names pattern
     * Examples:
     * * `org.example.**` -> `org/example/**/*.class`
     * * `org.example.Class` -> `org/example/Class.class`
     */
    private fun String.transformPattern() = "${replace('.', '/').replace("**", "**/*")}.class"

    fun ShadowJar.deprecateClassesByPattern(pattern: String, deprecationMessage: String, exclusions: List<String> = emptyList()) {
        val patternSet = PatternSet()
        patternSet.include(pattern.transformPattern())
        patternSet.exclude(exclusions.map { it.transformPattern() })
        val spec = patternSet.asSpec
        val archiveOperations = project.serviceOf<ArchiveOperations>()
        val deprecationList = project.provider {
            val outputFile = archiveFile.get().asFile
            outputFile.parentFile.resolve("${outputFile.name}$PATH_SUFFIX")
        }
        inputs.property("pattern", pattern)
        inputs.property("deprecationMessage", deprecationMessage)
        for ((index, exclusion) in exclusions.withIndex()) {
            inputs.property("exclusion$index", exclusion)
        }
        outputs.file(deprecationList)
        doLast {
            val intermediateZipFilePath = temporaryDir.resolve("${UUID.randomUUID()}.${archiveExtension.get()}")
            ZipOutputStream(intermediateZipFilePath.outputStream()).use { intermediateZipFile ->
                val deprecatedPackages = sortedSetOf<String>()
                archiveOperations.zipTree(archiveFile.get().asFile).visit {
                    if (name.endsWith(".class") && spec.isSatisfiedBy(this)) {
                        val classReader = ClassReader(file.inputStream())
                        val classWriter = ClassWriter(classReader, ClassWriter.COMPUTE_FRAMES)
                        val classVisitor = DeprecatingClassTransformer(classWriter, deprecationMessage) { className ->
                            require(className.contains('.')) {
                                "Deprecating classes in the default (unnamed) package is not supported. Tried to deprecate $className"
                            }
                            logger.info("Deprecating class $className")
                            deprecatedPackages.add(className.substringBeforeLast("."))
                        }
                        classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES)
                        val newBytes = classWriter.toByteArray()
                        val newEntry = ZipEntry(path)
                        if (!isPreserveFileTimestamps) {
                            newEntry.time = CONSTANT_TIME_FOR_ZIP_ENTRIES
                        }
                        intermediateZipFile.putNextEntry(newEntry)
                        intermediateZipFile.write(newBytes)
                        intermediateZipFile.closeEntry()
                    } else {
                        val newEntry = ZipEntry(if (isDirectory) "$path/" else path)
                        if (!isPreserveFileTimestamps) {
                            newEntry.time = CONSTANT_TIME_FOR_ZIP_ENTRIES
                        }
                        intermediateZipFile.putNextEntry(newEntry)
                        if (!isDirectory) {
                            file.inputStream().use {
                                it.copyTo(intermediateZipFile)
                            }
                        }
                        intermediateZipFile.closeEntry()
                    }
                }
                deprecationList.get().outputStream().bufferedWriter().use { deprecationListWriter ->
                    deprecationListWriter.appendLine("The following packages are (non-transitively) deprecated by the `asm-deprecating-transformer` plugin:")
                    deprecatedPackages.forEach { packageName ->
                        deprecationListWriter.appendLine("package $packageName")
                    }
                }
            }
            Files.move(intermediateZipFilePath.toPath(), archiveFile.get().asFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
        }
    }

    fun TaskContainer.registerDumpDeprecationsTask(shadowJarTaskName: String, suffix: String) =
        register<Copy>("dumpDeprecationsFor${suffix}") {
            val shadowJarTask = named<ShadowJar>(shadowJarTaskName)
            val actualDeprecations =
                shadowJarTask.map { it.archiveFile.get().asFile.parentFile.resolve("${it.archiveFile.get().asFile.name}$PATH_SUFFIX") }
            from(actualDeprecations)
            into(project.layout.projectDirectory.dir(BUILD_DIRECTORY))
            rename {
                "$suffix$PATH_SUFFIX"
            }
        }

    fun TaskContainer.registerCheckDeprecationsTask(
        shadowJarTaskName: String,
        suffix: String,
        expectedFileDoesNotExistMessage: String,
        checkFailureMessage: String,
    ) =
        register<DefaultTask>("checkDeprecationsFor${suffix}") {
            val shadowJarTask = named<ShadowJar>(shadowJarTaskName)
            val actualDeprecations =
                shadowJarTask.map { it.archiveFile.get().asFile.parentFile.resolve("${it.archiveFile.get().asFile.name}$PATH_SUFFIX") }
            val expectedDeprecations = project.layout.projectDirectory.file("$BUILD_DIRECTORY/$suffix$PATH_SUFFIX")
            inputs.file(actualDeprecations)
            // `files` to check it manually and give an actionable failure message.
            // otherwise Gradle will complain that the input file does not exist
            inputs.files(expectedDeprecations)
            doFirst {
                val expectedFile = expectedDeprecations.asFile
                if (!expectedFile.exists()) {
                    throw GradleException(expectedFileDoesNotExistMessage)
                }
                val actualFile = actualDeprecations.get()
                val diff = getDiff(expectedFile, actualFile)
                if (diff != null) {
                    throw GradleException("$checkFailureMessage\nDifference:\n$diff")
                }
            }
        }

    companion object {
        private const val PATH_SUFFIX = ".deprecations"
        private const val BUILD_DIRECTORY = "asm-deprecation"

        private fun getDiff(expectedFile: File, actualFile: File): String? {
            val expectedLines = expectedFile.readText().lines()
            val actualLines = actualFile.readText().lines()

            if (expectedLines == actualLines)
                return null

            val patch = DiffUtils.diff(expectedLines, actualLines)
            val diff =
                UnifiedDiffUtils.generateUnifiedDiff(expectedFile.absolutePath, actualFile.absolutePath, expectedLines, patch, 3)
            return diff.joinToString("\n")
        }
    }
}