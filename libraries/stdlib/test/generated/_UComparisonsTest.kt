/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package test.unsigned

//
// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLibTests.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import kotlin.random.*
import kotlin.test.*

class _UComparisonsTest {
    @Test
    fun maxOf_2_UInt() {
        expect(2u) { maxOf(2u, 1u) }
        expect(126u) { maxOf(58u, 126u) }
        expect(23u) { maxOf(Random.nextUInt(UInt.MIN_VALUE, 23u), 23u) }
        expect(UInt.MAX_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MAX_VALUE) }
        expect(UInt.MIN_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MIN_VALUE) }
    }

    @Test
    fun maxOf_2_ULong() {
        expect(2uL) { maxOf(2uL, 1uL) }
        expect(126uL) { maxOf(58uL, 126uL) }
        expect(23uL) { maxOf(Random.nextULong(ULong.MIN_VALUE, 23uL), 23uL) }
        expect(ULong.MAX_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MAX_VALUE) }
        expect(ULong.MIN_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MIN_VALUE) }
    }

    @Test
    fun maxOf_2_UByte() {
        expect(2.toUByte()) { maxOf(2.toUByte(), 1.toUByte()) }
        expect(126.toUByte()) { maxOf(58.toUByte(), 126.toUByte()) }
        expect(23.toUByte()) { maxOf(Random.nextInt(UByte.MIN_VALUE.toInt(), 23).toUByte(), 23.toUByte()) }
        expect(UByte.MAX_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MAX_VALUE) }
        expect(UByte.MIN_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MIN_VALUE) }
    }

    @Test
    fun maxOf_2_UShort() {
        expect(2.toUShort()) { maxOf(2.toUShort(), 1.toUShort()) }
        expect(126.toUShort()) { maxOf(58.toUShort(), 126.toUShort()) }
        expect(23.toUShort()) { maxOf(Random.nextInt(UShort.MIN_VALUE.toInt(), 23).toUShort(), 23.toUShort()) }
        expect(UShort.MAX_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MAX_VALUE) }
        expect(UShort.MIN_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MIN_VALUE) }
    }

    @Test
    fun maxOf_3_UInt() {
        expect(3u) { maxOf(2u, 1u, 3u) }
        expect(126u) { maxOf(58u, 126u, 55u) }
        expect(23u) { maxOf(Random.nextUInt(UInt.MIN_VALUE, 23u), 23u, Random.nextUInt(UInt.MIN_VALUE, 23u)) }
        expect(UInt.MIN_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MIN_VALUE, UInt.MIN_VALUE) }
            expect(UInt.MAX_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MAX_VALUE, 0u) }
            
    }

    @Test
    fun maxOf_3_ULong() {
        expect(3uL) { maxOf(2uL, 1uL, 3uL) }
        expect(126uL) { maxOf(58uL, 126uL, 55uL) }
        expect(23uL) { maxOf(Random.nextULong(ULong.MIN_VALUE, 23uL), 23uL, Random.nextULong(ULong.MIN_VALUE, 23uL)) }
        expect(ULong.MIN_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MIN_VALUE, ULong.MIN_VALUE) }
            expect(ULong.MAX_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MAX_VALUE, 0uL) }
            
    }

    @Test
    fun maxOf_3_UByte() {
        expect(3.toUByte()) { maxOf(2.toUByte(), 1.toUByte(), 3.toUByte()) }
        expect(126.toUByte()) { maxOf(58.toUByte(), 126.toUByte(), 55.toUByte()) }
        expect(23.toUByte()) { maxOf(Random.nextInt(UByte.MIN_VALUE.toInt(), 23).toUByte(), 23.toUByte(), Random.nextInt(UByte.MIN_VALUE.toInt(), 23).toUByte()) }
        expect(UByte.MIN_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MIN_VALUE, UByte.MIN_VALUE) }
            expect(UByte.MAX_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MAX_VALUE, 0.toUByte()) }
            
    }

    @Test
    fun maxOf_3_UShort() {
        expect(3.toUShort()) { maxOf(2.toUShort(), 1.toUShort(), 3.toUShort()) }
        expect(126.toUShort()) { maxOf(58.toUShort(), 126.toUShort(), 55.toUShort()) }
        expect(23.toUShort()) { maxOf(Random.nextInt(UShort.MIN_VALUE.toInt(), 23).toUShort(), 23.toUShort(), Random.nextInt(UShort.MIN_VALUE.toInt(), 23).toUShort()) }
        expect(UShort.MIN_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MIN_VALUE, UShort.MIN_VALUE) }
            expect(UShort.MAX_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MAX_VALUE, 0.toUShort()) }
            
    }

    @Test
    fun maxOf_vararg_UInt() {
        expect(10u) { maxOf(2u, 1u, 3u, 10u) }
        expect(126u) { maxOf(58u, 126u, 55u, 87u) }
        expect(23u) { maxOf(Random.nextUInt(UInt.MIN_VALUE, 23u), 23u, Random.nextUInt(UInt.MIN_VALUE, 23u), 21u) }
        expect(UInt.MIN_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MIN_VALUE, UInt.MIN_VALUE, UInt.MIN_VALUE) }
            expect(UInt.MAX_VALUE) { maxOf(UInt.MIN_VALUE, UInt.MAX_VALUE, 0u, 1u) }
            
    }

    @Test
    fun maxOf_vararg_ULong() {
        expect(10uL) { maxOf(2uL, 1uL, 3uL, 10uL) }
        expect(126uL) { maxOf(58uL, 126uL, 55uL, 87uL) }
        expect(23uL) { maxOf(Random.nextULong(ULong.MIN_VALUE, 23uL), 23uL, Random.nextULong(ULong.MIN_VALUE, 23uL), 21uL) }
        expect(ULong.MIN_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MIN_VALUE, ULong.MIN_VALUE, ULong.MIN_VALUE) }
            expect(ULong.MAX_VALUE) { maxOf(ULong.MIN_VALUE, ULong.MAX_VALUE, 0uL, 1uL) }
            
    }

    @Test
    fun maxOf_vararg_UByte() {
        expect(10.toUByte()) { maxOf(2.toUByte(), 1.toUByte(), 3.toUByte(), 10.toUByte()) }
        expect(126.toUByte()) { maxOf(58.toUByte(), 126.toUByte(), 55.toUByte(), 87.toUByte()) }
        expect(23.toUByte()) { maxOf(Random.nextInt(UByte.MIN_VALUE.toInt(), 23).toUByte(), 23.toUByte(), Random.nextInt(UByte.MIN_VALUE.toInt(), 23).toUByte(), 21.toUByte()) }
        expect(UByte.MIN_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MIN_VALUE, UByte.MIN_VALUE, UByte.MIN_VALUE) }
            expect(UByte.MAX_VALUE) { maxOf(UByte.MIN_VALUE, UByte.MAX_VALUE, 0.toUByte(), 1.toUByte()) }
            
    }

    @Test
    fun maxOf_vararg_UShort() {
        expect(10.toUShort()) { maxOf(2.toUShort(), 1.toUShort(), 3.toUShort(), 10.toUShort()) }
        expect(126.toUShort()) { maxOf(58.toUShort(), 126.toUShort(), 55.toUShort(), 87.toUShort()) }
        expect(23.toUShort()) { maxOf(Random.nextInt(UShort.MIN_VALUE.toInt(), 23).toUShort(), 23.toUShort(), Random.nextInt(UShort.MIN_VALUE.toInt(), 23).toUShort(), 21.toUShort()) }
        expect(UShort.MIN_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MIN_VALUE, UShort.MIN_VALUE, UShort.MIN_VALUE) }
            expect(UShort.MAX_VALUE) { maxOf(UShort.MIN_VALUE, UShort.MAX_VALUE, 0.toUShort(), 1.toUShort()) }
            
    }

    @Test
    fun minOf_2_UInt() {
        expect(1u) { minOf(2u, 1u) }
        expect(58u) { minOf(58u, 126u) }
        expect(23u) { minOf(Random.nextUInt(23u..UInt.MAX_VALUE), 23u) }
        expect(UInt.MIN_VALUE) { minOf(UInt.MIN_VALUE, UInt.MAX_VALUE) }
        expect(UInt.MAX_VALUE) { minOf(UInt.MAX_VALUE, UInt.MAX_VALUE) }
    }

    @Test
    fun minOf_2_ULong() {
        expect(1uL) { minOf(2uL, 1uL) }
        expect(58uL) { minOf(58uL, 126uL) }
        expect(23uL) { minOf(Random.nextULong(23uL..ULong.MAX_VALUE), 23uL) }
        expect(ULong.MIN_VALUE) { minOf(ULong.MIN_VALUE, ULong.MAX_VALUE) }
        expect(ULong.MAX_VALUE) { minOf(ULong.MAX_VALUE, ULong.MAX_VALUE) }
    }

    @Test
    fun minOf_2_UByte() {
        expect(1.toUByte()) { minOf(2.toUByte(), 1.toUByte()) }
        expect(58.toUByte()) { minOf(58.toUByte(), 126.toUByte()) }
        expect(23.toUByte()) { minOf(Random.nextInt(23..UByte.MAX_VALUE.toInt()).toUByte(), 23.toUByte()) }
        expect(UByte.MIN_VALUE) { minOf(UByte.MIN_VALUE, UByte.MAX_VALUE) }
        expect(UByte.MAX_VALUE) { minOf(UByte.MAX_VALUE, UByte.MAX_VALUE) }
    }

    @Test
    fun minOf_2_UShort() {
        expect(1.toUShort()) { minOf(2.toUShort(), 1.toUShort()) }
        expect(58.toUShort()) { minOf(58.toUShort(), 126.toUShort()) }
        expect(23.toUShort()) { minOf(Random.nextInt(23..UShort.MAX_VALUE.toInt()).toUShort(), 23.toUShort()) }
        expect(UShort.MIN_VALUE) { minOf(UShort.MIN_VALUE, UShort.MAX_VALUE) }
        expect(UShort.MAX_VALUE) { minOf(UShort.MAX_VALUE, UShort.MAX_VALUE) }
    }

    @Test
    fun minOf_3_UInt() {
        expect(1u) { minOf(2u, 1u, 3u) }
        expect(55u) { minOf(58u, 126u, 55u) }
        expect(23u) { minOf(Random.nextUInt(23u..UInt.MAX_VALUE), 23u, Random.nextUInt(23u..UInt.MAX_VALUE)) }
        expect(UInt.MAX_VALUE) { minOf(UInt.MAX_VALUE, UInt.MAX_VALUE, UInt.MAX_VALUE) }
            expect(UInt.MIN_VALUE) { minOf(UInt.MIN_VALUE, UInt.MAX_VALUE, 0u) }
            
    }

    @Test
    fun minOf_3_ULong() {
        expect(1uL) { minOf(2uL, 1uL, 3uL) }
        expect(55uL) { minOf(58uL, 126uL, 55uL) }
        expect(23uL) { minOf(Random.nextULong(23uL..ULong.MAX_VALUE), 23uL, Random.nextULong(23uL..ULong.MAX_VALUE)) }
        expect(ULong.MAX_VALUE) { minOf(ULong.MAX_VALUE, ULong.MAX_VALUE, ULong.MAX_VALUE) }
            expect(ULong.MIN_VALUE) { minOf(ULong.MIN_VALUE, ULong.MAX_VALUE, 0uL) }
            
    }

    @Test
    fun minOf_3_UByte() {
        expect(1.toUByte()) { minOf(2.toUByte(), 1.toUByte(), 3.toUByte()) }
        expect(55.toUByte()) { minOf(58.toUByte(), 126.toUByte(), 55.toUByte()) }
        expect(23.toUByte()) { minOf(Random.nextInt(23..UByte.MAX_VALUE.toInt()).toUByte(), 23.toUByte(), Random.nextInt(23..UByte.MAX_VALUE.toInt()).toUByte()) }
        expect(UByte.MAX_VALUE) { minOf(UByte.MAX_VALUE, UByte.MAX_VALUE, UByte.MAX_VALUE) }
            expect(UByte.MIN_VALUE) { minOf(UByte.MIN_VALUE, UByte.MAX_VALUE, 0u) }
            
    }

    @Test
    fun minOf_3_UShort() {
        expect(1.toUShort()) { minOf(2.toUShort(), 1.toUShort(), 3.toUShort()) }
        expect(55.toUShort()) { minOf(58.toUShort(), 126.toUShort(), 55.toUShort()) }
        expect(23.toUShort()) { minOf(Random.nextInt(23..UShort.MAX_VALUE.toInt()).toUShort(), 23.toUShort(), Random.nextInt(23..UShort.MAX_VALUE.toInt()).toUShort()) }
        expect(UShort.MAX_VALUE) { minOf(UShort.MAX_VALUE, UShort.MAX_VALUE, UShort.MAX_VALUE) }
            expect(UShort.MIN_VALUE) { minOf(UShort.MIN_VALUE, UShort.MAX_VALUE, 0u) }
            
    }

    @Test
    fun minOf_vararg_UInt() {
        expect(1u) { minOf(2u, 1u, 3u, 10u) }
        expect(55u) { minOf(58u, 126u, 55u, 87u) }
        expect(21u) { minOf(Random.nextUInt(23u..UInt.MAX_VALUE), 23u, Random.nextUInt(23u..UInt.MAX_VALUE), 21u) }
        expect(UInt.MAX_VALUE) { minOf(UInt.MAX_VALUE, UInt.MAX_VALUE, UInt.MAX_VALUE, UInt.MAX_VALUE) }
            assertEquals(UInt.MIN_VALUE, minOf(UInt.MIN_VALUE, UInt.MAX_VALUE, 0u, 1u))
            
    }

    @Test
    fun minOf_vararg_ULong() {
        expect(1uL) { minOf(2uL, 1uL, 3uL, 10uL) }
        expect(55uL) { minOf(58uL, 126uL, 55uL, 87uL) }
        expect(21uL) { minOf(Random.nextULong(23uL..ULong.MAX_VALUE), 23uL, Random.nextULong(23uL..ULong.MAX_VALUE), 21uL) }
        expect(ULong.MAX_VALUE) { minOf(ULong.MAX_VALUE, ULong.MAX_VALUE, ULong.MAX_VALUE, ULong.MAX_VALUE) }
            assertEquals(ULong.MIN_VALUE, minOf(ULong.MIN_VALUE, ULong.MAX_VALUE, 0uL, 1uL))
            
    }

    @Test
    fun minOf_vararg_UByte() {
        expect(1.toUByte()) { minOf(2.toUByte(), 1.toUByte(), 3.toUByte(), 10.toUByte()) }
        expect(55.toUByte()) { minOf(58.toUByte(), 126.toUByte(), 55.toUByte(), 87.toUByte()) }
        expect(21.toUByte()) { minOf(Random.nextInt(23..UByte.MAX_VALUE.toInt()).toUByte(), 23.toUByte(), Random.nextInt(23..UByte.MAX_VALUE.toInt()).toUByte(), 21.toUByte()) }
        expect(UByte.MAX_VALUE) { minOf(UByte.MAX_VALUE, UByte.MAX_VALUE, UByte.MAX_VALUE, UByte.MAX_VALUE) }
            assertEquals(UByte.MIN_VALUE, minOf(UByte.MIN_VALUE, UByte.MAX_VALUE, 0.toUByte(), 1.toUByte()))
            
    }

    @Test
    fun minOf_vararg_UShort() {
        expect(1.toUShort()) { minOf(2.toUShort(), 1.toUShort(), 3.toUShort(), 10.toUShort()) }
        expect(55.toUShort()) { minOf(58.toUShort(), 126.toUShort(), 55.toUShort(), 87.toUShort()) }
        expect(21.toUShort()) { minOf(Random.nextInt(23..UShort.MAX_VALUE.toInt()).toUShort(), 23.toUShort(), Random.nextInt(23..UShort.MAX_VALUE.toInt()).toUShort(), 21.toUShort()) }
        expect(UShort.MAX_VALUE) { minOf(UShort.MAX_VALUE, UShort.MAX_VALUE, UShort.MAX_VALUE, UShort.MAX_VALUE) }
            assertEquals(UShort.MIN_VALUE, minOf(UShort.MIN_VALUE, UShort.MAX_VALUE, 0.toUShort(), 1.toUShort()))
            
    }

}
