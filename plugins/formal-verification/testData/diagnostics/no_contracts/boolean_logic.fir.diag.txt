/boolean_logic.kt:(4,12): info: Generated Viper text for negation:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(nx: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall nx: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) }
      nx != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) ==
      nx)
  }
}

method global$pkg_$negation(local$x: Bool) returns (ret$: Bool)
{
  ret$ := !local$x
}

/boolean_logic.kt:(56,67): info: Generated Viper text for conjunction:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(nx: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall nx: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) }
      nx != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) ==
      nx)
  }
}

method global$pkg_$conjunction(local$x: Bool, local$y: Bool)
  returns (ret$: Bool)
{
  var anonymous$1: Bool
  if (local$x) {
    anonymous$1 := local$y
  } else {
    anonymous$1 := false}
  ret$ := anonymous$1
}

/boolean_logic.kt:(127,151): info: Generated Viper text for conjunction_side_effects:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(nx: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall nx: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) }
      nx != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) ==
      nx)
  }
}

method global$pkg_$negation(local$x: Bool) returns (ret$: Bool)


method global$pkg_$conjunction_side_effects(local$x: Bool, local$y: Bool)
  returns (ret$: Bool)
{
  var anonymous$1: Bool
  var anonymous$2: Bool
  anonymous$2 := global$pkg_$negation(local$x)
  if (anonymous$2) {
    var anonymous$3: Bool
    anonymous$3 := global$pkg_$negation(local$y)
    anonymous$1 := anonymous$3
  } else {
    anonymous$1 := false}
  ret$ := anonymous$1
}

/boolean_logic.kt:(324,335): info: Generated Viper text for disjunction:
domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(nx: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall nx: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) }
      nx != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(nx): T)): dom$Nullable[T]) ==
      nx)
  }
}

method global$pkg_$disjunction(local$x: Bool, local$y: Bool)
  returns (ret$: Bool)
{
  var anonymous$1: Bool
  if (local$x) {
    anonymous$1 := true
  } else {
    anonymous$1 := local$y}
  ret$ := anonymous$1
}
