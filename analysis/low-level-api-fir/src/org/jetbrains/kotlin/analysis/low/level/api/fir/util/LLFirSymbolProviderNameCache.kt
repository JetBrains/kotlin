/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.low.level.api.fir.util

import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.caches.createCache
import org.jetbrains.kotlin.fir.caches.firCachesFactory
import org.jetbrains.kotlin.fir.caches.getValue
import org.jetbrains.kotlin.fir.resolve.providers.mayHaveTopLevelClassifier
import org.jetbrains.kotlin.fir.types.functionTypeService
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

/**
 * Caches the names of classifiers and callables contained in a package. [LLFirSymbolProviderNameCache] is used by symbol providers to abort
 * symbol finding early if the symbol name isn't contained in the symbol provider's domain.
 */
internal abstract class LLFirSymbolProviderNameCache(private val firSession: FirSession) {
    internal data class ClassifierNamesInPackage(
        val names: Set<String>,

        /**
         * Some packages (such as `kotlin` or `kotlin.coroutines`) may contain function classes generated by the compiler. To avoid a hash
         * map access when checking `mayHaveTopLevelClassifier`, [mayHaveFunctionClass] is precomputed for each package name. Also see
         * [org.jetbrains.kotlin.builtins.functions.FunctionTypeKind].
         */
        val mayHaveFunctionClass: Boolean,
    )

    abstract fun computeClassifierNames(packageFqName: FqName): Set<String>?
    abstract fun computeCallableNames(packageFqName: FqName): Set<Name>?

    private val topLevelClassifierNamesByPackage =
        firSession.firCachesFactory.createCache<FqName, ClassifierNamesInPackage?> { packageFqName ->
            val names = computeClassifierNames(packageFqName) ?: return@createCache null
            val mayHaveFunctionClass = firSession.functionTypeService.hasKindWithSpecificPackage(packageFqName)
            ClassifierNamesInPackage(names, mayHaveFunctionClass)
        }

    private val topLevelCallableNamesByPackage =
        firSession.firCachesFactory.createCache<FqName, Set<Name>?>(::computeCallableNames)

    fun getTopLevelClassifierNamesInPackage(packageFqName: FqName): ClassifierNamesInPackage? =
        topLevelClassifierNamesByPackage.getValue(packageFqName)

    fun getTopLevelCallableNamesInPackage(packageFqName: FqName): Set<Name>? =
        topLevelCallableNamesByPackage.getValue(packageFqName)

    fun mayHaveTopLevelClassifier(classId: ClassId): Boolean {
        val (names, mayHaveFunctionClass) = getTopLevelClassifierNamesInPackage(classId.packageFqName) ?: return true
        return names.mayHaveTopLevelClassifier(classId, firSession, mayHaveFunctionClass)
    }

    fun mayHaveTopLevelCallable(packageFqName: FqName, name: Name): Boolean {
        if (name.isSpecial) return true
        val names = getTopLevelCallableNamesInPackage(packageFqName) ?: return true
        return name in names
    }
}
