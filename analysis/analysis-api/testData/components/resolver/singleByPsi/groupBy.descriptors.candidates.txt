KtDotQualifiedExpression(263,332): 'nums.withIndex().groupBy({ (_, value) -> value }) { (idx, _) -> idx }'
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.Array<out ERROR_TYPE>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        T -> (ERROR_TYPE),
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<T, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.Array<out ERROR_TYPE>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<T, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        T -> (ERROR_TYPE),
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.BooleanArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>, valueTransform: kotlin.Function1<kotlin.Boolean, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.BooleanArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Boolean>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Boolean>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ByteArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>, valueTransform: kotlin.Function1<kotlin.Byte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ByteArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Byte>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Byte>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Char, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.CharArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Char, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Char, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.CharArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Char>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Char, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Char, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.CharSequence
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Char, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
              callableId = null
          ]
          callableId = kotlin/text/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Char, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.CharSequence
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Char>>
          symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Char, K>
              callableId = null
          ]
          callableId = kotlin/text/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> defined in kotlin.text>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Double, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.DoubleArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>, valueTransform: kotlin.Function1<kotlin.Double, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Double, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Double, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.DoubleArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Double>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Double>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Double, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Float, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.FloatArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>, valueTransform: kotlin.Function1<kotlin.Float, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Float, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Float, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.FloatArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Float>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Float>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Float, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Int, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.IntArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>, valueTransform: kotlin.Function1<kotlin.Int, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Int, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Int, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.IntArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Int>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Int, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Long, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.LongArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>, valueTransform: kotlin.Function1<kotlin.Long, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Long, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Long, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.LongArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Long>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Long>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Long, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Short, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ShortArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>, valueTransform: kotlin.Function1<kotlin.Short, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Short, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Short, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ShortArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Short>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Short>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Short, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UByteArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>, valueTransform: kotlin.Function1<kotlin.UByte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UByteArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UByte>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UByte>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UIntArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>, valueTransform: kotlin.Function1<kotlin.UInt, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UIntArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UInt>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UInt>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ULongArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>, valueTransform: kotlin.Function1<kotlin.ULong, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.ULongArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.ULong>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.ULong>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UShortArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>, valueTransform: kotlin.Function1<kotlin.UShort, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.UShortArray
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UShort>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UShort>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.collections.IndexedValue<kotlin.Int>>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        T -> (kotlin.collections.IndexedValue<kotlin.Int>),
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.collections>
    isInBestCandidates = false
  
  KaApplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
          symbol = valueTransform: kotlin.Function1<T, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
          returnType = kotlin.collections.Map<kotlin.Int, kotlin.collections.List<kotlin.Int>>
          symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, kotlin.Int>
              symbol = valueTransform: kotlin.Function1<T, V>
              callableId = null
          ]
          callableId = kotlin/collections/groupBy
      typeArgumentsMapping = {
        T -> (kotlin.collections.IndexedValue<kotlin.Int>),
        K -> (kotlin.Int),
        V -> (kotlin.Int)
      }
    isInBestCandidates = true
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
          symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Int>>
          symbol = /groupBy(<extension receiver>: kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>, keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>, valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
              symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
              callableId = null
          ]
          callableId = /groupBy
      typeArgumentsMapping = {
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.sequences.Sequence<ERROR_TYPE>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null
          ]
          callableId = kotlin/sequences/groupBy
      typeArgumentsMapping = {
        T -> (ERROR_TYPE),
        K -> (ERROR_TYPE)
      }
    diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.sequences>
    isInBestCandidates = false
  
  KaInapplicableCallCandidateInfo:
    candidate = KaSimpleFunctionCall:
      argumentMapping = {
        { (_, value) -> value } -> (KaVariableSignature:
          name = keySelector
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = keySelector: kotlin.Function1<T, K>
          callableId = null),
        { (idx, _) -> idx } -> (KaVariableSignature:
          name = valueTransform
          receiverType = null
          returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
          symbol = valueTransform: kotlin.Function1<T, V>
          callableId = null)
      }
      isImplicitInvoke = false
      partiallyAppliedSymbol = KaPartiallyAppliedSymbol:
        dispatchReceiver = null
        extensionReceiver = KaExplicitReceiverValue:
          expression = nums.withIndex()
          isSafeNavigation = false
          type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        signature = KaFunctionSignature:
          receiverType = kotlin.sequences.Sequence<ERROR_TYPE>
          returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
          symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
          valueParameters = [
            KaVariableSignature:
              name = keySelector
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = keySelector: kotlin.Function1<T, K>
              callableId = null,
            KaVariableSignature:
              name = valueTransform
              receiverType = null
              returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
              symbol = valueTransform: kotlin.Function1<T, V>
              callableId = null
          ]
          callableId = kotlin/sequences/groupBy
      typeArgumentsMapping = {
        T -> (ERROR_TYPE),
        K -> (ERROR_TYPE),
        V -> (ERROR_TYPE)
      }
    diagnostic = ERROR<UNRESOLVED_REFERENCE: RECEIVER_TYPE_ERROR with groupBy>
    isInBestCandidates = false