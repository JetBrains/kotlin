/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.decompiler.psi;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.jetbrains.kotlin.test.TestMetadata;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.generators.tests.analysis.api.GenerateAnalysisApiTestsKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@TestMetadata("compiler/testData/psi")
@TestDataPath("$PROJECT_ROOT")
public class DecompiledTextTestGenerated extends AbstractDecompiledTextTest {
  @Test
  @TestMetadata("AbsentInnerType.kt")
  public void testAbsentInnerType() {
    runTest("compiler/testData/psi/AbsentInnerType.kt");
  }

  @Test
  public void testAllFilesPresentInPsi() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
  }

  @Test
  @TestMetadata("annotatedFlexibleTypes.kt")
  public void testAnnotatedFlexibleTypes() {
    runTest("compiler/testData/psi/annotatedFlexibleTypes.kt");
  }

  @Test
  @TestMetadata("AnnotatedIntersections.kt")
  public void testAnnotatedIntersections() {
    runTest("compiler/testData/psi/AnnotatedIntersections.kt");
  }

  @Test
  @TestMetadata("annotatedParameterInEnumConstructor.kt")
  public void testAnnotatedParameterInEnumConstructor() {
    runTest("compiler/testData/psi/annotatedParameterInEnumConstructor.kt");
  }

  @Test
  @TestMetadata("annotatedParameterInInnerClassConstructor.kt")
  public void testAnnotatedParameterInInnerClassConstructor() {
    runTest("compiler/testData/psi/annotatedParameterInInnerClassConstructor.kt");
  }

  @Test
  @TestMetadata("annotationClass.kt")
  public void testAnnotationClass() {
    runTest("compiler/testData/psi/annotationClass.kt");
  }

  @Test
  @TestMetadata("annotationValues.kt")
  public void testAnnotationValues() {
    runTest("compiler/testData/psi/annotationValues.kt");
  }

  @Test
  @TestMetadata("annotations.kt")
  public void testAnnotations() {
    runTest("compiler/testData/psi/annotations.kt");
  }

  @Test
  @TestMetadata("annotationsOnNullableTypes.kt")
  public void testAnnotationsOnNullableTypes() {
    runTest("compiler/testData/psi/annotationsOnNullableTypes.kt");
  }

  @Test
  @TestMetadata("annotationsOnParenthesizedTypes.kt")
  public void testAnnotationsOnParenthesizedTypes() {
    runTest("compiler/testData/psi/annotationsOnParenthesizedTypes.kt");
  }

  @Test
  @TestMetadata("AnonymousInitializer.kt")
  public void testAnonymousInitializer() {
    runTest("compiler/testData/psi/AnonymousInitializer.kt");
  }

  @Test
  @TestMetadata("anonymousReturnWithGenericType.kt")
  public void testAnonymousReturnWithGenericType() {
    runTest("compiler/testData/psi/anonymousReturnWithGenericType.kt");
  }

  @Test
  @TestMetadata("AssertNotNull.kt")
  public void testAssertNotNull() {
    runTest("compiler/testData/psi/AssertNotNull.kt");
  }

  @Test
  @TestMetadata("BabySteps.kt")
  public void testBabySteps() {
    runTest("compiler/testData/psi/BabySteps.kt");
  }

  @Test
  @TestMetadata("BabySteps_ERR.kt")
  public void testBabySteps_ERR() {
    runTest("compiler/testData/psi/BabySteps_ERR.kt");
  }

  @Test
  @TestMetadata("BackslashInString.kt")
  public void testBackslashInString() {
    runTest("compiler/testData/psi/BackslashInString.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile1.kt")
  public void testBlockCommentAtBeginningOfFile1() {
    runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile1.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile2.kt")
  public void testBlockCommentAtBeginningOfFile2() {
    runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile2.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile3.kt")
  public void testBlockCommentAtBeginningOfFile3() {
    runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile3.kt");
  }

  @Test
  @TestMetadata("BlockCommentAtBeginningOfFile4.kt")
  public void testBlockCommentAtBeginningOfFile4() {
    runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile4.kt");
  }

  @Test
  @TestMetadata("BlockCommentUnmatchedClosing_ERR.kt")
  public void testBlockCommentUnmatchedClosing_ERR() {
    runTest("compiler/testData/psi/BlockCommentUnmatchedClosing_ERR.kt");
  }

  @Test
  @TestMetadata("ByClauses.kt")
  public void testByClauses() {
    runTest("compiler/testData/psi/ByClauses.kt");
  }

  @Test
  @TestMetadata("CallWithManyClosures.kt")
  public void testCallWithManyClosures() {
    runTest("compiler/testData/psi/CallWithManyClosures.kt");
  }

  @Test
  @TestMetadata("CallsInWhen.kt")
  public void testCallsInWhen() {
    runTest("compiler/testData/psi/CallsInWhen.kt");
  }

  @Test
  @TestMetadata("classMembers.kt")
  public void testClassMembers() {
    runTest("compiler/testData/psi/classMembers.kt");
  }

  @Test
  @TestMetadata("classObject.kt")
  public void testClassObject() {
    runTest("compiler/testData/psi/classObject.kt");
  }

  @Test
  @TestMetadata("CollectionLiterals.kt")
  public void testCollectionLiterals() {
    runTest("compiler/testData/psi/CollectionLiterals.kt");
  }

  @Test
  @TestMetadata("CollectionLiterals_ERR.kt")
  public void testCollectionLiterals_ERR() {
    runTest("compiler/testData/psi/CollectionLiterals_ERR.kt");
  }

  @Test
  @TestMetadata("CommentsBinding.kt")
  public void testCommentsBinding() {
    runTest("compiler/testData/psi/CommentsBinding.kt");
  }

  @Test
  @TestMetadata("CommentsBindingInLambda.kt")
  public void testCommentsBindingInLambda() {
    runTest("compiler/testData/psi/CommentsBindingInLambda.kt");
  }

  @Test
  @TestMetadata("CommentsBindingInStatementBlock.kt")
  public void testCommentsBindingInStatementBlock() {
    runTest("compiler/testData/psi/CommentsBindingInStatementBlock.kt");
  }

  @Test
  @TestMetadata("complicateLTGT.kt")
  public void testComplicateLTGT() {
    runTest("compiler/testData/psi/complicateLTGT.kt");
  }

  @Test
  @TestMetadata("complicateLTGTE.kt")
  public void testComplicateLTGTE() {
    runTest("compiler/testData/psi/complicateLTGTE.kt");
  }

  @Test
  @TestMetadata("const.kt")
  public void testConst() {
    runTest("compiler/testData/psi/const.kt");
  }

  @Test
  @TestMetadata("Constructors.kt")
  public void testConstructors() {
    runTest("compiler/testData/psi/Constructors.kt");
  }

  @Test
  @TestMetadata("contextParametersAndAnnotations.kt")
  public void testContextParametersAndAnnotations() {
    runTest("compiler/testData/psi/contextParametersAndAnnotations.kt");
  }

  @Test
  @TestMetadata("ControlStructures.kt")
  public void testControlStructures() {
    runTest("compiler/testData/psi/ControlStructures.kt");
  }

  @Test
  @TestMetadata("dataClass.kt")
  public void testDataClass() {
    runTest("compiler/testData/psi/dataClass.kt");
  }

  @Test
  @TestMetadata("dataObject.kt")
  public void testDataObject() {
    runTest("compiler/testData/psi/dataObject.kt");
  }

  @Test
  @TestMetadata("defaultImplsInInterface.kt")
  public void testDefaultImplsInInterface() {
    runTest("compiler/testData/psi/defaultImplsInInterface.kt");
  }

  @Test
  @TestMetadata("DefaultKeyword.kt")
  public void testDefaultKeyword() {
    runTest("compiler/testData/psi/DefaultKeyword.kt");
  }

  @Test
  @TestMetadata("DefinitelyNotNullType.kt")
  public void testDefinitelyNotNullType() {
    runTest("compiler/testData/psi/DefinitelyNotNullType.kt");
  }

  @Test
  @TestMetadata("definitelyNotNullTypes.kt")
  public void testDefinitelyNotNullTypes() {
    runTest("compiler/testData/psi/definitelyNotNullTypes.kt");
  }

  @Test
  @TestMetadata("delegatedWithInitializer.kt")
  public void testDelegatedWithInitializer() {
    runTest("compiler/testData/psi/delegatedWithInitializer.kt");
  }

  @Test
  @TestMetadata("delegation.kt")
  public void testDelegation() {
    runTest("compiler/testData/psi/delegation.kt");
  }

  @Test
  @TestMetadata("dependencyOnNestedClasses.kt")
  public void testDependencyOnNestedClasses() {
    runTest("compiler/testData/psi/dependencyOnNestedClasses.kt");
  }

  @Test
  @TestMetadata("destructuringInLambdas.kt")
  public void testDestructuringInLambdas() {
    runTest("compiler/testData/psi/destructuringInLambdas.kt");
  }

  @Test
  @TestMetadata("destructuringInLambdas_ERR.kt")
  public void testDestructuringInLambdas_ERR() {
    runTest("compiler/testData/psi/destructuringInLambdas_ERR.kt");
  }

  @Test
  @TestMetadata("diagnosticTags_ERR.kt")
  public void testDiagnosticTags_ERR() {
    runTest("compiler/testData/psi/diagnosticTags_ERR.kt");
  }

  @Test
  @TestMetadata("DocCommentAfterFileAnnotations.kt")
  public void testDocCommentAfterFileAnnotations() {
    runTest("compiler/testData/psi/DocCommentAfterFileAnnotations.kt");
  }

  @Test
  @TestMetadata("DocCommentForFirstDeclaration.kt")
  public void testDocCommentForFirstDeclaration() {
    runTest("compiler/testData/psi/DocCommentForFirstDeclaration.kt");
  }

  @Test
  @TestMetadata("DocCommentOnPackageDirectiveLine.kt")
  public void testDocCommentOnPackageDirectiveLine() {
    runTest("compiler/testData/psi/DocCommentOnPackageDirectiveLine.kt");
  }

  @Test
  @TestMetadata("DocCommentsBinding.kt")
  public void testDocCommentsBinding() {
    runTest("compiler/testData/psi/DocCommentsBinding.kt");
  }

  @Test
  @TestMetadata("DoubleColon.kt")
  public void testDoubleColon() {
    runTest("compiler/testData/psi/DoubleColon.kt");
  }

  @Test
  @TestMetadata("DoubleColonWhitespaces.kt")
  public void testDoubleColonWhitespaces() {
    runTest("compiler/testData/psi/DoubleColonWhitespaces.kt");
  }

  @Test
  @TestMetadata("DoubleColon_ERR.kt")
  public void testDoubleColon_ERR() {
    runTest("compiler/testData/psi/DoubleColon_ERR.kt");
  }

  @Test
  @TestMetadata("DuplicateAccessor.kt")
  public void testDuplicateAccessor() {
    runTest("compiler/testData/psi/DuplicateAccessor.kt");
  }

  @Test
  @TestMetadata("DynamicReceiver.kt")
  public void testDynamicReceiver() {
    runTest("compiler/testData/psi/DynamicReceiver.kt");
  }

  @Test
  @TestMetadata("DynamicSoftKeyword.kt")
  public void testDynamicSoftKeyword() {
    runTest("compiler/testData/psi/DynamicSoftKeyword.kt");
  }

  @Test
  @TestMetadata("DynamicTypes.kt")
  public void testDynamicTypes() {
    runTest("compiler/testData/psi/DynamicTypes.kt");
  }

  @Test
  @TestMetadata("EOLsInComments.kt")
  public void testEOLsInComments() {
    runTest("compiler/testData/psi/EOLsInComments.kt");
  }

  @Test
  @TestMetadata("EOLsOnRollback.kt")
  public void testEOLsOnRollback() {
    runTest("compiler/testData/psi/EOLsOnRollback.kt");
  }

  @Test
  @TestMetadata("emptyEnum.kt")
  public void testEmptyEnum() {
    runTest("compiler/testData/psi/emptyEnum.kt");
  }

  @Test
  @TestMetadata("EmptyFile.kt")
  public void testEmptyFile() {
    runTest("compiler/testData/psi/EmptyFile.kt");
  }

  @Test
  @TestMetadata("EmptyName.kt")
  public void testEmptyName() {
    runTest("compiler/testData/psi/EmptyName.kt");
  }

  @Test
  @TestMetadata("enum.kt")
  public void testEnum() {
    runTest("compiler/testData/psi/enum.kt");
  }

  @Test
  @TestMetadata("EnumCommas.kt")
  public void testEnumCommas() {
    runTest("compiler/testData/psi/EnumCommas.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaAnnotatedMember.kt")
  public void testEnumEntryCommaAnnotatedMember() {
    runTest("compiler/testData/psi/EnumEntryCommaAnnotatedMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaInlineMember.kt")
  public void testEnumEntryCommaInlineMember() {
    runTest("compiler/testData/psi/EnumEntryCommaInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaMember.kt")
  public void testEnumEntryCommaMember() {
    runTest("compiler/testData/psi/EnumEntryCommaMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryCommaPublicMember.kt")
  public void testEnumEntryCommaPublicMember() {
    runTest("compiler/testData/psi/EnumEntryCommaPublicMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySemicolonInlineMember.kt")
  public void testEnumEntrySemicolonInlineMember() {
    runTest("compiler/testData/psi/EnumEntrySemicolonInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySemicolonMember.kt")
  public void testEnumEntrySemicolonMember() {
    runTest("compiler/testData/psi/EnumEntrySemicolonMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySpaceInlineMember.kt")
  public void testEnumEntrySpaceInlineMember() {
    runTest("compiler/testData/psi/EnumEntrySpaceInlineMember.kt");
  }

  @Test
  @TestMetadata("EnumEntrySpaceMember.kt")
  public void testEnumEntrySpaceMember() {
    runTest("compiler/testData/psi/EnumEntrySpaceMember.kt");
  }

  @Test
  @TestMetadata("EnumEntryTwoCommas.kt")
  public void testEnumEntryTwoCommas() {
    runTest("compiler/testData/psi/EnumEntryTwoCommas.kt");
  }

  @Test
  @TestMetadata("EnumIn.kt")
  public void testEnumIn() {
    runTest("compiler/testData/psi/EnumIn.kt");
  }

  @Test
  @TestMetadata("EnumInline.kt")
  public void testEnumInline() {
    runTest("compiler/testData/psi/EnumInline.kt");
  }

  @Test
  @TestMetadata("EnumInlinePublic.kt")
  public void testEnumInlinePublic() {
    runTest("compiler/testData/psi/EnumInlinePublic.kt");
  }

  @Test
  @TestMetadata("EnumMissingName.kt")
  public void testEnumMissingName() {
    runTest("compiler/testData/psi/EnumMissingName.kt");
  }

  @Test
  @TestMetadata("EnumOldConstructorSyntax.kt")
  public void testEnumOldConstructorSyntax() {
    runTest("compiler/testData/psi/EnumOldConstructorSyntax.kt");
  }

  @Test
  @TestMetadata("EnumShortCommas.kt")
  public void testEnumShortCommas() {
    runTest("compiler/testData/psi/EnumShortCommas.kt");
  }

  @Test
  @TestMetadata("EnumShortWithOverload.kt")
  public void testEnumShortWithOverload() {
    runTest("compiler/testData/psi/EnumShortWithOverload.kt");
  }

  @Test
  @TestMetadata("EnumWithAnnotationKeyword.kt")
  public void testEnumWithAnnotationKeyword() {
    runTest("compiler/testData/psi/EnumWithAnnotationKeyword.kt");
  }

  @Test
  @TestMetadata("Enums.kt")
  public void testEnums() {
    runTest("compiler/testData/psi/Enums.kt");
  }

  @Test
  @TestMetadata("escapedNames.kt")
  public void testEscapedNames() {
    runTest("compiler/testData/psi/escapedNames.kt");
  }

  @Test
  @TestMetadata("Expressions_ERR.kt")
  public void testExpressions_ERR() {
    runTest("compiler/testData/psi/Expressions_ERR.kt");
  }

  @Test
  @TestMetadata("ExtensionsWithQNReceiver.kt")
  public void testExtensionsWithQNReceiver() {
    runTest("compiler/testData/psi/ExtensionsWithQNReceiver.kt");
  }

  @Test
  @TestMetadata("FileStart_ERR.kt")
  public void testFileStart_ERR() {
    runTest("compiler/testData/psi/FileStart_ERR.kt");
  }

  @Test
  @TestMetadata("flexibleDnnType.kt")
  public void testFlexibleDnnType() {
    runTest("compiler/testData/psi/flexibleDnnType.kt");
  }

  @Test
  @TestMetadata("FloatingPointLiteral.kt")
  public void testFloatingPointLiteral() {
    runTest("compiler/testData/psi/FloatingPointLiteral.kt");
  }

  @Test
  @TestMetadata("ForWithMultiDecl.kt")
  public void testForWithMultiDecl() {
    runTest("compiler/testData/psi/ForWithMultiDecl.kt");
  }

  @Test
  @TestMetadata("funInterfaceDeclaration.kt")
  public void testFunInterfaceDeclaration() {
    runTest("compiler/testData/psi/funInterfaceDeclaration.kt");
  }

  @Test
  @TestMetadata("FunctionCalls.kt")
  public void testFunctionCalls() {
    runTest("compiler/testData/psi/FunctionCalls.kt");
  }

  @Test
  @TestMetadata("FunctionExpressions.kt")
  public void testFunctionExpressions() {
    runTest("compiler/testData/psi/FunctionExpressions.kt");
  }

  @Test
  @TestMetadata("FunctionExpressions_ERR.kt")
  public void testFunctionExpressions_ERR() {
    runTest("compiler/testData/psi/FunctionExpressions_ERR.kt");
  }

  @Test
  @TestMetadata("FunctionLiterals.kt")
  public void testFunctionLiterals() {
    runTest("compiler/testData/psi/FunctionLiterals.kt");
  }

  @Test
  @TestMetadata("FunctionLiterals_ERR.kt")
  public void testFunctionLiterals_ERR() {
    runTest("compiler/testData/psi/FunctionLiterals_ERR.kt");
  }

  @Test
  @TestMetadata("FunctionNoParameterList.kt")
  public void testFunctionNoParameterList() {
    runTest("compiler/testData/psi/FunctionNoParameterList.kt");
  }

  @Test
  @TestMetadata("FunctionTypes.kt")
  public void testFunctionTypes() {
    runTest("compiler/testData/psi/FunctionTypes.kt");
  }

  @Test
  @TestMetadata("Functions.kt")
  public void testFunctions() {
    runTest("compiler/testData/psi/Functions.kt");
  }

  @Test
  @TestMetadata("FunctionsWithoutName.kt")
  public void testFunctionsWithoutName() {
    runTest("compiler/testData/psi/FunctionsWithoutName.kt");
  }

  @Test
  @TestMetadata("FunctionsWithoutName_ERR.kt")
  public void testFunctionsWithoutName_ERR() {
    runTest("compiler/testData/psi/FunctionsWithoutName_ERR.kt");
  }

  @Test
  @TestMetadata("Functions_ERR.kt")
  public void testFunctions_ERR() {
    runTest("compiler/testData/psi/Functions_ERR.kt");
  }

  @Test
  @TestMetadata("HangOnLonelyModifier.kt")
  public void testHangOnLonelyModifier() {
    runTest("compiler/testData/psi/HangOnLonelyModifier.kt");
  }

  @Test
  @TestMetadata("IfWithPropery.kt")
  public void testIfWithPropery() {
    runTest("compiler/testData/psi/IfWithPropery.kt");
  }

  @Test
  @TestMetadata("ImportSoftKW.kt")
  public void testImportSoftKW() {
    runTest("compiler/testData/psi/ImportSoftKW.kt");
  }

  @Test
  @TestMetadata("Imports.kt")
  public void testImports() {
    runTest("compiler/testData/psi/Imports.kt");
  }

  @Test
  @TestMetadata("Imports_ERR.kt")
  public void testImports_ERR() {
    runTest("compiler/testData/psi/Imports_ERR.kt");
  }

  @Test
  @TestMetadata("IncompleteFunctionLiteral.kt")
  public void testIncompleteFunctionLiteral() {
    runTest("compiler/testData/psi/IncompleteFunctionLiteral.kt");
  }

  @Test
  @TestMetadata("incorrectLTGTFallback.kt")
  public void testIncorrectLTGTFallback() {
    runTest("compiler/testData/psi/incorrectLTGTFallback.kt");
  }

  @Test
  @TestMetadata("inheritingClasses.kt")
  public void testInheritingClasses() {
    runTest("compiler/testData/psi/inheritingClasses.kt");
  }

  @Test
  @TestMetadata("Inner.kt")
  public void testInner() {
    runTest("compiler/testData/psi/Inner.kt");
  }

  @Test
  @TestMetadata("innerClassEnumEntry.kt")
  public void testInnerClassEnumEntry() {
    runTest("compiler/testData/psi/innerClassEnumEntry.kt");
  }

  @Test
  @TestMetadata("innerTypes.kt")
  public void testInnerTypes() {
    runTest("compiler/testData/psi/innerTypes.kt");
  }

  @Test
  @TestMetadata("IntegerLiteral.kt")
  public void testIntegerLiteral() {
    runTest("compiler/testData/psi/IntegerLiteral.kt");
  }

  @Test
  @TestMetadata("Interface.kt")
  public void testInterface() {
    runTest("compiler/testData/psi/Interface.kt");
  }

  @Test
  @TestMetadata("InterfaceWithEnumKeyword.kt")
  public void testInterfaceWithEnumKeyword() {
    runTest("compiler/testData/psi/InterfaceWithEnumKeyword.kt");
  }

  @Test
  @TestMetadata("internalConst.kt")
  public void testInternalConst() {
    runTest("compiler/testData/psi/internalConst.kt");
  }

  @Test
  @TestMetadata("kotlinFunInterface_ERR.kt")
  public void testKotlinFunInterface_ERR() {
    runTest("compiler/testData/psi/kotlinFunInterface_ERR.kt");
  }

  @Test
  @TestMetadata("Labels.kt")
  public void testLabels() {
    runTest("compiler/testData/psi/Labels.kt");
  }

  @Test
  @TestMetadata("LineCommentAfterFileAnnotations.kt")
  public void testLineCommentAfterFileAnnotations() {
    runTest("compiler/testData/psi/LineCommentAfterFileAnnotations.kt");
  }

  @Test
  @TestMetadata("LineCommentForFirstDeclaration.kt")
  public void testLineCommentForFirstDeclaration() {
    runTest("compiler/testData/psi/LineCommentForFirstDeclaration.kt");
  }

  @Test
  @TestMetadata("LineCommentsInBlock.kt")
  public void testLineCommentsInBlock() {
    runTest("compiler/testData/psi/LineCommentsInBlock.kt");
  }

  @Test
  @TestMetadata("localClass.kt")
  public void testLocalClass() {
    runTest("compiler/testData/psi/localClass.kt");
  }

  @Test
  @TestMetadata("LocalDeclarations.kt")
  public void testLocalDeclarations() {
    runTest("compiler/testData/psi/LocalDeclarations.kt");
  }

  @Test
  @TestMetadata("LongPackageName.kt")
  public void testLongPackageName() {
    runTest("compiler/testData/psi/LongPackageName.kt");
  }

  @Test
  @TestMetadata("ModifierAsSelector.kt")
  public void testModifierAsSelector() {
    runTest("compiler/testData/psi/ModifierAsSelector.kt");
  }

  @Test
  @TestMetadata("modifiers.kt")
  public void testModifiers() {
    runTest("compiler/testData/psi/modifiers.kt");
  }

  @Test
  @TestMetadata("MultiVariableDeclarations.kt")
  public void testMultiVariableDeclarations() {
    runTest("compiler/testData/psi/MultiVariableDeclarations.kt");
  }

  @Test
  @TestMetadata("multifileClass.kt")
  public void testMultifileClass() {
    runTest("compiler/testData/psi/multifileClass.kt");
  }

  @Test
  @TestMetadata("multifileClass2.kt")
  public void testMultifileClass2() {
    runTest("compiler/testData/psi/multifileClass2.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueAndOverrides.kt")
  public void testMustUseReturnValueAndOverrides() {
    runTest("compiler/testData/psi/mustUseReturnValueAndOverrides.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueFullEnabled.kt")
  public void testMustUseReturnValueFullEnabled() {
    runTest("compiler/testData/psi/mustUseReturnValueFullEnabled.kt");
  }

  @Test
  @TestMetadata("mustUseReturnValueHalfEnabled.kt")
  public void testMustUseReturnValueHalfEnabled() {
    runTest("compiler/testData/psi/mustUseReturnValueHalfEnabled.kt");
  }

  @Test
  @TestMetadata("NamedClassObject.kt")
  public void testNamedClassObject() {
    runTest("compiler/testData/psi/NamedClassObject.kt");
  }

  @Test
  @TestMetadata("namedCompanionObject.kt")
  public void testNamedCompanionObject() {
    runTest("compiler/testData/psi/namedCompanionObject.kt");
  }

  @Test
  @TestMetadata("namelessObjectAsEnumMember.kt")
  public void testNamelessObjectAsEnumMember() {
    runTest("compiler/testData/psi/namelessObjectAsEnumMember.kt");
  }

  @Test
  @TestMetadata("nestedClasses.kt")
  public void testNestedClasses() {
    runTest("compiler/testData/psi/nestedClasses.kt");
  }

  @Test
  @TestMetadata("NestedComments.kt")
  public void testNestedComments() {
    runTest("compiler/testData/psi/NestedComments.kt");
  }

  @Test
  @TestMetadata("NewLinesValidOperations.kt")
  public void testNewLinesValidOperations() {
    runTest("compiler/testData/psi/NewLinesValidOperations.kt");
  }

  @Test
  @TestMetadata("NewlinesInParentheses.kt")
  public void testNewlinesInParentheses() {
    runTest("compiler/testData/psi/NewlinesInParentheses.kt");
  }

  @Test
  @TestMetadata("noCommaBetweenArguments.kt")
  public void testNoCommaBetweenArguments() {
    runTest("compiler/testData/psi/noCommaBetweenArguments.kt");
  }

  @Test
  @TestMetadata("NonTypeBeforeDotInBaseClass.kt")
  public void testNonTypeBeforeDotInBaseClass() {
    runTest("compiler/testData/psi/NonTypeBeforeDotInBaseClass.kt");
  }

  @Test
  @TestMetadata("NotIsAndNotIn.kt")
  public void testNotIsAndNotIn() {
    runTest("compiler/testData/psi/NotIsAndNotIn.kt");
  }

  @Test
  @TestMetadata("ObjectLiteralAsStatement.kt")
  public void testObjectLiteralAsStatement() {
    runTest("compiler/testData/psi/ObjectLiteralAsStatement.kt");
  }

  @Test
  @TestMetadata("objects.kt")
  public void testObjects() {
    runTest("compiler/testData/psi/objects.kt");
  }

  @Test
  @TestMetadata("ParameterNameMising.kt")
  public void testParameterNameMising() {
    runTest("compiler/testData/psi/ParameterNameMising.kt");
  }

  @Test
  @TestMetadata("ParameterType.kt")
  public void testParameterType() {
    runTest("compiler/testData/psi/ParameterType.kt");
  }

  @Test
  @TestMetadata("ParameterType_ERR.kt")
  public void testParameterType_ERR() {
    runTest("compiler/testData/psi/ParameterType_ERR.kt");
  }

  @Test
  @TestMetadata("Precedence.kt")
  public void testPrecedence() {
    runTest("compiler/testData/psi/Precedence.kt");
  }

  @Test
  @TestMetadata("PrimaryConstructorModifiers_ERR.kt")
  public void testPrimaryConstructorModifiers_ERR() {
    runTest("compiler/testData/psi/PrimaryConstructorModifiers_ERR.kt");
  }

  @Test
  @TestMetadata("privateConstField.kt")
  public void testPrivateConstField() {
    runTest("compiler/testData/psi/privateConstField.kt");
  }

  @Test
  @TestMetadata("privateToThis.kt")
  public void testPrivateToThis() {
    runTest("compiler/testData/psi/privateToThis.kt");
  }

  @Test
  @TestMetadata("Properties.kt")
  public void testProperties() {
    runTest("compiler/testData/psi/Properties.kt");
  }

  @Test
  @TestMetadata("PropertiesFollowedByInitializers.kt")
  public void testPropertiesFollowedByInitializers() {
    runTest("compiler/testData/psi/PropertiesFollowedByInitializers.kt");
  }

  @Test
  @TestMetadata("Properties_ERR.kt")
  public void testProperties_ERR() {
    runTest("compiler/testData/psi/Properties_ERR.kt");
  }

  @Test
  @TestMetadata("propertyAccessors.kt")
  public void testPropertyAccessors() {
    runTest("compiler/testData/psi/propertyAccessors.kt");
  }

  @Test
  @TestMetadata("PropertyInvokes.kt")
  public void testPropertyInvokes() {
    runTest("compiler/testData/psi/PropertyInvokes.kt");
  }

  @Test
  @TestMetadata("propertyWithConstraints.kt")
  public void testPropertyWithConstraints() {
    runTest("compiler/testData/psi/propertyWithConstraints.kt");
  }

  @Test
  @TestMetadata("QuotedIdentifiers.kt")
  public void testQuotedIdentifiers() {
    runTest("compiler/testData/psi/QuotedIdentifiers.kt");
  }

  @Test
  @TestMetadata("repeatableAnnotation.kt")
  public void testRepeatableAnnotation() {
    runTest("compiler/testData/psi/repeatableAnnotation.kt");
  }

  @Test
  @TestMetadata("repeatableAnnotationClass.kt")
  public void testRepeatableAnnotationClass() {
    runTest("compiler/testData/psi/repeatableAnnotationClass.kt");
  }

  @Test
  @TestMetadata("Reserved.kt")
  public void testReserved() {
    runTest("compiler/testData/psi/Reserved.kt");
  }

  @Test
  @TestMetadata("sealed.kt")
  public void testSealed() {
    runTest("compiler/testData/psi/sealed.kt");
  }

  @Test
  @TestMetadata("sealedInterface.kt")
  public void testSealedInterface() {
    runTest("compiler/testData/psi/sealedInterface.kt");
  }

  @Test
  @TestMetadata("SemicolonAfterIf.kt")
  public void testSemicolonAfterIf() {
    runTest("compiler/testData/psi/SemicolonAfterIf.kt");
  }

  @Test
  @TestMetadata("semicolonBetweenDeclarations.kt")
  public void testSemicolonBetweenDeclarations() {
    runTest("compiler/testData/psi/semicolonBetweenDeclarations.kt");
  }

  @Test
  @TestMetadata("SimpleClassMembers.kt")
  public void testSimpleClassMembers() {
    runTest("compiler/testData/psi/SimpleClassMembers.kt");
  }

  @Test
  @TestMetadata("SimpleClassMembers_ERR.kt")
  public void testSimpleClassMembers_ERR() {
    runTest("compiler/testData/psi/SimpleClassMembers_ERR.kt");
  }

  @Test
  @TestMetadata("SimpleExpressions.kt")
  public void testSimpleExpressions() {
    runTest("compiler/testData/psi/SimpleExpressions.kt");
  }

  @Test
  @TestMetadata("SimpleIntersections.kt")
  public void testSimpleIntersections() {
    runTest("compiler/testData/psi/SimpleIntersections.kt");
  }

  @Test
  @TestMetadata("SimpleModifiers.kt")
  public void testSimpleModifiers() {
    runTest("compiler/testData/psi/SimpleModifiers.kt");
  }

  @Test
  @TestMetadata("SoftKeywords.kt")
  public void testSoftKeywords() {
    runTest("compiler/testData/psi/SoftKeywords.kt");
  }

  @Test
  @TestMetadata("SoftKeywordsInTypeArguments.kt")
  public void testSoftKeywordsInTypeArguments() {
    runTest("compiler/testData/psi/SoftKeywordsInTypeArguments.kt");
  }

  @Test
  @TestMetadata("specialNames.kt")
  public void testSpecialNames() {
    runTest("compiler/testData/psi/specialNames.kt");
  }

  @Test
  @TestMetadata("StringTemplates.kt")
  public void testStringTemplates() {
    runTest("compiler/testData/psi/StringTemplates.kt");
  }

  @Test
  @TestMetadata("suggestGuardSyntax.kt")
  public void testSuggestGuardSyntax() {
    runTest("compiler/testData/psi/suggestGuardSyntax.kt");
  }

  @Test
  @TestMetadata("Super.kt")
  public void testSuper() {
    runTest("compiler/testData/psi/Super.kt");
  }

  @Test
  @TestMetadata("suspendLambda.kt")
  public void testSuspendLambda() {
    runTest("compiler/testData/psi/suspendLambda.kt");
  }

  @Test
  @TestMetadata("topJvmPackageName.kt")
  public void testTopJvmPackageName() {
    runTest("compiler/testData/psi/topJvmPackageName.kt");
  }

  @Test
  @TestMetadata("topJvmPackageNameMultifile.kt")
  public void testTopJvmPackageNameMultifile() {
    runTest("compiler/testData/psi/topJvmPackageNameMultifile.kt");
  }

  @Test
  @TestMetadata("topLevelMembers.kt")
  public void testTopLevelMembers() {
    runTest("compiler/testData/psi/topLevelMembers.kt");
  }

  @Test
  @TestMetadata("topLevelMembersAnnotated.kt")
  public void testTopLevelMembersAnnotated() {
    runTest("compiler/testData/psi/topLevelMembersAnnotated.kt");
  }

  @Test
  @TestMetadata("trailingCommaAllowed.kt")
  public void testTrailingCommaAllowed() {
    runTest("compiler/testData/psi/trailingCommaAllowed.kt");
  }

  @Test
  @TestMetadata("trailingCommaForbidden.kt")
  public void testTrailingCommaForbidden() {
    runTest("compiler/testData/psi/trailingCommaForbidden.kt");
  }

  @Test
  @TestMetadata("TraitConstructor.kt")
  public void testTraitConstructor() {
    runTest("compiler/testData/psi/TraitConstructor.kt");
  }

  @Test
  @TestMetadata("TripleDot.kt")
  public void testTripleDot() {
    runTest("compiler/testData/psi/TripleDot.kt");
  }

  @Test
  @TestMetadata("TryRecovery.kt")
  public void testTryRecovery() {
    runTest("compiler/testData/psi/TryRecovery.kt");
  }

  @Test
  @TestMetadata("TypeAlias.kt")
  public void testTypeAlias() {
    runTest("compiler/testData/psi/TypeAlias.kt");
  }

  @Test
  @TestMetadata("typeAliasExpansion.kt")
  public void testTypeAliasExpansion() {
    runTest("compiler/testData/psi/typeAliasExpansion.kt");
  }

  @Test
  @TestMetadata("typeAliasWithConstraints.kt")
  public void testTypeAliasWithConstraints() {
    runTest("compiler/testData/psi/typeAliasWithConstraints.kt");
  }

  @Test
  @TestMetadata("TypeAlias_ERR.kt")
  public void testTypeAlias_ERR() {
    runTest("compiler/testData/psi/TypeAlias_ERR.kt");
  }

  @Test
  @TestMetadata("typeAliases.kt")
  public void testTypeAliases() {
    runTest("compiler/testData/psi/typeAliases.kt");
  }

  @Test
  @TestMetadata("typeBoundsAndDelegationSpecifiers.kt")
  public void testTypeBoundsAndDelegationSpecifiers() {
    runTest("compiler/testData/psi/typeBoundsAndDelegationSpecifiers.kt");
  }

  @Test
  @TestMetadata("TypeConstraints.kt")
  public void testTypeConstraints() {
    runTest("compiler/testData/psi/TypeConstraints.kt");
  }

  @Test
  @TestMetadata("TypeExpressionAmbiguities_ERR.kt")
  public void testTypeExpressionAmbiguities_ERR() {
    runTest("compiler/testData/psi/TypeExpressionAmbiguities_ERR.kt");
  }

  @Test
  @TestMetadata("TypeModifiers.kt")
  public void testTypeModifiers() {
    runTest("compiler/testData/psi/TypeModifiers.kt");
  }

  @Test
  @TestMetadata("typeModifiers2.kt")
  public void testTypeModifiers2() {
    runTest("compiler/testData/psi/typeModifiers2.kt");
  }

  @Test
  @TestMetadata("TypeModifiersParenthesized.kt")
  public void testTypeModifiersParenthesized() {
    runTest("compiler/testData/psi/TypeModifiersParenthesized.kt");
  }

  @Test
  @TestMetadata("TypeModifiers_ERR.kt")
  public void testTypeModifiers_ERR() {
    runTest("compiler/testData/psi/TypeModifiers_ERR.kt");
  }

  @Test
  @TestMetadata("TypeParametersBeforeName.kt")
  public void testTypeParametersBeforeName() {
    runTest("compiler/testData/psi/TypeParametersBeforeName.kt");
  }

  @Test
  @TestMetadata("typeParams.kt")
  public void testTypeParams() {
    runTest("compiler/testData/psi/typeParams.kt");
  }

  @Test
  @TestMetadata("TypealiasIsKeyword.kt")
  public void testTypealiasIsKeyword() {
    runTest("compiler/testData/psi/TypealiasIsKeyword.kt");
  }

  @Test
  @TestMetadata("types.kt")
  public void testTypes() {
    runTest("compiler/testData/psi/types.kt");
  }

  @Test
  @TestMetadata("underscoreParameterName.kt")
  public void testUnderscoreParameterName() {
    runTest("compiler/testData/psi/underscoreParameterName.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfCall.kt")
  public void testUnderscoredTypeArgumentsOfCall() {
    runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfCall.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfCallIllegal.kt")
  public void testUnderscoredTypeArgumentsOfCallIllegal() {
    runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfCallIllegal.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeArgumentsOfType.kt")
  public void testUnderscoredTypeArgumentsOfType() {
    runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfType.kt");
  }

  @Test
  @TestMetadata("UnderscoredTypeParameters.kt")
  public void testUnderscoredTypeParameters() {
    runTest("compiler/testData/psi/UnderscoredTypeParameters.kt");
  }

  @Test
  @TestMetadata("UnsignedLiteral.kt")
  public void testUnsignedLiteral() {
    runTest("compiler/testData/psi/UnsignedLiteral.kt");
  }

  @Test
  @TestMetadata("validKotlinFunInterface.kt")
  public void testValidKotlinFunInterface() {
    runTest("compiler/testData/psi/validKotlinFunInterface.kt");
  }

  @Test
  @TestMetadata("valueClass.kt")
  public void testValueClass() {
    runTest("compiler/testData/psi/valueClass.kt");
  }

  @Test
  @TestMetadata("varargArgumentWithFunctionalType.kt")
  public void testVarargArgumentWithFunctionalType() {
    runTest("compiler/testData/psi/varargArgumentWithFunctionalType.kt");
  }

  @Test
  @TestMetadata("When.kt")
  public void testWhen() {
    runTest("compiler/testData/psi/When.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable.kt")
  public void testWhenWithSubjectVariable() {
    runTest("compiler/testData/psi/WhenWithSubjectVariable.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable_ERR.kt")
  public void testWhenWithSubjectVariable_ERR() {
    runTest("compiler/testData/psi/WhenWithSubjectVariable_ERR.kt");
  }

  @Test
  @TestMetadata("WhenWithSubjectVariable_SoftModifierName.kt")
  public void testWhenWithSubjectVariable_SoftModifierName() {
    runTest("compiler/testData/psi/WhenWithSubjectVariable_SoftModifierName.kt");
  }

  @Test
  @TestMetadata("When_ERR.kt")
  public void testWhen_ERR() {
    runTest("compiler/testData/psi/When_ERR.kt");
  }

  @Nested
  @TestMetadata("compiler/testData/psi/annotation")
  @TestDataPath("$PROJECT_ROOT")
  public class Annotation {
    @Test
    public void testAllFilesPresentInAnnotation() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedDefaultPropertyAccessor.kt")
    public void testAnnotatedDefaultPropertyAccessor() {
      runTest("compiler/testData/psi/annotation/annotatedDefaultPropertyAccessor.kt");
    }

    @Test
    @TestMetadata("annotatedDefaultPropertyAccessorK1.kt")
    public void testAnnotatedDefaultPropertyAccessorK1() {
      runTest("compiler/testData/psi/annotation/annotatedDefaultPropertyAccessorK1.kt");
    }

    @Test
    @TestMetadata("AnnotatedExpressions.kt")
    public void testAnnotatedExpressions() {
      runTest("compiler/testData/psi/annotation/AnnotatedExpressions.kt");
    }

    @Test
    @TestMetadata("annotatedProperties.kt")
    public void testAnnotatedProperties() {
      runTest("compiler/testData/psi/annotation/annotatedProperties.kt");
    }

    @Test
    @TestMetadata("annotatedPropertiesK1.kt")
    public void testAnnotatedPropertiesK1() {
      runTest("compiler/testData/psi/annotation/annotatedPropertiesK1.kt");
    }

    @Test
    @TestMetadata("annotatedProperty.kt")
    public void testAnnotatedProperty() {
      runTest("compiler/testData/psi/annotation/annotatedProperty.kt");
    }

    @Test
    @TestMetadata("annotatedReturnType.kt")
    public void testAnnotatedReturnType() {
      runTest("compiler/testData/psi/annotation/annotatedReturnType.kt");
    }

    @Test
    @TestMetadata("annotatedTypeConstraint.kt")
    public void testAnnotatedTypeConstraint() {
      runTest("compiler/testData/psi/annotation/annotatedTypeConstraint.kt");
    }

    @Test
    @TestMetadata("Annotations.kt")
    public void testAnnotations() {
      runTest("compiler/testData/psi/annotation/Annotations.kt");
    }

    @Test
    @TestMetadata("annotationsOnNullableTypes.kt")
    public void testAnnotationsOnNullableTypes() {
      runTest("compiler/testData/psi/annotation/annotationsOnNullableTypes.kt");
    }

    @Test
    @TestMetadata("annotationsOnParenthesizedTypes.kt")
    public void testAnnotationsOnParenthesizedTypes() {
      runTest("compiler/testData/psi/annotation/annotationsOnParenthesizedTypes.kt");
    }

    @Test
    @TestMetadata("AnnotationsOnPatterns.kt")
    public void testAnnotationsOnPatterns() {
      runTest("compiler/testData/psi/annotation/AnnotationsOnPatterns.kt");
    }

    @Test
    @TestMetadata("Annotations_ERR.kt")
    public void testAnnotations_ERR() {
      runTest("compiler/testData/psi/annotation/Annotations_ERR.kt");
    }

    @Test
    @TestMetadata("forParameters.kt")
    public void testForParameters() {
      runTest("compiler/testData/psi/annotation/forParameters.kt");
    }

    @Test
    @TestMetadata("lambda.kt")
    public void testLambda() {
      runTest("compiler/testData/psi/annotation/lambda.kt");
    }

    @Test
    @TestMetadata("lambdaRecovery.kt")
    public void testLambdaRecovery() {
      runTest("compiler/testData/psi/annotation/lambdaRecovery.kt");
    }

    @Test
    @TestMetadata("multiDeclaration.kt")
    public void testMultiDeclaration() {
      runTest("compiler/testData/psi/annotation/multiDeclaration.kt");
    }

    @Test
    @TestMetadata("noParameterYet.kt")
    public void testNoParameterYet() {
      runTest("compiler/testData/psi/annotation/noParameterYet.kt");
    }

    @Test
    @TestMetadata("oldAnnotationsRecovery.kt")
    public void testOldAnnotationsRecovery() {
      runTest("compiler/testData/psi/annotation/oldAnnotationsRecovery.kt");
    }

    @Test
    @TestMetadata("ShortAnnotations.kt")
    public void testShortAnnotations() {
      runTest("compiler/testData/psi/annotation/ShortAnnotations.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/at")
    @TestDataPath("$PROJECT_ROOT")
    public class At {
      @Test
      public void testAllFilesPresentInAt() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/at"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("annotationAtFileStart.kt")
      public void testAnnotationAtFileStart() {
        runTest("compiler/testData/psi/annotation/at/annotationAtFileStart.kt");
      }

      @Test
      @TestMetadata("annotationValueArgumentsAmbiguity.kt")
      public void testAnnotationValueArgumentsAmbiguity() {
        runTest("compiler/testData/psi/annotation/at/annotationValueArgumentsAmbiguity.kt");
      }

      @Test
      @TestMetadata("blockLevelExpressions.kt")
      public void testBlockLevelExpressions() {
        runTest("compiler/testData/psi/annotation/at/blockLevelExpressions.kt");
      }

      @Test
      @TestMetadata("blockLevelExpressionsNoNewLine.kt")
      public void testBlockLevelExpressionsNoNewLine() {
        runTest("compiler/testData/psi/annotation/at/blockLevelExpressionsNoNewLine.kt");
      }

      @Test
      @TestMetadata("danglingBlockLevelAnnotations.kt")
      public void testDanglingBlockLevelAnnotations() {
        runTest("compiler/testData/psi/annotation/at/danglingBlockLevelAnnotations.kt");
      }

      @Test
      @TestMetadata("declarationsJustAtTyped.kt")
      public void testDeclarationsJustAtTyped() {
        runTest("compiler/testData/psi/annotation/at/declarationsJustAtTyped.kt");
      }

      @Test
      @TestMetadata("enumEntries.kt")
      public void testEnumEntries() {
        runTest("compiler/testData/psi/annotation/at/enumEntries.kt");
      }

      @Test
      @TestMetadata("expressionJustAtTyped.kt")
      public void testExpressionJustAtTyped() {
        runTest("compiler/testData/psi/annotation/at/expressionJustAtTyped.kt");
      }

      @Test
      @TestMetadata("kt21055.kt")
      public void testKt21055() {
        runTest("compiler/testData/psi/annotation/at/kt21055.kt");
      }

      @Test
      @TestMetadata("modifierAtFileStart.kt")
      public void testModifierAtFileStart() {
        runTest("compiler/testData/psi/annotation/at/modifierAtFileStart.kt");
      }

      @Test
      @TestMetadata("primaryConstructor.kt")
      public void testPrimaryConstructor() {
        runTest("compiler/testData/psi/annotation/at/primaryConstructor.kt");
      }

      @Test
      @TestMetadata("recoveryWhitespaceBeforeColon.kt")
      public void testRecoveryWhitespaceBeforeColon() {
        runTest("compiler/testData/psi/annotation/at/recoveryWhitespaceBeforeColon.kt");
      }

      @Test
      @TestMetadata("recoveryWhitespaceBeforeColon_ERR.kt")
      public void testRecoveryWhitespaceBeforeColon_ERR() {
        runTest("compiler/testData/psi/annotation/at/recoveryWhitespaceBeforeColon_ERR.kt");
      }

      @Test
      @TestMetadata("validDeclarations.kt")
      public void testValidDeclarations() {
        runTest("compiler/testData/psi/annotation/at/validDeclarations.kt");
      }

      @Test
      @TestMetadata("validExpressions.kt")
      public void testValidExpressions() {
        runTest("compiler/testData/psi/annotation/at/validExpressions.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/functionalTypes")
    @TestDataPath("$PROJECT_ROOT")
    public class FunctionalTypes {
      @Test
      public void testAllFilesPresentInFunctionalTypes() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax")
      @TestDataPath("$PROJECT_ROOT")
      public class RegressionForSimilarSyntax {
        @Test
        public void testAllFilesPresentInRegressionForSimilarSyntax() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("forDestructuring.kt")
        public void testForDestructuring() {
          runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/forDestructuring.kt");
        }

        @Test
        @TestMetadata("lambdaParameterDeclaration.kt")
        public void testLambdaParameterDeclaration() {
          runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/lambdaParameterDeclaration.kt");
        }

        @Test
        @TestMetadata("variableDestructuring.kt")
        public void testVariableDestructuring() {
          runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/variableDestructuring.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withParentheses")
      @TestDataPath("$PROJECT_ROOT")
      public class WithParentheses {
        @Test
        public void testAllFilesPresentInWithParentheses() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withParentheses"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("withParameter.kt")
        public void testWithParameter() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withParentheses/withParameter.kt");
        }

        @Test
        @TestMetadata("withoutParameter.kt")
        public void testWithoutParameter() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withParentheses/withoutParameter.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withoutParentheses")
      @TestDataPath("$PROJECT_ROOT")
      public class WithoutParentheses {
        @Test
        public void testAllFilesPresentInWithoutParentheses() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withoutParentheses"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("annotationList.kt")
        public void testAnnotationList() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/annotationList.kt");
        }

        @Test
        @TestMetadata("withParameter.kt")
        public void testWithParameter() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withParameter.kt");
        }

        @Test
        @TestMetadata("withReveiver.kt")
        public void testWithReveiver() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withReveiver.kt");
        }

        @Test
        @TestMetadata("withoutParameter.kt")
        public void testWithoutParameter() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withoutParameter.kt");
        }

        @Test
        @TestMetadata("withoutParameterOnSuspend.kt")
        public void testWithoutParameterOnSuspend() {
          runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withoutParameterOnSuspend.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/list")
    @TestDataPath("$PROJECT_ROOT")
    public class List {
      @Test
      public void testAllFilesPresentInList() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/list"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("basic.kt")
      public void testBasic() {
        runTest("compiler/testData/psi/annotation/list/basic.kt");
      }

      @Test
      @TestMetadata("recovery.kt")
      public void testRecovery() {
        runTest("compiler/testData/psi/annotation/list/recovery.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/modifiersMigration")
    @TestDataPath("$PROJECT_ROOT")
    public class ModifiersMigration {
      @Test
      public void testAllFilesPresentInModifiersMigration() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/modifiersMigration"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("newModifiers.kt")
      public void testNewModifiers() {
        runTest("compiler/testData/psi/annotation/modifiersMigration/newModifiers.kt");
      }

      @Test
      @TestMetadata("oldUsages.kt")
      public void testOldUsages() {
        runTest("compiler/testData/psi/annotation/modifiersMigration/oldUsages.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/options")
    @TestDataPath("$PROJECT_ROOT")
    public class Options {
      @Test
      public void testAllFilesPresentInOptions() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/options"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("annotationAsArg.kt")
      public void testAnnotationAsArg() {
        runTest("compiler/testData/psi/annotation/options/annotationAsArg.kt");
      }

      @Test
      @TestMetadata("annotationAsArgComplex.kt")
      public void testAnnotationAsArgComplex() {
        runTest("compiler/testData/psi/annotation/options/annotationAsArgComplex.kt");
      }

      @Test
      @TestMetadata("java.kt")
      public void testJava() {
        runTest("compiler/testData/psi/annotation/options/java.kt");
      }

      @Test
      @TestMetadata("local.kt")
      public void testLocal() {
        runTest("compiler/testData/psi/annotation/options/local.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/targeted")
    @TestDataPath("$PROJECT_ROOT")
    public class Targeted {
      @Test
      public void testAllFilesPresentInTargeted() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("onAll.kt")
      public void testOnAll() {
        runTest("compiler/testData/psi/annotation/targeted/onAll.kt");
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onField")
      @TestDataPath("$PROJECT_ROOT")
      public class OnField {
        @Test
        public void testAllFilesPresentInOnField() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onField"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("delegate.kt")
        public void testDelegate() {
          runTest("compiler/testData/psi/annotation/targeted/onField/delegate.kt");
        }

        @Test
        @TestMetadata("fqName.kt")
        public void testFqName() {
          runTest("compiler/testData/psi/annotation/targeted/onField/fqName.kt");
        }

        @Test
        @TestMetadata("inWrongPlace.kt")
        public void testInWrongPlace() {
          runTest("compiler/testData/psi/annotation/targeted/onField/inWrongPlace.kt");
        }

        @Test
        @TestMetadata("manyInOneAnnotationBlock.kt")
        public void testManyInOneAnnotationBlock() {
          runTest("compiler/testData/psi/annotation/targeted/onField/manyInOneAnnotationBlock.kt");
        }

        @Test
        @TestMetadata("simpleFieldAnnotation.kt")
        public void testSimpleFieldAnnotation() {
          runTest("compiler/testData/psi/annotation/targeted/onField/simpleFieldAnnotation.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onFile")
      @TestDataPath("$PROJECT_ROOT")
      public class OnFile {
        @Test
        public void testAllFilesPresentInOnFile() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onFile"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("fileAnnotationInWrongPlace.kt")
        public void testFileAnnotationInWrongPlace() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/fileAnnotationInWrongPlace.kt");
        }

        @Test
        @TestMetadata("manyAnnotationBlocks.kt")
        public void testManyAnnotationBlocks() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/manyAnnotationBlocks.kt");
        }

        @Test
        @TestMetadata("manyInOneAnnotationBlock.kt")
        public void testManyInOneAnnotationBlock() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/manyInOneAnnotationBlock.kt");
        }

        @Test
        @TestMetadata("nonFIleAnnotationBeforePackage.kt")
        public void testNonFIleAnnotationBeforePackage() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/nonFIleAnnotationBeforePackage.kt");
        }

        @Test
        @TestMetadata("single.kt")
        public void testSingle() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/single.kt");
        }

        @Test
        @TestMetadata("withoutFileAnnotationAndPackageDeclaration.kt")
        public void testWithoutFileAnnotationAndPackageDeclaration() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/withoutFileAnnotationAndPackageDeclaration.kt");
        }

        @Test
        @TestMetadata("withoutPackage.kt")
        public void testWithoutPackage() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/withoutPackage.kt");
        }

        @Test
        @TestMetadata("withoutPackageWithSimpleAnnotation.kt")
        public void testWithoutPackageWithSimpleAnnotation() {
          runTest("compiler/testData/psi/annotation/targeted/onFile/withoutPackageWithSimpleAnnotation.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onGetSetSparam")
      @TestDataPath("$PROJECT_ROOT")
      public class OnGetSetSparam {
        @Test
        public void testAllFilesPresentInOnGetSetSparam() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onGetSetSparam"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("inWrongPlace.kt")
        public void testInWrongPlace() {
          runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/inWrongPlace.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/simple.kt");
        }

        @Test
        @TestMetadata("twoAnnotationLists.kt")
        public void testTwoAnnotationLists() {
          runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/twoAnnotationLists.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/annotation/targeted/onParam")
      @TestDataPath("$PROJECT_ROOT")
      public class OnParam {
        @Test
        public void testAllFilesPresentInOnParam() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onParam"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("modifiers.kt")
        public void testModifiers() {
          runTest("compiler/testData/psi/annotation/targeted/onParam/modifiers.kt");
        }

        @Test
        @TestMetadata("recovery.kt")
        public void testRecovery() {
          runTest("compiler/testData/psi/annotation/targeted/onParam/recovery.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          runTest("compiler/testData/psi/annotation/targeted/onParam/simple.kt");
        }

        @Test
        @TestMetadata("targetExpected.kt")
        public void testTargetExpected() {
          runTest("compiler/testData/psi/annotation/targeted/onParam/targetExpected.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/annotation/values")
    @TestDataPath("$PROJECT_ROOT")
    public class Values {
      @Test
      public void testAllFilesPresentInValues() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/values"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("arrays.kt")
      public void testArrays() {
        runTest("compiler/testData/psi/annotation/values/arrays.kt");
      }

      @Test
      @TestMetadata("arraysWithNonConstantValue.kt")
      public void testArraysWithNonConstantValue() {
        runTest("compiler/testData/psi/annotation/values/arraysWithNonConstantValue.kt");
      }

      @Test
      @TestMetadata("classLiterals.kt")
      public void testClassLiterals() {
        runTest("compiler/testData/psi/annotation/values/classLiterals.kt");
      }

      @Test
      @TestMetadata("deprecated.kt")
      public void testDeprecated() {
        runTest("compiler/testData/psi/annotation/values/deprecated.kt");
      }

      @Test
      @TestMetadata("enumArray.kt")
      public void testEnumArray() {
        runTest("compiler/testData/psi/annotation/values/enumArray.kt");
      }

      @Test
      @TestMetadata("enumLiterals.kt")
      public void testEnumLiterals() {
        runTest("compiler/testData/psi/annotation/values/enumLiterals.kt");
      }

      @Test
      @TestMetadata("intVarargLiterals.kt")
      public void testIntVarargLiterals() {
        runTest("compiler/testData/psi/annotation/values/intVarargLiterals.kt");
      }

      @Test
      @TestMetadata("longStringTemplateEntryWithTwoExpressions.kt")
      public void testLongStringTemplateEntryWithTwoExpressions() {
        runTest("compiler/testData/psi/annotation/values/longStringTemplateEntryWithTwoExpressions.kt");
      }

      @Test
      @TestMetadata("nestedAnnotation.kt")
      public void testNestedAnnotation() {
        runTest("compiler/testData/psi/annotation/values/nestedAnnotation.kt");
      }

      @Test
      @TestMetadata("qualifiedLiterals.kt")
      public void testQualifiedLiterals() {
        runTest("compiler/testData/psi/annotation/values/qualifiedLiterals.kt");
      }

      @Test
      @TestMetadata("simpleLiterals.kt")
      public void testSimpleLiterals() {
        runTest("compiler/testData/psi/annotation/values/simpleLiterals.kt");
      }

      @Test
      @TestMetadata("stringLiterals.kt")
      public void testStringLiterals() {
        runTest("compiler/testData/psi/annotation/values/stringLiterals.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/contextParameters")
  @TestDataPath("$PROJECT_ROOT")
  public class ContextParameters {
    @Test
    public void testAllFilesPresentInContextParameters() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contextParameters"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedContextParameterType.kt")
    public void testAnnotatedContextParameterType() {
      runTest("compiler/testData/psi/contextParameters/annotatedContextParameterType.kt");
    }

    @Test
    @TestMetadata("anonymousFunction.kt")
    public void testAnonymousFunction() {
      runTest("compiler/testData/psi/contextParameters/anonymousFunction.kt");
    }

    @Test
    @TestMetadata("contextParametersOnCallableMembers.kt")
    public void testContextParametersOnCallableMembers() {
      runTest("compiler/testData/psi/contextParameters/contextParametersOnCallableMembers.kt");
    }

    @Test
    @TestMetadata("contextParametersOnTopLevelCallables.kt")
    public void testContextParametersOnTopLevelCallables() {
      runTest("compiler/testData/psi/contextParameters/contextParametersOnTopLevelCallables.kt");
    }

    @Test
    @TestMetadata("contextReceiversCallableMembers.kt")
    public void testContextReceiversCallableMembers() {
      runTest("compiler/testData/psi/contextParameters/contextReceiversCallableMembers.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnClass.kt")
    public void testContextReceiversOnClass() {
      runTest("compiler/testData/psi/contextParameters/contextReceiversOnClass.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnFunctionType.kt")
    public void testContextReceiversOnFunctionType() {
      runTest("compiler/testData/psi/contextParameters/contextReceiversOnFunctionType.kt");
    }

    @Test
    @TestMetadata("contextReceiversOnTopLevelCallables.kt")
    public void testContextReceiversOnTopLevelCallables() {
      runTest("compiler/testData/psi/contextParameters/contextReceiversOnTopLevelCallables.kt");
    }

    @Test
    @TestMetadata("danglingContextParameter.kt")
    public void testDanglingContextParameter() {
      runTest("compiler/testData/psi/contextParameters/danglingContextParameter.kt");
    }

    @Test
    @TestMetadata("danglingContextParameterAndAnnotations.kt")
    public void testDanglingContextParameterAndAnnotations() {
      runTest("compiler/testData/psi/contextParameters/danglingContextParameterAndAnnotations.kt");
    }

    @Test
    @TestMetadata("differentTypes.kt")
    public void testDifferentTypes() {
      runTest("compiler/testData/psi/contextParameters/differentTypes.kt");
    }

    @Test
    @TestMetadata("functions.kt")
    public void testFunctions() {
      runTest("compiler/testData/psi/contextParameters/functions.kt");
    }

    @Test
    @TestMetadata("labelInFunctionTypeContext.kt")
    public void testLabelInFunctionTypeContext() {
      runTest("compiler/testData/psi/contextParameters/labelInFunctionTypeContext.kt");
    }

    @Test
    @TestMetadata("properties.kt")
    public void testProperties() {
      runTest("compiler/testData/psi/contextParameters/properties.kt");
    }

    @Test
    @TestMetadata("syntaxError.kt")
    public void testSyntaxError() {
      runTest("compiler/testData/psi/contextParameters/syntaxError.kt");
    }

    @Test
    @TestMetadata("trailingComma.kt")
    public void testTrailingComma() {
      runTest("compiler/testData/psi/contextParameters/trailingComma.kt");
    }

    @Test
    @TestMetadata("trailingCommaForbidden.kt")
    public void testTrailingCommaForbidden() {
      runTest("compiler/testData/psi/contextParameters/trailingCommaForbidden.kt");
    }

    @Test
    @TestMetadata("unnamed.kt")
    public void testUnnamed() {
      runTest("compiler/testData/psi/contextParameters/unnamed.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/contracts")
  @TestDataPath("$PROJECT_ROOT")
  public class Contracts {
    @Test
    public void testAllFilesPresentInContracts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotatedContract.kt")
    public void testAnnotatedContract() {
      runTest("compiler/testData/psi/contracts/annotatedContract.kt");
    }

    @Test
    @TestMetadata("contracts.kt")
    public void testContracts() {
      runTest("compiler/testData/psi/contracts/contracts.kt");
    }

    @Test
    @TestMetadata("contractsPropertyAccessors.kt")
    public void testContractsPropertyAccessors() {
      runTest("compiler/testData/psi/contracts/contractsPropertyAccessors.kt");
    }

    @Test
    @TestMetadata("contractsSecondaryConstructor.kt")
    public void testContractsSecondaryConstructor() {
      runTest("compiler/testData/psi/contracts/contractsSecondaryConstructor.kt");
    }

    @Test
    @TestMetadata("FunctionWithMultilineContract.kt")
    public void testFunctionWithMultilineContract() {
      runTest("compiler/testData/psi/contracts/FunctionWithMultilineContract.kt");
    }

    @Test
    @TestMetadata("FunctionsWithTypeConstraintsAndContract.kt")
    public void testFunctionsWithTypeConstraintsAndContract() {
      runTest("compiler/testData/psi/contracts/FunctionsWithTypeConstraintsAndContract.kt");
    }

    @Test
    @TestMetadata("nonKotlinContractCall.kt")
    public void testNonKotlinContractCall() {
      runTest("compiler/testData/psi/contracts/nonKotlinContractCall.kt");
    }

    @Test
    @TestMetadata("nonKotlinContractCall2.kt")
    public void testNonKotlinContractCall2() {
      runTest("compiler/testData/psi/contracts/nonKotlinContractCall2.kt");
    }

    @Test
    @TestMetadata("operator.kt")
    public void testOperator() {
      runTest("compiler/testData/psi/contracts/operator.kt");
    }

    @Test
    @TestMetadata("PropertyAccessorsContracts.kt")
    public void testPropertyAccessorsContracts() {
      runTest("compiler/testData/psi/contracts/PropertyAccessorsContracts.kt");
    }

    @Test
    @TestMetadata("SimpleFunctionWithContract.kt")
    public void testSimpleFunctionWithContract() {
      runTest("compiler/testData/psi/contracts/SimpleFunctionWithContract.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/contracts/good")
    @TestDataPath("$PROJECT_ROOT")
    public class Good {
      @Test
      public void testAllFilesPresentInGood() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/callsInPlace")
      @TestDataPath("$PROJECT_ROOT")
      public class CallsInPlace {
        @Test
        public void testAllFilesPresentInCallsInPlace() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/callsInPlace"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("atLeastOnce.kt")
        public void testAtLeastOnce() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/atLeastOnce.kt");
        }

        @Test
        @TestMetadata("atMostOnce.kt")
        public void testAtMostOnce() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/atMostOnce.kt");
        }

        @Test
        @TestMetadata("contractsUsage.kt")
        public void testContractsUsage() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/contractsUsage.kt");
        }

        @Test
        @TestMetadata("exactlyOnce.kt")
        public void testExactlyOnce() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/exactlyOnce.kt");
        }

        @Test
        @TestMetadata("flow.kt")
        public void testFlow() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/flow.kt");
        }

        @Test
        @TestMetadata("inPlaceLambda.kt")
        public void testInPlaceLambda() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/inPlaceLambda.kt");
        }

        @Test
        @TestMetadata("infiniteLoop.kt")
        public void testInfiniteLoop() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/infiniteLoop.kt");
        }

        @Test
        @TestMetadata("namedArgument.kt")
        public void testNamedArgument() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/namedArgument.kt");
        }

        @Test
        @TestMetadata("simple.kt")
        public void testSimple() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/simple.kt");
        }

        @Test
        @TestMetadata("tryFinally.kt")
        public void testTryFinally() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/tryFinally.kt");
        }

        @Test
        @TestMetadata("unknown.kt")
        public void testUnknown() {
          runTest("compiler/testData/psi/contracts/good/callsInPlace/unknown.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/returnsImplies")
      @TestDataPath("$PROJECT_ROOT")
      public class ReturnsImplies {
        @Test
        public void testAllFilesPresentInReturnsImplies() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/returnsImplies"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("booleanOperators.kt")
        public void testBooleanOperators() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/booleanOperators.kt");
        }

        @Test
        @TestMetadata("conditionLogic.kt")
        public void testConditionLogic() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/conditionLogic.kt");
        }

        @Test
        @TestMetadata("eqNotEq.kt")
        public void testEqNotEq() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/eqNotEq.kt");
        }

        @Test
        @TestMetadata("inapplicable.kt")
        public void testInapplicable() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/inapplicable.kt");
        }

        @Test
        @TestMetadata("namedArguments.kt")
        public void testNamedArguments() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/namedArguments.kt");
        }

        @Test
        @TestMetadata("notNull.kt")
        public void testNotNull() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/notNull.kt");
        }

        @Test
        @TestMetadata("propertyAccessors.kt")
        public void testPropertyAccessors() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/propertyAccessors.kt");
        }

        @Test
        @TestMetadata("receivers.kt")
        public void testReceivers() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/receivers.kt");
        }

        @Test
        @TestMetadata("safeCall.kt")
        public void testSafeCall() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/safeCall.kt");
        }

        @Test
        @TestMetadata("trickyCases.kt")
        public void testTrickyCases() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/trickyCases.kt");
        }

        @Test
        @TestMetadata("typePredicate.kt")
        public void testTypePredicate() {
          runTest("compiler/testData/psi/contracts/good/returnsImplies/typePredicate.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/contracts/good/variousContracts")
      @TestDataPath("$PROJECT_ROOT")
      public class VariousContracts {
        @Test
        public void testAllFilesPresentInVariousContracts() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/variousContracts"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Nested
        @TestMetadata("compiler/testData/psi/contracts/good/variousContracts/newSyntax")
        @TestDataPath("$PROJECT_ROOT")
        public class NewSyntax {
          @Test
          public void testAllFilesPresentInNewSyntax() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts/good/variousContracts/newSyntax"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
          }

          @Test
          @TestMetadata("functionsWithContract.kt")
          public void testFunctionsWithContract() {
            runTest("compiler/testData/psi/contracts/good/variousContracts/newSyntax/functionsWithContract.kt");
          }
        }
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/destructuring")
  @TestDataPath("$PROJECT_ROOT")
  public class Destructuring {
    @Test
    public void testAllFilesPresentInDestructuring() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/destructuring"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("freezeKt79951.kt")
    public void testFreezeKt79951() {
      runTest("compiler/testData/psi/destructuring/freezeKt79951.kt");
    }

    @Test
    @TestMetadata("fullNameBasedDestructuring.kt")
    public void testFullNameBasedDestructuring() {
      runTest("compiler/testData/psi/destructuring/fullNameBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("fullNameBasedDestructuringErrors.kt")
    public void testFullNameBasedDestructuringErrors() {
      runTest("compiler/testData/psi/destructuring/fullNameBasedDestructuringErrors.kt");
    }

    @Test
    @TestMetadata("fullPositionBasedDestructuring.kt")
    public void testFullPositionBasedDestructuring() {
      runTest("compiler/testData/psi/destructuring/fullPositionBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("fullPositionBasedDestructuringErrors.kt")
    public void testFullPositionBasedDestructuringErrors() {
      runTest("compiler/testData/psi/destructuring/fullPositionBasedDestructuringErrors.kt");
    }

    @Test
    @TestMetadata("ktij23263.kt")
    public void testKtij23263() {
      runTest("compiler/testData/psi/destructuring/ktij23263.kt");
    }

    @Test
    @TestMetadata("shortNameBasedDestructuringWithRenaming.kt")
    public void testShortNameBasedDestructuringWithRenaming() {
      runTest("compiler/testData/psi/destructuring/shortNameBasedDestructuringWithRenaming.kt");
    }

    @Test
    @TestMetadata("shortPositionBasedDestructuring.kt")
    public void testShortPositionBasedDestructuring() {
      runTest("compiler/testData/psi/destructuring/shortPositionBasedDestructuring.kt");
    }

    @Test
    @TestMetadata("shortPositionBasedDestructuringErrors.kt")
    public void testShortPositionBasedDestructuringErrors() {
      runTest("compiler/testData/psi/destructuring/shortPositionBasedDestructuringErrors.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/examples")
  @TestDataPath("$PROJECT_ROOT")
  public class Examples {
    @Test
    public void testAllFilesPresentInExamples() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("AnonymousObjects.kt")
    public void testAnonymousObjects() {
      runTest("compiler/testData/psi/examples/AnonymousObjects.kt");
    }

    @Test
    @TestMetadata("BinaryTree.kt")
    public void testBinaryTree() {
      runTest("compiler/testData/psi/examples/BinaryTree.kt");
    }

    @Test
    @TestMetadata("BitArith.kt")
    public void testBitArith() {
      runTest("compiler/testData/psi/examples/BitArith.kt");
    }

    @Test
    @TestMetadata("Builder.kt")
    public void testBuilder() {
      runTest("compiler/testData/psi/examples/Builder.kt");
    }

    @Test
    @TestMetadata("Color.kt")
    public void testColor() {
      runTest("compiler/testData/psi/examples/Color.kt");
    }

    @Test
    @TestMetadata("FunctionsAndTypes.kt")
    public void testFunctionsAndTypes() {
      runTest("compiler/testData/psi/examples/FunctionsAndTypes.kt");
    }

    @Test
    @TestMetadata("Graph.kt")
    public void testGraph() {
      runTest("compiler/testData/psi/examples/Graph.kt");
    }

    @Test
    @TestMetadata("IPushPop.kt")
    public void testIPushPop() {
      runTest("compiler/testData/psi/examples/IPushPop.kt");
    }

    @Test
    @TestMetadata("LINQ.kt")
    public void testLINQ() {
      runTest("compiler/testData/psi/examples/LINQ.kt");
    }

    @Test
    @TestMetadata("Queue.kt")
    public void testQueue() {
      runTest("compiler/testData/psi/examples/Queue.kt");
    }

    @Test
    @TestMetadata("Stack.kt")
    public void testStack() {
      runTest("compiler/testData/psi/examples/Stack.kt");
    }

    @Test
    @TestMetadata("UnionFind.kt")
    public void testUnionFind() {
      runTest("compiler/testData/psi/examples/UnionFind.kt");
    }

    @Test
    @TestMetadata("UpdateOperation.kt")
    public void testUpdateOperation() {
      runTest("compiler/testData/psi/examples/UpdateOperation.kt");
    }

    @Test
    @TestMetadata("With.kt")
    public void testWith() {
      runTest("compiler/testData/psi/examples/With.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/array")
    @TestDataPath("$PROJECT_ROOT")
    public class Array {
      @Test
      public void testAllFilesPresentInArray() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/array"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("MutableArray.kt")
      public void testMutableArray() {
        runTest("compiler/testData/psi/examples/array/MutableArray.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/collections")
    @TestDataPath("$PROJECT_ROOT")
    public class Collections {
      @Test
      public void testAllFilesPresentInCollections() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/collections"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("ArrayList.kt")
      public void testArrayList() {
        runTest("compiler/testData/psi/examples/collections/ArrayList.kt");
      }

      @Test
      @TestMetadata("HashMap.kt")
      public void testHashMap() {
        runTest("compiler/testData/psi/examples/collections/HashMap.kt");
      }

      @Test
      @TestMetadata("IIterable.kt")
      public void testIIterable() {
        runTest("compiler/testData/psi/examples/collections/IIterable.kt");
      }

      @Test
      @TestMetadata("IIterator.kt")
      public void testIIterator() {
        runTest("compiler/testData/psi/examples/collections/IIterator.kt");
      }

      @Test
      @TestMetadata("IList.kt")
      public void testIList() {
        runTest("compiler/testData/psi/examples/collections/IList.kt");
      }

      @Test
      @TestMetadata("IMutableIterable.kt")
      public void testIMutableIterable() {
        runTest("compiler/testData/psi/examples/collections/IMutableIterable.kt");
      }

      @Test
      @TestMetadata("IMutableIterator.kt")
      public void testIMutableIterator() {
        runTest("compiler/testData/psi/examples/collections/IMutableIterator.kt");
      }

      @Test
      @TestMetadata("IMutableList.kt")
      public void testIMutableList() {
        runTest("compiler/testData/psi/examples/collections/IMutableList.kt");
      }

      @Test
      @TestMetadata("IMutableSet.kt")
      public void testIMutableSet() {
        runTest("compiler/testData/psi/examples/collections/IMutableSet.kt");
      }

      @Test
      @TestMetadata("ISet.kt")
      public void testISet() {
        runTest("compiler/testData/psi/examples/collections/ISet.kt");
      }

      @Test
      @TestMetadata("ISized.kt")
      public void testISized() {
        runTest("compiler/testData/psi/examples/collections/ISized.kt");
      }

      @Test
      @TestMetadata("LinkedList.kt")
      public void testLinkedList() {
        runTest("compiler/testData/psi/examples/collections/LinkedList.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/io")
    @TestDataPath("$PROJECT_ROOT")
    public class Io {
      @Test
      public void testAllFilesPresentInIo() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/io"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("IOSamples.kt")
      public void testIOSamples() {
        runTest("compiler/testData/psi/examples/io/IOSamples.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/map")
    @TestDataPath("$PROJECT_ROOT")
    public class Map {
      @Test
      public void testAllFilesPresentInMap() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/map"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("IMap.kt")
      public void testIMap() {
        runTest("compiler/testData/psi/examples/map/IMap.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/priorityqueues")
    @TestDataPath("$PROJECT_ROOT")
    public class Priorityqueues {
      @Test
      public void testAllFilesPresentInPriorityqueues() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/priorityqueues"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("BinaryHeap.kt")
      public void testBinaryHeap() {
        runTest("compiler/testData/psi/examples/priorityqueues/BinaryHeap.kt");
      }

      @Test
      @TestMetadata("IPriorityQueue.kt")
      public void testIPriorityQueue() {
        runTest("compiler/testData/psi/examples/priorityqueues/IPriorityQueue.kt");
      }

      @Test
      @TestMetadata("PriorityQueueAsPushPop.kt")
      public void testPriorityQueueAsPushPop() {
        runTest("compiler/testData/psi/examples/priorityqueues/PriorityQueueAsPushPop.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/examples/util")
    @TestDataPath("$PROJECT_ROOT")
    public class Util {
      @Test
      public void testAllFilesPresentInUtil() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/util"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("Comparison.kt")
      public void testComparison() {
        runTest("compiler/testData/psi/examples/util/Comparison.kt");
      }

      @Test
      @TestMetadata("IComparable.kt")
      public void testIComparable() {
        runTest("compiler/testData/psi/examples/util/IComparable.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/functionReceivers")
  @TestDataPath("$PROJECT_ROOT")
  public class FunctionReceivers {
    @Test
    public void testAllFilesPresentInFunctionReceivers() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/functionReceivers"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("FunctionTypesWithFunctionReceivers.kt")
    public void testFunctionTypesWithFunctionReceivers() {
      runTest("compiler/testData/psi/functionReceivers/FunctionTypesWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceivers.kt")
    public void testFunctionsWithFunctionReceivers() {
      runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceiversAnnotations.kt")
    public void testFunctionsWithFunctionReceiversAnnotations() {
      runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceiversAnnotations.kt");
    }

    @Test
    @TestMetadata("FunctionsWithFunctionReceiversRecovery.kt")
    public void testFunctionsWithFunctionReceiversRecovery() {
      runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceiversRecovery.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceivers.kt")
    public void testPropertiesWithFunctionReceivers() {
      runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceivers.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceiversAnnotations.kt")
    public void testPropertiesWithFunctionReceiversAnnotations() {
      runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceiversAnnotations.kt");
    }

    @Test
    @TestMetadata("PropertiesWithFunctionReceiversRecovery.kt")
    public void testPropertiesWithFunctionReceiversRecovery() {
      runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceiversRecovery.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/greatSyntacticShift")
  @TestDataPath("$PROJECT_ROOT")
  public class GreatSyntacticShift {
    @Test
    public void testAllFilesPresentInGreatSyntacticShift() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/greatSyntacticShift"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("functionLiterals.kt")
    public void testFunctionLiterals() {
      runTest("compiler/testData/psi/greatSyntacticShift/functionLiterals.kt");
    }

    @Test
    @TestMetadata("functionTypes.kt")
    public void testFunctionTypes() {
      runTest("compiler/testData/psi/greatSyntacticShift/functionTypes.kt");
    }

    @Test
    @TestMetadata("FunctionTypesAsArguments.kt")
    public void testFunctionTypesAsArguments() {
      runTest("compiler/testData/psi/greatSyntacticShift/FunctionTypesAsArguments.kt");
    }

    @Test
    @TestMetadata("nullableTypes.kt")
    public void testNullableTypes() {
      runTest("compiler/testData/psi/greatSyntacticShift/nullableTypes.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/kdoc")
  @TestDataPath("$PROJECT_ROOT")
  public class Kdoc {
    @Test
    public void testAllFilesPresentInKdoc() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/kdoc"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("AtTags.kt")
    public void testAtTags() {
      runTest("compiler/testData/psi/kdoc/AtTags.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile1.kt")
    public void testDocCommentAtBeginningOfFile1() {
      runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile1.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile2.kt")
    public void testDocCommentAtBeginningOfFile2() {
      runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile2.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile3.kt")
    public void testDocCommentAtBeginningOfFile3() {
      runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile3.kt");
    }

    @Test
    @TestMetadata("DocCommentAtBeginningOfFile4.kt")
    public void testDocCommentAtBeginningOfFile4() {
      runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile4.kt");
    }

    @Test
    @TestMetadata("EndOnLeadingAsterisks.kt")
    public void testEndOnLeadingAsterisks() {
      runTest("compiler/testData/psi/kdoc/EndOnLeadingAsterisks.kt");
    }

    @Test
    @TestMetadata("EndRightAfterText.kt")
    public void testEndRightAfterText() {
      runTest("compiler/testData/psi/kdoc/EndRightAfterText.kt");
    }

    @Test
    @TestMetadata("HttpLink.kt")
    public void testHttpLink() {
      runTest("compiler/testData/psi/kdoc/HttpLink.kt");
    }

    @Test
    @TestMetadata("Incomplete.kt")
    public void testIncomplete() {
      runTest("compiler/testData/psi/kdoc/Incomplete.kt");
    }

    @Test
    @TestMetadata("Markdown.kt")
    public void testMarkdown() {
      runTest("compiler/testData/psi/kdoc/Markdown.kt");
    }

    @Test
    @TestMetadata("MarkdownLinkWithError.kt")
    public void testMarkdownLinkWithError() {
      runTest("compiler/testData/psi/kdoc/MarkdownLinkWithError.kt");
    }

    @Test
    @TestMetadata("MarkdownLinkWithLabel.kt")
    public void testMarkdownLinkWithLabel() {
      runTest("compiler/testData/psi/kdoc/MarkdownLinkWithLabel.kt");
    }

    @Test
    @TestMetadata("MarkdownQualifiedName.kt")
    public void testMarkdownQualifiedName() {
      runTest("compiler/testData/psi/kdoc/MarkdownQualifiedName.kt");
    }

    @Test
    @TestMetadata("ParamTag.kt")
    public void testParamTag() {
      runTest("compiler/testData/psi/kdoc/ParamTag.kt");
    }

    @Test
    @TestMetadata("ParamTagAtStart.kt")
    public void testParamTagAtStart() {
      runTest("compiler/testData/psi/kdoc/ParamTagAtStart.kt");
    }

    @Test
    @TestMetadata("ReturnWithBrackets.kt")
    public void testReturnWithBrackets() {
      runTest("compiler/testData/psi/kdoc/ReturnWithBrackets.kt");
    }

    @Test
    @TestMetadata("Sections.kt")
    public void testSections() {
      runTest("compiler/testData/psi/kdoc/Sections.kt");
    }

    @Test
    @TestMetadata("SeeEmpty.kt")
    public void testSeeEmpty() {
      runTest("compiler/testData/psi/kdoc/SeeEmpty.kt");
    }

    @Test
    @TestMetadata("SeeLink.kt")
    public void testSeeLink() {
      runTest("compiler/testData/psi/kdoc/SeeLink.kt");
    }

    @Test
    @TestMetadata("Simple.kt")
    public void testSimple() {
      runTest("compiler/testData/psi/kdoc/Simple.kt");
    }

    @Test
    @TestMetadata("TextLinkWithNewLine.kt")
    public void testTextLinkWithNewLine() {
      runTest("compiler/testData/psi/kdoc/TextLinkWithNewLine.kt");
    }

    @Test
    @TestMetadata("TextRightAfterLeadAsterisks.kt")
    public void testTextRightAfterLeadAsterisks() {
      runTest("compiler/testData/psi/kdoc/TextRightAfterLeadAsterisks.kt");
    }

    @Test
    @TestMetadata("TwoTags.kt")
    public void testTwoTags() {
      runTest("compiler/testData/psi/kdoc/TwoTags.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/newLabels")
  @TestDataPath("$PROJECT_ROOT")
  public class NewLabels {
    @Test
    public void testAllFilesPresentInNewLabels() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/newLabels"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("basic.kt")
    public void testBasic() {
      runTest("compiler/testData/psi/newLabels/basic.kt");
    }

    @Test
    @TestMetadata("oldSyntaxExpressions.kt")
    public void testOldSyntaxExpressions() {
      runTest("compiler/testData/psi/newLabels/oldSyntaxExpressions.kt");
    }

    @Test
    @TestMetadata("recovery.kt")
    public void testRecovery() {
      runTest("compiler/testData/psi/newLabels/recovery.kt");
    }

    @Test
    @TestMetadata("spaceBeforeLabelReference.kt")
    public void testSpaceBeforeLabelReference() {
      runTest("compiler/testData/psi/newLabels/spaceBeforeLabelReference.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/operators")
  @TestDataPath("$PROJECT_ROOT")
  public class Operators {
    @Test
    public void testAllFilesPresentInOperators() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/operators"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("untilOperator.kt")
    public void testUntilOperator() {
      runTest("compiler/testData/psi/operators/untilOperator.kt");
    }

    @Test
    @TestMetadata("untilOperatorDifferentContexts.kt")
    public void testUntilOperatorDifferentContexts() {
      runTest("compiler/testData/psi/operators/untilOperatorDifferentContexts.kt");
    }

    @Test
    @TestMetadata("untilOperatorGenericsClash.kt")
    public void testUntilOperatorGenericsClash() {
      runTest("compiler/testData/psi/operators/untilOperatorGenericsClash.kt");
    }

    @Test
    @TestMetadata("untilOperatorGreater.kt")
    public void testUntilOperatorGreater() {
      runTest("compiler/testData/psi/operators/untilOperatorGreater.kt");
    }

    @Test
    @TestMetadata("untilOperatorWithWhitespace.kt")
    public void testUntilOperatorWithWhitespace() {
      runTest("compiler/testData/psi/operators/untilOperatorWithWhitespace.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/packages")
  @TestDataPath("$PROJECT_ROOT")
  public class Packages {
    @Test
    public void testAllFilesPresentInPackages() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/packages"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("PackageBlockFirst.kt")
    public void testPackageBlockFirst() {
      runTest("compiler/testData/psi/packages/PackageBlockFirst.kt");
    }

    @Test
    @TestMetadata("PackageLeadingDotDoubleID.kt")
    public void testPackageLeadingDotDoubleID() {
      runTest("compiler/testData/psi/packages/PackageLeadingDotDoubleID.kt");
    }

    @Test
    @TestMetadata("PackageLongNameBetweenDots.kt")
    public void testPackageLongNameBetweenDots() {
      runTest("compiler/testData/psi/packages/PackageLongNameBetweenDots.kt");
    }

    @Test
    @TestMetadata("PackageLongNameDoubleID.kt")
    public void testPackageLongNameDoubleID() {
      runTest("compiler/testData/psi/packages/PackageLongNameDoubleID.kt");
    }

    @Test
    @TestMetadata("PackageLongNameLeadingDot.kt")
    public void testPackageLongNameLeadingDot() {
      runTest("compiler/testData/psi/packages/PackageLongNameLeadingDot.kt");
    }

    @Test
    @TestMetadata("PackageLongNameLeadingDoubleDot.kt")
    public void testPackageLongNameLeadingDoubleDot() {
      runTest("compiler/testData/psi/packages/PackageLongNameLeadingDoubleDot.kt");
    }

    @Test
    @TestMetadata("PackageModifiers.kt")
    public void testPackageModifiers() {
      runTest("compiler/testData/psi/packages/PackageModifiers.kt");
    }

    @Test
    @TestMetadata("PackageNameDoubleDot.kt")
    public void testPackageNameDoubleDot() {
      runTest("compiler/testData/psi/packages/PackageNameDoubleDot.kt");
    }

    @Test
    @TestMetadata("PackageNameJustDot.kt")
    public void testPackageNameJustDot() {
      runTest("compiler/testData/psi/packages/PackageNameJustDot.kt");
    }

    @Test
    @TestMetadata("PackageSimpleNameLeadingDot.kt")
    public void testPackageSimpleNameLeadingDot() {
      runTest("compiler/testData/psi/packages/PackageSimpleNameLeadingDot.kt");
    }

    @Test
    @TestMetadata("PackageSimpleNameLeadingDoubleDot.kt")
    public void testPackageSimpleNameLeadingDoubleDot() {
      runTest("compiler/testData/psi/packages/PackageSimpleNameLeadingDoubleDot.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/platformTypesRecovery")
  @TestDataPath("$PROJECT_ROOT")
  public class PlatformTypesRecovery {
    @Test
    public void testAllFilesPresentInPlatformTypesRecovery() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/platformTypesRecovery"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("Array.kt")
    public void testArray() {
      runTest("compiler/testData/psi/platformTypesRecovery/Array.kt");
    }

    @Test
    @TestMetadata("BeforeDot.kt")
    public void testBeforeDot() {
      runTest("compiler/testData/psi/platformTypesRecovery/BeforeDot.kt");
    }

    @Test
    @TestMetadata("Collections.kt")
    public void testCollections() {
      runTest("compiler/testData/psi/platformTypesRecovery/Collections.kt");
    }

    @Test
    @TestMetadata("FunctionsNotPlatform.kt")
    public void testFunctionsNotPlatform() {
      runTest("compiler/testData/psi/platformTypesRecovery/FunctionsNotPlatform.kt");
    }

    @Test
    @TestMetadata("MapEntry.kt")
    public void testMapEntry() {
      runTest("compiler/testData/psi/platformTypesRecovery/MapEntry.kt");
    }

    @Test
    @TestMetadata("ParenthesizedNotPlatform.kt")
    public void testParenthesizedNotPlatform() {
      runTest("compiler/testData/psi/platformTypesRecovery/ParenthesizedNotPlatform.kt");
    }

    @Test
    @TestMetadata("Qualified.kt")
    public void testQualified() {
      runTest("compiler/testData/psi/platformTypesRecovery/Qualified.kt");
    }

    @Test
    @TestMetadata("QualifiedCollections.kt")
    public void testQualifiedCollections() {
      runTest("compiler/testData/psi/platformTypesRecovery/QualifiedCollections.kt");
    }

    @Test
    @TestMetadata("Simple.kt")
    public void testSimple() {
      runTest("compiler/testData/psi/platformTypesRecovery/Simple.kt");
    }

    @Test
    @TestMetadata("WrongWordInParentheses.kt")
    public void testWrongWordInParentheses() {
      runTest("compiler/testData/psi/platformTypesRecovery/WrongWordInParentheses.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/primaryConstructor")
  @TestDataPath("$PROJECT_ROOT")
  public class PrimaryConstructor {
    @Test
    public void testAllFilesPresentInPrimaryConstructor() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/primaryConstructor"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("local.kt")
    public void testLocal() {
      runTest("compiler/testData/psi/primaryConstructor/local.kt");
    }

    @Test
    @TestMetadata("nestedClassAmbiguity.kt")
    public void testNestedClassAmbiguity() {
      runTest("compiler/testData/psi/primaryConstructor/nestedClassAmbiguity.kt");
    }

    @Test
    @TestMetadata("recovery.kt")
    public void testRecovery() {
      runTest("compiler/testData/psi/primaryConstructor/recovery.kt");
    }

    @Test
    @TestMetadata("recoveryNestedClassAmbiguity.kt")
    public void testRecoveryNestedClassAmbiguity() {
      runTest("compiler/testData/psi/primaryConstructor/recoveryNestedClassAmbiguity.kt");
    }

    @Test
    @TestMetadata("valid.kt")
    public void testValid() {
      runTest("compiler/testData/psi/primaryConstructor/valid.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/propertyBackingField")
  @TestDataPath("$PROJECT_ROOT")
  public class PropertyBackingField {
    @Test
    public void testAllFilesPresentInPropertyBackingField() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyBackingField"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("annotationClass.kt")
    public void testAnnotationClass() {
      runTest("compiler/testData/psi/propertyBackingField/annotationClass.kt");
    }

    @Test
    @TestMetadata("backingFieldComment.kt")
    public void testBackingFieldComment() {
      runTest("compiler/testData/psi/propertyBackingField/backingFieldComment.kt");
    }

    @Test
    @TestMetadata("explicitBackingField.kt")
    public void testExplicitBackingField() {
      runTest("compiler/testData/psi/propertyBackingField/explicitBackingField.kt");
    }

    @Test
    @TestMetadata("properties.kt")
    public void testProperties() {
      runTest("compiler/testData/psi/propertyBackingField/properties.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/propertyDelegate")
  @TestDataPath("$PROJECT_ROOT")
  public class PropertyDelegate {
    @Test
    public void testAllFilesPresentInPropertyDelegate() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyDelegate"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("BracketsInDelegate.kt")
    public void testBracketsInDelegate() {
      runTest("compiler/testData/psi/propertyDelegate/BracketsInDelegate.kt");
    }

    @Test
    @TestMetadata("DelegateAndInitializer.kt")
    public void testDelegateAndInitializer() {
      runTest("compiler/testData/psi/propertyDelegate/DelegateAndInitializer.kt");
    }

    @Test
    @TestMetadata("GetterInSameLine.kt")
    public void testGetterInSameLine() {
      runTest("compiler/testData/psi/propertyDelegate/GetterInSameLine.kt");
    }

    @Test
    @TestMetadata("LocalProperty.kt")
    public void testLocalProperty() {
      runTest("compiler/testData/psi/propertyDelegate/LocalProperty.kt");
    }

    @Test
    @TestMetadata("OnlyBy.kt")
    public void testOnlyBy() {
      runTest("compiler/testData/psi/propertyDelegate/OnlyBy.kt");
    }

    @Test
    @TestMetadata("PropertyInClass.kt")
    public void testPropertyInClass() {
      runTest("compiler/testData/psi/propertyDelegate/PropertyInClass.kt");
    }

    @Test
    @TestMetadata("PropertyWithGetter.kt")
    public void testPropertyWithGetter() {
      runTest("compiler/testData/psi/propertyDelegate/PropertyWithGetter.kt");
    }

    @Test
    @TestMetadata("PropertyWithInitializer.kt")
    public void testPropertyWithInitializer() {
      runTest("compiler/testData/psi/propertyDelegate/PropertyWithInitializer.kt");
    }

    @Test
    @TestMetadata("PropertyWithoutTypeRef.kt")
    public void testPropertyWithoutTypeRef() {
      runTest("compiler/testData/psi/propertyDelegate/PropertyWithoutTypeRef.kt");
    }

    @Test
    @TestMetadata("TopLevelProperty.kt")
    public void testTopLevelProperty() {
      runTest("compiler/testData/psi/propertyDelegate/TopLevelProperty.kt");
    }

    @Test
    @TestMetadata("TwoProperties.kt")
    public void testTwoProperties() {
      runTest("compiler/testData/psi/propertyDelegate/TwoProperties.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/recovery")
  @TestDataPath("$PROJECT_ROOT")
  public class Recovery {
    @Test
    @TestMetadata("AbsentLeftHandSide.kt")
    public void testAbsentLeftHandSide() {
      runTest("compiler/testData/psi/recovery/AbsentLeftHandSide.kt");
    }

    @Test
    public void testAllFilesPresentInRecovery() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("BareVal.kt")
    public void testBareVal() {
      runTest("compiler/testData/psi/recovery/BareVal.kt");
    }

    @Test
    @TestMetadata("BrokenFunctionSuperType.kt")
    public void testBrokenFunctionSuperType() {
      runTest("compiler/testData/psi/recovery/BrokenFunctionSuperType.kt");
    }

    @Test
    @TestMetadata("CatchKeywordRBrace.kt")
    public void testCatchKeywordRBrace() {
      runTest("compiler/testData/psi/recovery/CatchKeywordRBrace.kt");
    }

    @Test
    @TestMetadata("CloseBraceAtTopLevel.kt")
    public void testCloseBraceAtTopLevel() {
      runTest("compiler/testData/psi/recovery/CloseBraceAtTopLevel.kt");
    }

    @Test
    @TestMetadata("DeclarationAfterDotSelectorExpected.kt")
    public void testDeclarationAfterDotSelectorExpected() {
      runTest("compiler/testData/psi/recovery/DeclarationAfterDotSelectorExpected.kt");
    }

    @Test
    @TestMetadata("DeclarationAfterIncompleteElvis.kt")
    public void testDeclarationAfterIncompleteElvis() {
      runTest("compiler/testData/psi/recovery/DeclarationAfterIncompleteElvis.kt");
    }

    @Test
    @TestMetadata("DoWhileWithEmptyCondition.kt")
    public void testDoWhileWithEmptyCondition() {
      runTest("compiler/testData/psi/recovery/DoWhileWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("DoWhileWithoutLPar.kt")
    public void testDoWhileWithoutLPar() {
      runTest("compiler/testData/psi/recovery/DoWhileWithoutLPar.kt");
    }

    @Test
    @TestMetadata("enumWthoutClass.kt")
    public void testEnumWthoutClass() {
      runTest("compiler/testData/psi/recovery/enumWthoutClass.kt");
    }

    @Test
    @TestMetadata("ForEmptyParentheses.kt")
    public void testForEmptyParentheses() {
      runTest("compiler/testData/psi/recovery/ForEmptyParentheses.kt");
    }

    @Test
    @TestMetadata("ForEmptyWithoutBody.kt")
    public void testForEmptyWithoutBody() {
      runTest("compiler/testData/psi/recovery/ForEmptyWithoutBody.kt");
    }

    @Test
    @TestMetadata("ForNoBodyBeforeRBrace.kt")
    public void testForNoBodyBeforeRBrace() {
      runTest("compiler/testData/psi/recovery/ForNoBodyBeforeRBrace.kt");
    }

    @Test
    @TestMetadata("ForRecovery.kt")
    public void testForRecovery() {
      runTest("compiler/testData/psi/recovery/ForRecovery.kt");
    }

    @Test
    @TestMetadata("ForWithOnlyOneLParInEOF.kt")
    public void testForWithOnlyOneLParInEOF() {
      runTest("compiler/testData/psi/recovery/ForWithOnlyOneLParInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutBodyInEOF.kt")
    public void testForWithoutBodyInEOF() {
      runTest("compiler/testData/psi/recovery/ForWithoutBodyInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutLPar.kt")
    public void testForWithoutLPar() {
      runTest("compiler/testData/psi/recovery/ForWithoutLPar.kt");
    }

    @Test
    @TestMetadata("ForWithoutLParInEOF.kt")
    public void testForWithoutLParInEOF() {
      runTest("compiler/testData/psi/recovery/ForWithoutLParInEOF.kt");
    }

    @Test
    @TestMetadata("ForWithoutParamButWithRange.kt")
    public void testForWithoutParamButWithRange() {
      runTest("compiler/testData/psi/recovery/ForWithoutParamButWithRange.kt");
    }

    @Test
    @TestMetadata("ForWithoutRange.kt")
    public void testForWithoutRange() {
      runTest("compiler/testData/psi/recovery/ForWithoutRange.kt");
    }

    @Test
    @TestMetadata("FunFun.kt")
    public void testFunFun() {
      runTest("compiler/testData/psi/recovery/FunFun.kt");
    }

    @Test
    @TestMetadata("IfKeywordRBrace.kt")
    public void testIfKeywordRBrace() {
      runTest("compiler/testData/psi/recovery/IfKeywordRBrace.kt");
    }

    @Test
    @TestMetadata("IfWithEmptyCondition.kt")
    public void testIfWithEmptyCondition() {
      runTest("compiler/testData/psi/recovery/IfWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("IfWithoutLPar.kt")
    public void testIfWithoutLPar() {
      runTest("compiler/testData/psi/recovery/IfWithoutLPar.kt");
    }

    @Test
    @TestMetadata("ImportRecovery.kt")
    public void testImportRecovery() {
      runTest("compiler/testData/psi/recovery/ImportRecovery.kt");
    }

    @Test
    @TestMetadata("importsWithConflict.kt")
    public void testImportsWithConflict() {
      runTest("compiler/testData/psi/recovery/importsWithConflict.kt");
    }

    @Test
    @TestMetadata("IncompleteAccessor1.kt")
    public void testIncompleteAccessor1() {
      runTest("compiler/testData/psi/recovery/IncompleteAccessor1.kt");
    }

    @Test
    @TestMetadata("IncompleteAccessor2.kt")
    public void testIncompleteAccessor2() {
      runTest("compiler/testData/psi/recovery/IncompleteAccessor2.kt");
    }

    @Test
    @TestMetadata("IncompleteClassDeclaration.kt")
    public void testIncompleteClassDeclaration() {
      runTest("compiler/testData/psi/recovery/IncompleteClassDeclaration.kt");
    }

    @Test
    @TestMetadata("IncompleteClassTypeParameters.kt")
    public void testIncompleteClassTypeParameters() {
      runTest("compiler/testData/psi/recovery/IncompleteClassTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteForRBrace.kt")
    public void testIncompleteForRBrace() {
      runTest("compiler/testData/psi/recovery/IncompleteForRBrace.kt");
    }

    @Test
    @TestMetadata("IncompleteFun.kt")
    public void testIncompleteFun() {
      runTest("compiler/testData/psi/recovery/IncompleteFun.kt");
    }

    @Test
    @TestMetadata("IncompleteFunDeclaration.kt")
    public void testIncompleteFunDeclaration() {
      runTest("compiler/testData/psi/recovery/IncompleteFunDeclaration.kt");
    }

    @Test
    @TestMetadata("IncompleteFunTypeParameters.kt")
    public void testIncompleteFunTypeParameters() {
      runTest("compiler/testData/psi/recovery/IncompleteFunTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteTypeParameters.kt")
    public void testIncompleteTypeParameters() {
      runTest("compiler/testData/psi/recovery/IncompleteTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteTypeRefWithPackageKeyword.kt")
    public void testIncompleteTypeRefWithPackageKeyword() {
      runTest("compiler/testData/psi/recovery/IncompleteTypeRefWithPackageKeyword.kt");
    }

    @Test
    @TestMetadata("IncompleteValTypeParameters.kt")
    public void testIncompleteValTypeParameters() {
      runTest("compiler/testData/psi/recovery/IncompleteValTypeParameters.kt");
    }

    @Test
    @TestMetadata("IncompleteWhenElse.kt")
    public void testIncompleteWhenElse() {
      runTest("compiler/testData/psi/recovery/IncompleteWhenElse.kt");
    }

    @Test
    @TestMetadata("IncompleteWhere.kt")
    public void testIncompleteWhere() {
      runTest("compiler/testData/psi/recovery/IncompleteWhere.kt");
    }

    @Test
    @TestMetadata("IncompleteWhere2.kt")
    public void testIncompleteWhere2() {
      runTest("compiler/testData/psi/recovery/IncompleteWhere2.kt");
    }

    @Test
    @TestMetadata("initRecovery.kt")
    public void testInitRecovery() {
      runTest("compiler/testData/psi/recovery/initRecovery.kt");
    }

    @Test
    @TestMetadata("InterfaceInExpressionPosition.kt")
    public void testInterfaceInExpressionPosition() {
      runTest("compiler/testData/psi/recovery/InterfaceInExpressionPosition.kt");
    }

    @Test
    @TestMetadata("InvalidCharAfterPropertyName.kt")
    public void testInvalidCharAfterPropertyName() {
      runTest("compiler/testData/psi/recovery/InvalidCharAfterPropertyName.kt");
    }

    @Test
    @TestMetadata("InvalidCharInSingleLineLambda.kt")
    public void testInvalidCharInSingleLineLambda() {
      runTest("compiler/testData/psi/recovery/InvalidCharInSingleLineLambda.kt");
    }

    @Test
    @TestMetadata("kt2172.kt")
    public void testKt2172() {
      runTest("compiler/testData/psi/recovery/kt2172.kt");
    }

    @Test
    @TestMetadata("kt24158.kt")
    public void testKt24158() {
      runTest("compiler/testData/psi/recovery/kt24158.kt");
    }

    @Test
    @TestMetadata("kt5102.kt")
    public void testKt5102() {
      runTest("compiler/testData/psi/recovery/kt5102.kt");
    }

    @Test
    @TestMetadata("lambdaExpressionInString_1.kt")
    public void testLambdaExpressionInString_1() {
      runTest("compiler/testData/psi/recovery/lambdaExpressionInString_1.kt");
    }

    @Test
    @TestMetadata("lambdaExpressionInString_2.kt")
    public void testLambdaExpressionInString_2() {
      runTest("compiler/testData/psi/recovery/lambdaExpressionInString_2.kt");
    }

    @Test
    @TestMetadata("MissingCommaInConstructorValueParameterList.kt")
    public void testMissingCommaInConstructorValueParameterList() {
      runTest("compiler/testData/psi/recovery/MissingCommaInConstructorValueParameterList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueArgumentList.kt")
    public void testMissingCommaInValueArgumentList() {
      runTest("compiler/testData/psi/recovery/MissingCommaInValueArgumentList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueParameterList.kt")
    public void testMissingCommaInValueParameterList() {
      runTest("compiler/testData/psi/recovery/MissingCommaInValueParameterList.kt");
    }

    @Test
    @TestMetadata("MissingCommaInValueParameterListWithValOrVar.kt")
    public void testMissingCommaInValueParameterListWithValOrVar() {
      runTest("compiler/testData/psi/recovery/MissingCommaInValueParameterListWithValOrVar.kt");
    }

    @Test
    @TestMetadata("NoArrowInWhen.kt")
    public void testNoArrowInWhen() {
      runTest("compiler/testData/psi/recovery/NoArrowInWhen.kt");
    }

    @Test
    @TestMetadata("NoGTInTypeArguments.kt")
    public void testNoGTInTypeArguments() {
      runTest("compiler/testData/psi/recovery/NoGTInTypeArguments.kt");
    }

    @Test
    @TestMetadata("PackageNewLineRecovery.kt")
    public void testPackageNewLineRecovery() {
      runTest("compiler/testData/psi/recovery/PackageNewLineRecovery.kt");
    }

    @Test
    @TestMetadata("PackageRecovery.kt")
    public void testPackageRecovery() {
      runTest("compiler/testData/psi/recovery/PackageRecovery.kt");
    }

    @Test
    @TestMetadata("SameLineStatementRecovery.kt")
    public void testSameLineStatementRecovery() {
      runTest("compiler/testData/psi/recovery/SameLineStatementRecovery.kt");
    }

    @Test
    @TestMetadata("UnfinishedExtension.kt")
    public void testUnfinishedExtension() {
      runTest("compiler/testData/psi/recovery/UnfinishedExtension.kt");
    }

    @Test
    @TestMetadata("ValNoName.kt")
    public void testValNoName() {
      runTest("compiler/testData/psi/recovery/ValNoName.kt");
    }

    @Test
    @TestMetadata("ValWithNoNameBeforeNextDeclarationWithModifiers.kt")
    public void testValWithNoNameBeforeNextDeclarationWithModifiers() {
      runTest("compiler/testData/psi/recovery/ValWithNoNameBeforeNextDeclarationWithModifiers.kt");
    }

    @Test
    @TestMetadata("ValWithNoNameInBlock.kt")
    public void testValWithNoNameInBlock() {
      runTest("compiler/testData/psi/recovery/ValWithNoNameInBlock.kt");
    }

    @Test
    @TestMetadata("ValueParameterNoTypeRecovery.kt")
    public void testValueParameterNoTypeRecovery() {
      runTest("compiler/testData/psi/recovery/ValueParameterNoTypeRecovery.kt");
    }

    @Test
    @TestMetadata("valueParameterRecovery.kt")
    public void testValueParameterRecovery() {
      runTest("compiler/testData/psi/recovery/valueParameterRecovery.kt");
    }

    @Test
    @TestMetadata("valueParameterRecoveryWithTypes.kt")
    public void testValueParameterRecoveryWithTypes() {
      runTest("compiler/testData/psi/recovery/valueParameterRecoveryWithTypes.kt");
    }

    @Test
    @TestMetadata("WhenWithoutBraces.kt")
    public void testWhenWithoutBraces() {
      runTest("compiler/testData/psi/recovery/WhenWithoutBraces.kt");
    }

    @Test
    @TestMetadata("WhileWithEmptyCondition.kt")
    public void testWhileWithEmptyCondition() {
      runTest("compiler/testData/psi/recovery/WhileWithEmptyCondition.kt");
    }

    @Test
    @TestMetadata("WhileWithoutLPar.kt")
    public void testWhileWithoutLPar() {
      runTest("compiler/testData/psi/recovery/WhileWithoutLPar.kt");
    }

    @Test
    @TestMetadata("WithWithoutInAndMultideclaration.kt")
    public void testWithWithoutInAndMultideclaration() {
      runTest("compiler/testData/psi/recovery/WithWithoutInAndMultideclaration.kt");
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/objects")
    @TestDataPath("$PROJECT_ROOT")
    public class Objects {
      @Test
      public void testAllFilesPresentInObjects() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Nested
      @TestMetadata("compiler/testData/psi/recovery/objects/declarations")
      @TestDataPath("$PROJECT_ROOT")
      public class Declarations {
        @Test
        public void testAllFilesPresentInDeclarations() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/declarations"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("ConstructorModifiers.kt")
        public void testConstructorModifiers() {
          runTest("compiler/testData/psi/recovery/objects/declarations/ConstructorModifiers.kt");
        }

        @Test
        @TestMetadata("EmptyParentheses.kt")
        public void testEmptyParentheses() {
          runTest("compiler/testData/psi/recovery/objects/declarations/EmptyParentheses.kt");
        }

        @Test
        @TestMetadata("Everything.kt")
        public void testEverything() {
          runTest("compiler/testData/psi/recovery/objects/declarations/Everything.kt");
        }

        @Test
        @TestMetadata("FollowedByModifiers.kt")
        public void testFollowedByModifiers() {
          runTest("compiler/testData/psi/recovery/objects/declarations/FollowedByModifiers.kt");
        }

        @Test
        @TestMetadata("ParametersInParentheses.kt")
        public void testParametersInParentheses() {
          runTest("compiler/testData/psi/recovery/objects/declarations/ParametersInParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParametersAndParentheses.kt")
        public void testTypeParametersAndParentheses() {
          runTest("compiler/testData/psi/recovery/objects/declarations/TypeParametersAndParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParameterss.kt")
        public void testTypeParameterss() {
          runTest("compiler/testData/psi/recovery/objects/declarations/TypeParameterss.kt");
        }

        @Test
        @TestMetadata("Where.kt")
        public void testWhere() {
          runTest("compiler/testData/psi/recovery/objects/declarations/Where.kt");
        }
      }

      @Nested
      @TestMetadata("compiler/testData/psi/recovery/objects/expressions")
      @TestDataPath("$PROJECT_ROOT")
      public class Expressions {
        @Test
        public void testAllFilesPresentInExpressions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/expressions"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
        }

        @Test
        @TestMetadata("ConstructorModifiers.kt")
        public void testConstructorModifiers() {
          runTest("compiler/testData/psi/recovery/objects/expressions/ConstructorModifiers.kt");
        }

        @Test
        @TestMetadata("ConstructorModifiersAndName.kt")
        public void testConstructorModifiersAndName() {
          runTest("compiler/testData/psi/recovery/objects/expressions/ConstructorModifiersAndName.kt");
        }

        @Test
        @TestMetadata("EmptyParentheses.kt")
        public void testEmptyParentheses() {
          runTest("compiler/testData/psi/recovery/objects/expressions/EmptyParentheses.kt");
        }

        @Test
        @TestMetadata("Everything.kt")
        public void testEverything() {
          runTest("compiler/testData/psi/recovery/objects/expressions/Everything.kt");
        }

        @Test
        @TestMetadata("InFunction.kt")
        public void testInFunction() {
          runTest("compiler/testData/psi/recovery/objects/expressions/InFunction.kt");
        }

        @Test
        @TestMetadata("ParametersInParentheses.kt")
        public void testParametersInParentheses() {
          runTest("compiler/testData/psi/recovery/objects/expressions/ParametersInParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParametersAndParentheses.kt")
        public void testTypeParametersAndParentheses() {
          runTest("compiler/testData/psi/recovery/objects/expressions/TypeParametersAndParentheses.kt");
        }

        @Test
        @TestMetadata("TypeParameterss.kt")
        public void testTypeParameterss() {
          runTest("compiler/testData/psi/recovery/objects/expressions/TypeParameterss.kt");
        }

        @Test
        @TestMetadata("Where.kt")
        public void testWhere() {
          runTest("compiler/testData/psi/recovery/objects/expressions/Where.kt");
        }
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/qualifiedExpression")
    @TestDataPath("$PROJECT_ROOT")
    public class QualifiedExpression {
      @Test
      public void testAllFilesPresentInQualifiedExpression() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/qualifiedExpression"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("noQualifiedExpression.kt")
      public void testNoQualifiedExpression() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/noQualifiedExpression.kt");
      }

      @Test
      @TestMetadata("noSafeQualifiedExpression.kt")
      public void testNoSafeQualifiedExpression() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/noSafeQualifiedExpression.kt");
      }

      @Test
      @TestMetadata("qualifiedExpressionWithSelector.kt")
      public void testQualifiedExpressionWithSelector() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/qualifiedExpressionWithSelector.kt");
      }

      @Test
      @TestMetadata("qualifiedExpressionWithoutSelector.kt")
      public void testQualifiedExpressionWithoutSelector() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/qualifiedExpressionWithoutSelector.kt");
      }

      @Test
      @TestMetadata("safeQualifiedExpressionWithSelector.kt")
      public void testSafeQualifiedExpressionWithSelector() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/safeQualifiedExpressionWithSelector.kt");
      }

      @Test
      @TestMetadata("safeQualifiedExpressionWithoutSelector.kt")
      public void testSafeQualifiedExpressionWithoutSelector() {
        runTest("compiler/testData/psi/recovery/qualifiedExpression/safeQualifiedExpressionWithoutSelector.kt");
      }
    }

    @Nested
    @TestMetadata("compiler/testData/psi/recovery/unnamedParameter")
    @TestDataPath("$PROJECT_ROOT")
    public class UnnamedParameter {
      @Test
      public void testAllFilesPresentInUnnamedParameter() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/unnamedParameter"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("firstInFunction.kt")
      public void testFirstInFunction() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInFunction.kt");
      }

      @Test
      @TestMetadata("firstInFunctionalType.kt")
      public void testFirstInFunctionalType() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInFunctionalType.kt");
      }

      @Test
      @TestMetadata("firstInLambda.kt")
      public void testFirstInLambda() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInLambda.kt");
      }

      @Test
      @TestMetadata("firstInPrimaryConstructor.kt")
      public void testFirstInPrimaryConstructor() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInPrimaryConstructor.kt");
      }

      @Test
      @TestMetadata("firstInSecondaryConstructor.kt")
      public void testFirstInSecondaryConstructor() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInSecondaryConstructor.kt");
      }

      @Test
      @TestMetadata("firstInSetter.kt")
      public void testFirstInSetter() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/firstInSetter.kt");
      }

      @Test
      @TestMetadata("secondInFunction.kt")
      public void testSecondInFunction() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/secondInFunction.kt");
      }

      @Test
      @TestMetadata("secondInFunctionalType.kt")
      public void testSecondInFunctionalType() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/secondInFunctionalType.kt");
      }

      @Test
      @TestMetadata("secondInLambda.kt")
      public void testSecondInLambda() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/secondInLambda.kt");
      }

      @Test
      @TestMetadata("secondInPrimaryConstructor.kt")
      public void testSecondInPrimaryConstructor() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/secondInPrimaryConstructor.kt");
      }

      @Test
      @TestMetadata("secondInSecondaryConstructor.kt")
      public void testSecondInSecondaryConstructor() {
        runTest("compiler/testData/psi/recovery/unnamedParameter/secondInSecondaryConstructor.kt");
      }
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/script")
  @TestDataPath("$PROJECT_ROOT")
  public class Script {
    @Test
    public void testAllFilesPresentInScript() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/script"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/secondaryConstructors")
  @TestDataPath("$PROJECT_ROOT")
  public class SecondaryConstructors {
    @Test
    public void testAllFilesPresentInSecondaryConstructors() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/secondaryConstructors"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("anonymousInitializer.kt")
    public void testAnonymousInitializer() {
      runTest("compiler/testData/psi/secondaryConstructors/anonymousInitializer.kt");
    }

    @Test
    @TestMetadata("basic.kt")
    public void testBasic() {
      runTest("compiler/testData/psi/secondaryConstructors/basic.kt");
    }

    @Test
    @TestMetadata("emptyBody.kt")
    public void testEmptyBody() {
      runTest("compiler/testData/psi/secondaryConstructors/emptyBody.kt");
    }

    @Test
    @TestMetadata("enumParsing.kt")
    public void testEnumParsing() {
      runTest("compiler/testData/psi/secondaryConstructors/enumParsing.kt");
    }

    @Test
    @TestMetadata("recoveryEmptyDelegationType.kt")
    public void testRecoveryEmptyDelegationType() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryEmptyDelegationType.kt");
    }

    @Test
    @TestMetadata("recoveryJustConstructorKeyword.kt")
    public void testRecoveryJustConstructorKeyword() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryJustConstructorKeyword.kt");
    }

    @Test
    @TestMetadata("recoveryJustConstructorKeywordSameLineBrace.kt")
    public void testRecoveryJustConstructorKeywordSameLineBrace() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryJustConstructorKeywordSameLineBrace.kt");
    }

    @Test
    @TestMetadata("recoveryNoDelegationCallAfterColon.kt")
    public void testRecoveryNoDelegationCallAfterColon() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryNoDelegationCallAfterColon.kt");
    }

    @Test
    @TestMetadata("recoveryWithoutBodyWrongDelegationName.kt")
    public void testRecoveryWithoutBodyWrongDelegationName() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryWithoutBodyWrongDelegationName.kt");
    }

    @Test
    @TestMetadata("recoveryWithoutParameterList.kt")
    public void testRecoveryWithoutParameterList() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryWithoutParameterList.kt");
    }

    @Test
    @TestMetadata("recoveryWrongDelegationName.kt")
    public void testRecoveryWrongDelegationName() {
      runTest("compiler/testData/psi/secondaryConstructors/recoveryWrongDelegationName.kt");
    }

    @Test
    @TestMetadata("secondaryConstructors.kt")
    public void testSecondaryConstructors() {
      runTest("compiler/testData/psi/secondaryConstructors/secondaryConstructors.kt");
    }
  }

  @Nested
  @TestMetadata("compiler/testData/psi/stringTemplates")
  @TestDataPath("$PROJECT_ROOT")
  public class StringTemplates {
    @Test
    public void testAllFilesPresentInStringTemplates() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/stringTemplates"), Pattern.compile("^([^.]+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("IncorrectMultiDollarInterpolationCode.kt")
    public void testIncorrectMultiDollarInterpolationCode() {
      runTest("compiler/testData/psi/stringTemplates/IncorrectMultiDollarInterpolationCode.kt");
    }

    @Test
    @TestMetadata("IncorrectPaddedMultiDollarInterpolationCode.kt")
    public void testIncorrectPaddedMultiDollarInterpolationCode() {
      runTest("compiler/testData/psi/stringTemplates/IncorrectPaddedMultiDollarInterpolationCode.kt");
    }

    @Test
    @TestMetadata("MultiDollarBacktick.kt")
    public void testMultiDollarBacktick() {
      runTest("compiler/testData/psi/stringTemplates/MultiDollarBacktick.kt");
    }

    @Test
    @TestMetadata("RawStringsWithManyQuotes.kt")
    public void testRawStringsWithManyQuotes() {
      runTest("compiler/testData/psi/stringTemplates/RawStringsWithManyQuotes.kt");
    }

    @Test
    @TestMetadata("StringTemplateWithTryWithoutBlockInLongEntry.kt")
    public void testStringTemplateWithTryWithoutBlockInLongEntry() {
      runTest("compiler/testData/psi/stringTemplates/StringTemplateWithTryWithoutBlockInLongEntry.kt");
    }

    @Test
    @TestMetadata("StringTemplateWithTryWithoutBlockInShortEntry.kt")
    public void testStringTemplateWithTryWithoutBlockInShortEntry() {
      runTest("compiler/testData/psi/stringTemplates/StringTemplateWithTryWithoutBlockInShortEntry.kt");
    }
  }
}
