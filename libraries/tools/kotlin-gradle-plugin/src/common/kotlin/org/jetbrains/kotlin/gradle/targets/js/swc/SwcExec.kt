/*
* Copyright 2010-2025 JetBrains s.r.o. and Kotlin Programming Language contributors.
* Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
*/

package org.jetbrains.kotlin.gradle.targets.js.swc

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.FileSystemOperations
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.IgnoreEmptyDirectories
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.TaskProvider
import org.gradle.process.ExecOperations
import org.gradle.work.ChangeType
import org.gradle.work.Incremental
import org.gradle.work.InputChanges
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrCompilation
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrOutputGranularity
import org.jetbrains.kotlin.gradle.targets.js.webpack.KotlinWebpackConfig.Mode
import org.jetbrains.kotlin.gradle.tasks.registerTask
import org.jetbrains.kotlin.js.config.ModuleKind
import org.jetbrains.kotlin.platform.js.SwcConfig
import javax.inject.Inject

/**
 * A Gradle task for transpiling generated by the compiler JS-code using SWC (Speedy Web Compiler) CLI.
 *
 * See [Speedy Web Compiler](https://swc.rs/)
 */
@CacheableTask
internal abstract class SwcExec
@Inject
internal constructor(
    private val execOps: ExecOperations,
    private val fs: FileSystemOperations,
) : DefaultTask() {
    @get:Input
    abstract val executable: Property<String>

    @get:Input
    abstract val mode: Property<Mode>

    @get:Input
    abstract val fileExtension: Property<String>

    @get:Input
    // We want on the granularity changes to run the task in non-incremental mode, since there will be a lot of changes anyway
    abstract val granularity: Property<KotlinJsIrOutputGranularity>

    @get:InputFile
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val configFile: RegularFileProperty

    @get:Incremental
    @get:InputDirectory
    @get:IgnoreEmptyDirectories
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val inputDirectory: DirectoryProperty

    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    @TaskAction
    protected fun exec(inputs: InputChanges) {
        val isIncremental = inputs.isIncremental

        val (filesToTranspile, deletedFiles) = if (isIncremental) {
            val (changedFiles, deletedFiles) = inputs.getFileChanges(inputDirectory)
                .filter { change -> change.file.extension.let { it in ModuleKind.allowedJsExtensions } }
                .partition { it.changeType == ChangeType.ADDED || it.changeType == ChangeType.MODIFIED }

            changedFiles.map { it.normalizedPath } to deletedFiles.flatMap {
                listOf(
                    outputDirectory.file(it.normalizedPath),
                    outputDirectory.file("${it.normalizedPath.substringBeforeLast(".")}.js.map")
                )
            }
        } else {
            listOf("./") to listOf(outputDirectory)
        }

        if (isIncremental) {
            logger.info("$path SWC incremental setup, re-compiling ${filesToTranspile.size} files, deleting ${deletedFiles.size} stale files")
        }

        if (deletedFiles.isNotEmpty()) {
            fs.delete { it.delete(deletedFiles) }
        }

        if (filesToTranspile.isNotEmpty()) {
            val args = SwcConfig.getArgumentsWhen(
                inputDirectoryOrFiles = filesToTranspile,
                outputDirectory = outputDirectory.get().asFile.absolutePath,
                configPath = configFile.get().asFile.absolutePath,
                fileExtension = fileExtension.get(),
                environmentCode = mode.get().code
            )

            execOps.exec { spec ->
                spec.executable = executable.get()
                spec.workingDir = inputDirectory.get().asFile
                spec.args = args
            }
        }

    }

    internal companion object {
        internal fun register(
            compilation: KotlinJsIrCompilation,
            name: String,
            generateSwcConfigTask: TaskProvider<GenerateSwcConfig>,
            configuration: SwcExec.() -> Unit = {},
        ): TaskProvider<SwcExec> {
            val target = compilation.target
            val project = target.project
            val swc = SwcPlugin.apply(project)

            val configFile = generateSwcConfigTask.flatMap(GenerateSwcConfig::configFile)
            val fileExtension = generateSwcConfigTask
                .flatMap(GenerateSwcConfig::moduleSystemToUse)
                .map { it.jsExtension.removePrefix(".") }

            return project.registerTask(name) {
                it.executable.set(swc.executable)
                it.configFile.set(configFile)
                it.fileExtension.set(fileExtension)

                it.dependsOn(with(swc) { project.swcSetupTaskProvider })
                it.configuration()
            }
        }
    }
}
