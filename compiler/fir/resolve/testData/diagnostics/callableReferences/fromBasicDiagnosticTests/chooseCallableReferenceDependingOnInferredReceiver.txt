FILE: chooseCallableReferenceDependingOnInferredReceiver.kt
    public final class A : R|kotlin/Any| {
        public constructor(): R|A| {
            super<R|kotlin/Any|>()
        }

        public final fun foo(i: R|A|): R|kotlin/Unit| {
        }

        public final fun baz(i: R|A|): R|kotlin/Unit| {
        }

    }
    public final class B : R|kotlin/Any| {
        public constructor(): R|B| {
            super<R|kotlin/Any|>()
        }

        public final fun foo(s: R|B|): R|kotlin/Unit| {
        }

        public final fun foo(c: R|kotlin/Char|): R|kotlin/Unit| {
        }

        public final fun baz(s: R|B|): R|kotlin/Unit| {
        }

    }
    public final fun <T> bar(f: R|kotlin/Function1<T, kotlin/Unit>|): R|T| {
        ^bar R|kotlin/TODO|()
    }
    public final fun test(): R|kotlin/Unit| {
        R|/myWith|<R|A|, R|kotlin/Unit|>(R|/A.A|(), <L> = myWith@fun <anonymous>(it: R|A|): R|kotlin/Unit| <kind=UNKNOWN>  {
            lval t1: <ERROR TYPE REF: Inapplicable(INAPPLICABLE): [/bar]> = <Inapplicable(INAPPLICABLE): [/bar]>#(::foo#)
            lval t2: <ERROR TYPE REF: Inapplicable(INAPPLICABLE): [/bar]> = <Inapplicable(INAPPLICABLE): [/bar]>#(::baz#)
            R|/myWith|<R|B|, R|kotlin/Unit|>(R|/B.B|(), <L> = myWith@fun <anonymous>(it: R|B|): R|kotlin/Unit| <kind=UNKNOWN>  {
                lval a: R|A| = <Inapplicable(INAPPLICABLE): [/bar]>#(::foo#)
                lval b: R|B| = <Inapplicable(INAPPLICABLE): [/bar]>#(::foo#)
                lval t3: <ERROR TYPE REF: Inapplicable(INAPPLICABLE): [/bar]> = <Inapplicable(INAPPLICABLE): [/bar]>#(::baz#)
                <Inapplicable(INAPPLICABLE): [/bar]>#(::foo#)
            }
            )
        }
        )
    }
    public final inline fun <T, R> myWith(receiver: R|T|, block: R|kotlin/Function1<T, R>|): R|R| {
        ^myWith R|kotlin/TODO|()
    }
