/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.parsing;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.JUnit3RunnerWithInners;
import org.jetbrains.kotlin.test.KotlinTestUtils;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.jetbrains.kotlin.test.TestMetadata;
import org.junit.runner.RunWith;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.test.generators.GenerateCompilerTestsKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@RunWith(JUnit3RunnerWithInners.class)
public class ParsingTestGenerated extends AbstractParsingTest {
  @TestMetadata("compiler/testData/psi")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Psi extends AbstractParsingTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
    }

    @TestMetadata("AbsentInnerType.kt")
    public void testAbsentInnerType() {
      runTest("compiler/testData/psi/AbsentInnerType.kt");
    }

    public void testAllFilesPresentInPsi() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi"), Pattern.compile("^(.*)\\.kts?$"), null, true);
    }

    @TestMetadata("AnnotatedIntersections.kt")
    public void testAnnotatedIntersections() {
      runTest("compiler/testData/psi/AnnotatedIntersections.kt");
    }

    @TestMetadata("AnonymousInitializer.kt")
    public void testAnonymousInitializer() {
      runTest("compiler/testData/psi/AnonymousInitializer.kt");
    }

    @TestMetadata("AssertNotNull.kt")
    public void testAssertNotNull() {
      runTest("compiler/testData/psi/AssertNotNull.kt");
    }

    @TestMetadata("BabySteps.kt")
    public void testBabySteps() {
      runTest("compiler/testData/psi/BabySteps.kt");
    }

    @TestMetadata("BabySteps_ERR.kt")
    public void testBabySteps_ERR() {
      runTest("compiler/testData/psi/BabySteps_ERR.kt");
    }

    @TestMetadata("BackslashInString.kt")
    public void testBackslashInString() {
      runTest("compiler/testData/psi/BackslashInString.kt");
    }

    @TestMetadata("BlockCommentAtBeginningOfFile1.kt")
    public void testBlockCommentAtBeginningOfFile1() {
      runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile1.kt");
    }

    @TestMetadata("BlockCommentAtBeginningOfFile2.kt")
    public void testBlockCommentAtBeginningOfFile2() {
      runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile2.kt");
    }

    @TestMetadata("BlockCommentAtBeginningOfFile3.kt")
    public void testBlockCommentAtBeginningOfFile3() {
      runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile3.kt");
    }

    @TestMetadata("BlockCommentAtBeginningOfFile4.kt")
    public void testBlockCommentAtBeginningOfFile4() {
      runTest("compiler/testData/psi/BlockCommentAtBeginningOfFile4.kt");
    }

    @TestMetadata("BlockCommentUnmatchedClosing_ERR.kt")
    public void testBlockCommentUnmatchedClosing_ERR() {
      runTest("compiler/testData/psi/BlockCommentUnmatchedClosing_ERR.kt");
    }

    @TestMetadata("ByClauses.kt")
    public void testByClauses() {
      runTest("compiler/testData/psi/ByClauses.kt");
    }

    @TestMetadata("CallWithManyClosures.kt")
    public void testCallWithManyClosures() {
      runTest("compiler/testData/psi/CallWithManyClosures.kt");
    }

    @TestMetadata("CallsInWhen.kt")
    public void testCallsInWhen() {
      runTest("compiler/testData/psi/CallsInWhen.kt");
    }

    @TestMetadata("CollectionLiterals.kt")
    public void testCollectionLiterals() {
      runTest("compiler/testData/psi/CollectionLiterals.kt");
    }

    @TestMetadata("CollectionLiterals_ERR.kt")
    public void testCollectionLiterals_ERR() {
      runTest("compiler/testData/psi/CollectionLiterals_ERR.kt");
    }

    @TestMetadata("CommentsBinding.kt")
    public void testCommentsBinding() {
      runTest("compiler/testData/psi/CommentsBinding.kt");
    }

    @TestMetadata("CommentsBindingInLambda.kt")
    public void testCommentsBindingInLambda() {
      runTest("compiler/testData/psi/CommentsBindingInLambda.kt");
    }

    @TestMetadata("CommentsBindingInStatementBlock.kt")
    public void testCommentsBindingInStatementBlock() {
      runTest("compiler/testData/psi/CommentsBindingInStatementBlock.kt");
    }

    @TestMetadata("complicateLTGT.kt")
    public void testComplicateLTGT() {
      runTest("compiler/testData/psi/complicateLTGT.kt");
    }

    @TestMetadata("complicateLTGTE.kt")
    public void testComplicateLTGTE() {
      runTest("compiler/testData/psi/complicateLTGTE.kt");
    }

    @TestMetadata("Constructors.kt")
    public void testConstructors() {
      runTest("compiler/testData/psi/Constructors.kt");
    }

    @TestMetadata("ControlStructures.kt")
    public void testControlStructures() {
      runTest("compiler/testData/psi/ControlStructures.kt");
    }

    @TestMetadata("DefaultKeyword.kt")
    public void testDefaultKeyword() {
      runTest("compiler/testData/psi/DefaultKeyword.kt");
    }

    @TestMetadata("DefinitelyNotNullType.kt")
    public void testDefinitelyNotNullType() {
      runTest("compiler/testData/psi/DefinitelyNotNullType.kt");
    }

    @TestMetadata("destructuringInLambdas.kt")
    public void testDestructuringInLambdas() {
      runTest("compiler/testData/psi/destructuringInLambdas.kt");
    }

    @TestMetadata("destructuringInLambdas_ERR.kt")
    public void testDestructuringInLambdas_ERR() {
      runTest("compiler/testData/psi/destructuringInLambdas_ERR.kt");
    }

    @TestMetadata("diagnosticTags_ERR.kt")
    public void testDiagnosticTags_ERR() {
      runTest("compiler/testData/psi/diagnosticTags_ERR.kt");
    }

    @TestMetadata("DocCommentAfterFileAnnotations.kt")
    public void testDocCommentAfterFileAnnotations() {
      runTest("compiler/testData/psi/DocCommentAfterFileAnnotations.kt");
    }

    @TestMetadata("DocCommentForFirstDeclaration.kt")
    public void testDocCommentForFirstDeclaration() {
      runTest("compiler/testData/psi/DocCommentForFirstDeclaration.kt");
    }

    @TestMetadata("DocCommentOnPackageDirectiveLine.kt")
    public void testDocCommentOnPackageDirectiveLine() {
      runTest("compiler/testData/psi/DocCommentOnPackageDirectiveLine.kt");
    }

    @TestMetadata("DocCommentsBinding.kt")
    public void testDocCommentsBinding() {
      runTest("compiler/testData/psi/DocCommentsBinding.kt");
    }

    @TestMetadata("DoubleColon.kt")
    public void testDoubleColon() {
      runTest("compiler/testData/psi/DoubleColon.kt");
    }

    @TestMetadata("DoubleColonWhitespaces.kt")
    public void testDoubleColonWhitespaces() {
      runTest("compiler/testData/psi/DoubleColonWhitespaces.kt");
    }

    @TestMetadata("DoubleColon_ERR.kt")
    public void testDoubleColon_ERR() {
      runTest("compiler/testData/psi/DoubleColon_ERR.kt");
    }

    @TestMetadata("DuplicateAccessor.kt")
    public void testDuplicateAccessor() {
      runTest("compiler/testData/psi/DuplicateAccessor.kt");
    }

    @TestMetadata("DynamicReceiver.kt")
    public void testDynamicReceiver() {
      runTest("compiler/testData/psi/DynamicReceiver.kt");
    }

    @TestMetadata("DynamicSoftKeyword.kt")
    public void testDynamicSoftKeyword() {
      runTest("compiler/testData/psi/DynamicSoftKeyword.kt");
    }

    @TestMetadata("DynamicTypes.kt")
    public void testDynamicTypes() {
      runTest("compiler/testData/psi/DynamicTypes.kt");
    }

    @TestMetadata("EOLsInComments.kt")
    public void testEOLsInComments() {
      runTest("compiler/testData/psi/EOLsInComments.kt");
    }

    @TestMetadata("EOLsOnRollback.kt")
    public void testEOLsOnRollback() {
      runTest("compiler/testData/psi/EOLsOnRollback.kt");
    }

    @TestMetadata("EmptyFile.kt")
    public void testEmptyFile() {
      runTest("compiler/testData/psi/EmptyFile.kt");
    }

    @TestMetadata("EmptyName.kt")
    public void testEmptyName() {
      runTest("compiler/testData/psi/EmptyName.kt");
    }

    @TestMetadata("EnumCommas.kt")
    public void testEnumCommas() {
      runTest("compiler/testData/psi/EnumCommas.kt");
    }

    @TestMetadata("EnumEntryCommaAnnotatedMember.kt")
    public void testEnumEntryCommaAnnotatedMember() {
      runTest("compiler/testData/psi/EnumEntryCommaAnnotatedMember.kt");
    }

    @TestMetadata("EnumEntryCommaInlineMember.kt")
    public void testEnumEntryCommaInlineMember() {
      runTest("compiler/testData/psi/EnumEntryCommaInlineMember.kt");
    }

    @TestMetadata("EnumEntryCommaMember.kt")
    public void testEnumEntryCommaMember() {
      runTest("compiler/testData/psi/EnumEntryCommaMember.kt");
    }

    @TestMetadata("EnumEntryCommaPublicMember.kt")
    public void testEnumEntryCommaPublicMember() {
      runTest("compiler/testData/psi/EnumEntryCommaPublicMember.kt");
    }

    @TestMetadata("EnumEntrySemicolonInlineMember.kt")
    public void testEnumEntrySemicolonInlineMember() {
      runTest("compiler/testData/psi/EnumEntrySemicolonInlineMember.kt");
    }

    @TestMetadata("EnumEntrySemicolonMember.kt")
    public void testEnumEntrySemicolonMember() {
      runTest("compiler/testData/psi/EnumEntrySemicolonMember.kt");
    }

    @TestMetadata("EnumEntrySpaceInlineMember.kt")
    public void testEnumEntrySpaceInlineMember() {
      runTest("compiler/testData/psi/EnumEntrySpaceInlineMember.kt");
    }

    @TestMetadata("EnumEntrySpaceMember.kt")
    public void testEnumEntrySpaceMember() {
      runTest("compiler/testData/psi/EnumEntrySpaceMember.kt");
    }

    @TestMetadata("EnumEntryTwoCommas.kt")
    public void testEnumEntryTwoCommas() {
      runTest("compiler/testData/psi/EnumEntryTwoCommas.kt");
    }

    @TestMetadata("EnumIn.kt")
    public void testEnumIn() {
      runTest("compiler/testData/psi/EnumIn.kt");
    }

    @TestMetadata("EnumInline.kt")
    public void testEnumInline() {
      runTest("compiler/testData/psi/EnumInline.kt");
    }

    @TestMetadata("EnumInlinePublic.kt")
    public void testEnumInlinePublic() {
      runTest("compiler/testData/psi/EnumInlinePublic.kt");
    }

    @TestMetadata("EnumMissingName.kt")
    public void testEnumMissingName() {
      runTest("compiler/testData/psi/EnumMissingName.kt");
    }

    @TestMetadata("EnumOldConstructorSyntax.kt")
    public void testEnumOldConstructorSyntax() {
      runTest("compiler/testData/psi/EnumOldConstructorSyntax.kt");
    }

    @TestMetadata("EnumShortCommas.kt")
    public void testEnumShortCommas() {
      runTest("compiler/testData/psi/EnumShortCommas.kt");
    }

    @TestMetadata("EnumShortWithOverload.kt")
    public void testEnumShortWithOverload() {
      runTest("compiler/testData/psi/EnumShortWithOverload.kt");
    }

    @TestMetadata("EnumWithAnnotationKeyword.kt")
    public void testEnumWithAnnotationKeyword() {
      runTest("compiler/testData/psi/EnumWithAnnotationKeyword.kt");
    }

    @TestMetadata("Enums.kt")
    public void testEnums() {
      runTest("compiler/testData/psi/Enums.kt");
    }

    @TestMetadata("Expressions_ERR.kt")
    public void testExpressions_ERR() {
      runTest("compiler/testData/psi/Expressions_ERR.kt");
    }

    @TestMetadata("ExtensionsWithQNReceiver.kt")
    public void testExtensionsWithQNReceiver() {
      runTest("compiler/testData/psi/ExtensionsWithQNReceiver.kt");
    }

    @TestMetadata("FileStart_ERR.kt")
    public void testFileStart_ERR() {
      runTest("compiler/testData/psi/FileStart_ERR.kt");
    }

    @TestMetadata("FloatingPointLiteral.kt")
    public void testFloatingPointLiteral() {
      runTest("compiler/testData/psi/FloatingPointLiteral.kt");
    }

    @TestMetadata("ForWithMultiDecl.kt")
    public void testForWithMultiDecl() {
      runTest("compiler/testData/psi/ForWithMultiDecl.kt");
    }

    @TestMetadata("FunctionCalls.kt")
    public void testFunctionCalls() {
      runTest("compiler/testData/psi/FunctionCalls.kt");
    }

    @TestMetadata("FunctionExpressions.kt")
    public void testFunctionExpressions() {
      runTest("compiler/testData/psi/FunctionExpressions.kt");
    }

    @TestMetadata("FunctionExpressions_ERR.kt")
    public void testFunctionExpressions_ERR() {
      runTest("compiler/testData/psi/FunctionExpressions_ERR.kt");
    }

    @TestMetadata("FunctionLiterals.kt")
    public void testFunctionLiterals() {
      runTest("compiler/testData/psi/FunctionLiterals.kt");
    }

    @TestMetadata("FunctionLiterals_ERR.kt")
    public void testFunctionLiterals_ERR() {
      runTest("compiler/testData/psi/FunctionLiterals_ERR.kt");
    }

    @TestMetadata("FunctionNoParameterList.kt")
    public void testFunctionNoParameterList() {
      runTest("compiler/testData/psi/FunctionNoParameterList.kt");
    }

    @TestMetadata("FunctionTypes.kt")
    public void testFunctionTypes() {
      runTest("compiler/testData/psi/FunctionTypes.kt");
    }

    @TestMetadata("Functions.kt")
    public void testFunctions() {
      runTest("compiler/testData/psi/Functions.kt");
    }

    @TestMetadata("FunctionsWithoutName.kt")
    public void testFunctionsWithoutName() {
      runTest("compiler/testData/psi/FunctionsWithoutName.kt");
    }

    @TestMetadata("FunctionsWithoutName_ERR.kt")
    public void testFunctionsWithoutName_ERR() {
      runTest("compiler/testData/psi/FunctionsWithoutName_ERR.kt");
    }

    @TestMetadata("Functions_ERR.kt")
    public void testFunctions_ERR() {
      runTest("compiler/testData/psi/Functions_ERR.kt");
    }

    @TestMetadata("HangOnLonelyModifier.kt")
    public void testHangOnLonelyModifier() {
      runTest("compiler/testData/psi/HangOnLonelyModifier.kt");
    }

    @TestMetadata("IfWithPropery.kt")
    public void testIfWithPropery() {
      runTest("compiler/testData/psi/IfWithPropery.kt");
    }

    @TestMetadata("ImportSoftKW.kt")
    public void testImportSoftKW() {
      runTest("compiler/testData/psi/ImportSoftKW.kt");
    }

    @TestMetadata("Imports.kt")
    public void testImports() {
      runTest("compiler/testData/psi/Imports.kt");
    }

    @TestMetadata("Imports_ERR.kt")
    public void testImports_ERR() {
      runTest("compiler/testData/psi/Imports_ERR.kt");
    }

    @TestMetadata("IncompleteFunctionLiteral.kt")
    public void testIncompleteFunctionLiteral() {
      runTest("compiler/testData/psi/IncompleteFunctionLiteral.kt");
    }

    @TestMetadata("incorrectLTGTFallback.kt")
    public void testIncorrectLTGTFallback() {
      runTest("compiler/testData/psi/incorrectLTGTFallback.kt");
    }

    @TestMetadata("Inner.kt")
    public void testInner() {
      runTest("compiler/testData/psi/Inner.kt");
    }

    @TestMetadata("IntegerLiteral.kt")
    public void testIntegerLiteral() {
      runTest("compiler/testData/psi/IntegerLiteral.kt");
    }

    @TestMetadata("Interface.kt")
    public void testInterface() {
      runTest("compiler/testData/psi/Interface.kt");
    }

    @TestMetadata("InterfaceWithEnumKeyword.kt")
    public void testInterfaceWithEnumKeyword() {
      runTest("compiler/testData/psi/InterfaceWithEnumKeyword.kt");
    }

    @TestMetadata("kotlinFunInterface_ERR.kt")
    public void testKotlinFunInterface_ERR() {
      runTest("compiler/testData/psi/kotlinFunInterface_ERR.kt");
    }

    @TestMetadata("Labels.kt")
    public void testLabels() {
      runTest("compiler/testData/psi/Labels.kt");
    }

    @TestMetadata("LineCommentAfterFileAnnotations.kt")
    public void testLineCommentAfterFileAnnotations() {
      runTest("compiler/testData/psi/LineCommentAfterFileAnnotations.kt");
    }

    @TestMetadata("LineCommentForFirstDeclaration.kt")
    public void testLineCommentForFirstDeclaration() {
      runTest("compiler/testData/psi/LineCommentForFirstDeclaration.kt");
    }

    @TestMetadata("LineCommentsInBlock.kt")
    public void testLineCommentsInBlock() {
      runTest("compiler/testData/psi/LineCommentsInBlock.kt");
    }

    @TestMetadata("LocalDeclarations.kt")
    public void testLocalDeclarations() {
      runTest("compiler/testData/psi/LocalDeclarations.kt");
    }

    @TestMetadata("LongPackageName.kt")
    public void testLongPackageName() {
      runTest("compiler/testData/psi/LongPackageName.kt");
    }

    @TestMetadata("ModifierAsSelector.kt")
    public void testModifierAsSelector() {
      runTest("compiler/testData/psi/ModifierAsSelector.kt");
    }

    @TestMetadata("MultiVariableDeclarations.kt")
    public void testMultiVariableDeclarations() {
      runTest("compiler/testData/psi/MultiVariableDeclarations.kt");
    }

    @TestMetadata("NamedClassObject.kt")
    public void testNamedClassObject() {
      runTest("compiler/testData/psi/NamedClassObject.kt");
    }

    @TestMetadata("namelessObjectAsEnumMember.kt")
    public void testNamelessObjectAsEnumMember() {
      runTest("compiler/testData/psi/namelessObjectAsEnumMember.kt");
    }

    @TestMetadata("NestedComments.kt")
    public void testNestedComments() {
      runTest("compiler/testData/psi/NestedComments.kt");
    }

    @TestMetadata("NewLinesValidOperations.kt")
    public void testNewLinesValidOperations() {
      runTest("compiler/testData/psi/NewLinesValidOperations.kt");
    }

    @TestMetadata("NewlinesInParentheses.kt")
    public void testNewlinesInParentheses() {
      runTest("compiler/testData/psi/NewlinesInParentheses.kt");
    }

    @TestMetadata("noCommaBetweenArguments.kt")
    public void testNoCommaBetweenArguments() {
      runTest("compiler/testData/psi/noCommaBetweenArguments.kt");
    }

    @TestMetadata("NonTypeBeforeDotInBaseClass.kt")
    public void testNonTypeBeforeDotInBaseClass() {
      runTest("compiler/testData/psi/NonTypeBeforeDotInBaseClass.kt");
    }

    @TestMetadata("NotIsAndNotIn.kt")
    public void testNotIsAndNotIn() {
      runTest("compiler/testData/psi/NotIsAndNotIn.kt");
    }

    @TestMetadata("ObjectLiteralAsStatement.kt")
    public void testObjectLiteralAsStatement() {
      runTest("compiler/testData/psi/ObjectLiteralAsStatement.kt");
    }

    @TestMetadata("ParameterNameMising.kt")
    public void testParameterNameMising() {
      runTest("compiler/testData/psi/ParameterNameMising.kt");
    }

    @TestMetadata("ParameterType.kt")
    public void testParameterType() {
      runTest("compiler/testData/psi/ParameterType.kt");
    }

    @TestMetadata("ParameterType_ERR.kt")
    public void testParameterType_ERR() {
      runTest("compiler/testData/psi/ParameterType_ERR.kt");
    }

    @TestMetadata("Precedence.kt")
    public void testPrecedence() {
      runTest("compiler/testData/psi/Precedence.kt");
    }

    @TestMetadata("PrimaryConstructorModifiers_ERR.kt")
    public void testPrimaryConstructorModifiers_ERR() {
      runTest("compiler/testData/psi/PrimaryConstructorModifiers_ERR.kt");
    }

    @TestMetadata("Properties.kt")
    public void testProperties() {
      runTest("compiler/testData/psi/Properties.kt");
    }

    @TestMetadata("PropertiesFollowedByInitializers.kt")
    public void testPropertiesFollowedByInitializers() {
      runTest("compiler/testData/psi/PropertiesFollowedByInitializers.kt");
    }

    @TestMetadata("Properties_ERR.kt")
    public void testProperties_ERR() {
      runTest("compiler/testData/psi/Properties_ERR.kt");
    }

    @TestMetadata("PropertyInvokes.kt")
    public void testPropertyInvokes() {
      runTest("compiler/testData/psi/PropertyInvokes.kt");
    }

    @TestMetadata("QuotedIdentifiers.kt")
    public void testQuotedIdentifiers() {
      runTest("compiler/testData/psi/QuotedIdentifiers.kt");
    }

    @TestMetadata("Reserved.kt")
    public void testReserved() {
      runTest("compiler/testData/psi/Reserved.kt");
    }

    @TestMetadata("SemicolonAfterIf.kt")
    public void testSemicolonAfterIf() {
      runTest("compiler/testData/psi/SemicolonAfterIf.kt");
    }

    @TestMetadata("semicolonBetweenDeclarations.kt")
    public void testSemicolonBetweenDeclarations() {
      runTest("compiler/testData/psi/semicolonBetweenDeclarations.kt");
    }

    @TestMetadata("SimpleClassMembers.kt")
    public void testSimpleClassMembers() {
      runTest("compiler/testData/psi/SimpleClassMembers.kt");
    }

    @TestMetadata("SimpleClassMembers_ERR.kt")
    public void testSimpleClassMembers_ERR() {
      runTest("compiler/testData/psi/SimpleClassMembers_ERR.kt");
    }

    @TestMetadata("SimpleExpressions.kt")
    public void testSimpleExpressions() {
      runTest("compiler/testData/psi/SimpleExpressions.kt");
    }

    @TestMetadata("SimpleIntersections.kt")
    public void testSimpleIntersections() {
      runTest("compiler/testData/psi/SimpleIntersections.kt");
    }

    @TestMetadata("SimpleModifiers.kt")
    public void testSimpleModifiers() {
      runTest("compiler/testData/psi/SimpleModifiers.kt");
    }

    @TestMetadata("SoftKeywords.kt")
    public void testSoftKeywords() {
      runTest("compiler/testData/psi/SoftKeywords.kt");
    }

    @TestMetadata("SoftKeywordsInTypeArguments.kt")
    public void testSoftKeywordsInTypeArguments() {
      runTest("compiler/testData/psi/SoftKeywordsInTypeArguments.kt");
    }

    @TestMetadata("StringTemplates.kt")
    public void testStringTemplates() {
      runTest("compiler/testData/psi/StringTemplates.kt");
    }

    @TestMetadata("Super.kt")
    public void testSuper() {
      runTest("compiler/testData/psi/Super.kt");
    }

    @TestMetadata("trailingCommaAllowed.kt")
    public void testTrailingCommaAllowed() {
      runTest("compiler/testData/psi/trailingCommaAllowed.kt");
    }

    @TestMetadata("trailingCommaForbidden.kt")
    public void testTrailingCommaForbidden() {
      runTest("compiler/testData/psi/trailingCommaForbidden.kt");
    }

    @TestMetadata("TraitConstructor.kt")
    public void testTraitConstructor() {
      runTest("compiler/testData/psi/TraitConstructor.kt");
    }

    @TestMetadata("TripleDot.kt")
    public void testTripleDot() {
      runTest("compiler/testData/psi/TripleDot.kt");
    }

    @TestMetadata("TryRecovery.kt")
    public void testTryRecovery() {
      runTest("compiler/testData/psi/TryRecovery.kt");
    }

    @TestMetadata("TypeAlias.kt")
    public void testTypeAlias() {
      runTest("compiler/testData/psi/TypeAlias.kt");
    }

    @TestMetadata("TypeAlias_ERR.kt")
    public void testTypeAlias_ERR() {
      runTest("compiler/testData/psi/TypeAlias_ERR.kt");
    }

    @TestMetadata("TypeConstraints.kt")
    public void testTypeConstraints() {
      runTest("compiler/testData/psi/TypeConstraints.kt");
    }

    @TestMetadata("TypeExpressionAmbiguities_ERR.kt")
    public void testTypeExpressionAmbiguities_ERR() {
      runTest("compiler/testData/psi/TypeExpressionAmbiguities_ERR.kt");
    }

    @TestMetadata("TypeModifiers.kt")
    public void testTypeModifiers() {
      runTest("compiler/testData/psi/TypeModifiers.kt");
    }

    @TestMetadata("TypeModifiersParenthesized.kt")
    public void testTypeModifiersParenthesized() {
      runTest("compiler/testData/psi/TypeModifiersParenthesized.kt");
    }

    @TestMetadata("TypeModifiers_ERR.kt")
    public void testTypeModifiers_ERR() {
      runTest("compiler/testData/psi/TypeModifiers_ERR.kt");
    }

    @TestMetadata("TypeParametersBeforeName.kt")
    public void testTypeParametersBeforeName() {
      runTest("compiler/testData/psi/TypeParametersBeforeName.kt");
    }

    @TestMetadata("TypealiasIsKeyword.kt")
    public void testTypealiasIsKeyword() {
      runTest("compiler/testData/psi/TypealiasIsKeyword.kt");
    }

    @TestMetadata("UnderscoredTypeArgumentsOfCall.kt")
    public void testUnderscoredTypeArgumentsOfCall() {
      runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfCall.kt");
    }

    @TestMetadata("UnderscoredTypeArgumentsOfCallIllegal.kt")
    public void testUnderscoredTypeArgumentsOfCallIllegal() {
      runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfCallIllegal.kt");
    }

    @TestMetadata("UnderscoredTypeArgumentsOfType.kt")
    public void testUnderscoredTypeArgumentsOfType() {
      runTest("compiler/testData/psi/UnderscoredTypeArgumentsOfType.kt");
    }

    @TestMetadata("UnderscoredTypeParameters.kt")
    public void testUnderscoredTypeParameters() {
      runTest("compiler/testData/psi/UnderscoredTypeParameters.kt");
    }

    @TestMetadata("UnsignedLiteral.kt")
    public void testUnsignedLiteral() {
      runTest("compiler/testData/psi/UnsignedLiteral.kt");
    }

    @TestMetadata("validKotlinFunInterface.kt")
    public void testValidKotlinFunInterface() {
      runTest("compiler/testData/psi/validKotlinFunInterface.kt");
    }

    @TestMetadata("valueClass.kt")
    public void testValueClass() {
      runTest("compiler/testData/psi/valueClass.kt");
    }

    @TestMetadata("When.kt")
    public void testWhen() {
      runTest("compiler/testData/psi/When.kt");
    }

    @TestMetadata("WhenWithSubjectVariable.kt")
    public void testWhenWithSubjectVariable() {
      runTest("compiler/testData/psi/WhenWithSubjectVariable.kt");
    }

    @TestMetadata("WhenWithSubjectVariable_ERR.kt")
    public void testWhenWithSubjectVariable_ERR() {
      runTest("compiler/testData/psi/WhenWithSubjectVariable_ERR.kt");
    }

    @TestMetadata("WhenWithSubjectVariable_SoftModifierName.kt")
    public void testWhenWithSubjectVariable_SoftModifierName() {
      runTest("compiler/testData/psi/WhenWithSubjectVariable_SoftModifierName.kt");
    }

    @TestMetadata("When_ERR.kt")
    public void testWhen_ERR() {
      runTest("compiler/testData/psi/When_ERR.kt");
    }

    @TestMetadata("compiler/testData/psi/annotation")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Annotation extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInAnnotation() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("AnnotatedExpressions.kt")
      public void testAnnotatedExpressions() {
        runTest("compiler/testData/psi/annotation/AnnotatedExpressions.kt");
      }

      @TestMetadata("Annotations.kt")
      public void testAnnotations() {
        runTest("compiler/testData/psi/annotation/Annotations.kt");
      }

      @TestMetadata("annotationsOnNullableTypes.kt")
      public void testAnnotationsOnNullableTypes() {
        runTest("compiler/testData/psi/annotation/annotationsOnNullableTypes.kt");
      }

      @TestMetadata("annotationsOnParenthesizedTypes.kt")
      public void testAnnotationsOnParenthesizedTypes() {
        runTest("compiler/testData/psi/annotation/annotationsOnParenthesizedTypes.kt");
      }

      @TestMetadata("AnnotationsOnPatterns.kt")
      public void testAnnotationsOnPatterns() {
        runTest("compiler/testData/psi/annotation/AnnotationsOnPatterns.kt");
      }

      @TestMetadata("Annotations_ERR.kt")
      public void testAnnotations_ERR() {
        runTest("compiler/testData/psi/annotation/Annotations_ERR.kt");
      }

      @TestMetadata("forParameters.kt")
      public void testForParameters() {
        runTest("compiler/testData/psi/annotation/forParameters.kt");
      }

      @TestMetadata("lambda.kt")
      public void testLambda() {
        runTest("compiler/testData/psi/annotation/lambda.kt");
      }

      @TestMetadata("lambdaRecovery.kt")
      public void testLambdaRecovery() {
        runTest("compiler/testData/psi/annotation/lambdaRecovery.kt");
      }

      @TestMetadata("multiDeclaration.kt")
      public void testMultiDeclaration() {
        runTest("compiler/testData/psi/annotation/multiDeclaration.kt");
      }

      @TestMetadata("noParameterYet.kt")
      public void testNoParameterYet() {
        runTest("compiler/testData/psi/annotation/noParameterYet.kt");
      }

      @TestMetadata("oldAnnotationsRecovery.kt")
      public void testOldAnnotationsRecovery() {
        runTest("compiler/testData/psi/annotation/oldAnnotationsRecovery.kt");
      }

      @TestMetadata("ShortAnnotations.kt")
      public void testShortAnnotations() {
        runTest("compiler/testData/psi/annotation/ShortAnnotations.kt");
      }

      @TestMetadata("compiler/testData/psi/annotation/at")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class At extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInAt() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/at"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("annotationAtFileStart.kt")
        public void testAnnotationAtFileStart() {
          runTest("compiler/testData/psi/annotation/at/annotationAtFileStart.kt");
        }

        @TestMetadata("annotationValueArgumentsAmbiguity.kt")
        public void testAnnotationValueArgumentsAmbiguity() {
          runTest("compiler/testData/psi/annotation/at/annotationValueArgumentsAmbiguity.kt");
        }

        @TestMetadata("blockLevelExpressions.kt")
        public void testBlockLevelExpressions() {
          runTest("compiler/testData/psi/annotation/at/blockLevelExpressions.kt");
        }

        @TestMetadata("blockLevelExpressionsNoNewLine.kt")
        public void testBlockLevelExpressionsNoNewLine() {
          runTest("compiler/testData/psi/annotation/at/blockLevelExpressionsNoNewLine.kt");
        }

        @TestMetadata("danglingBlockLevelAnnotations.kt")
        public void testDanglingBlockLevelAnnotations() {
          runTest("compiler/testData/psi/annotation/at/danglingBlockLevelAnnotations.kt");
        }

        @TestMetadata("declarationsJustAtTyped.kt")
        public void testDeclarationsJustAtTyped() {
          runTest("compiler/testData/psi/annotation/at/declarationsJustAtTyped.kt");
        }

        @TestMetadata("enumEntries.kt")
        public void testEnumEntries() {
          runTest("compiler/testData/psi/annotation/at/enumEntries.kt");
        }

        @TestMetadata("expressionJustAtTyped.kt")
        public void testExpressionJustAtTyped() {
          runTest("compiler/testData/psi/annotation/at/expressionJustAtTyped.kt");
        }

        @TestMetadata("kt21055.kt")
        public void testKt21055() {
          runTest("compiler/testData/psi/annotation/at/kt21055.kt");
        }

        @TestMetadata("modifierAtFileStart.kt")
        public void testModifierAtFileStart() {
          runTest("compiler/testData/psi/annotation/at/modifierAtFileStart.kt");
        }

        @TestMetadata("primaryConstructor.kt")
        public void testPrimaryConstructor() {
          runTest("compiler/testData/psi/annotation/at/primaryConstructor.kt");
        }

        @TestMetadata("recoveryWhitespaceBeforeColon.kt")
        public void testRecoveryWhitespaceBeforeColon() {
          runTest("compiler/testData/psi/annotation/at/recoveryWhitespaceBeforeColon.kt");
        }

        @TestMetadata("recoveryWhitespaceBeforeColon_ERR.kt")
        public void testRecoveryWhitespaceBeforeColon_ERR() {
          runTest("compiler/testData/psi/annotation/at/recoveryWhitespaceBeforeColon_ERR.kt");
        }

        @TestMetadata("validDeclarations.kt")
        public void testValidDeclarations() {
          runTest("compiler/testData/psi/annotation/at/validDeclarations.kt");
        }

        @TestMetadata("validExpressions.kt")
        public void testValidExpressions() {
          runTest("compiler/testData/psi/annotation/at/validExpressions.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/annotation/functionalTypes")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class FunctionalTypes extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInFunctionalTypes() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class RegressionForSimilarSyntax extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInRegressionForSimilarSyntax() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("forDestructuring.kt")
          public void testForDestructuring() {
            runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/forDestructuring.kt");
          }

          @TestMetadata("lambdaParameterDeclaration.kt")
          public void testLambdaParameterDeclaration() {
            runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/lambdaParameterDeclaration.kt");
          }

          @TestMetadata("variableDestructuring.kt")
          public void testVariableDestructuring() {
            runTest("compiler/testData/psi/annotation/functionalTypes/regressionForSimilarSyntax/variableDestructuring.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withParentheses")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class WithParentheses extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInWithParentheses() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withParentheses"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("withParameter.kt")
          public void testWithParameter() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withParentheses/withParameter.kt");
          }

          @TestMetadata("withoutParameter.kt")
          public void testWithoutParameter() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withParentheses/withoutParameter.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/annotation/functionalTypes/withoutParentheses")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class WithoutParentheses extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInWithoutParentheses() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/functionalTypes/withoutParentheses"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("annotationList.kt")
          public void testAnnotationList() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/annotationList.kt");
          }

          @TestMetadata("withParameter.kt")
          public void testWithParameter() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withParameter.kt");
          }

          @TestMetadata("withReveiver.kt")
          public void testWithReveiver() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withReveiver.kt");
          }

          @TestMetadata("withoutParameter.kt")
          public void testWithoutParameter() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withoutParameter.kt");
          }

          @TestMetadata("withoutParameterOnSuspend.kt")
          public void testWithoutParameterOnSuspend() {
            runTest("compiler/testData/psi/annotation/functionalTypes/withoutParentheses/withoutParameterOnSuspend.kt");
          }
        }
      }

      @TestMetadata("compiler/testData/psi/annotation/list")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class List extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInList() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/list"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("basic.kt")
        public void testBasic() {
          runTest("compiler/testData/psi/annotation/list/basic.kt");
        }

        @TestMetadata("recovery.kt")
        public void testRecovery() {
          runTest("compiler/testData/psi/annotation/list/recovery.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/annotation/modifiersMigration")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class ModifiersMigration extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInModifiersMigration() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/modifiersMigration"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("newModifiers.kt")
        public void testNewModifiers() {
          runTest("compiler/testData/psi/annotation/modifiersMigration/newModifiers.kt");
        }

        @TestMetadata("oldUsages.kt")
        public void testOldUsages() {
          runTest("compiler/testData/psi/annotation/modifiersMigration/oldUsages.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/annotation/options")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Options extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInOptions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/options"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("annotationAsArg.kt")
        public void testAnnotationAsArg() {
          runTest("compiler/testData/psi/annotation/options/annotationAsArg.kt");
        }

        @TestMetadata("annotationAsArgComplex.kt")
        public void testAnnotationAsArgComplex() {
          runTest("compiler/testData/psi/annotation/options/annotationAsArgComplex.kt");
        }

        @TestMetadata("java.kt")
        public void testJava() {
          runTest("compiler/testData/psi/annotation/options/java.kt");
        }

        @TestMetadata("local.kt")
        public void testLocal() {
          runTest("compiler/testData/psi/annotation/options/local.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/annotation/targeted")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Targeted extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInTargeted() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("compiler/testData/psi/annotation/targeted/onField")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class OnField extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInOnField() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onField"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("delegate.kt")
          public void testDelegate() {
            runTest("compiler/testData/psi/annotation/targeted/onField/delegate.kt");
          }

          @TestMetadata("fqName.kt")
          public void testFqName() {
            runTest("compiler/testData/psi/annotation/targeted/onField/fqName.kt");
          }

          @TestMetadata("inWrongPlace.kt")
          public void testInWrongPlace() {
            runTest("compiler/testData/psi/annotation/targeted/onField/inWrongPlace.kt");
          }

          @TestMetadata("manyInOneAnnotationBlock.kt")
          public void testManyInOneAnnotationBlock() {
            runTest("compiler/testData/psi/annotation/targeted/onField/manyInOneAnnotationBlock.kt");
          }

          @TestMetadata("simpleFieldAnnotation.kt")
          public void testSimpleFieldAnnotation() {
            runTest("compiler/testData/psi/annotation/targeted/onField/simpleFieldAnnotation.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/annotation/targeted/onFile")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class OnFile extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInOnFile() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onFile"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("fileAnnotationInWrongPlace.kt")
          public void testFileAnnotationInWrongPlace() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/fileAnnotationInWrongPlace.kt");
          }

          @TestMetadata("manyAnnotationBlocks.kt")
          public void testManyAnnotationBlocks() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/manyAnnotationBlocks.kt");
          }

          @TestMetadata("manyInOneAnnotationBlock.kt")
          public void testManyInOneAnnotationBlock() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/manyInOneAnnotationBlock.kt");
          }

          @TestMetadata("nonFIleAnnotationBeforePackage.kt")
          public void testNonFIleAnnotationBeforePackage() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/nonFIleAnnotationBeforePackage.kt");
          }

          @TestMetadata("single.kt")
          public void testSingle() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/single.kt");
          }

          @TestMetadata("withoutFileAnnotationAndPackageDeclaration.kt")
          public void testWithoutFileAnnotationAndPackageDeclaration() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/withoutFileAnnotationAndPackageDeclaration.kt");
          }

          @TestMetadata("withoutPackage.kt")
          public void testWithoutPackage() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/withoutPackage.kt");
          }

          @TestMetadata("withoutPackageWithSimpleAnnotation.kt")
          public void testWithoutPackageWithSimpleAnnotation() {
            runTest("compiler/testData/psi/annotation/targeted/onFile/withoutPackageWithSimpleAnnotation.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/annotation/targeted/onGetSetSparam")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class OnGetSetSparam extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInOnGetSetSparam() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onGetSetSparam"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("inWrongPlace.kt")
          public void testInWrongPlace() {
            runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/inWrongPlace.kt");
          }

          @TestMetadata("simple.kt")
          public void testSimple() {
            runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/simple.kt");
          }

          @TestMetadata("twoAnnotationLists.kt")
          public void testTwoAnnotationLists() {
            runTest("compiler/testData/psi/annotation/targeted/onGetSetSparam/twoAnnotationLists.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/annotation/targeted/onParam")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class OnParam extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInOnParam() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/annotation/targeted/onParam"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("modifiers.kt")
          public void testModifiers() {
            runTest("compiler/testData/psi/annotation/targeted/onParam/modifiers.kt");
          }

          @TestMetadata("recovery.kt")
          public void testRecovery() {
            runTest("compiler/testData/psi/annotation/targeted/onParam/recovery.kt");
          }

          @TestMetadata("simple.kt")
          public void testSimple() {
            runTest("compiler/testData/psi/annotation/targeted/onParam/simple.kt");
          }

          @TestMetadata("targetExpected.kt")
          public void testTargetExpected() {
            runTest("compiler/testData/psi/annotation/targeted/onParam/targetExpected.kt");
          }
        }
      }
    }

    @TestMetadata("compiler/testData/psi/contracts")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Contracts extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInContracts() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/contracts"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("FunctionWithMultilineContract.kt")
      public void testFunctionWithMultilineContract() {
        runTest("compiler/testData/psi/contracts/FunctionWithMultilineContract.kt");
      }

      @TestMetadata("FunctionsWithTypeConstraintsAndContract.kt")
      public void testFunctionsWithTypeConstraintsAndContract() {
        runTest("compiler/testData/psi/contracts/FunctionsWithTypeConstraintsAndContract.kt");
      }

      @TestMetadata("PropertyAccessorsContracts.kt")
      public void testPropertyAccessorsContracts() {
        runTest("compiler/testData/psi/contracts/PropertyAccessorsContracts.kt");
      }

      @TestMetadata("SimpleFunctionWithContract.kt")
      public void testSimpleFunctionWithContract() {
        runTest("compiler/testData/psi/contracts/SimpleFunctionWithContract.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/examples")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Examples extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInExamples() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("AnonymousObjects.kt")
      public void testAnonymousObjects() {
        runTest("compiler/testData/psi/examples/AnonymousObjects.kt");
      }

      @TestMetadata("BinaryTree.kt")
      public void testBinaryTree() {
        runTest("compiler/testData/psi/examples/BinaryTree.kt");
      }

      @TestMetadata("BitArith.kt")
      public void testBitArith() {
        runTest("compiler/testData/psi/examples/BitArith.kt");
      }

      @TestMetadata("Builder.kt")
      public void testBuilder() {
        runTest("compiler/testData/psi/examples/Builder.kt");
      }

      @TestMetadata("Color.kt")
      public void testColor() {
        runTest("compiler/testData/psi/examples/Color.kt");
      }

      @TestMetadata("FunctionsAndTypes.kt")
      public void testFunctionsAndTypes() {
        runTest("compiler/testData/psi/examples/FunctionsAndTypes.kt");
      }

      @TestMetadata("Graph.kt")
      public void testGraph() {
        runTest("compiler/testData/psi/examples/Graph.kt");
      }

      @TestMetadata("IPushPop.kt")
      public void testIPushPop() {
        runTest("compiler/testData/psi/examples/IPushPop.kt");
      }

      @TestMetadata("LINQ.kt")
      public void testLINQ() {
        runTest("compiler/testData/psi/examples/LINQ.kt");
      }

      @TestMetadata("Queue.kt")
      public void testQueue() {
        runTest("compiler/testData/psi/examples/Queue.kt");
      }

      @TestMetadata("Stack.kt")
      public void testStack() {
        runTest("compiler/testData/psi/examples/Stack.kt");
      }

      @TestMetadata("UnionFind.kt")
      public void testUnionFind() {
        runTest("compiler/testData/psi/examples/UnionFind.kt");
      }

      @TestMetadata("UpdateOperation.kt")
      public void testUpdateOperation() {
        runTest("compiler/testData/psi/examples/UpdateOperation.kt");
      }

      @TestMetadata("With.kt")
      public void testWith() {
        runTest("compiler/testData/psi/examples/With.kt");
      }

      @TestMetadata("compiler/testData/psi/examples/array")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Array extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInArray() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/array"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("MutableArray.kt")
        public void testMutableArray() {
          runTest("compiler/testData/psi/examples/array/MutableArray.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/examples/collections")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Collections extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInCollections() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/collections"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("ArrayList.kt")
        public void testArrayList() {
          runTest("compiler/testData/psi/examples/collections/ArrayList.kt");
        }

        @TestMetadata("HashMap.kt")
        public void testHashMap() {
          runTest("compiler/testData/psi/examples/collections/HashMap.kt");
        }

        @TestMetadata("IIterable.kt")
        public void testIIterable() {
          runTest("compiler/testData/psi/examples/collections/IIterable.kt");
        }

        @TestMetadata("IIterator.kt")
        public void testIIterator() {
          runTest("compiler/testData/psi/examples/collections/IIterator.kt");
        }

        @TestMetadata("IList.kt")
        public void testIList() {
          runTest("compiler/testData/psi/examples/collections/IList.kt");
        }

        @TestMetadata("IMutableIterable.kt")
        public void testIMutableIterable() {
          runTest("compiler/testData/psi/examples/collections/IMutableIterable.kt");
        }

        @TestMetadata("IMutableIterator.kt")
        public void testIMutableIterator() {
          runTest("compiler/testData/psi/examples/collections/IMutableIterator.kt");
        }

        @TestMetadata("IMutableList.kt")
        public void testIMutableList() {
          runTest("compiler/testData/psi/examples/collections/IMutableList.kt");
        }

        @TestMetadata("IMutableSet.kt")
        public void testIMutableSet() {
          runTest("compiler/testData/psi/examples/collections/IMutableSet.kt");
        }

        @TestMetadata("ISet.kt")
        public void testISet() {
          runTest("compiler/testData/psi/examples/collections/ISet.kt");
        }

        @TestMetadata("ISized.kt")
        public void testISized() {
          runTest("compiler/testData/psi/examples/collections/ISized.kt");
        }

        @TestMetadata("LinkedList.kt")
        public void testLinkedList() {
          runTest("compiler/testData/psi/examples/collections/LinkedList.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/examples/io")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Io extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInIo() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/io"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("IOSamples.kt")
        public void testIOSamples() {
          runTest("compiler/testData/psi/examples/io/IOSamples.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/examples/map")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Map extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInMap() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/map"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("IMap.kt")
        public void testIMap() {
          runTest("compiler/testData/psi/examples/map/IMap.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/examples/priorityqueues")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Priorityqueues extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInPriorityqueues() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/priorityqueues"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("BinaryHeap.kt")
        public void testBinaryHeap() {
          runTest("compiler/testData/psi/examples/priorityqueues/BinaryHeap.kt");
        }

        @TestMetadata("IPriorityQueue.kt")
        public void testIPriorityQueue() {
          runTest("compiler/testData/psi/examples/priorityqueues/IPriorityQueue.kt");
        }

        @TestMetadata("PriorityQueueAsPushPop.kt")
        public void testPriorityQueueAsPushPop() {
          runTest("compiler/testData/psi/examples/priorityqueues/PriorityQueueAsPushPop.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/examples/util")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Util extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInUtil() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/examples/util"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("Comparison.kt")
        public void testComparison() {
          runTest("compiler/testData/psi/examples/util/Comparison.kt");
        }

        @TestMetadata("IComparable.kt")
        public void testIComparable() {
          runTest("compiler/testData/psi/examples/util/IComparable.kt");
        }
      }
    }

    @TestMetadata("compiler/testData/psi/functionReceivers")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class FunctionReceivers extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInFunctionReceivers() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/functionReceivers"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("FunctionTypesWithFunctionReceivers.kt")
      public void testFunctionTypesWithFunctionReceivers() {
        runTest("compiler/testData/psi/functionReceivers/FunctionTypesWithFunctionReceivers.kt");
      }

      @TestMetadata("FunctionsWithFunctionReceivers.kt")
      public void testFunctionsWithFunctionReceivers() {
        runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceivers.kt");
      }

      @TestMetadata("FunctionsWithFunctionReceiversAnnotations.kt")
      public void testFunctionsWithFunctionReceiversAnnotations() {
        runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceiversAnnotations.kt");
      }

      @TestMetadata("FunctionsWithFunctionReceiversRecovery.kt")
      public void testFunctionsWithFunctionReceiversRecovery() {
        runTest("compiler/testData/psi/functionReceivers/FunctionsWithFunctionReceiversRecovery.kt");
      }

      @TestMetadata("PropertiesWithFunctionReceivers.kt")
      public void testPropertiesWithFunctionReceivers() {
        runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceivers.kt");
      }

      @TestMetadata("PropertiesWithFunctionReceiversAnnotations.kt")
      public void testPropertiesWithFunctionReceiversAnnotations() {
        runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceiversAnnotations.kt");
      }

      @TestMetadata("PropertiesWithFunctionReceiversRecovery.kt")
      public void testPropertiesWithFunctionReceiversRecovery() {
        runTest("compiler/testData/psi/functionReceivers/PropertiesWithFunctionReceiversRecovery.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/greatSyntacticShift")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class GreatSyntacticShift extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInGreatSyntacticShift() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/greatSyntacticShift"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("functionLiterals.kt")
      public void testFunctionLiterals() {
        runTest("compiler/testData/psi/greatSyntacticShift/functionLiterals.kt");
      }

      @TestMetadata("functionTypes.kt")
      public void testFunctionTypes() {
        runTest("compiler/testData/psi/greatSyntacticShift/functionTypes.kt");
      }

      @TestMetadata("FunctionTypesAsArguments.kt")
      public void testFunctionTypesAsArguments() {
        runTest("compiler/testData/psi/greatSyntacticShift/FunctionTypesAsArguments.kt");
      }

      @TestMetadata("nullableTypes.kt")
      public void testNullableTypes() {
        runTest("compiler/testData/psi/greatSyntacticShift/nullableTypes.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/kdoc")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Kdoc extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInKdoc() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/kdoc"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("AtTags.kt")
      public void testAtTags() {
        runTest("compiler/testData/psi/kdoc/AtTags.kt");
      }

      @TestMetadata("DocCommentAtBeginningOfFile1.kt")
      public void testDocCommentAtBeginningOfFile1() {
        runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile1.kt");
      }

      @TestMetadata("DocCommentAtBeginningOfFile2.kt")
      public void testDocCommentAtBeginningOfFile2() {
        runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile2.kt");
      }

      @TestMetadata("DocCommentAtBeginningOfFile3.kt")
      public void testDocCommentAtBeginningOfFile3() {
        runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile3.kt");
      }

      @TestMetadata("DocCommentAtBeginningOfFile4.kt")
      public void testDocCommentAtBeginningOfFile4() {
        runTest("compiler/testData/psi/kdoc/DocCommentAtBeginningOfFile4.kt");
      }

      @TestMetadata("EndOnLeadingAsterisks.kt")
      public void testEndOnLeadingAsterisks() {
        runTest("compiler/testData/psi/kdoc/EndOnLeadingAsterisks.kt");
      }

      @TestMetadata("EndRightAfterText.kt")
      public void testEndRightAfterText() {
        runTest("compiler/testData/psi/kdoc/EndRightAfterText.kt");
      }

      @TestMetadata("HttpLink.kt")
      public void testHttpLink() {
        runTest("compiler/testData/psi/kdoc/HttpLink.kt");
      }

      @TestMetadata("Incomplete.kt")
      public void testIncomplete() {
        runTest("compiler/testData/psi/kdoc/Incomplete.kt");
      }

      @TestMetadata("Markdown.kt")
      public void testMarkdown() {
        runTest("compiler/testData/psi/kdoc/Markdown.kt");
      }

      @TestMetadata("MarkdownLinkWithError.kt")
      public void testMarkdownLinkWithError() {
        runTest("compiler/testData/psi/kdoc/MarkdownLinkWithError.kt");
      }

      @TestMetadata("MarkdownLinkWithLabel.kt")
      public void testMarkdownLinkWithLabel() {
        runTest("compiler/testData/psi/kdoc/MarkdownLinkWithLabel.kt");
      }

      @TestMetadata("MarkdownQualifiedName.kt")
      public void testMarkdownQualifiedName() {
        runTest("compiler/testData/psi/kdoc/MarkdownQualifiedName.kt");
      }

      @TestMetadata("ParamTag.kt")
      public void testParamTag() {
        runTest("compiler/testData/psi/kdoc/ParamTag.kt");
      }

      @TestMetadata("ParamTagAtStart.kt")
      public void testParamTagAtStart() {
        runTest("compiler/testData/psi/kdoc/ParamTagAtStart.kt");
      }

      @TestMetadata("ReturnWithBrackets.kt")
      public void testReturnWithBrackets() {
        runTest("compiler/testData/psi/kdoc/ReturnWithBrackets.kt");
      }

      @TestMetadata("Sections.kt")
      public void testSections() {
        runTest("compiler/testData/psi/kdoc/Sections.kt");
      }

      @TestMetadata("SeeEmpty.kt")
      public void testSeeEmpty() {
        runTest("compiler/testData/psi/kdoc/SeeEmpty.kt");
      }

      @TestMetadata("SeeLink.kt")
      public void testSeeLink() {
        runTest("compiler/testData/psi/kdoc/SeeLink.kt");
      }

      @TestMetadata("Simple.kt")
      public void testSimple() {
        runTest("compiler/testData/psi/kdoc/Simple.kt");
      }

      @TestMetadata("TextRightAfterLeadAsterisks.kt")
      public void testTextRightAfterLeadAsterisks() {
        runTest("compiler/testData/psi/kdoc/TextRightAfterLeadAsterisks.kt");
      }

      @TestMetadata("TwoTags.kt")
      public void testTwoTags() {
        runTest("compiler/testData/psi/kdoc/TwoTags.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/newLabels")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class NewLabels extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInNewLabels() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/newLabels"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("basic.kt")
      public void testBasic() {
        runTest("compiler/testData/psi/newLabels/basic.kt");
      }

      @TestMetadata("oldSyntaxExpressions.kt")
      public void testOldSyntaxExpressions() {
        runTest("compiler/testData/psi/newLabels/oldSyntaxExpressions.kt");
      }

      @TestMetadata("recovery.kt")
      public void testRecovery() {
        runTest("compiler/testData/psi/newLabels/recovery.kt");
      }

      @TestMetadata("spaceBeforeLabelReference.kt")
      public void testSpaceBeforeLabelReference() {
        runTest("compiler/testData/psi/newLabels/spaceBeforeLabelReference.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/operators")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Operators extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInOperators() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/operators"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("untilOperator.kt")
      public void testUntilOperator() {
        runTest("compiler/testData/psi/operators/untilOperator.kt");
      }

      @TestMetadata("untilOperatorDifferentContexts.kt")
      public void testUntilOperatorDifferentContexts() {
        runTest("compiler/testData/psi/operators/untilOperatorDifferentContexts.kt");
      }

      @TestMetadata("untilOperatorGenericsClash.kt")
      public void testUntilOperatorGenericsClash() {
        runTest("compiler/testData/psi/operators/untilOperatorGenericsClash.kt");
      }

      @TestMetadata("untilOperatorGreater.kt")
      public void testUntilOperatorGreater() {
        runTest("compiler/testData/psi/operators/untilOperatorGreater.kt");
      }

      @TestMetadata("untilOperatorWithWhitespace.kt")
      public void testUntilOperatorWithWhitespace() {
        runTest("compiler/testData/psi/operators/untilOperatorWithWhitespace.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/packages")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Packages extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInPackages() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/packages"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("PackageBlockFirst.kt")
      public void testPackageBlockFirst() {
        runTest("compiler/testData/psi/packages/PackageBlockFirst.kt");
      }

      @TestMetadata("PackageLeadingDotDoubleID.kt")
      public void testPackageLeadingDotDoubleID() {
        runTest("compiler/testData/psi/packages/PackageLeadingDotDoubleID.kt");
      }

      @TestMetadata("PackageLongNameBetweenDots.kt")
      public void testPackageLongNameBetweenDots() {
        runTest("compiler/testData/psi/packages/PackageLongNameBetweenDots.kt");
      }

      @TestMetadata("PackageLongNameDoubleID.kt")
      public void testPackageLongNameDoubleID() {
        runTest("compiler/testData/psi/packages/PackageLongNameDoubleID.kt");
      }

      @TestMetadata("PackageLongNameLeadingDot.kt")
      public void testPackageLongNameLeadingDot() {
        runTest("compiler/testData/psi/packages/PackageLongNameLeadingDot.kt");
      }

      @TestMetadata("PackageLongNameLeadingDoubleDot.kt")
      public void testPackageLongNameLeadingDoubleDot() {
        runTest("compiler/testData/psi/packages/PackageLongNameLeadingDoubleDot.kt");
      }

      @TestMetadata("PackageModifiers.kt")
      public void testPackageModifiers() {
        runTest("compiler/testData/psi/packages/PackageModifiers.kt");
      }

      @TestMetadata("PackageNameDoubleDot.kt")
      public void testPackageNameDoubleDot() {
        runTest("compiler/testData/psi/packages/PackageNameDoubleDot.kt");
      }

      @TestMetadata("PackageNameJustDot.kt")
      public void testPackageNameJustDot() {
        runTest("compiler/testData/psi/packages/PackageNameJustDot.kt");
      }

      @TestMetadata("PackageSimpleNameLeadingDot.kt")
      public void testPackageSimpleNameLeadingDot() {
        runTest("compiler/testData/psi/packages/PackageSimpleNameLeadingDot.kt");
      }

      @TestMetadata("PackageSimpleNameLeadingDoubleDot.kt")
      public void testPackageSimpleNameLeadingDoubleDot() {
        runTest("compiler/testData/psi/packages/PackageSimpleNameLeadingDoubleDot.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/platformTypesRecovery")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class PlatformTypesRecovery extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInPlatformTypesRecovery() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/platformTypesRecovery"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("Array.kt")
      public void testArray() {
        runTest("compiler/testData/psi/platformTypesRecovery/Array.kt");
      }

      @TestMetadata("BeforeDot.kt")
      public void testBeforeDot() {
        runTest("compiler/testData/psi/platformTypesRecovery/BeforeDot.kt");
      }

      @TestMetadata("Collections.kt")
      public void testCollections() {
        runTest("compiler/testData/psi/platformTypesRecovery/Collections.kt");
      }

      @TestMetadata("FunctionsNotPlatform.kt")
      public void testFunctionsNotPlatform() {
        runTest("compiler/testData/psi/platformTypesRecovery/FunctionsNotPlatform.kt");
      }

      @TestMetadata("MapEntry.kt")
      public void testMapEntry() {
        runTest("compiler/testData/psi/platformTypesRecovery/MapEntry.kt");
      }

      @TestMetadata("ParenthesizedNotPlatform.kt")
      public void testParenthesizedNotPlatform() {
        runTest("compiler/testData/psi/platformTypesRecovery/ParenthesizedNotPlatform.kt");
      }

      @TestMetadata("Qualified.kt")
      public void testQualified() {
        runTest("compiler/testData/psi/platformTypesRecovery/Qualified.kt");
      }

      @TestMetadata("QualifiedCollections.kt")
      public void testQualifiedCollections() {
        runTest("compiler/testData/psi/platformTypesRecovery/QualifiedCollections.kt");
      }

      @TestMetadata("Simple.kt")
      public void testSimple() {
        runTest("compiler/testData/psi/platformTypesRecovery/Simple.kt");
      }

      @TestMetadata("WrongWordInParentheses.kt")
      public void testWrongWordInParentheses() {
        runTest("compiler/testData/psi/platformTypesRecovery/WrongWordInParentheses.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/primaryConstructor")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class PrimaryConstructor extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInPrimaryConstructor() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/primaryConstructor"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("local.kt")
      public void testLocal() {
        runTest("compiler/testData/psi/primaryConstructor/local.kt");
      }

      @TestMetadata("nestedClassAmbiguity.kt")
      public void testNestedClassAmbiguity() {
        runTest("compiler/testData/psi/primaryConstructor/nestedClassAmbiguity.kt");
      }

      @TestMetadata("recovery.kt")
      public void testRecovery() {
        runTest("compiler/testData/psi/primaryConstructor/recovery.kt");
      }

      @TestMetadata("recoveryNestedClassAmbiguity.kt")
      public void testRecoveryNestedClassAmbiguity() {
        runTest("compiler/testData/psi/primaryConstructor/recoveryNestedClassAmbiguity.kt");
      }

      @TestMetadata("valid.kt")
      public void testValid() {
        runTest("compiler/testData/psi/primaryConstructor/valid.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/propertyBackingField")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class PropertyBackingField extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInPropertyBackingField() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyBackingField"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("explicitBackingField.kt")
      public void testExplicitBackingField() {
        runTest("compiler/testData/psi/propertyBackingField/explicitBackingField.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/propertyDelegate")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class PropertyDelegate extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInPropertyDelegate() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/propertyDelegate"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("BracketsInDelegate.kt")
      public void testBracketsInDelegate() {
        runTest("compiler/testData/psi/propertyDelegate/BracketsInDelegate.kt");
      }

      @TestMetadata("DelegateAndInitializer.kt")
      public void testDelegateAndInitializer() {
        runTest("compiler/testData/psi/propertyDelegate/DelegateAndInitializer.kt");
      }

      @TestMetadata("GetterInSameLine.kt")
      public void testGetterInSameLine() {
        runTest("compiler/testData/psi/propertyDelegate/GetterInSameLine.kt");
      }

      @TestMetadata("LocalProperty.kt")
      public void testLocalProperty() {
        runTest("compiler/testData/psi/propertyDelegate/LocalProperty.kt");
      }

      @TestMetadata("OnlyBy.kt")
      public void testOnlyBy() {
        runTest("compiler/testData/psi/propertyDelegate/OnlyBy.kt");
      }

      @TestMetadata("PropertyInClass.kt")
      public void testPropertyInClass() {
        runTest("compiler/testData/psi/propertyDelegate/PropertyInClass.kt");
      }

      @TestMetadata("PropertyWithGetter.kt")
      public void testPropertyWithGetter() {
        runTest("compiler/testData/psi/propertyDelegate/PropertyWithGetter.kt");
      }

      @TestMetadata("PropertyWithInitializer.kt")
      public void testPropertyWithInitializer() {
        runTest("compiler/testData/psi/propertyDelegate/PropertyWithInitializer.kt");
      }

      @TestMetadata("PropertyWithoutTypeRef.kt")
      public void testPropertyWithoutTypeRef() {
        runTest("compiler/testData/psi/propertyDelegate/PropertyWithoutTypeRef.kt");
      }

      @TestMetadata("TopLevelProperty.kt")
      public void testTopLevelProperty() {
        runTest("compiler/testData/psi/propertyDelegate/TopLevelProperty.kt");
      }

      @TestMetadata("TwoProperties.kt")
      public void testTwoProperties() {
        runTest("compiler/testData/psi/propertyDelegate/TwoProperties.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/recovery")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Recovery extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      @TestMetadata("AbsentLeftHandSide.kt")
      public void testAbsentLeftHandSide() {
        runTest("compiler/testData/psi/recovery/AbsentLeftHandSide.kt");
      }

      public void testAllFilesPresentInRecovery() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("BareVal.kt")
      public void testBareVal() {
        runTest("compiler/testData/psi/recovery/BareVal.kt");
      }

      @TestMetadata("BrokenFunctionSuperType.kt")
      public void testBrokenFunctionSuperType() {
        runTest("compiler/testData/psi/recovery/BrokenFunctionSuperType.kt");
      }

      @TestMetadata("CatchKeywordRBrace.kt")
      public void testCatchKeywordRBrace() {
        runTest("compiler/testData/psi/recovery/CatchKeywordRBrace.kt");
      }

      @TestMetadata("CloseBraceAtTopLevel.kt")
      public void testCloseBraceAtTopLevel() {
        runTest("compiler/testData/psi/recovery/CloseBraceAtTopLevel.kt");
      }

      @TestMetadata("DeclarationAfterDotSelectorExpected.kt")
      public void testDeclarationAfterDotSelectorExpected() {
        runTest("compiler/testData/psi/recovery/DeclarationAfterDotSelectorExpected.kt");
      }

      @TestMetadata("DeclarationAfterIncompleteElvis.kt")
      public void testDeclarationAfterIncompleteElvis() {
        runTest("compiler/testData/psi/recovery/DeclarationAfterIncompleteElvis.kt");
      }

      @TestMetadata("DoWhileWithEmptyCondition.kt")
      public void testDoWhileWithEmptyCondition() {
        runTest("compiler/testData/psi/recovery/DoWhileWithEmptyCondition.kt");
      }

      @TestMetadata("DoWhileWithoutLPar.kt")
      public void testDoWhileWithoutLPar() {
        runTest("compiler/testData/psi/recovery/DoWhileWithoutLPar.kt");
      }

      @TestMetadata("enumWthoutClass.kt")
      public void testEnumWthoutClass() {
        runTest("compiler/testData/psi/recovery/enumWthoutClass.kt");
      }

      @TestMetadata("ForEmptyParentheses.kt")
      public void testForEmptyParentheses() {
        runTest("compiler/testData/psi/recovery/ForEmptyParentheses.kt");
      }

      @TestMetadata("ForEmptyWithoutBody.kt")
      public void testForEmptyWithoutBody() {
        runTest("compiler/testData/psi/recovery/ForEmptyWithoutBody.kt");
      }

      @TestMetadata("ForNoBodyBeforeRBrace.kt")
      public void testForNoBodyBeforeRBrace() {
        runTest("compiler/testData/psi/recovery/ForNoBodyBeforeRBrace.kt");
      }

      @TestMetadata("ForRecovery.kt")
      public void testForRecovery() {
        runTest("compiler/testData/psi/recovery/ForRecovery.kt");
      }

      @TestMetadata("ForWithOnlyOneLParInEOF.kt")
      public void testForWithOnlyOneLParInEOF() {
        runTest("compiler/testData/psi/recovery/ForWithOnlyOneLParInEOF.kt");
      }

      @TestMetadata("ForWithoutBodyInEOF.kt")
      public void testForWithoutBodyInEOF() {
        runTest("compiler/testData/psi/recovery/ForWithoutBodyInEOF.kt");
      }

      @TestMetadata("ForWithoutLPar.kt")
      public void testForWithoutLPar() {
        runTest("compiler/testData/psi/recovery/ForWithoutLPar.kt");
      }

      @TestMetadata("ForWithoutLParInEOF.kt")
      public void testForWithoutLParInEOF() {
        runTest("compiler/testData/psi/recovery/ForWithoutLParInEOF.kt");
      }

      @TestMetadata("ForWithoutParamButWithRange.kt")
      public void testForWithoutParamButWithRange() {
        runTest("compiler/testData/psi/recovery/ForWithoutParamButWithRange.kt");
      }

      @TestMetadata("ForWithoutRange.kt")
      public void testForWithoutRange() {
        runTest("compiler/testData/psi/recovery/ForWithoutRange.kt");
      }

      @TestMetadata("FunFun.kt")
      public void testFunFun() {
        runTest("compiler/testData/psi/recovery/FunFun.kt");
      }

      @TestMetadata("IfKeywordRBrace.kt")
      public void testIfKeywordRBrace() {
        runTest("compiler/testData/psi/recovery/IfKeywordRBrace.kt");
      }

      @TestMetadata("IfWithEmptyCondition.kt")
      public void testIfWithEmptyCondition() {
        runTest("compiler/testData/psi/recovery/IfWithEmptyCondition.kt");
      }

      @TestMetadata("IfWithoutLPar.kt")
      public void testIfWithoutLPar() {
        runTest("compiler/testData/psi/recovery/IfWithoutLPar.kt");
      }

      @TestMetadata("ImportRecovery.kt")
      public void testImportRecovery() {
        runTest("compiler/testData/psi/recovery/ImportRecovery.kt");
      }

      @TestMetadata("importsWithConflict.kt")
      public void testImportsWithConflict() {
        runTest("compiler/testData/psi/recovery/importsWithConflict.kt");
      }

      @TestMetadata("IncompleteAccessor1.kt")
      public void testIncompleteAccessor1() {
        runTest("compiler/testData/psi/recovery/IncompleteAccessor1.kt");
      }

      @TestMetadata("IncompleteAccessor2.kt")
      public void testIncompleteAccessor2() {
        runTest("compiler/testData/psi/recovery/IncompleteAccessor2.kt");
      }

      @TestMetadata("IncompleteClassDeclaration.kt")
      public void testIncompleteClassDeclaration() {
        runTest("compiler/testData/psi/recovery/IncompleteClassDeclaration.kt");
      }

      @TestMetadata("IncompleteClassTypeParameters.kt")
      public void testIncompleteClassTypeParameters() {
        runTest("compiler/testData/psi/recovery/IncompleteClassTypeParameters.kt");
      }

      @TestMetadata("IncompleteForRBrace.kt")
      public void testIncompleteForRBrace() {
        runTest("compiler/testData/psi/recovery/IncompleteForRBrace.kt");
      }

      @TestMetadata("IncompleteFun.kt")
      public void testIncompleteFun() {
        runTest("compiler/testData/psi/recovery/IncompleteFun.kt");
      }

      @TestMetadata("IncompleteFunDeclaration.kt")
      public void testIncompleteFunDeclaration() {
        runTest("compiler/testData/psi/recovery/IncompleteFunDeclaration.kt");
      }

      @TestMetadata("IncompleteFunTypeParameters.kt")
      public void testIncompleteFunTypeParameters() {
        runTest("compiler/testData/psi/recovery/IncompleteFunTypeParameters.kt");
      }

      @TestMetadata("IncompleteTypeParameters.kt")
      public void testIncompleteTypeParameters() {
        runTest("compiler/testData/psi/recovery/IncompleteTypeParameters.kt");
      }

      @TestMetadata("IncompleteTypeRefWithPackageKeyword.kt")
      public void testIncompleteTypeRefWithPackageKeyword() {
        runTest("compiler/testData/psi/recovery/IncompleteTypeRefWithPackageKeyword.kt");
      }

      @TestMetadata("IncompleteValTypeParameters.kt")
      public void testIncompleteValTypeParameters() {
        runTest("compiler/testData/psi/recovery/IncompleteValTypeParameters.kt");
      }

      @TestMetadata("IncompleteWhenElse.kt")
      public void testIncompleteWhenElse() {
        runTest("compiler/testData/psi/recovery/IncompleteWhenElse.kt");
      }

      @TestMetadata("IncompleteWhere.kt")
      public void testIncompleteWhere() {
        runTest("compiler/testData/psi/recovery/IncompleteWhere.kt");
      }

      @TestMetadata("IncompleteWhere2.kt")
      public void testIncompleteWhere2() {
        runTest("compiler/testData/psi/recovery/IncompleteWhere2.kt");
      }

      @TestMetadata("initRecovery.kt")
      public void testInitRecovery() {
        runTest("compiler/testData/psi/recovery/initRecovery.kt");
      }

      @TestMetadata("InterfaceInExpressionPosition.kt")
      public void testInterfaceInExpressionPosition() {
        runTest("compiler/testData/psi/recovery/InterfaceInExpressionPosition.kt");
      }

      @TestMetadata("InvalidCharAfterPropertyName.kt")
      public void testInvalidCharAfterPropertyName() {
        runTest("compiler/testData/psi/recovery/InvalidCharAfterPropertyName.kt");
      }

      @TestMetadata("InvalidCharInSingleLineLambda.kt")
      public void testInvalidCharInSingleLineLambda() {
        runTest("compiler/testData/psi/recovery/InvalidCharInSingleLineLambda.kt");
      }

      @TestMetadata("kt2172.kt")
      public void testKt2172() {
        runTest("compiler/testData/psi/recovery/kt2172.kt");
      }

      @TestMetadata("kt24158.kt")
      public void testKt24158() {
        runTest("compiler/testData/psi/recovery/kt24158.kt");
      }

      @TestMetadata("kt5102.kt")
      public void testKt5102() {
        runTest("compiler/testData/psi/recovery/kt5102.kt");
      }

      @TestMetadata("lambdaExpressionInString_1.kt")
      public void testLambdaExpressionInString_1() {
        runTest("compiler/testData/psi/recovery/lambdaExpressionInString_1.kt");
      }

      @TestMetadata("lambdaExpressionInString_2.kt")
      public void testLambdaExpressionInString_2() {
        runTest("compiler/testData/psi/recovery/lambdaExpressionInString_2.kt");
      }

      @TestMetadata("MissingCommaInConstructorValueParameterList.kt")
      public void testMissingCommaInConstructorValueParameterList() {
        runTest("compiler/testData/psi/recovery/MissingCommaInConstructorValueParameterList.kt");
      }

      @TestMetadata("MissingCommaInValueArgumentList.kt")
      public void testMissingCommaInValueArgumentList() {
        runTest("compiler/testData/psi/recovery/MissingCommaInValueArgumentList.kt");
      }

      @TestMetadata("MissingCommaInValueParameterList.kt")
      public void testMissingCommaInValueParameterList() {
        runTest("compiler/testData/psi/recovery/MissingCommaInValueParameterList.kt");
      }

      @TestMetadata("MissingCommaInValueParameterListWithValOrVar.kt")
      public void testMissingCommaInValueParameterListWithValOrVar() {
        runTest("compiler/testData/psi/recovery/MissingCommaInValueParameterListWithValOrVar.kt");
      }

      @TestMetadata("NoArrowInWhen.kt")
      public void testNoArrowInWhen() {
        runTest("compiler/testData/psi/recovery/NoArrowInWhen.kt");
      }

      @TestMetadata("NoGTInTypeArguments.kt")
      public void testNoGTInTypeArguments() {
        runTest("compiler/testData/psi/recovery/NoGTInTypeArguments.kt");
      }

      @TestMetadata("PackageNewLineRecovery.kt")
      public void testPackageNewLineRecovery() {
        runTest("compiler/testData/psi/recovery/PackageNewLineRecovery.kt");
      }

      @TestMetadata("PackageRecovery.kt")
      public void testPackageRecovery() {
        runTest("compiler/testData/psi/recovery/PackageRecovery.kt");
      }

      @TestMetadata("SameLineStatementRecovery.kt")
      public void testSameLineStatementRecovery() {
        runTest("compiler/testData/psi/recovery/SameLineStatementRecovery.kt");
      }

      @TestMetadata("UnfinishedExtension.kt")
      public void testUnfinishedExtension() {
        runTest("compiler/testData/psi/recovery/UnfinishedExtension.kt");
      }

      @TestMetadata("ValNoName.kt")
      public void testValNoName() {
        runTest("compiler/testData/psi/recovery/ValNoName.kt");
      }

      @TestMetadata("ValWithNoNameBeforeNextDeclarationWithModifiers.kt")
      public void testValWithNoNameBeforeNextDeclarationWithModifiers() {
        runTest("compiler/testData/psi/recovery/ValWithNoNameBeforeNextDeclarationWithModifiers.kt");
      }

      @TestMetadata("ValWithNoNameInBlock.kt")
      public void testValWithNoNameInBlock() {
        runTest("compiler/testData/psi/recovery/ValWithNoNameInBlock.kt");
      }

      @TestMetadata("ValueParameterNoTypeRecovery.kt")
      public void testValueParameterNoTypeRecovery() {
        runTest("compiler/testData/psi/recovery/ValueParameterNoTypeRecovery.kt");
      }

      @TestMetadata("valueParameterRecovery.kt")
      public void testValueParameterRecovery() {
        runTest("compiler/testData/psi/recovery/valueParameterRecovery.kt");
      }

      @TestMetadata("valueParameterRecoveryWithTypes.kt")
      public void testValueParameterRecoveryWithTypes() {
        runTest("compiler/testData/psi/recovery/valueParameterRecoveryWithTypes.kt");
      }

      @TestMetadata("WhenWithoutBraces.kt")
      public void testWhenWithoutBraces() {
        runTest("compiler/testData/psi/recovery/WhenWithoutBraces.kt");
      }

      @TestMetadata("WhileWithEmptyCondition.kt")
      public void testWhileWithEmptyCondition() {
        runTest("compiler/testData/psi/recovery/WhileWithEmptyCondition.kt");
      }

      @TestMetadata("WhileWithoutLPar.kt")
      public void testWhileWithoutLPar() {
        runTest("compiler/testData/psi/recovery/WhileWithoutLPar.kt");
      }

      @TestMetadata("WithWithoutInAndMultideclaration.kt")
      public void testWithWithoutInAndMultideclaration() {
        runTest("compiler/testData/psi/recovery/WithWithoutInAndMultideclaration.kt");
      }

      @TestMetadata("compiler/testData/psi/recovery/objects")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class Objects extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInObjects() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("compiler/testData/psi/recovery/objects/declarations")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class Declarations extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInDeclarations() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/declarations"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("ConstructorModifiers.kt")
          public void testConstructorModifiers() {
            runTest("compiler/testData/psi/recovery/objects/declarations/ConstructorModifiers.kt");
          }

          @TestMetadata("EmptyParentheses.kt")
          public void testEmptyParentheses() {
            runTest("compiler/testData/psi/recovery/objects/declarations/EmptyParentheses.kt");
          }

          @TestMetadata("Everything.kt")
          public void testEverything() {
            runTest("compiler/testData/psi/recovery/objects/declarations/Everything.kt");
          }

          @TestMetadata("FollowedByModifiers.kt")
          public void testFollowedByModifiers() {
            runTest("compiler/testData/psi/recovery/objects/declarations/FollowedByModifiers.kt");
          }

          @TestMetadata("ParametersInParentheses.kt")
          public void testParametersInParentheses() {
            runTest("compiler/testData/psi/recovery/objects/declarations/ParametersInParentheses.kt");
          }

          @TestMetadata("TypeParametersAndParentheses.kt")
          public void testTypeParametersAndParentheses() {
            runTest("compiler/testData/psi/recovery/objects/declarations/TypeParametersAndParentheses.kt");
          }

          @TestMetadata("TypeParameterss.kt")
          public void testTypeParameterss() {
            runTest("compiler/testData/psi/recovery/objects/declarations/TypeParameterss.kt");
          }

          @TestMetadata("Where.kt")
          public void testWhere() {
            runTest("compiler/testData/psi/recovery/objects/declarations/Where.kt");
          }
        }

        @TestMetadata("compiler/testData/psi/recovery/objects/expressions")
        @TestDataPath("$PROJECT_ROOT")
        @RunWith(JUnit3RunnerWithInners.class)
        public static class Expressions extends AbstractParsingTest {
          private void runTest(String testDataFilePath) {
            KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
          }

          public void testAllFilesPresentInExpressions() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/objects/expressions"), Pattern.compile("^(.*)\\.kts?$"), null, true);
          }

          @TestMetadata("ConstructorModifiers.kt")
          public void testConstructorModifiers() {
            runTest("compiler/testData/psi/recovery/objects/expressions/ConstructorModifiers.kt");
          }

          @TestMetadata("ConstructorModifiersAndName.kt")
          public void testConstructorModifiersAndName() {
            runTest("compiler/testData/psi/recovery/objects/expressions/ConstructorModifiersAndName.kt");
          }

          @TestMetadata("EmptyParentheses.kt")
          public void testEmptyParentheses() {
            runTest("compiler/testData/psi/recovery/objects/expressions/EmptyParentheses.kt");
          }

          @TestMetadata("Everything.kt")
          public void testEverything() {
            runTest("compiler/testData/psi/recovery/objects/expressions/Everything.kt");
          }

          @TestMetadata("InFunction.kt")
          public void testInFunction() {
            runTest("compiler/testData/psi/recovery/objects/expressions/InFunction.kt");
          }

          @TestMetadata("ParametersInParentheses.kt")
          public void testParametersInParentheses() {
            runTest("compiler/testData/psi/recovery/objects/expressions/ParametersInParentheses.kt");
          }

          @TestMetadata("TypeParametersAndParentheses.kt")
          public void testTypeParametersAndParentheses() {
            runTest("compiler/testData/psi/recovery/objects/expressions/TypeParametersAndParentheses.kt");
          }

          @TestMetadata("TypeParameterss.kt")
          public void testTypeParameterss() {
            runTest("compiler/testData/psi/recovery/objects/expressions/TypeParameterss.kt");
          }

          @TestMetadata("Where.kt")
          public void testWhere() {
            runTest("compiler/testData/psi/recovery/objects/expressions/Where.kt");
          }
        }
      }

      @TestMetadata("compiler/testData/psi/recovery/qualifiedExpression")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class QualifiedExpression extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInQualifiedExpression() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/qualifiedExpression"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("noQualifiedExpression.kt")
        public void testNoQualifiedExpression() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/noQualifiedExpression.kt");
        }

        @TestMetadata("noSafeQualifiedExpression.kt")
        public void testNoSafeQualifiedExpression() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/noSafeQualifiedExpression.kt");
        }

        @TestMetadata("qualifiedExpressionWithSelector.kt")
        public void testQualifiedExpressionWithSelector() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/qualifiedExpressionWithSelector.kt");
        }

        @TestMetadata("qualifiedExpressionWithoutSelector.kt")
        public void testQualifiedExpressionWithoutSelector() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/qualifiedExpressionWithoutSelector.kt");
        }

        @TestMetadata("safeQualifiedExpressionWithSelector.kt")
        public void testSafeQualifiedExpressionWithSelector() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/safeQualifiedExpressionWithSelector.kt");
        }

        @TestMetadata("safeQualifiedExpressionWithoutSelector.kt")
        public void testSafeQualifiedExpressionWithoutSelector() {
          runTest("compiler/testData/psi/recovery/qualifiedExpression/safeQualifiedExpressionWithoutSelector.kt");
        }
      }

      @TestMetadata("compiler/testData/psi/recovery/unnamedParameter")
      @TestDataPath("$PROJECT_ROOT")
      @RunWith(JUnit3RunnerWithInners.class)
      public static class UnnamedParameter extends AbstractParsingTest {
        private void runTest(String testDataFilePath) {
          KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
        }

        public void testAllFilesPresentInUnnamedParameter() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/recovery/unnamedParameter"), Pattern.compile("^(.*)\\.kts?$"), null, true);
        }

        @TestMetadata("firstInFunction.kt")
        public void testFirstInFunction() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInFunction.kt");
        }

        @TestMetadata("firstInFunctionalType.kt")
        public void testFirstInFunctionalType() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInFunctionalType.kt");
        }

        @TestMetadata("firstInLambda.kt")
        public void testFirstInLambda() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInLambda.kt");
        }

        @TestMetadata("firstInPrimaryConstructor.kt")
        public void testFirstInPrimaryConstructor() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInPrimaryConstructor.kt");
        }

        @TestMetadata("firstInSecondaryConstructor.kt")
        public void testFirstInSecondaryConstructor() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInSecondaryConstructor.kt");
        }

        @TestMetadata("firstInSetter.kt")
        public void testFirstInSetter() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/firstInSetter.kt");
        }

        @TestMetadata("secondInFunction.kt")
        public void testSecondInFunction() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/secondInFunction.kt");
        }

        @TestMetadata("secondInFunctionalType.kt")
        public void testSecondInFunctionalType() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/secondInFunctionalType.kt");
        }

        @TestMetadata("secondInLambda.kt")
        public void testSecondInLambda() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/secondInLambda.kt");
        }

        @TestMetadata("secondInPrimaryConstructor.kt")
        public void testSecondInPrimaryConstructor() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/secondInPrimaryConstructor.kt");
        }

        @TestMetadata("secondInSecondaryConstructor.kt")
        public void testSecondInSecondaryConstructor() {
          runTest("compiler/testData/psi/recovery/unnamedParameter/secondInSecondaryConstructor.kt");
        }
      }
    }

    @TestMetadata("compiler/testData/psi/script")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class Script extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInScript() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/script"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("ComplexScript.kts")
      public void testComplexScript() {
        runTest("compiler/testData/psi/script/ComplexScript.kts");
      }

      @TestMetadata("FunctionComment.kts")
      public void testFunctionComment() {
        runTest("compiler/testData/psi/script/FunctionComment.kts");
      }

      @TestMetadata("Import.kts")
      public void testImport() {
        runTest("compiler/testData/psi/script/Import.kts");
      }

      @TestMetadata("manyAnnotationsOnFile.kts")
      public void testManyAnnotationsOnFile() {
        runTest("compiler/testData/psi/script/manyAnnotationsOnFile.kts");
      }

      @TestMetadata("OneLiner.kts")
      public void testOneLiner() {
        runTest("compiler/testData/psi/script/OneLiner.kts");
      }

      @TestMetadata("Shebang.kts")
      public void testShebang() {
        runTest("compiler/testData/psi/script/Shebang.kts");
      }

      @TestMetadata("ShebangIncorrect.kts")
      public void testShebangIncorrect() {
        runTest("compiler/testData/psi/script/ShebangIncorrect.kts");
      }

      @TestMetadata("ShebangWithImports.kts")
      public void testShebangWithImports() {
        runTest("compiler/testData/psi/script/ShebangWithImports.kts");
      }

      @TestMetadata("ShebangWithPackage.kts")
      public void testShebangWithPackage() {
        runTest("compiler/testData/psi/script/ShebangWithPackage.kts");
      }

      @TestMetadata("SimpleScript.kts")
      public void testSimpleScript() {
        runTest("compiler/testData/psi/script/SimpleScript.kts");
      }

      @TestMetadata("topLevelPropertiesWithGetSet.kts")
      public void testTopLevelPropertiesWithGetSet() {
        runTest("compiler/testData/psi/script/topLevelPropertiesWithGetSet.kts");
      }

      @TestMetadata("unexpectedSymbol.kts")
      public void testUnexpectedSymbol() {
        runTest("compiler/testData/psi/script/unexpectedSymbol.kts");
      }
    }

    @TestMetadata("compiler/testData/psi/secondaryConstructors")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class SecondaryConstructors extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInSecondaryConstructors() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/secondaryConstructors"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("anonymousInitializer.kt")
      public void testAnonymousInitializer() {
        runTest("compiler/testData/psi/secondaryConstructors/anonymousInitializer.kt");
      }

      @TestMetadata("basic.kt")
      public void testBasic() {
        runTest("compiler/testData/psi/secondaryConstructors/basic.kt");
      }

      @TestMetadata("emptyBody.kt")
      public void testEmptyBody() {
        runTest("compiler/testData/psi/secondaryConstructors/emptyBody.kt");
      }

      @TestMetadata("enumParsing.kt")
      public void testEnumParsing() {
        runTest("compiler/testData/psi/secondaryConstructors/enumParsing.kt");
      }

      @TestMetadata("recoveryEmptyDelegationType.kt")
      public void testRecoveryEmptyDelegationType() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryEmptyDelegationType.kt");
      }

      @TestMetadata("recoveryJustConstructorKeyword.kt")
      public void testRecoveryJustConstructorKeyword() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryJustConstructorKeyword.kt");
      }

      @TestMetadata("recoveryJustConstructorKeywordSameLineBrace.kt")
      public void testRecoveryJustConstructorKeywordSameLineBrace() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryJustConstructorKeywordSameLineBrace.kt");
      }

      @TestMetadata("recoveryNoDelegationCallAfterColon.kt")
      public void testRecoveryNoDelegationCallAfterColon() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryNoDelegationCallAfterColon.kt");
      }

      @TestMetadata("recoveryWithoutBodyWrongDelegationName.kt")
      public void testRecoveryWithoutBodyWrongDelegationName() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryWithoutBodyWrongDelegationName.kt");
      }

      @TestMetadata("recoveryWithoutParameterList.kt")
      public void testRecoveryWithoutParameterList() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryWithoutParameterList.kt");
      }

      @TestMetadata("recoveryWrongDelegationName.kt")
      public void testRecoveryWrongDelegationName() {
        runTest("compiler/testData/psi/secondaryConstructors/recoveryWrongDelegationName.kt");
      }
    }

    @TestMetadata("compiler/testData/psi/stringTemplates")
    @TestDataPath("$PROJECT_ROOT")
    @RunWith(JUnit3RunnerWithInners.class)
    public static class StringTemplates extends AbstractParsingTest {
      private void runTest(String testDataFilePath) {
        KotlinTestUtils.runTest(this::doParsingTest, this, testDataFilePath);
      }

      public void testAllFilesPresentInStringTemplates() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/psi/stringTemplates"), Pattern.compile("^(.*)\\.kts?$"), null, true);
      }

      @TestMetadata("RawStringsWithManyQuotes.kt")
      public void testRawStringsWithManyQuotes() {
        runTest("compiler/testData/psi/stringTemplates/RawStringsWithManyQuotes.kt");
      }

      @TestMetadata("StringTemplateWithTryWithoutBlockInLongEntry.kt")
      public void testStringTemplateWithTryWithoutBlockInLongEntry() {
        runTest("compiler/testData/psi/stringTemplates/StringTemplateWithTryWithoutBlockInLongEntry.kt");
      }

      @TestMetadata("StringTemplateWithTryWithoutBlockInShortEntry.kt")
      public void testStringTemplateWithTryWithoutBlockInShortEntry() {
        runTest("compiler/testData/psi/stringTemplates/StringTemplateWithTryWithoutBlockInShortEntry.kt");
      }
    }
  }

  @TestMetadata("compiler/testData/parseCodeFragment/expression")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Expression extends AbstractParsingTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doExpressionCodeFragmentParsingTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInExpression() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/parseCodeFragment/expression"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @TestMetadata("error.kt")
    public void testError() {
      runTest("compiler/testData/parseCodeFragment/expression/error.kt");
    }

    @TestMetadata("simple.kt")
    public void testSimple() {
      runTest("compiler/testData/parseCodeFragment/expression/simple.kt");
    }
  }

  @TestMetadata("compiler/testData/parseCodeFragment/block")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Block extends AbstractParsingTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doBlockCodeFragmentParsingTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInBlock() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/parseCodeFragment/block"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @TestMetadata("expressionOnTopLevel.kt")
    public void testExpressionOnTopLevel() {
      runTest("compiler/testData/parseCodeFragment/block/expressionOnTopLevel.kt");
    }

    @TestMetadata("imports.kt")
    public void testImports() {
      runTest("compiler/testData/parseCodeFragment/block/imports.kt");
    }

    @TestMetadata("localFun.kt")
    public void testLocalFun() {
      runTest("compiler/testData/parseCodeFragment/block/localFun.kt");
    }

    @TestMetadata("oneLine.kt")
    public void testOneLine() {
      runTest("compiler/testData/parseCodeFragment/block/oneLine.kt");
    }

    @TestMetadata("oneStatement.kt")
    public void testOneStatement() {
      runTest("compiler/testData/parseCodeFragment/block/oneStatement.kt");
    }

    @TestMetadata("packageAndImport.kt")
    public void testPackageAndImport() {
      runTest("compiler/testData/parseCodeFragment/block/packageAndImport.kt");
    }

    @TestMetadata("packageDirective.kt")
    public void testPackageDirective() {
      runTest("compiler/testData/parseCodeFragment/block/packageDirective.kt");
    }

    @TestMetadata("severalExpressions.kt")
    public void testSeveralExpressions() {
      runTest("compiler/testData/parseCodeFragment/block/severalExpressions.kt");
    }

    @TestMetadata("severalStatements.kt")
    public void testSeveralStatements() {
      runTest("compiler/testData/parseCodeFragment/block/severalStatements.kt");
    }

    @TestMetadata("unexpectedSymbol.kt")
    public void testUnexpectedSymbol() {
      runTest("compiler/testData/parseCodeFragment/block/unexpectedSymbol.kt");
    }
  }
}
