/returns_booleans.kt:(121,133): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$returns_true() returns (ret$: Bool)
  ensures true
  ensures ret$ == true
{
  ret$ := true
}

/returns_booleans.kt:(268,281): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$returns_false() returns (ret$: Bool)
  ensures true
  ensures ret$ == false
{
  ret$ := false
}

/returns_booleans.kt:(418,435): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$conditional_basic(local$b: Bool) returns (ret$: Bool)
  ensures ret$ == true ==> true
  ensures ret$ == false ==> local$b
{
  ret$ := true
}

/returns_booleans.kt:(612,636): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$binary_logic_expressions(local$a: Bool, local$b: Bool)
  returns (ret$: Bool)
  ensures ret$ == false ==> local$b && false
  ensures ret$ == true ==> (true || local$a) && (local$b || true)
{
  ret$ := true
}

/returns_booleans.kt:(855,866): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$logical_not(local$b: Bool) returns (ret$: Bool)
  ensures ret$ == true ==> !local$b && local$b
  ensures ret$ == false ==> local$b || !local$b
{
  ret$ := false
}

/returns_booleans.kt:(1052,1075): info: domain dom$Unit  {

  function dom$Unit$element(): dom$Unit
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  function dom$Nullable$nullable_of(x: T): dom$Nullable[T]

  function dom$Nullable$val_of(x: dom$Nullable[T]): T

  axiom dom$Nullable$some_not_null {
    (forall x: T ::
      { (dom$Nullable$nullable_of(x): dom$Nullable[T]) }
      (dom$Nullable$nullable_of(x): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T ::
      { (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) }
      (dom$Nullable$val_of((dom$Nullable$nullable_of(x): dom$Nullable[T])): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall x: dom$Nullable[T] ::
      { (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) }
      x != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Nullable$nullable_of((dom$Nullable$val_of(x): T)): dom$Nullable[T]) ==
      x)
  }
}

method global$pkg_$binary_logic_expressions(local$a: Bool, local$b: Bool)
  returns (ret$: Bool)
  ensures ret$ == false ==> local$b && false
  ensures ret$ == true ==> (true || local$a) && (local$b || true)


method global$pkg_$call_fun_with_contracts(local$b: Bool)
  returns (ret$: Bool)
  ensures ret$ == true
{
  var anonymous$1: Bool
  var local$a: Bool
  anonymous$1 := global$pkg_$binary_logic_expressions(local$b, local$b)
  local$a := anonymous$1
  ret$ := local$a
}
