
RAW_FIR:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [RAW_FIR] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

IMPORTS:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [RAW_FIR] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

COMPILER_REQUIRED_ANNOTATIONS:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [COMPILER_REQUIRED_ANNOTATIONS] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

COMPANION_GENERATION:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [COMPANION_GENERATION] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

SUPER_TYPES:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [SUPER_TYPES] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

TYPES:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public? final? [TYPES] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

STATUS:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public final [STATUS] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

ARGUMENTS_OF_ANNOTATIONS:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public final [ARGUMENTS_OF_ANNOTATIONS] fun resolveMe(): R|kotlin/Unit| { LAZY_BLOCK }

CONTRACTS:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public final [CONTRACTS] fun resolveMe(): R|kotlin/Unit| {
        testMe#(<L> = [STATUS] testMe@fun <implicit>.<anonymous>([RAW_FIR] b: <implicit>): <implicit> <inline=Unknown>  {
            b#
        }
        )
    }

IMPLICIT_TYPES_BODY_RESOLVE:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public final [IMPLICIT_TYPES_BODY_RESOLVE] fun resolveMe(): R|kotlin/Unit| {
        testMe#(<L> = [STATUS] testMe@fun <implicit>.<anonymous>([RAW_FIR] b: <implicit>): <implicit> <inline=Unknown>  {
            b#
        }
        )
    }

EXPECT_ACTUAL_MATCHING:
FILE: lambdaAsSAMInterface.kt
    public? final? [RAW_FIR] class Arg : R|kotlin/Any| {
        public? [RAW_FIR] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public? final? fun [RAW_FIR] interface Foo : R|kotlin/Any| {
        public? final? [RAW_FIR] fun foo([RAW_FIR] a: Arg): Arg

    }
    public? final? [RAW_FIR] fun testMe([RAW_FIR] f: Foo): R|kotlin/Unit| { LAZY_BLOCK }
    public final [EXPECT_ACTUAL_MATCHING] fun resolveMe(): R|kotlin/Unit| {
        testMe#(<L> = [STATUS] testMe@fun <implicit>.<anonymous>([RAW_FIR] b: <implicit>): <implicit> <inline=Unknown>  {
            b#
        }
        )
    }

BODY_RESOLVE:
FILE: lambdaAsSAMInterface.kt
    public? final? [COMPILER_REQUIRED_ANNOTATIONS] class Arg : R|kotlin/Any| {
        public? [COMPILER_REQUIRED_ANNOTATIONS] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public abstract fun [SUPER_TYPES] interface Foo : R|kotlin/Any| {
        public abstract [STATUS] fun foo([STATUS] a: R|foo/Arg|): R|foo/Arg|

    }
    public final [CONTRACTS] fun testMe([CONTRACTS] f: R|foo/Foo|): R|kotlin/Unit| {
    }
    public final [BODY_RESOLVE] fun resolveMe(): R|kotlin/Unit| {
        R|foo/testMe|(<L> = [BODY_RESOLVE] [MatchingParameterFunctionTypeKey=foo/Foo] testMe@fun <anonymous>([BODY_RESOLVE] b: R|foo/Arg|): R|foo/Arg| <inline=NoInline>  {
            ^ R|<local>/b|
        }
        )
    }

FILE RAW TO BODY:
FILE: lambdaAsSAMInterface.kt
    public final [BODY_RESOLVE] class Arg : R|kotlin/Any| {
        public [BODY_RESOLVE] [ContainingClassKey=Arg] constructor(): R|foo/Arg| {
            super<R|kotlin/Any|>()
        }

    }
    public abstract fun [BODY_RESOLVE] interface Foo : R|kotlin/Any| {
        public abstract [BODY_RESOLVE] fun foo([BODY_RESOLVE] a: R|foo/Arg|): R|foo/Arg|

    }
    public final [BODY_RESOLVE] fun testMe([BODY_RESOLVE] f: R|foo/Foo|): R|kotlin/Unit| {
    }
    public final [BODY_RESOLVE] fun resolveMe(): R|kotlin/Unit| {
        R|foo/testMe|(<L> = [BODY_RESOLVE] [MatchingParameterFunctionTypeKey=foo/Foo] testMe@fun <anonymous>([BODY_RESOLVE] b: R|foo/Arg|): R|foo/Arg| <inline=NoInline>  {
            ^ R|<local>/b|
        }
        )
    }
