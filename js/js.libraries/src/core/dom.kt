
package org.w3c.dom



//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateJavaScriptStubs.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

// Contains stub APIs for the W3C DOM API so we can delegate to the platform DOM instead


native public trait Attr: Node {
    public val name: String
    public val ownerElement: Element
    public val schemaTypeInfo: TypeInfo
    public val specified: Boolean
    public var value: String
    public fun isId(): Boolean = noImpl
}

native public trait CDATASection: Text {
}

native public trait CharacterData: Node {
    public var data: String
    public val length: Int
    public fun appendData(arg1: String?): Unit = noImpl
    public fun deleteData(arg1: Int, arg2: Int): Unit = noImpl
    public fun insertData(arg1: Int, arg2: String?): Unit = noImpl
    public fun replaceData(arg1: Int, arg2: Int, arg3: String?): Unit = noImpl
    public fun substringData(arg1: Int, arg2: Int): String = noImpl
}

native public trait Comment: CharacterData {
}

native public trait Document: Node {
    public val doctype: DocumentType
    public val documentElement: Element
    public var documentURI: String
    public val domConfig: DOMConfiguration
    public val implementation: DOMImplementation
    public val inputEncoding: String
    public var strictErrorChecking: Boolean
    public val xmlEncoding: String
    public var xmlStandalone: Boolean
    public var xmlVersion: String
    public fun adoptNode(arg1: Node): Node = noImpl
    public fun createAttribute(arg1: String?): Attr = noImpl
    public fun createAttributeNS(arg1: String?, arg2: String?): Attr = noImpl
    public fun createCDATASection(arg1: String?): CDATASection = noImpl
    public fun createComment(arg1: String?): Comment = noImpl
    public fun createDocumentFragment(): DocumentFragment = noImpl
    public fun createElement(arg1: String?): Element = noImpl
    public fun createElementNS(arg1: String?, arg2: String?): Element = noImpl
    public fun createEntityReference(arg1: String?): EntityReference = noImpl
    public fun createProcessingInstruction(arg1: String?, arg2: String?): ProcessingInstruction = noImpl
    public fun createTextNode(arg1: String?): Text = noImpl
    public fun getElementById(arg1: String?): Element = noImpl
    public fun getElementsByTagName(arg1: String?): NodeList = noImpl
    public fun getElementsByTagNameNS(arg1: String?, arg2: String?): NodeList = noImpl
    public fun importNode(arg1: Node, arg2: Boolean): Node = noImpl
    public fun normalizeDocument(): Unit = noImpl
    public fun renameNode(arg1: Node, arg2: String?, arg3: String?): Node = noImpl
}

native public trait DocumentFragment: Node {
}

native public trait DocumentType: Node {
    public val entities: NamedNodeMap
    public val internalSubset: String
    public val name: String
    public val notations: NamedNodeMap
    public val publicId: String
    public val systemId: String
}

native public trait DOMConfiguration {
    public val parameterNames: DOMStringList
    public fun canSetParameter(arg1: String?, arg2: Any): Boolean = noImpl
    public fun getParameter(arg1: String?): Any = noImpl
    public fun setParameter(arg1: String?, arg2: Any): Unit = noImpl
}

native public trait DOMError {
    public val location: DOMLocator
    public val message: String
    public val relatedData: Any
    public val relatedException: Any
    public val severity: Short
    public val type: String

    public default object {
        public val SEVERITY_ERROR: Short = 2
        public val SEVERITY_FATAL_ERROR: Short = 3
        public val SEVERITY_WARNING: Short = 1
    }
}

native public trait DOMErrorHandler {
    public fun handleError(arg1: DOMError): Boolean = noImpl
}

native public trait DOMImplementation {
    public fun createDocument(arg1: String?, arg2: String?, arg3: DocumentType?): Document = noImpl
    public fun createDocumentType(arg1: String?, arg2: String?, arg3: String?): DocumentType = noImpl
    public fun getFeature(arg1: String?, arg2: String?): Any = noImpl
    public fun hasFeature(arg1: String?, arg2: String?): Boolean = noImpl
}

native public trait DOMImplementationList {
    public val length: Int
    public fun item(arg1: Int): DOMImplementation = noImpl
}

native public trait DOMLocator {
    public val byteOffset: Int
    public val columnNumber: Int
    public val lineNumber: Int
    public val relatedNode: Node
    public val uri: String
    public val utf16Offset: Int
}

native public trait DOMStringList {
    public val length: Int
    public fun contains(arg1: String?): Boolean = noImpl
    public fun item(arg1: Int): String = noImpl
}

native public trait Element: Node {
    public val schemaTypeInfo: TypeInfo
    public val tagName: String
    public fun getAttribute(arg1: String?): String = noImpl
    public fun getAttributeNS(arg1: String?, arg2: String?): String = noImpl
    public fun getAttributeNode(arg1: String?): Attr = noImpl
    public fun getAttributeNodeNS(arg1: String?, arg2: String?): Attr = noImpl
    public fun getElementsByTagName(arg1: String?): NodeList = noImpl
    public fun getElementsByTagNameNS(arg1: String?, arg2: String?): NodeList = noImpl
    public fun hasAttribute(arg1: String?): Boolean = noImpl
    public fun hasAttributeNS(arg1: String?, arg2: String?): Boolean = noImpl
    public fun removeAttribute(arg1: String?): Unit = noImpl
    public fun removeAttributeNS(arg1: String?, arg2: String?): Unit = noImpl
    public fun removeAttributeNode(arg1: Attr): Attr = noImpl
    public fun setAttribute(arg1: String?, arg2: String?): Unit = noImpl
    public fun setAttributeNS(arg1: String?, arg2: String?, arg3: String?): Unit = noImpl
    public fun setIdAttribute(arg1: String?, arg2: Boolean): Unit = noImpl
    public fun setIdAttributeNS(arg1: String?, arg2: String?, arg3: Boolean): Unit = noImpl
    public fun setIdAttributeNode(arg1: Attr, arg2: Boolean): Unit = noImpl
    public fun setAttributeNode(arg1: Attr): Attr = noImpl
    public fun setAttributeNodeNS(arg1: Attr): Attr = noImpl
}

native public trait Entity: Node {
    public val inputEncoding: String
    public val notationName: String
    public val publicId: String
    public val systemId: String
    public val xmlEncoding: String
    public val xmlVersion: String
}

native public trait EntityReference: Node {
}

native public trait NameList {
    public val length: Int
    public fun contains(arg1: String?): Boolean = noImpl
    public fun containsNS(arg1: String?, arg2: String?): Boolean = noImpl
    public fun getName(arg1: Int): String = noImpl
    public fun getNamespaceURI(arg1: Int): String = noImpl
}

native public trait NamedNodeMap {
    public val length: Int
    public fun getNamedItem(arg1: String?): Node = noImpl
    public fun getNamedItemNS(arg1: String?, arg2: String?): Node = noImpl
    public fun item(arg1: Int): Node = noImpl
    public fun removeNamedItem(arg1: String?): Node = noImpl
    public fun removeNamedItemNS(arg1: String?, arg2: String?): Node = noImpl
    public fun setNamedItem(arg1: Node): Node = noImpl
    public fun setNamedItemNS(arg1: Node): Node = noImpl
}

native public trait Node {
    public val attributes: NamedNodeMap
    public val baseURI: String
    public val childNodes: NodeList
    public val firstChild: Node
    public val lastChild: Node
    public val localName: String
    public val namespaceURI: String
    public val nextSibling: Node
    public val nodeName: String
    public val nodeType: Short
    public var nodeValue: String
    public val ownerDocument: Document
    public val parentNode: Node
    public var prefix: String
    public val previousSibling: Node
    public var textContent: String
    public fun appendChild(arg1: Node): Node = noImpl
    public fun cloneNode(arg1: Boolean): Node = noImpl
    public fun compareDocumentPosition(arg1: Node): Short = noImpl
    public fun getFeature(arg1: String?, arg2: String?): Any = noImpl
    public fun getUserData(arg1: String?): Any = noImpl
    public fun hasAttributes(): Boolean = noImpl
    public fun hasChildNodes(): Boolean = noImpl
    public fun insertBefore(arg1: Node, arg2: Node): Node = noImpl
    public fun isDefaultNamespace(arg1: String?): Boolean = noImpl
    public fun isEqualNode(arg1: Node): Boolean = noImpl
    public fun isSameNode(arg1: Node): Boolean = noImpl
    public fun isSupported(arg1: String?, arg2: String?): Boolean = noImpl
    public fun lookupNamespaceURI(arg1: String?): String = noImpl
    public fun lookupPrefix(arg1: String?): String = noImpl
    public fun normalize(): Unit = noImpl
    public fun removeChild(arg1: Node): Node = noImpl
    public fun replaceChild(arg1: Node, arg2: Node): Node = noImpl
    public fun setUserData(arg1: String?, arg2: Any, arg3: UserDataHandler): Any = noImpl

    public default object {
        public val ATTRIBUTE_NODE: Short = 2
        public val CDATA_SECTION_NODE: Short = 4
        public val COMMENT_NODE: Short = 8
        public val DOCUMENT_FRAGMENT_NODE: Short = 11
        public val DOCUMENT_NODE: Short = 9
        public val DOCUMENT_POSITION_CONTAINED_BY: Short = 16
        public val DOCUMENT_POSITION_CONTAINS: Short = 8
        public val DOCUMENT_POSITION_DISCONNECTED: Short = 1
        public val DOCUMENT_POSITION_FOLLOWING: Short = 4
        public val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short = 32
        public val DOCUMENT_POSITION_PRECEDING: Short = 2
        public val DOCUMENT_TYPE_NODE: Short = 10
        public val ELEMENT_NODE: Short = 1
        public val ENTITY_NODE: Short = 6
        public val ENTITY_REFERENCE_NODE: Short = 5
        public val NOTATION_NODE: Short = 12
        public val PROCESSING_INSTRUCTION_NODE: Short = 7
        public val TEXT_NODE: Short = 3
    }
}

native public trait NodeList {
    public val length: Int
    public fun item(arg1: Int): Node = noImpl
}

native public trait Notation: Node {
    public val publicId: String
    public val systemId: String
}

native public trait ProcessingInstruction: Node {
    public var data: String
    public val target: String
}

native public trait Text: CharacterData {
    public val wholeText: String
    public fun isElementContentWhitespace(): Boolean = noImpl
    public fun replaceWholeText(arg1: String?): Text = noImpl
    public fun splitText(arg1: Int): Text = noImpl
}

native public trait TypeInfo {
    public val typeName: String
    public val typeNamespace: String
    public fun isDerivedFrom(arg1: String?, arg2: String?, arg3: Int): Boolean = noImpl

    public default object {
        public val DERIVATION_EXTENSION: Int = 2
        public val DERIVATION_LIST: Int = 8
        public val DERIVATION_RESTRICTION: Int = 1
        public val DERIVATION_UNION: Int = 4
    }
}

native public trait UserDataHandler {
    public fun handle(arg1: Short, arg2: String?, arg3: Any, arg4: Node, arg5: Node): Unit = noImpl

    public default object {
        public val NODE_ADOPTED: Short = 5
        public val NODE_CLONED: Short = 1
        public val NODE_DELETED: Short = 3
        public val NODE_IMPORTED: Short = 2
        public val NODE_RENAMED: Short = 4
    }
}

