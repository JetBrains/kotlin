package kotlin

//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import kotlin.platform.*
import java.util.*

import java.util.Collections // TODO: it's temporary while we have java.util.Collections in js

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <T, R, V> Array<out T>.merge(array: Array<out R>, transform: (T, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> BooleanArray.merge(array: Array<out R>, transform: (Boolean, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> ByteArray.merge(array: Array<out R>, transform: (Byte, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> CharArray.merge(array: Array<out R>, transform: (Char, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> DoubleArray.merge(array: Array<out R>, transform: (Double, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> FloatArray.merge(array: Array<out R>, transform: (Float, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> IntArray.merge(array: Array<out R>, transform: (Int, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> LongArray.merge(array: Array<out R>, transform: (Long, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> ShortArray.merge(array: Array<out R>, transform: (Short, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <T, R, V> Iterable<T>.merge(array: Array<out R>, transform: (T, R) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(collectionSizeOrDefault(10))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> BooleanArray.merge(array: BooleanArray, transform: (Boolean, Boolean) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> ByteArray.merge(array: ByteArray, transform: (Byte, Byte) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> CharArray.merge(array: CharArray, transform: (Char, Char) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> DoubleArray.merge(array: DoubleArray, transform: (Double, Double) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> FloatArray.merge(array: FloatArray, transform: (Float, Float) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> IntArray.merge(array: IntArray, transform: (Int, Int) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> LongArray.merge(array: LongArray, transform: (Long, Long) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <V> ShortArray.merge(array: ShortArray, transform: (Short, Short) -> V): List<V> {
    val first = iterator()
    val second = array.iterator()
    val list = ArrayList<V>(Math.min(size(), array.size()))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <T, R, V> Array<out T>.merge(other: Iterable<R>, transform: (T, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> BooleanArray.merge(other: Iterable<R>, transform: (Boolean, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> ByteArray.merge(other: Iterable<R>, transform: (Byte, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> CharArray.merge(other: Iterable<R>, transform: (Char, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> DoubleArray.merge(other: Iterable<R>, transform: (Double, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> FloatArray.merge(other: Iterable<R>, transform: (Float, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> IntArray.merge(other: Iterable<R>, transform: (Int, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> LongArray.merge(other: Iterable<R>, transform: (Long, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <R, V> ShortArray.merge(other: Iterable<R>, transform: (Short, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(size())
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a list of values built from elements of both collections with same indexes using provided [transform]. List has length of shortest collection.
 */
public inline fun <T, R, V> Iterable<T>.merge(other: Iterable<R>, transform: (T, R) -> V): List<V> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<V>(collectionSizeOrDefault(10))
    while (first.hasNext() && second.hasNext()) {
        list.add(transform(first.next(), second.next()))
    }
    return list
}

/**
 * Returns a sequence of values built from elements of both collections with same indexes using provided [transform]. Resulting sequence has length of shortest input sequences.
 */
public fun <T, R, V> Sequence<T>.merge(sequence: Sequence<R>, transform: (T, R) -> V): Sequence<V> {
    return MergingSequence(this, sequence, transform)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {
    val first = ArrayList<Boolean>()
    val second = ArrayList<Boolean>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {
    val first = ArrayList<Byte>()
    val second = ArrayList<Byte>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {
    val first = ArrayList<Char>()
    val second = ArrayList<Char>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {
    val first = ArrayList<Double>()
    val second = ArrayList<Double>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {
    val first = ArrayList<Float>()
    val second = ArrayList<Float>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {
    val first = ArrayList<Int>()
    val second = ArrayList<Int>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {
    val first = ArrayList<Long>()
    val second = ArrayList<Long>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {
    val first = ArrayList<Short>()
    val second = ArrayList<Short>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which [predicate] yielded `true`,
 * while *second* collection contains elements for which [predicate] yielded `false`.
 */
public inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {
    val first = StringBuilder()
    val second = StringBuilder()
    for (element in this) {
        if (predicate(element)) {
            first.append(element)
        } else {
            second.append(element)
        }
    }
    return Pair(first.toString(), second.toString())
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given [array].
 */
public fun <T> Collection<T>.plus(array: Array<out T>): List<T> {
    val answer = ArrayList<T>(this.size() + array.size())
    answer.addAll(this)
    answer.addAll(array)
    return answer
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given [array].
 */
public fun <T> Iterable<T>.plus(array: Array<out T>): List<T> {
    if (this is Collection) return this.plus(array)
    val answer = ArrayList<T>()
    answer.addAll(this)
    answer.addAll(array)
    return answer
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given [array].
 */
public fun <T> Sequence<T>.plus(array: Array<out T>): Sequence<T> {
    return this.plus(array.asList())
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given [array].
 */
public fun <T> Set<T>.plus(array: Array<out T>): Set<T> {
    val result = LinkedHashSet<T>(mapCapacity(this.size() + array.size()))
    result.addAll(this)
    result.addAll(array)
    return result
}

public fun <T> Array<out T>.plus(collection: Collection<T>): Array<out T> {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as Array<out T>
}

public fun BooleanArray.plus(collection: Collection<Boolean>): BooleanArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as BooleanArray
}

public fun ByteArray.plus(collection: Collection<Byte>): ByteArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as ByteArray
}

public fun CharArray.plus(collection: Collection<Char>): CharArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as CharArray
}

public fun DoubleArray.plus(collection: Collection<Double>): DoubleArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as DoubleArray
}

public fun FloatArray.plus(collection: Collection<Float>): FloatArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as FloatArray
}

public fun IntArray.plus(collection: Collection<Int>): IntArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as IntArray
}

public fun LongArray.plus(collection: Collection<Long>): LongArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as LongArray
}

public fun ShortArray.plus(collection: Collection<Short>): ShortArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as ShortArray
}

public fun <T> Collection<T>.plus(collection: Collection<T>): List<T> {
    val answer = ArrayList<T>(this.size() + collection.size())
    answer.addAll(this)
    answer.addAll(collection)
    return answer
}

/**
 * Returns a list containing all elements of the original collection and then all elements of the given [collection].
 */
public fun <T> Collection<T>.plus(collection: Iterable<T>): List<T> {
    if (collection is Collection) return this.plus(collection)
    val answer = ArrayList<T>(this)
    answer.addAll(collection)
    return answer
}

/**
 * Returns a list containing all elements of the original collection and then all elements of the given [collection].
 */
public fun <T> Iterable<T>.plus(collection: Iterable<T>): List<T> {
    if (this is Collection) return this.plus(collection)
    val answer = ArrayList<T>(0)
    answer.addAll(this)
    answer.addAll(collection)
    return answer
}

/**
 * Returns a sequence containing all elements of original sequence and then all elements of the given [collection]
 */
public fun <T> Sequence<T>.plus(collection: Iterable<T>): Sequence<T> {
    return sequenceOf(this, collection.asSequence()).flatten()
}

/**
 * Returns a list containing all elements of the original collection and then all elements of the given [collection].
 */
public fun <T> Set<T>.plus(collection: Iterable<T>): Set<T> {
    val result = LinkedHashSet<T>(mapCapacity(collection.collectionSizeOrNull()?.let { this.size() + it } ?: this.size() * 2))
    result.addAll(this)
    result.addAll(collection)
    return result
}

public fun <T> Array<out T>.plus(collection: Array<out T>): Array<out T> {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as Array<out T>
}

public fun BooleanArray.plus(collection: BooleanArray): BooleanArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as BooleanArray
}

public fun ByteArray.plus(collection: ByteArray): ByteArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as ByteArray
}

public fun CharArray.plus(collection: CharArray): CharArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as CharArray
}

public fun DoubleArray.plus(collection: DoubleArray): DoubleArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as DoubleArray
}

public fun FloatArray.plus(collection: FloatArray): FloatArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as FloatArray
}

public fun IntArray.plus(collection: IntArray): IntArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as IntArray
}

public fun LongArray.plus(collection: LongArray): LongArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as LongArray
}

public fun ShortArray.plus(collection: ShortArray): ShortArray {
    val thisSize = size()
    val answer = this.copyOf(thisSize + collection.size())
    collection.forEachIndexed { i, element ->
        answer[thisSize + i] = element
    }
    return answer as ShortArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun <T> Array<out T>.plus(element: T): Array<out T> {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as Array<out T>
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun BooleanArray.plus(element: Boolean): BooleanArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as BooleanArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun ByteArray.plus(element: Byte): ByteArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as ByteArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun CharArray.plus(element: Char): CharArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as CharArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun DoubleArray.plus(element: Double): DoubleArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as DoubleArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun FloatArray.plus(element: Float): FloatArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as FloatArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun IntArray.plus(element: Int): IntArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as IntArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun LongArray.plus(element: Long): LongArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as LongArray
}

/**
 * Returns an array containing all elements of the original array and then the given [element].
 */
public fun ShortArray.plus(element: Short): ShortArray {
    val answer = this.copyOf(size() + 1)
    answer[size()] = element
    return answer as ShortArray
}

/**
 * Returns a list containing all elements of the original collection and then the given [element].
 */
public fun <T> Collection<T>.plus(element: T): List<T> {
    val answer = ArrayList<T>(size() + 1)
    answer.addAll(this)
    answer.add(element)
    return answer
}

/**
 * Returns a list containing all elements of the original collection and then the given [element].
 */
public fun <T> Iterable<T>.plus(element: T): List<T> {
    if (this is Collection) return this.plus(element)
    val answer = ArrayList<T>()
    answer.addAll(this)
    answer.add(element)
    return answer
}

/**
 * Returns a sequence containing all elements of the original sequence and then the given [element].
 */
public fun <T> Sequence<T>.plus(element: T): Sequence<T> {
    return sequenceOf(this, sequenceOf(element)).flatten()
}

/**
 * Returns a set containing all elements of the original set and then the given [element].
 */
public fun <T> Set<T>.plus(element: T): Set<T> {
    val copyOfSet = LinkedHashSet<T>(mapCapacity(size() + 1))
    copyOfSet.addAll(this)
    copyOfSet.add(element)
    return copyOfSet
}

/**
 * Returns a sequence containing all elements of original sequence and then all elements of the given [sequence].
 */
public fun <T> Sequence<T>.plus(sequence: Sequence<T>): Sequence<T> {
    return sequenceOf(this, sequence).flatten()
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <T, R> Array<out T>.zip(array: Array<out R>): List<Pair<T, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> BooleanArray.zip(array: Array<out R>): List<Pair<Boolean, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> ByteArray.zip(array: Array<out R>): List<Pair<Byte, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> CharArray.zip(array: Array<out R>): List<Pair<Char, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> DoubleArray.zip(array: Array<out R>): List<Pair<Double, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> FloatArray.zip(array: Array<out R>): List<Pair<Float, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> IntArray.zip(array: Array<out R>): List<Pair<Int, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> LongArray.zip(array: Array<out R>): List<Pair<Long, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> ShortArray.zip(array: Array<out R>): List<Pair<Short, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <T, R> Iterable<T>.zip(array: Array<out R>): List<Pair<T, R>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun BooleanArray.zip(array: BooleanArray): List<Pair<Boolean, Boolean>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun ByteArray.zip(array: ByteArray): List<Pair<Byte, Byte>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun CharArray.zip(array: CharArray): List<Pair<Char, Char>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun DoubleArray.zip(array: DoubleArray): List<Pair<Double, Double>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun FloatArray.zip(array: FloatArray): List<Pair<Float, Float>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun IntArray.zip(array: IntArray): List<Pair<Int, Int>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun LongArray.zip(array: LongArray): List<Pair<Long, Long>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun ShortArray.zip(array: ShortArray): List<Pair<Short, Short>> {
    return merge(array) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from elements of both collections with same indexes. List has length of shortest collection.
 */
public fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {
    return merge(other) { t1, t2 -> t1 to t2 }
}

/**
 * Returns a list of pairs built from characters of both strings with same indexes. List has length of shortest collection.
 */
public fun String.zip(other: String): List<Pair<Char, Char>> {
    val first = iterator()
    val second = other.iterator()
    val list = ArrayList<Pair<Char, Char>>(length())
    while (first.hasNext() && second.hasNext()) {
        list.add(first.next() to second.next())
    }
    return list
}

/**
 * Returns a sequence of pairs built from elements of both collections with same indexes.
 * Resulting sequence has length of shortest input sequences.
 */
public fun <T, R> Sequence<T>.zip(sequence: Sequence<R>): Sequence<Pair<T, R>> {
    return MergingSequence(this, sequence) { t1, t2 -> t1 to t2 }
}

