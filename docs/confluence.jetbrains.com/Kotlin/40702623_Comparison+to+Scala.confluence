Two of the [main design goals|Welcome#Design goals] for [Kotlin] are
* make *compilation* at least as fast as *Java* and, 
* keeping the useful level of expressiveness (see above), make it as simple as possible.

{info:title:Note}
If you are happy with *Scala*, you probably don't need [Kotlin].
{info}

h3. What Scala has that [Kotlin] has not

* Implicit conversions, parameters, etc
** In *Scala*, sometimes it's very hard to tell what's happening in your code without using a debugger, because too many implicits get into the picture
** To enrich your types with functions in [Kotlin] use [Extension functions].
* Overridable type members
* Path-dependent types
* Existential types
** [Type projections|Generics#Type projections] are a very special case
* Complicated logic for initialization of traits
** See [Classes and Inheritance]
* Custom symbolic operations
** See [Operator overloading]
* Built-in XML
** See [Type-safe Groovy-style builders]

Things that may be added to [Kotlin] later:
* Higher kinds
* Structural types
* Yield operator
* Actors
* Parallel collections
* .NET target

h3. What [Kotlin] has that Scala has not
* [Zero-overhead null-safety|Null-safety]
** *Scala* has {{Option}}, which is a syntactic and run-time wrapper
* [Smart casts|Type casts]
* Static [extension functions|Extension functions] 
** Instead of wrapping at runtime (with Scala 2.10, implicit value classes will fix the runtime overhead problem)
* [Kotlin]'s [Inline functions|Functions#Inline functions] facilitate [Nonlocal jumps|Returns and jumps#custom]
* [String templates|Strings#Templates]. 
** This feature will be supported in Scala 2.10
* [First-class delegation|Classes and Inheritance#Delegation]. Also implemented via 3rd party plugin: [Autoproxy|https://github.com/kevinwright/Autoproxy-Lite]
* [Modules|Modules and Compilation]

h3. What's next

* [Modules and Compilation]