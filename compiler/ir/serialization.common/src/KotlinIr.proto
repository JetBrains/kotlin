edition = "2023";

package org.jetbrains.kotlin.backend.common.serialization.proto;

// Changes to this proto are tracked by KotlinAbiVersion version. See KotlinAbiVersion KDoc.

option java_multiple_files = true;
option java_outer_classname = "KotlinIr";
option features.utf8_validation = NONE;

/* ------ Top Level --------------------------------------------- */

message FileEntry {
  string name = 1 [features.field_presence = LEGACY_REQUIRED];
  repeated int32 line_start_offset = 2;
  int32 first_relevant_line_index = 3 [default = 0];
}

message IrFile {
  repeated int32 declaration_id = 1;
  FileEntry file_entry = 2; // Required: either `file_entry` or `file_entry_id` is present.
  int32 file_entry_id = 7;  // Required: either `file_entry` or `file_entry_id` is present.
  repeated int32 fq_name = 3;
  repeated IrConstructorCall annotation = 4;
  repeated int64 explicitly_exported_to_compiler = 5;
  repeated int32 preprocessed_inline_functions = 8;

  // WARNING: Don't occupy index 6 which was previously used for storing expect/actual table.
  // repeated Actual actual = 6;
}

/* ------ IdSignature -------------------------------------------- */

message CommonIdSignature {
  repeated int32 package_fq_name = 1;
  repeated int32 declaration_fq_name = 2;
  int64 member_uniq_id = 3;
  int64 flags = 4 [default = 0];
  int32 debug_info = 5;
}

message AccessorIdSignature {
  int32 property_signature = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 name = 2 [features.field_presence = LEGACY_REQUIRED];
  int64 accessor_hash_id = 3 [features.field_presence = LEGACY_REQUIRED];
  int64 flags = 4 [default = 0];
  int32 debug_info = 5;
}

message FileLocalIdSignature {
  int32 container = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 local_id = 2 [features.field_presence = LEGACY_REQUIRED];

  // WARNING: Don't occupy index 3 which was previously used for storing local signature description.
  //int32 debug_info = 3;
}

message CompositeSignature {
  int32 container_sig = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 inner_sig = 2 [features.field_presence = LEGACY_REQUIRED];
}

message LocalSignature {
  repeated int32 local_fq_name = 1;
  int64 local_hash = 2;

  // WARNING: Don't occupy index 3 which was previously used for storing local signature description.
  //int32 debug_info = 3;
}

message FileSignature {}

message IdSignature {
  oneof idSig {
    CommonIdSignature public_sig = 1;
    FileLocalIdSignature private_sig = 2;
    AccessorIdSignature accessor_sig = 3;
    int32 scoped_local_sig = 4;
    CompositeSignature composite_sig = 5;
    LocalSignature local_sig = 6;
    FileSignature file_sig = 7;
  }
}

/* ------ IrTypes --------------------------------------------- */

// Note: IrTypeArgument [63..2 - IrType index | 1..0 - Variance]
// If x...xxx00 -> *

message IrSimpleTypeLegacy {
  repeated IrConstructorCall annotation = 1;
  int64 classifier = 2 [features.field_presence = LEGACY_REQUIRED];
  bool has_question_mark = 3 [features.field_presence = LEGACY_REQUIRED];
  repeated int64 argument = 4; // 0 - STAR, otherwise [63..2 - IrType index | 1..0 - Variance]
  IrTypeAbbreviation abbreviation = 5;
}

enum IrSimpleTypeNullability {
  option features.enum_type = CLOSED;
  MARKED_NULLABLE = 0;
  NOT_SPECIFIED = 1;
  DEFINITELY_NOT_NULL = 2;
}

message IrSimpleType {
  repeated IrConstructorCall annotation = 1;
  int64 classifier = 2 [features.field_presence = LEGACY_REQUIRED];
  IrSimpleTypeNullability nullability = 3 [default=NOT_SPECIFIED];
  repeated int64 argument = 4; // 0 - STAR, otherwise [63..2 - IrType index | 1..0 - Variance]
  IrTypeAbbreviation abbreviation = 5;
}

message IrTypeAbbreviation {
  repeated IrConstructorCall annotation = 1;
  int64 type_alias = 2 [features.field_presence = LEGACY_REQUIRED];
  bool has_question_mark = 3 [features.field_presence = LEGACY_REQUIRED];
  repeated int64 argument = 4; // 0 - STAR, otherwise [63..2 - IrType index | 1..0 - Variance]
}

message IrDynamicType {
  repeated IrConstructorCall annotation = 1;
}

message IrDefinitelyNotNullType {
  // In fact that is an `IntersectionType` so let represent it as it. In future it could be easy to support general case
  repeated int32 types = 1;
}

message IrType {
  oneof kind {
    IrSimpleTypeLegacy legacySimple = 1;
    IrDynamicType dynamic = 2;
    IrDefinitelyNotNullType dnn = 4;
    IrSimpleType simple = 5;

    // WARNING: Don't occupy index 3 which was previously used for storing IrErrorType.
    // IrErrorType error = 3;
  }
}

/* ------ IrExpressions --------------------------------------------- */


message IrBreak {
  int32 loop_id = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 label = 2;
}

message IrBlock {
  repeated IrStatement statement = 1;
  int32 origin_name = 2;
}

message IrReturnableBlock {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  IrBlock base = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrInlinedFunctionBlock {
  int64 inlined_function_symbol = 1;
  FileEntry inlined_function_file_entry = 2; // Required: either `inlined_function_file_entry` or `inlined_function_file_entry_id` is present.
  IrBlock base = 3 [features.field_presence = LEGACY_REQUIRED];
  int32 inlined_function_start_offset = 4 [features.field_presence = LEGACY_REQUIRED];
  int32 inlined_function_end_offset = 5 [features.field_presence = LEGACY_REQUIRED];
  int32 inlined_function_file_entry_id = 6;  // Required: either `inlined_function_file_entry` or `inlined_function_file_entry_id` is present.
}

message MemberAccessCommon {
  // Value argument serialization scheme after 2.2.0
  repeated NullableIrExpression argument = 6;

  // Value argument serialization scheme before 2.2.0
  IrExpression dispatch_receiver = 1;
  IrExpression extension_receiver = 2;
  repeated NullableIrExpression regular_argument = 3;

  repeated int32 type_argument = 4;

  // Previously used fields:
  //repeated NullableIrExpression context_argument = 5;
}

message IrCall {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  MemberAccessCommon member_access = 2 [features.field_presence = LEGACY_REQUIRED];
  int64 super = 3;
  int32 origin_name = 4;
}

message IrConstructorCall {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 constructor_type_arguments_count = 2 [features.field_presence = LEGACY_REQUIRED];
  MemberAccessCommon member_access = 3 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 4;
}

message IrFunctionReference {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 2;
  MemberAccessCommon member_access = 3 [features.field_presence = LEGACY_REQUIRED];
  int64 reflection_target_symbol = 4;
}

message IrLocalDelegatedPropertyReference {
  int64 delegate = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 getter = 2;
  int64 setter = 3;
  int64 symbol = 4 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 5;
}

message IrPropertyReference {
  int64 field = 1;
  int64 getter = 2;
  int64 setter = 3;
  int32 origin_name = 4;
  MemberAccessCommon member_access = 5 [features.field_presence = LEGACY_REQUIRED];
  int64 symbol = 6 [features.field_presence = LEGACY_REQUIRED];
}

message IrRichFunctionReference {
  repeated IrExpression bound_values = 1;
  int64 reflection_target_symbol = 2;
  int64 overridden_function_symbol = 3 [features.field_presence = LEGACY_REQUIRED];
  IrFunction invoke_function = 4 [features.field_presence = LEGACY_REQUIRED];
  int64 flags = 5 [default = 0];
  int32 origin_name = 6;
}

message IrRichPropertyReference {
  repeated IrExpression bound_values = 1;
  int64 reflection_target_symbol = 2;
  IrFunction getter_function = 3 [features.field_presence = LEGACY_REQUIRED];
  IrFunction setter_function = 4;
  int32 origin_name = 5;
}

message IrComposite {
  repeated IrStatement statement = 1;
  int32 origin_name = 2;
}

message IrClassReference {
  int64 class_symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 class_type = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrConst {
  oneof value {
    bool null = 1;
    bool boolean = 2;
    int32 char = 3;
    int32 byte = 4;
    int32 short = 5;
    int32 int = 6;
    int64 long = 7;
    fixed32 float_bits = 8;  // float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
    fixed64 double_bits = 9;
    int32 string = 10;
  }
}

message IrContinue {
  int32 loop_id = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 label = 2;
}

message IrDelegatingConstructorCall {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  MemberAccessCommon member_access = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrDoWhile {
  Loop loop = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrEnumConstructorCall {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  MemberAccessCommon member_access = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrGetClass {
  IrExpression argument = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrGetEnumValue {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
}

message FieldAccessCommon {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 super = 2;
  IrExpression receiver = 3;
}

message IrGetField {
  FieldAccessCommon field_access = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 2;
}

message IrGetValue {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 2;
}

message IrGetObject {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrInstanceInitializerCall {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
}

message Loop {
  int32 loop_id = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression condition = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 label = 3;
  IrExpression body = 4;
  int32 origin_name = 5;
}

message IrReturn {
  int64 return_target = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression value = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrSetField {
  FieldAccessCommon field_access = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression value = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 3;
}

message IrSetValue {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression value = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 3;
}

message IrSpreadElement {
  IrExpression expression = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 coordinates = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrStringConcat {
  repeated IrExpression argument = 1;
}

message IrThrow {
  IrExpression value = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrTry {
  IrExpression result = 1 [features.field_presence = LEGACY_REQUIRED];
  repeated IrStatement catch = 2;
  IrExpression finally = 3;
}

message IrTypeOp {
  IrTypeOperator operator = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 operand = 2 [features.field_presence = LEGACY_REQUIRED];
  IrExpression argument = 3 [features.field_presence = LEGACY_REQUIRED];
}

message IrVararg {
  int32 element_type = 1 [features.field_presence = LEGACY_REQUIRED];
  repeated IrVarargElement element = 2;
}

message IrVarargElement {
  oneof vararg_element {
    IrExpression expression = 1;
    IrSpreadElement spread_element = 2;
  }
}

message IrWhen {
  repeated IrStatement branch = 1;
  int32 origin_name = 2;
}

message IrWhile {
  Loop loop = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrFunctionExpression {
  IrFunction function = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrErrorExpression {
  int32 description = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrErrorCallExpression {
  int32 description = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression receiver = 2;
  repeated IrExpression value_argument = 3;
}

/* ------ Dynamic expression --------------------------------------------- */

message IrDynamicMemberExpression {
  int32 member_name = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression receiver = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrDynamicOperatorExpression {
  enum IrDynamicOperator {
    option features.enum_type = CLOSED;
    UNARY_PLUS = 1;
    UNARY_MINUS = 2;
    EXCL = 3;
    PREFIX_INCREMENT = 4;
    POSTFIX_INCREMENT = 5;
    PREFIX_DECREMENT = 6;
    POSTFIX_DECREMENT = 7;

    BINARY_PLUS = 8;
    BINARY_MINUS = 9;
    MUL = 10;
    DIV = 11;
    MOD = 12;
    GT = 13;
    LT = 14;
    GE = 15;
    LE = 16;
    EQEQ = 17;
    EXCLEQ = 18;
    EQEQEQ = 19;
    EXCLEQEQ = 20;
    ANDAND = 21;
    OROR = 22;

    EQ = 23;
    PLUSEQ = 24;
    MINUSEQ = 25;
    MULEQ = 26;
    DIVEQ = 27;
    MODEQ = 28;

    ARRAY_ACCESS = 29;
    INVOKE = 30;
  }
  IrDynamicOperator operator = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression receiver = 2 [features.field_presence = LEGACY_REQUIRED];
  repeated IrExpression argument = 3;
}

// TODO: we need an extension mechanism to accomodate new
// IR operators in upcoming releases.
message IrOperation {
  oneof operation {
    IrBlock block = 1;
    IrBreak break = 2;
    IrCall call = 3;
    IrClassReference class_reference = 4;
    IrComposite composite = 5;
    IrConst const = 6;
    IrContinue continue = 7;
    IrDelegatingConstructorCall delegating_constructor_call = 8;
    IrDoWhile do_while = 9;
    IrEnumConstructorCall enum_constructor_call = 10;
    IrFunctionReference function_reference = 11;
    IrGetClass get_class = 12;
    IrGetEnumValue get_enum_value = 13;
    IrGetField get_field = 14;
    IrGetObject get_object = 15;
    IrGetValue get_value = 16;
    IrInstanceInitializerCall instance_initializer_call = 17;
    IrPropertyReference property_reference = 18;
    IrReturn return = 19;
    IrSetField set_field = 20;
    IrSetValue set_value = 21;
    IrStringConcat string_concat = 22;
    IrThrow throw = 23;
    IrTry try = 24;
    IrTypeOp type_op = 25;
    IrVararg vararg = 26;
    IrWhen when = 27;
    IrWhile while = 28;
    IrDynamicMemberExpression dynamic_member = 29;
    IrDynamicOperatorExpression dynamic_operator = 30;
    IrLocalDelegatedPropertyReference local_delegated_property_reference = 31;
    IrConstructorCall constructor_call = 32;
    IrFunctionExpression function_expression = 33;
    // Error code
    IrErrorExpression error_expression = 34;
    IrErrorCallExpression error_call_expression = 35;
    // Operations again
    IrReturnableBlock returnable_block = 36;
    IrInlinedFunctionBlock inlined_function_block = 37;
    IrRichFunctionReference rich_function_reference = 38;
    IrRichPropertyReference rich_property_reference = 39;
  }
}

enum IrTypeOperator {
  option features.enum_type = CLOSED;
  CAST = 1;
  IMPLICIT_CAST = 2;
  IMPLICIT_NOTNULL = 3;
  IMPLICIT_COERCION_TO_UNIT = 4;
  IMPLICIT_INTEGER_COERCION = 5;
  SAFE_CAST = 6;
  INSTANCEOF = 7;
  NOT_INSTANCEOF = 8;
  SAM_CONVERSION = 9;
  IMPLICIT_DYNAMIC_CAST = 10;
  REINTERPRET_CAST = 11;
}


message IrExpression {
  IrOperation operation = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 type = 2 [features.field_presence = LEGACY_REQUIRED];
  int64 coordinates = 3 [features.field_presence = LEGACY_REQUIRED];
}

message NullableIrExpression {
  IrExpression expression = 1;
}

/* ------ Declarations --------------------------------------------- */

message IrDeclarationBase {
  int64 symbol = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 origin_name = 2 [features.field_presence = LEGACY_REQUIRED];
  int64 coordinates = 3 [features.field_presence = LEGACY_REQUIRED];
  int64 flags = 4 [default = 0];
  repeated IrConstructorCall annotation = 5;
}

message IrFunctionBase {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  repeated IrTypeParameter type_parameter = 3;
  IrValueParameter dispatch_receiver = 4;
  repeated IrValueParameter context_parameter = 9;
  IrValueParameter extension_receiver = 5;
  repeated IrValueParameter regular_parameter = 6;
  int32 body = 7;
  //int32 context_receiver_parameters_count = 8;
}

message IrFunction {
  IrFunctionBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  repeated int64 overridden = 2; // TODO: supposed to be deleted
  //UniqId corresponding_property = 7;
}

message IrConstructor {
  IrFunctionBase base = 1 [features.field_presence = LEGACY_REQUIRED];
}

message IrField {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 initializer = 3;
}

message IrLocalDelegatedProperty {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  IrVariable delegate = 3;
  IrFunction getter = 4;
  IrFunction setter = 5;
}

message IrProperty {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 name = 2 [features.field_presence = LEGACY_REQUIRED];
  IrField backing_field = 3;
  IrFunction getter = 4;
  IrFunction setter = 5;
}

message IrVariable {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  IrExpression initializer = 3;
}

message IrValueParameter {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 vararg_element_type = 3;
  int32 default_value = 4;
}

message IrTypeParameter {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 name = 2 [features.field_presence = LEGACY_REQUIRED];
  repeated int32 super_type = 3;
}

message IrClass {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 name = 2 [features.field_presence = LEGACY_REQUIRED];
  IrValueParameter this_receiver = 3;
  repeated IrTypeParameter type_parameter = 4;
  repeated IrDeclaration declaration = 5;
  repeated int32 super_type = 6;
  IrInlineClassRepresentation inline_class_representation = 7;
  IrMultiFieldValueClassRepresentation multi_field_value_class_representation = 9;
  repeated int64 sealed_subclass = 8;
}

message IrTypeAlias {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int64 name_type = 2 [features.field_presence = LEGACY_REQUIRED];
  repeated IrTypeParameter type_parameter = 3;
}

message IrEnumEntry {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 name = 2 [features.field_presence = LEGACY_REQUIRED];
  int32 initializer = 3;
  IrClass corresponding_class = 4;
}

message IrAnonymousInit {
  IrDeclarationBase base = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 body = 2 [features.field_presence = LEGACY_REQUIRED];
}

// TODO: we need an extension mechanism to accomodate new
// IR operators in upcoming releases.

message IrDeclaration {
  oneof declarator {
    IrAnonymousInit ir_anonymous_init = 1;
    IrClass ir_class = 2;
    IrConstructor ir_constructor = 3;
    IrEnumEntry ir_enum_entry = 4;
    IrField ir_field = 5;
    IrFunction ir_function = 6;
    IrProperty ir_property = 7;
    IrTypeParameter ir_type_parameter = 8;
    IrVariable ir_variable = 9;
    IrValueParameter ir_value_parameter = 10;
    IrLocalDelegatedProperty ir_local_delegated_property = 11;
    IrTypeAlias ir_type_alias = 12;

    // WARNING: Don't occupy index 13 which was previously used for storing IrErrorDeclaration.
    // IrErrorDeclaration ir_error_declaration = 13;
  }
}

/* ------- IrStatements --------------------------------------------- */

message IrBranch {
  IrExpression condition = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression result = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrBlockBody {
  repeated IrStatement statement = 1;
}

message IrCatch {
  IrVariable catch_parameter = 1 [features.field_presence = LEGACY_REQUIRED];
  IrExpression result = 2 [features.field_presence = LEGACY_REQUIRED];
}

enum IrSyntheticBodyKind {
  option features.enum_type = CLOSED;
  ENUM_VALUES = 1;
  ENUM_VALUEOF = 2;
  ENUM_ENTRIES = 3;
}

message IrSyntheticBody {
  IrSyntheticBodyKind kind = 1 [features.field_presence = LEGACY_REQUIRED];
}

// Let's try to map IrElement as well as IrStatement to IrStatement.
message IrStatement {
  int64 coordinates = 1 [features.field_presence = LEGACY_REQUIRED];
  oneof statement {
    IrDeclaration declaration = 2;
    IrExpression expression = 3;
    IrBlockBody block_body = 4;
    IrBranch branch = 5;
    IrCatch catch = 6;
    IrSyntheticBody synthetic_body = 7;
  }
}

message IrInlineClassRepresentation {
  int32 underlying_property_name = 1 [features.field_presence = LEGACY_REQUIRED];
  int32 underlying_property_type = 2 [features.field_presence = LEGACY_REQUIRED];
}

message IrMultiFieldValueClassRepresentation {
  repeated int32 underlying_property_name = 1;
  repeated int32 underlying_property_type = 2;
}
