/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.formver.plugin.runners;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.TestMetadata;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.generators.tests.GenerateTestsKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@TestMetadata("plugins/formal-verification/testData/diagnostics")
@TestDataPath("$PROJECT_ROOT")
public class FirLightTreeFormVerPluginDiagnosticsTestGenerated extends AbstractFirLightTreeFormVerPluginDiagnosticsTest {
  @Test
  public void testAllFilesPresentInDiagnostics() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics"), Pattern.compile("^(.+)\\.kt$"), null, true);
  }

  @Nested
  @TestMetadata("plugins/formal-verification/testData/diagnostics/bad_contracts")
  @TestDataPath("$PROJECT_ROOT")
  public class Bad_contracts {
    @Test
    public void testAllFilesPresentInBad_contracts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/bad_contracts"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("as_type_contract.kt")
    public void testAs_type_contract() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/as_type_contract.kt");
    }

    @Test
    @TestMetadata("binary_search.kt")
    public void testBinary_search() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/binary_search.kt");
    }

    @Test
    @TestMetadata("cond_effects.kt")
    public void testCond_effects() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/cond_effects.kt");
    }

    @Test
    @TestMetadata("do_not_verify.kt")
    public void testDo_not_verify() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/do_not_verify.kt");
    }

    @Test
    @TestMetadata("is_type_contract.kt")
    public void testIs_type_contract() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/is_type_contract.kt");
    }

    @Test
    @TestMetadata("list.kt")
    public void testList() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/list.kt");
    }

    @Test
    @TestMetadata("returns_booleans.kt")
    public void testReturns_booleans() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/returns_booleans.kt");
    }

    @Test
    @TestMetadata("returns_not_null.kt")
    public void testReturns_not_null() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/returns_not_null.kt");
    }

    @Test
    @TestMetadata("returns_null.kt")
    public void testReturns_null() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/returns_null.kt");
    }

    @Test
    @TestMetadata("viper_verify.kt")
    public void testViper_verify() {
      runTest("plugins/formal-verification/testData/diagnostics/bad_contracts/viper_verify.kt");
    }
  }

  @Nested
  @TestMetadata("plugins/formal-verification/testData/diagnostics/good_contracts")
  @TestDataPath("$PROJECT_ROOT")
  public class Good_contracts {
    @Test
    public void testAllFilesPresentInGood_contracts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/good_contracts"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("as_type_contract.kt")
    public void testAs_type_contract() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/as_type_contract.kt");
    }

    @Test
    @TestMetadata("backing_field_getters.kt")
    public void testBacking_field_getters() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/backing_field_getters.kt");
    }

    @Test
    @TestMetadata("binary_search.kt")
    public void testBinary_search() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/binary_search.kt");
    }

    @Test
    @TestMetadata("custom_list.kt")
    public void testCustom_list() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/custom_list.kt");
    }

    @Test
    @TestMetadata("inline_correctness.kt")
    public void testInline_correctness() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/inline_correctness.kt");
    }

    @Test
    @TestMetadata("is_type_contract.kt")
    public void testIs_type_contract() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/is_type_contract.kt");
    }

    @Test
    @TestMetadata("list.kt")
    public void testList() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/list.kt");
    }

    @Test
    @TestMetadata("multiple_interfaces.kt")
    public void testMultiple_interfaces() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/multiple_interfaces.kt");
    }

    @Test
    @TestMetadata("nullability.kt")
    public void testNullability() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/nullability.kt");
    }

    @Test
    @TestMetadata("override_properties_types.kt")
    public void testOverride_properties_types() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/override_properties_types.kt");
    }

    @Test
    @TestMetadata("private_properties.kt")
    public void testPrivate_properties() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/private_properties.kt");
    }

    @Test
    @TestMetadata("returns_booleans.kt")
    public void testReturns_booleans() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/returns_booleans.kt");
    }

    @Test
    @TestMetadata("returns_null.kt")
    public void testReturns_null() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/returns_null.kt");
    }

    @Test
    @TestMetadata("simple.kt")
    public void testSimple() {
      runTest("plugins/formal-verification/testData/diagnostics/good_contracts/simple.kt");
    }
  }

  @Nested
  @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts")
  @TestDataPath("$PROJECT_ROOT")
  public class No_contracts {
    @Test
    public void testAllFilesPresentInNo_contracts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Test
    @TestMetadata("basic.kt")
    public void testBasic() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/basic.kt");
    }

    @Test
    @TestMetadata("extension_properties.kt")
    public void testExtension_properties() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/extension_properties.kt");
    }

    @Test
    @TestMetadata("full_viper_dump.kt")
    public void testFull_viper_dump() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/full_viper_dump.kt");
    }

    @Test
    @TestMetadata("function_object.kt")
    public void testFunction_object() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/function_object.kt");
    }

    @Test
    @TestMetadata("function_overloading.kt")
    public void testFunction_overloading() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/function_overloading.kt");
    }

    @Test
    @TestMetadata("scope_functions.kt")
    public void testScope_functions() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/scope_functions.kt");
    }

    @Test
    @TestMetadata("shadowing.kt")
    public void testShadowing() {
      runTest("plugins/formal-verification/testData/diagnostics/no_contracts/shadowing.kt");
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts/classes")
    @TestDataPath("$PROJECT_ROOT")
    public class Classes {
      @Test
      public void testAllFilesPresentInClasses() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts/classes"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("field_getters.kt")
      public void testField_getters() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/field_getters.kt");
      }

      @Test
      @TestMetadata("inheritance.kt")
      public void testInheritance() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/inheritance.kt");
      }

      @Test
      @TestMetadata("inheritance_fields.kt")
      public void testInheritance_fields() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/inheritance_fields.kt");
      }

      @Test
      @TestMetadata("interface.kt")
      public void testInterface() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/interface.kt");
      }

      @Test
      @TestMetadata("member_functions.kt")
      public void testMember_functions() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/member_functions.kt");
      }

      @Test
      @TestMetadata("multiple_interfaces.kt")
      public void testMultiple_interfaces() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/multiple_interfaces.kt");
      }

      @Test
      @TestMetadata("predicates.kt")
      public void testPredicates() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/predicates.kt");
      }

      @Test
      @TestMetadata("predicates_access.kt")
      public void testPredicates_access() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/predicates_access.kt");
      }

      @Test
      @TestMetadata("primary_constructors.kt")
      public void testPrimary_constructors() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/primary_constructors.kt");
      }

      @Test
      @TestMetadata("property_getters.kt")
      public void testProperty_getters() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/property_getters.kt");
      }

      @Test
      @TestMetadata("secondary_constructors.kt")
      public void testSecondary_constructors() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/secondary_constructors.kt");
      }

      @Test
      @TestMetadata("setters.kt")
      public void testSetters() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/setters.kt");
      }

      @Test
      @TestMetadata("subtyping.kt")
      public void testSubtyping() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/subtyping.kt");
      }

      @Test
      @TestMetadata("unique_predicates.kt")
      public void testUnique_predicates() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/classes/unique_predicates.kt");
      }
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow")
    @TestDataPath("$PROJECT_ROOT")
    public class Control_flow {
      @Test
      public void testAllFilesPresentInControl_flow() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("exp_side_effects.kt")
      public void testExp_side_effects() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/exp_side_effects.kt");
      }

      @Test
      @TestMetadata("function_call.kt")
      public void testFunction_call() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/function_call.kt");
      }

      @Test
      @TestMetadata("if.kt")
      public void testIf() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/if.kt");
      }

      @Test
      @TestMetadata("loop.kt")
      public void testLoop() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/loop.kt");
      }

      @Test
      @TestMetadata("loop_invariants.kt")
      public void testLoop_invariants() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/loop_invariants.kt");
      }

      @Test
      @TestMetadata("non-local-returns.kt")
      public void testNon_local_returns() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/non-local-returns.kt");
      }

      @Test
      @TestMetadata("recursion.kt")
      public void testRecursion() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/recursion.kt");
      }

      @Test
      @TestMetadata("return_break_continue.kt")
      public void testReturn_break_continue() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/return_break_continue.kt");
      }

      @Test
      @TestMetadata("try_catch.kt")
      public void testTry_catch() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/try_catch.kt");
      }

      @Test
      @TestMetadata("when.kt")
      public void testWhen() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/control_flow/when.kt");
      }
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts/inlining")
    @TestDataPath("$PROJECT_ROOT")
    public class Inlining {
      @Test
      public void testAllFilesPresentInInlining() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts/inlining"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("captured.kt")
      public void testCaptured() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/inlining/captured.kt");
      }

      @Test
      @TestMetadata("inline.kt")
      public void testInline() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/inlining/inline.kt");
      }

      @Test
      @TestMetadata("lambdas.kt")
      public void testLambdas() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/inlining/lambdas.kt");
      }
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts/operators")
    @TestDataPath("$PROJECT_ROOT")
    public class Operators {
      @Test
      public void testAllFilesPresentInOperators() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts/operators"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("arithmetic.kt")
      public void testArithmetic() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/arithmetic.kt");
      }

      @Test
      @TestMetadata("as_operator.kt")
      public void testAs_operator() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/as_operator.kt");
      }

      @Test
      @TestMetadata("boolean_logic.kt")
      public void testBoolean_logic() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/boolean_logic.kt");
      }

      @Test
      @TestMetadata("comparison.kt")
      public void testComparison() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/comparison.kt");
      }

      @Test
      @TestMetadata("elvis.kt")
      public void testElvis() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/elvis.kt");
      }

      @Test
      @TestMetadata("is_operator.kt")
      public void testIs_operator() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/is_operator.kt");
      }

      @Test
      @TestMetadata("safe_call.kt")
      public void testSafe_call() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/operators/safe_call.kt");
      }
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/no_contracts/types")
    @TestDataPath("$PROJECT_ROOT")
    public class Types {
      @Test
      public void testAllFilesPresentInTypes() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/no_contracts/types"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("any.kt")
      public void testAny() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/types/any.kt");
      }

      @Test
      @TestMetadata("generics.kt")
      public void testGenerics() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/types/generics.kt");
      }

      @Test
      @TestMetadata("nullable.kt")
      public void testNullable() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/types/nullable.kt");
      }

      @Test
      @TestMetadata("smartcast.kt")
      public void testSmartcast() {
        runTest("plugins/formal-verification/testData/diagnostics/no_contracts/types/smartcast.kt");
      }
    }
  }

  @Nested
  @TestMetadata("plugins/formal-verification/testData/diagnostics/uniqueness")
  @TestDataPath("$PROJECT_ROOT")
  public class Uniqueness {
    @Test
    public void testAllFilesPresentInUniqueness() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/uniqueness"), Pattern.compile("^(.+)\\.kt$"), null, true);
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/uniqueness/bad_unique")
    @TestDataPath("$PROJECT_ROOT")
    public class Bad_unique {
      @Test
      public void testAllFilesPresentInBad_unique() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/uniqueness/bad_unique"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("direct_pass_shared_to_unique.kt")
      public void testDirect_pass_shared_to_unique() {
        runTest("plugins/formal-verification/testData/diagnostics/uniqueness/bad_unique/direct_pass_shared_to_unique.kt");
      }
    }

    @Nested
    @TestMetadata("plugins/formal-verification/testData/diagnostics/uniqueness/good_unique")
    @TestDataPath("$PROJECT_ROOT")
    public class Good_unique {
      @Test
      public void testAllFilesPresentInGood_unique() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("plugins/formal-verification/testData/diagnostics/uniqueness/good_unique"), Pattern.compile("^(.+)\\.kt$"), null, true);
      }

      @Test
      @TestMetadata("shared_to_shared.kt")
      public void testShared_to_shared() {
        runTest("plugins/formal-verification/testData/diagnostics/uniqueness/good_unique/shared_to_shared.kt");
      }
    }
  }
}
