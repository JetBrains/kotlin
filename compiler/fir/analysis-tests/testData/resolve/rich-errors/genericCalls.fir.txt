FILE: genericCalls.kt
    public final object E1 : R|kotlin/Nothing | Error| {
        private constructor(): R|kotlin/Nothing | E1| {
            super<R|kotlin/Nothing | Error|>()
        }

    }
    public final object E2 : R|kotlin/Nothing | Error| {
        private constructor(): R|kotlin/Nothing | E2| {
            super<R|kotlin/Nothing | Error|>()
        }

    }
    public final object E3 : R|kotlin/Nothing | Error| {
        private constructor(): R|kotlin/Nothing | E3| {
            super<R|kotlin/Nothing | Error|>()
        }

    }
    public final fun <T> foo1(t: R|T|): R|kotlin/Unit| {
    }
    public final fun <T : R|kotlin/Any? | E1 | E2 | E3|> foo2(t: R|T|): R|kotlin/Unit| {
    }
    public final fun <T : R|kotlin/Any? | E1 | E2|> foo3(t: R|T|): R|kotlin/Unit| {
    }
    public final fun <T : R|kotlin/Nothing | E1 | E2|> foo4(t: R|kotlin/Nothing | T|): R|kotlin/Unit| {
    }
    public final fun <T : R|kotlin/Nothing | E1 | E2|> foo5(t1: R|kotlin/Nothing | T|, t2: R|kotlin/Nothing | T|): R|kotlin/Unit| {
    }
    public final fun <T : R|kotlin/Nothing | E1 | E2|, V : R|kotlin/Nothing | T|> foo6(t1: R|kotlin/Nothing | T|, t2: R|kotlin/Nothing | V|): R|kotlin/Unit| {
    }
    public final fun bar(): R|kotlin/Unit| {
        R|/foo1<Inapplicable(INAPPLICABLE): /foo1>#|<<ERROR TYPE REF: Cannot infer argument for type parameter T>>(Q|E1|)
        R|/foo1<Inapplicable(INAPPLICABLE): /foo1>#|<<ERROR TYPE REF: Cannot infer argument for type parameter T>>(Q|E2|)
        R|/foo1<Inapplicable(INAPPLICABLE): /foo1>#|<<ERROR TYPE REF: Cannot infer argument for type parameter T>>(Q|E3|)
        R|/foo2|<R|kotlin/Nothing | E1|>(Q|E1|)
        R|/foo2|<R|kotlin/Nothing | E2|>(Q|E2|)
        R|/foo2|<R|kotlin/Nothing | E3|>(Q|E3|)
        R|/foo3|<R|kotlin/Nothing | E1|>(Q|E1|)
        R|/foo3|<R|kotlin/Nothing | E2|>(Q|E2|)
        R|/foo3<Inapplicable(INAPPLICABLE): /foo3>#|<<ERROR TYPE REF: Cannot infer argument for type parameter T>>(Q|E3|)
        R|/foo4|<R|kotlin/Nothing | E1|>(Q|E1|)
        R|/foo4|<R|kotlin/Nothing | E2|>(Q|E2|)
        R|/foo4<Inapplicable(INAPPLICABLE): /foo4>#|<R|kotlin/Nothing | TypeVariable(T)|>(Q|E3|)
        R|/foo5|<R|kotlin/Nothing | E1|>(Q|E1|, Q|E1|)
        R|/foo5|<R|kotlin/Nothing | E1 | E2|>(Q|E1|, Q|E2|)
        R|/foo5<Inapplicable(INAPPLICABLE): /foo5>#|<R|kotlin/Nothing | E1|>(Q|E1|, Q|E3|)
        R|/foo5|<R|kotlin/Nothing | E2 | E1|>(Q|E2|, Q|E1|)
        R|/foo5|<R|kotlin/Nothing | E2|>(Q|E2|, Q|E2|)
        R|/foo5<Inapplicable(INAPPLICABLE): /foo5>#|<R|kotlin/Nothing | E2|>(Q|E2|, Q|E3|)
        R|/foo5<Inapplicable(INAPPLICABLE): /foo5>#|<R|kotlin/Nothing | TypeVariable(T)|>(Q|E3|, Q|E1|)
        R|/foo5<Inapplicable(INAPPLICABLE): /foo5>#|<R|kotlin/Nothing | TypeVariable(T)|>(Q|E3|, Q|E2|)
        R|/foo5<Inapplicable(INAPPLICABLE): /foo5>#|<R|kotlin/Nothing | TypeVariable(T)|>(Q|E3|, Q|E3|)
        R|/foo6|<R|kotlin/Nothing | E1|, R|kotlin/Nothing | E1|>(Q|E1|, Q|E1|)
        R|/foo6|<R|kotlin/Nothing | E1 | E2|, R|kotlin/Nothing | E2|>(Q|E1|, Q|E2|)
        R|/foo6<Inapplicable(INAPPLICABLE): /foo6>#|<R|kotlin/Nothing | E1|, R|kotlin/Nothing | TypeVariable(V)|>(Q|E1|, Q|E3|)
        R|/foo6|<R|kotlin/Nothing | E2 | E1|, R|kotlin/Nothing | E1|>(Q|E2|, Q|E1|)
        R|/foo6|<R|kotlin/Nothing | E2|, R|kotlin/Nothing | E2|>(Q|E2|, Q|E2|)
        R|/foo6<Inapplicable(INAPPLICABLE): /foo6>#|<R|kotlin/Nothing | E2|, R|kotlin/Nothing | TypeVariable(V)|>(Q|E2|, Q|E3|)
        R|/foo6<Inapplicable(INAPPLICABLE): /foo6>#|<R|kotlin/Nothing | TypeVariable(T)|, R|kotlin/Nothing | TypeVariable(V)|>(Q|E3|, Q|E1|)
        R|/foo6<Inapplicable(INAPPLICABLE): /foo6>#|<R|kotlin/Nothing | TypeVariable(T)|, R|kotlin/Nothing | TypeVariable(V)|>(Q|E3|, Q|E2|)
        R|/foo6<Inapplicable(INAPPLICABLE): /foo6>#|<R|kotlin/Nothing | TypeVariable(T)|, R|kotlin/Nothing | TypeVariable(V)|>(Q|E3|, Q|E3|)
    }
    public final inline fun <T, E1 : R|kotlin/Nothing | Error|, E2 : R|kotlin/Nothing | Error|> R|T | E1|.onError(f: R|(kotlin/Nothing | E1) -> kotlin/Nothing | E2|): R|T | E2| {
        when () {
            (this@R|/onError| is R|kotlin/Nothing | Error|) ->  {
                ^onError R|<local>/f|.R|SubstitutionOverride<kotlin/Function1.invoke: R|kotlin/Nothing | E2|>|(this@R|/onError|)
            }
            else ->  {
                ^onError this@R|/onError|
            }
        }

    }
    public final fun onErrorCaller(v: R|kotlin/Int | E1|): R|kotlin/Nothing | E1| {
        lval v2: R|kotlin/Int| = R|<local>/v|.R|/onError|<R|kotlin/Int|, R|kotlin/Nothing | E1|, R|kotlin/Nothing | TypeVariable(E2)|>(<L> = onError@fun <anonymous>(it: R|kotlin/Nothing | E1|): R|kotlin/Nothing | TypeVariable(E2)| <inline=Inline, kind=UNKNOWN>  {
            ^onErrorCaller R|<local>/it|
        }
        )
        lval v3: R|kotlin/Int| = R|<local>/v2|
        Null(null)!!
    }
