package test

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) public/*package*/ final annotation class A : kotlin.Annotation {
    public/*package*/ constructor A(/*0*/ value: kotlin.String = ...)
    public final val value: kotlin.String
}

public/*package*/ interface G0 {
}

public/*package*/ interface G1</*0*/ T : kotlin.Any!> {
}

public/*package*/ interface G2</*0*/ A : kotlin.Any!, /*1*/ B : kotlin.Any!> {
}

public/*package*/ interface ReturnType {
    public abstract fun f0(): test.G1<@test.A test.G0!>!
    public abstract fun f1(): test.G1<test.G1<test.G1<test.G1<@test.A test.G0!>!>!>!>!
    public abstract fun f11(): test.G2<in @test.A kotlin.String!, test.G2<in @test.A(value = "abc") kotlin.Int!, test.G2<in @test.A(value = "abc") test.G2<kotlin.Int!, in @test.A kotlin.Int!>!, in @test.A(value = "abc") kotlin.Int!>!>!>!
    public abstract fun f13(): (@test.A kotlin.Array<kotlin.Int!>..@test.A kotlin.Array<out kotlin.Int!>?)
    public abstract fun f14(): @test.A kotlin.IntArray!
    public abstract fun f15(): kotlin.Array<(out) @test.A kotlin.Int!>!
    public abstract fun f16(): kotlin.IntArray!
    public abstract fun f17(): (@test.A kotlin.Array<@test.A kotlin.Int!>..@test.A kotlin.Array<out @test.A kotlin.Int!>?)
    public abstract fun f19(): (@test.A kotlin.Array<kotlin.Array<(out) kotlin.Int!>!>..@test.A kotlin.Array<out kotlin.Array<(out) kotlin.Int!>!>?)
    public abstract fun f2(): test.G1<@test.A kotlin.String!>!
    public abstract fun f20(): (@test.A kotlin.Array<@test.A kotlin.IntArray!>..@test.A kotlin.Array<out @test.A kotlin.IntArray!>?)
    public abstract fun f22(): (@test.A kotlin.Array<(@test.A kotlin.Array<kotlin.Array<(out) @test.A kotlin.IntArray!>!>..@test.A kotlin.Array<out kotlin.Array<(out) @test.A kotlin.IntArray!>!>?)>..@test.A kotlin.Array<out (@test.A kotlin.Array<kotlin.Array<(out) @test.A kotlin.IntArray!>!>..@test.A kotlin.Array<out kotlin.Array<(out) @test.A kotlin.IntArray!>!>?)>?)
    public abstract fun f23(): (@test.A kotlin.Array<kotlin.Array<(out) (@test.A kotlin.Array<kotlin.Array<(out) @test.A kotlin.Int!>!>..@test.A kotlin.Array<out kotlin.Array<(out) @test.A kotlin.Int!>!>?)>!>..@test.A kotlin.Array<out kotlin.Array<(out) (@test.A kotlin.Array<kotlin.Array<(out) @test.A kotlin.Int!>!>..@test.A kotlin.Array<out kotlin.Array<(out) @test.A kotlin.Int!>!>?)>!>?)
    public abstract fun f25(): kotlin.Array<(out) @test.A kotlin.IntArray!>!
    public abstract fun f26(): kotlin.Array<(out) (@test.A kotlin.Array<kotlin.Any!>..@test.A kotlin.Array<out kotlin.Any!>?)>!
    public abstract fun f27(): kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) (@test.A kotlin.Array<@test.A kotlin.Any!>..@test.A kotlin.Array<out @test.A kotlin.Any!>?)>!>!>!>!
    public abstract fun f28(): test.G1<(@test.A kotlin.Array<kotlin.Int!>..@test.A kotlin.Array<out kotlin.Int!>?)>!
    public abstract fun f29(): test.G2<kotlin.Int!, @test.A kotlin.IntArray!>!
    public abstract fun f3(): test.G2<@test.A kotlin.String!, test.G2<@test.A(value = "abc") kotlin.Int!, test.G2<@test.A(value = "abc") test.G2<kotlin.Int!, @test.A kotlin.Int!>!, @test.A(value = "abc") kotlin.Int!>!>!>!
    public abstract fun f30(): test.G1<kotlin.Array<(out) @test.A kotlin.Int!>!>!
    public abstract fun f31(): test.G1<test.G1<kotlin.IntArray!>!>!
    public abstract fun f32(): test.G1<test.G2<test.G1<(@test.A kotlin.Array<@test.A kotlin.Int!>..@test.A kotlin.Array<out @test.A kotlin.Int!>?)>!, test.G1<@test.A kotlin.IntArray!>!>!>!
    public abstract fun f33(): test.G1<@test.A kotlin.IntArray!>!
    public abstract fun f34(): test.G1<kotlin.Array<(out) (@test.A kotlin.Array<kotlin.Int!>..@test.A kotlin.Array<out kotlin.Int!>?)>!>!
    public abstract fun f36(): test.G1<(@test.A kotlin.Array<kotlin.Array<(out) @test.A kotlin.Int!>!>..@test.A kotlin.Array<out kotlin.Array<(out) @test.A kotlin.Int!>!>?)>!
    public abstract fun f37(): test.G1<test.G1<kotlin.Array<(out) kotlin.Array<(out) kotlin.IntArray!>!>!>!>!
    public abstract fun f38(): test.G1<test.G2<test.G1<(@test.A kotlin.Array<@test.A kotlin.Int!>..@test.A kotlin.Array<out @test.A kotlin.Int!>?)>!, test.G1<kotlin.Array<(out) kotlin.Array<(out) @test.A kotlin.IntArray!>!>!>!>!>!
    public abstract fun f39(): test.G1<(@test.A kotlin.Array<(@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)>..@test.A kotlin.Array<out (@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)>?)>!
    public abstract fun f40(): test.G1<out (@test.A kotlin.Array<kotlin.Int!>..@test.A kotlin.Array<out kotlin.Int!>?)>!
    public abstract fun f41(): test.G2<out kotlin.Int!, in @test.A kotlin.IntArray!>!
    public abstract fun f42(): test.G1<in kotlin.Array<(out) @test.A kotlin.Int!>!>!
    public abstract fun f43(): test.G1<in test.G1<in kotlin.IntArray!>!>!
    public abstract fun f44(): test.G1<out test.G2<test.G1<in (@test.A kotlin.Array<@test.A kotlin.Int!>..@test.A kotlin.Array<out @test.A kotlin.Int!>?)>!, test.G1<out @test.A kotlin.IntArray!>!>!>!
    public abstract fun f46(): test.G1<in @test.A kotlin.IntArray!>!
    public abstract fun f47(): test.G1<out kotlin.Array<(out) (@test.A kotlin.Array<kotlin.Int!>..@test.A kotlin.Array<out kotlin.Int!>?)>!>!
    public abstract fun f49(): test.G1<in kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) @test.A kotlin.Int!>!>!>!>!>!>!
    public abstract fun f5(): test.G1<test.G1<test.G1<test.G1<out @test.A test.G0!>!>!>!>!
    public abstract fun f50(): test.G1<in test.G1<in (@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)>!>!
    public abstract fun f51(): test.G1<out test.G2<test.G1<in kotlin.Array<(out) kotlin.Array<(out) (@test.A kotlin.Array<@test.A kotlin.Int!>..@test.A kotlin.Array<out @test.A kotlin.Int!>?)>!>!>!, test.G1<out (@test.A kotlin.Array<(@test.A kotlin.Array<@test.A kotlin.IntArray!>..@test.A kotlin.Array<out @test.A kotlin.IntArray!>?)>..@test.A kotlin.Array<out (@test.A kotlin.Array<@test.A kotlin.IntArray!>..@test.A kotlin.Array<out @test.A kotlin.IntArray!>?)>?)>!>!>!
    public abstract fun f53(): test.G1<in (@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)>!
    public abstract fun f6(): test.G1<out @test.A kotlin.String!>!
    public abstract fun f7(): test.G2<out @test.A kotlin.String!, test.G2<out @test.A(value = "abc") kotlin.Int!, test.G2<out @test.A(value = "abc") test.G2<kotlin.Int!, out @test.A kotlin.Int!>!, out @test.A(value = "abc") kotlin.Int!>!>!>!
    public abstract fun f8(): test.G1<in @test.A test.G0!>!
    public abstract fun f9(): test.G1<test.G1<test.G1<test.G1<in @test.A test.G0!>!>!>!>!

    public open class ReturnType2 {
        public constructor ReturnType2()
        public/*package*/ final var f10: test.G1<in kotlin.String!>!
        public/*package*/ final var f12: test.G2<in kotlin.String!, test.G2<out kotlin.Int!, test.G2<out test.G2<kotlin.Int!, in kotlin.Int!>!, out kotlin.Int!>!>!>!
        public/*package*/ final var f18: @test.A kotlin.IntArray!
        public/*package*/ final var f21: kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Int!>!>!>!
        public/*package*/ final var f24: (@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)
        public/*package*/ final var f35: test.G2<kotlin.Int!, kotlin.Array<(out) kotlin.IntArray!>!>!
        public/*package*/ final var f4: test.G1<out test.G0!>!
        public/*package*/ final var f45: test.G1<out test.G2<in test.G1<kotlin.Array<(out) kotlin.Int!>!>!, test.G1<out kotlin.IntArray!>!>!>!
        public/*package*/ final var f48: test.G2<out kotlin.Int!, in kotlin.Array<(out) kotlin.Array<(out) kotlin.IntArray!>!>!>!
        public/*package*/ final var f52: test.G1<out test.G2<in test.G1<kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Int!>!>!>!>!, test.G1<out kotlin.Array<(out) kotlin.IntArray!>!>!>!>!
    }

    // Static members
    public final val f10: test.G1<in kotlin.String!>!
    public final val f12: test.G2<in kotlin.String!, test.G2<out kotlin.Int!, test.G2<out test.G2<kotlin.Int!, in kotlin.Int!>!, out kotlin.Int!>!>!>!
    public final val f18: @test.A kotlin.IntArray!
    public final val f21: kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Int!>!>!>!
    public final val f24: (@test.A kotlin.Array<kotlin.IntArray!>..@test.A kotlin.Array<out kotlin.IntArray!>?)
    public final val f35: test.G2<kotlin.Int!, kotlin.Array<(out) kotlin.IntArray!>!>!
    public final val f4: test.G1<out test.G0!>!
    public final val f45: test.G1<out test.G2<in test.G1<kotlin.Array<(out) kotlin.Int!>!>!, test.G1<out kotlin.IntArray!>!>!>!
    public final val f48: test.G2<out kotlin.Int!, in kotlin.Array<(out) kotlin.Array<(out) kotlin.IntArray!>!>!>!
    public final val f52: test.G1<out test.G2<in test.G1<kotlin.Array<(out) kotlin.Array<(out) kotlin.Array<(out) kotlin.Int!>!>!>!>!, test.G1<out kotlin.Array<(out) kotlin.IntArray!>!>!>!>!
}
