package

public final class C1 : java.util.Hashtable<kotlin.String, kotlin.Int> {
    public constructor C1()
    invisible_fake final override /*1*/ /*fake_override*/ var count: kotlin.Int
    public open override /*1*/ /*fake_override*/ val entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<kotlin.String!, kotlin.Int!>>
    invisible_fake final override /*1*/ /*fake_override*/ var entrySet: kotlin.collections.(Mutable)Set<kotlin.collections.(Mutable)Map.(Mutable)Entry<kotlin.String!, kotlin.Int!>!>!
    invisible_fake final override /*1*/ /*fake_override*/ var keySet: kotlin.collections.(Mutable)Set<kotlin.String!>!
    public open override /*1*/ /*fake_override*/ val keys: kotlin.collections.MutableSet<kotlin.String!>
    invisible_fake final override /*1*/ /*fake_override*/ var loadFactor: kotlin.Float
    invisible_fake final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
    public open override /*1*/ /*fake_override*/ val size: kotlin.Int
    invisible_fake final override /*1*/ /*fake_override*/ var table: kotlin.Array<(out) java.util.Hashtable.Entry<*, *>!>!
    invisible_fake final override /*1*/ /*fake_override*/ var threshold: kotlin.Int
    invisible_fake final override /*1*/ /*fake_override*/ var values: kotlin.collections.(Mutable)Collection<kotlin.Int!>!
    public open override /*1*/ /*fake_override*/ val values: kotlin.collections.MutableCollection<kotlin.Int!>
    invisible_fake open override /*1*/ /*fake_override*/ fun addEntry(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int!, /*3*/ p3: kotlin.Int): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any
    public open override /*1*/ /*fake_override*/ fun compute(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int?, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun computeIfAbsent(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.Function<in kotlin.String!, out kotlin.Int!>): kotlin.Int!
    public open override /*1*/ /*fake_override*/ fun computeIfPresent(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: kotlin.Any!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.String!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun elements(): java.util.Enumeration<kotlin.Int!>!
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.BiConsumer<in kotlin.String!, in kotlin.Int!>): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.String!): kotlin.Int?
    invisible_fake open override /*1*/ /*fake_override*/ fun </*0*/ T : kotlin.Any!> getEnumeration(/*0*/ p0: kotlin.Int): java.util.Enumeration<T!>!
    invisible_fake open override /*1*/ /*fake_override*/ fun </*0*/ T : kotlin.Any!> getIterator(/*0*/ p0: kotlin.Int): kotlin.collections.(Mutable)Iterator<T!>!
    public open override /*1*/ /*fake_override*/ fun getOrDefault(/*0*/ key: kotlin.String!, /*1*/ defaultValue: kotlin.Int!): kotlin.Int!
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun keys(): java.util.Enumeration<kotlin.String!>!
    public open override /*1*/ /*fake_override*/ fun merge(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.function.BiFunction<in kotlin.Int, in kotlin.Int, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun put(/*0*/ key: kotlin.String!, /*1*/ value: kotlin.Int!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ from: kotlin.collections.Map<out kotlin.String!, kotlin.Int!>): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun putIfAbsent(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!): kotlin.Int?
    invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
    invisible_fake open override /*1*/ /*fake_override*/ fun reconstitutionPut(/*0*/ p0: kotlin.Array<(out) java.util.Hashtable.Entry<*, *>!>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int!): kotlin.Unit
    protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun rehash(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.String!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.String!, /*1*/ value: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun replace(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun replace(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!, /*2*/ p2: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun replaceAll(/*0*/ p0: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int!, out kotlin.Int!>): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
    invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit
}

public final class C2 : java.util.Hashtable<kotlin.String, kotlin.Int> {
    public constructor C2()
    invisible_fake final override /*1*/ /*fake_override*/ var count: kotlin.Int
    public open override /*1*/ /*fake_override*/ val entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<kotlin.String!, kotlin.Int!>>
    invisible_fake final override /*1*/ /*fake_override*/ var entrySet: kotlin.collections.(Mutable)Set<kotlin.collections.(Mutable)Map.(Mutable)Entry<kotlin.String!, kotlin.Int!>!>!
    invisible_fake final override /*1*/ /*fake_override*/ var keySet: kotlin.collections.(Mutable)Set<kotlin.String!>!
    public open override /*1*/ /*fake_override*/ val keys: kotlin.collections.MutableSet<kotlin.String!>
    invisible_fake final override /*1*/ /*fake_override*/ var loadFactor: kotlin.Float
    invisible_fake final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
    public open override /*1*/ /*fake_override*/ val size: kotlin.Int
    invisible_fake final override /*1*/ /*fake_override*/ var table: kotlin.Array<(out) java.util.Hashtable.Entry<*, *>!>!
    invisible_fake final override /*1*/ /*fake_override*/ var threshold: kotlin.Int
    invisible_fake final override /*1*/ /*fake_override*/ var values: kotlin.collections.(Mutable)Collection<kotlin.Int!>!
    public open override /*1*/ /*fake_override*/ val values: kotlin.collections.MutableCollection<kotlin.Int!>
    invisible_fake open override /*1*/ /*fake_override*/ fun addEntry(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int!, /*3*/ p3: kotlin.Int): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any
    public open override /*1*/ /*fake_override*/ fun compute(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int?, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun computeIfAbsent(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.Function<in kotlin.String!, out kotlin.Int!>): kotlin.Int!
    public open override /*1*/ /*fake_override*/ fun computeIfPresent(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: kotlin.Any!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.String!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun elements(): java.util.Enumeration<kotlin.Int!>!
    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.BiConsumer<in kotlin.String!, in kotlin.Int!>): kotlin.Unit
    public open override /*1*/ fun get(/*0*/ key: kotlin.String): kotlin.Int
    invisible_fake open override /*1*/ /*fake_override*/ fun </*0*/ T : kotlin.Any!> getEnumeration(/*0*/ p0: kotlin.Int): java.util.Enumeration<T!>!
    invisible_fake open override /*1*/ /*fake_override*/ fun </*0*/ T : kotlin.Any!> getIterator(/*0*/ p0: kotlin.Int): kotlin.collections.(Mutable)Iterator<T!>!
    public open override /*1*/ /*fake_override*/ fun getOrDefault(/*0*/ key: kotlin.String!, /*1*/ defaultValue: kotlin.Int!): kotlin.Int!
    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun keys(): java.util.Enumeration<kotlin.String!>!
    public open override /*1*/ /*fake_override*/ fun merge(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.function.BiFunction<in kotlin.Int, in kotlin.Int, out kotlin.Int?>): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun put(/*0*/ key: kotlin.String!, /*1*/ value: kotlin.Int!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ from: kotlin.collections.Map<out kotlin.String!, kotlin.Int!>): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun putIfAbsent(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!): kotlin.Int?
    invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
    invisible_fake open override /*1*/ /*fake_override*/ fun reconstitutionPut(/*0*/ p0: kotlin.Array<(out) java.util.Hashtable.Entry<*, *>!>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int!): kotlin.Unit
    protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun rehash(): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.String!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.String!, /*1*/ value: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun replace(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!): kotlin.Int?
    public open override /*1*/ /*fake_override*/ fun replace(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!, /*2*/ p2: kotlin.Int!): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun replaceAll(/*0*/ p0: java.util.function.BiFunction<in kotlin.String!, in kotlin.Int!, out kotlin.Int!>): kotlin.Unit
    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
    invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit
}
