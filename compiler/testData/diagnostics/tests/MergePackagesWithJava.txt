package 

package java {
    internal val c: java.lang.Class<*>? = null
    internal val </*0*/ T> kotlin.Array<T>?.length: kotlin.Int

    package java.awt {

        public open class AWTKeyStroke : java.io.Serializable {
            protected/*protected and package*/ constructor AWTKeyStroke()
            protected/*protected and package*/ constructor AWTKeyStroke(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean)
            private final var keyChar: kotlin.Char
            private final var keyCode: kotlin.Int
            private final var modifiers: kotlin.Int
            private final var onKeyRelease: kotlin.Boolean
            public final override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public final fun getKeyChar(): kotlin.Char
            public final fun getKeyCode(): kotlin.Int
            public final fun getKeyEventType(): kotlin.Int
            public final fun getModifiers(): kotlin.Int
            public open override /*1*/ fun hashCode(): kotlin.Int
            public final fun isOnKeyRelease(): kotlin.Boolean
            protected/*protected and package*/ open fun readResolve(): kotlin.Any!
            public open override /*1*/ fun toString(): kotlin.String!

            // Static members
            private final var APP_CONTEXT_CACHE_KEY: kotlin.Any!
            private final var APP_CONTEXT_KEYSTROKE_KEY: java.awt.AWTKeyStroke!
            private final var modifierKeywords: kotlin.(Mutable)Map<*, *>!
            public/*package*/ final val serialVersionUID: kotlin.Long = -6430539691155161871.toLong()
            private final var vks: [ERROR : Unresolved java classifier: VKCollection]!
            public open fun getAWTKeyStroke(/*0*/ p0: kotlin.Char): java.awt.AWTKeyStroke!
            public open fun getAWTKeyStroke(/*0*/ p0: kotlin.Char!, /*1*/ p1: kotlin.Int): java.awt.AWTKeyStroke!
            public open fun getAWTKeyStroke(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.AWTKeyStroke!
            public open fun getAWTKeyStroke(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.AWTKeyStroke!
            public open fun getAWTKeyStroke(/*0*/ p0: kotlin.String!): java.awt.AWTKeyStroke!
            private open fun getAWTKeyStrokeClass(): java.lang.Class<*>!
            public open fun getAWTKeyStrokeForEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): java.awt.AWTKeyStroke!
            private open fun getCachedStroke(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean): java.awt.AWTKeyStroke!
            private open fun getCtor(/*0*/ p0: java.lang.Class<*>!): java.lang.reflect.Constructor<*>!
            public/*package*/ open fun getModifiersText(/*0*/ p0: kotlin.Int): kotlin.String!
            private open fun getVKCollection(): [ERROR : Unresolved java classifier: VKCollection]!
            public/*package*/ open fun getVKText(/*0*/ p0: kotlin.Int): kotlin.String!
            private open fun getVKValue(/*0*/ p0: kotlin.String!): kotlin.Int
            private open fun mapNewModifiers(/*0*/ p0: kotlin.Int): kotlin.Int
            private open fun mapOldModifiers(/*0*/ p0: kotlin.Int): kotlin.Int
            protected/*protected static*/ open fun registerSubclass(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
        }

        public abstract class Component : java.io.Serializable {
            protected/*protected and package*/ constructor Component()
            private final var acc: [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ final var accessibleContext: [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ final var appContext: [ERROR : Unresolved java classifier: AppContext]!
            private final var autoFocusTransferOnDisposal: kotlin.Boolean
            public/*package*/ final var background: [ERROR : Unresolved java classifier: Color]!
            public/*package*/ final var backgroundEraseDisabled: kotlin.Boolean
            private final var boundsOp: kotlin.Int
            public/*package*/ final var bufferStrategy: [ERROR : Unresolved java classifier: BufferStrategy]!
            private final var changeSupport: [ERROR : Unresolved java classifier: PropertyChangeSupport]!
            private final var coalescingEnabled: kotlin.Boolean
            public/*package*/ final var componentListener: [ERROR : Unresolved java classifier: ComponentListener]!
            public/*package*/ final var componentOrientation: [ERROR : Unresolved java classifier: ComponentOrientation]!
            private final var componentSerializedDataVersion: kotlin.Int
            private final var compoundShape: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final var cursor: [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final var dropTarget: [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ final var enabled: kotlin.Boolean
            public/*package*/ final var eventCache: kotlin.Array<(out) [ERROR : Unresolved java classifier: EventQueueItem]!>!
            public/*package*/ final var eventMask: kotlin.Long
            public/*package*/ final var focusListener: [ERROR : Unresolved java classifier: FocusListener]!
            public/*package*/ final var focusTraversalKeys: kotlin.Array<(out) kotlin.(Mutable)Set<*>!>!
            private final var focusTraversalKeysEnabled: kotlin.Boolean
            private final var focusable: kotlin.Boolean
            public/*package*/ final var font: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final var foreground: [ERROR : Unresolved java classifier: Color]!
            private final var graphicsConfig: [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final var height: kotlin.Int
            public/*package*/ final var hierarchyBoundsListener: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!
            public/*package*/ final var hierarchyListener: [ERROR : Unresolved java classifier: HierarchyListener]!
            public/*package*/ final var ignoreRepaint: kotlin.Boolean
            public/*package*/ final var inputMethodListener: [ERROR : Unresolved java classifier: InputMethodListener]!
            private final var isAddNotifyComplete: kotlin.Boolean
            private final var isFocusTraversableOverridden: kotlin.Int
            public/*package*/ final var isPacked: kotlin.Boolean
            public/*package*/ final var keyListener: [ERROR : Unresolved java classifier: KeyListener]!
            public/*package*/ final var locale: java.util.Locale!
            public/*package*/ final var maxSize: java.awt.Dimension!
            public/*package*/ final var maxSizeSet: kotlin.Boolean
            public/*package*/ final var minSize: java.awt.Dimension!
            public/*package*/ final var minSizeSet: kotlin.Boolean
            private final var mixingCutoutRegion: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final var mouseListener: [ERROR : Unresolved java classifier: MouseListener]!
            public/*package*/ final var mouseMotionListener: [ERROR : Unresolved java classifier: MouseMotionListener]!
            public/*package*/ final var mouseWheelListener: [ERROR : Unresolved java classifier: MouseWheelListener]!
            private final var name: kotlin.String!
            private final var nameExplicitlySet: kotlin.Boolean
            public/*package*/ final var newEventsOnly: kotlin.Boolean
            private final var objectLock: kotlin.Any!
            public/*package*/ final var parent: java.awt.Container!
            public/*package*/ final var peer: [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ final var peerFont: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final var popups: [ERROR : Unresolved java classifier: Vector]!
            public/*package*/ final var prefSize: java.awt.Dimension!
            public/*package*/ final var prefSizeSet: kotlin.Boolean
            private final var valid: kotlin.Boolean
            public/*package*/ final var visible: kotlin.Boolean
            public/*package*/ final var width: kotlin.Int
            public/*package*/ final var windowClosingException: java.lang.RuntimeException!
            public/*package*/ final var x: kotlin.Int
            public/*package*/ final var y: kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun action(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open fun add(/*0*/ p0: [ERROR : Unresolved java classifier: PopupMenu]!): kotlin.Unit
            public open fun addComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open fun addHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open fun addHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            public open fun addInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open fun addKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open fun addMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open fun addMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open fun addMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open fun addNotify(): kotlin.Unit
            public open fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open fun addPropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public/*package*/ open fun adjustListeningChildrenOnParent(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun applyComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public/*package*/ open fun applyCompoundShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ open fun applyCurrentShape(): kotlin.Unit
            private final fun applyCurrentShapeBelowMe(): kotlin.Unit
            public/*package*/ final fun areBoundsValid(): kotlin.Boolean
            public open fun areFocusTraversalKeysSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ open fun areInputMethodsEnabled(): kotlin.Boolean
            public/*package*/ open fun autoProcessMouseWheel(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun bounds(): [ERROR : Unresolved java classifier: Rectangle]!
            private open fun calculateCurrentShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final fun canBeFocusOwner(): kotlin.Boolean
            public/*package*/ final fun canBeFocusOwnerRecursively(): kotlin.Boolean
            private open fun checkCoalescing(): kotlin.Boolean
            public/*package*/ open fun checkGD(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            public open fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            public/*package*/ final fun checkTreeLock(): kotlin.Unit
            public/*package*/ open fun checkWindowClosingException(): kotlin.Boolean
            public/*package*/ open fun clearCurrentFocusCycleRootOnHide(): kotlin.Unit
            public/*package*/ open fun clearMostRecentFocusOwnerOnHide(): kotlin.Unit
            protected/*protected and package*/ open fun coalesceEvents(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!, /*1*/ p1: [ERROR : Unresolved java classifier: AWTEvent]!): [ERROR : Unresolved java classifier: AWTEvent]!
            public/*package*/ open fun constructComponentName(): kotlin.String!
            public open fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
            public open fun contains(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public/*package*/ open fun containsFocus(): kotlin.Boolean
            public/*package*/ open fun countHierarchyMembers(): kotlin.Int
            public/*package*/ open fun createBufferStrategy(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open fun createBufferStrategy(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
            public/*package*/ open fun createHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: java.awt.Component!, /*2*/ p2: java.awt.Container!, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.Boolean): kotlin.Int
            public open fun createImage(/*0*/ p0: [ERROR : Unresolved java classifier: ImageProducer]!): [ERROR : Unresolved java classifier: Image]!
            public open fun createImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: Image]!
            public open fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: VolatileImage]!
            public open fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: ImageCapabilities]!): [ERROR : Unresolved java classifier: VolatileImage]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun deliverEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun disable(): kotlin.Unit
            protected/*protected and package*/ final fun disableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final fun dispatchEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open fun dispatchEventImpl(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open fun dispatchMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Boolean
            public open fun doLayout(): kotlin.Unit
            private open fun doSwingSerialization(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun enable(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun enable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ final fun enableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun enableInputMethods(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open fun eventEnabled(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Boolean
            public/*package*/ open fun eventTypeEnabled(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ open fun findUnderMouseInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: PointerInfo]!): java.awt.Component!
            protected/*protected and package*/ open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
            protected/*protected and package*/ open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte, /*2*/ p2: kotlin.Byte): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char, /*2*/ p2: kotlin.Char): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float, /*2*/ p2: kotlin.Float): kotlin.Unit
            protected/*protected and package*/ open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Unit
            public open fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short, /*2*/ p2: kotlin.Short): kotlin.Unit
            public/*package*/ final fun getAccessControlContext(): [ERROR : Unresolved java classifier: AccessControlContext]!
            public open fun getAccessibleContext(): [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ open fun getAccessibleIndexInParent(): kotlin.Int
            public/*package*/ open fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
            public open fun getAlignmentX(): kotlin.Float
            public open fun getAlignmentY(): kotlin.Float
            private open fun getAppliedShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
            [ERROR : java.beans.Transient]() public open fun getBackground(): [ERROR : Unresolved java classifier: Color]!
            public open fun getBaseline(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun getBaselineResizeBehavior(): java.awt.Component.BaselineResizeBehavior!
            public open fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
            public open fun getBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): [ERROR : Unresolved java classifier: Rectangle]!
            public/*package*/ open fun getBoundsOp(): kotlin.Int
            public/*package*/ open fun getBufferStrategy(): [ERROR : Unresolved java classifier: BufferStrategy]!
            public open fun getColorModel(): [ERROR : Unresolved java classifier: ColorModel]!
            public open fun getComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open fun getComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open fun getComponentListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ComponentListener]!>!
            public open fun getComponentOrientation(): [ERROR : Unresolved java classifier: ComponentOrientation]!
            public/*package*/ open fun getContainer(): java.awt.Container!
            public/*package*/ open fun getContainingWindow(): java.awt.Window!
            public open fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final fun getCursor_NoClientCode(): [ERROR : Unresolved java classifier: Cursor]!
            public open fun getDropTarget(): [ERROR : Unresolved java classifier: DropTarget]!
            public open fun getFocusCycleRootAncestor(): java.awt.Container!
            public open fun getFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: FocusListener]!>!
            public open fun getFocusTraversalKeys(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<java.awt.AWTKeyStroke!>!
            public open fun getFocusTraversalKeysEnabled(): kotlin.Boolean
            public/*package*/ final fun getFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<*>!
            [ERROR : java.beans.Transient]() public open fun getFont(): [ERROR : Unresolved java classifier: Font]!
            public open fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
            public/*package*/ final fun getFont_NoClientCode(): [ERROR : Unresolved java classifier: Font]!
            [ERROR : java.beans.Transient]() public open fun getForeground(): [ERROR : Unresolved java classifier: Color]!
            public open fun getGraphics(): [ERROR : Unresolved java classifier: Graphics]!
            public open fun getGraphicsConfiguration(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final fun getGraphicsConfiguration_NoClientCode(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final fun getGraphics_NoClientCode(): [ERROR : Unresolved java classifier: Graphics]!
            public/*package*/ final fun getHWPeerAboveMe(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public open fun getHeight(): kotlin.Int
            public open fun getHierarchyBoundsListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyBoundsListener]!>!
            public open fun getHierarchyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyListener]!>!
            public open fun getIgnoreRepaint(): kotlin.Boolean
            public open fun getInputContext(): [ERROR : Unresolved java classifier: InputContext]!
            public open fun getInputMethodListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: InputMethodListener]!>!
            public open fun getInputMethodRequests(): [ERROR : Unresolved java classifier: InputMethodRequests]!
            private open fun getInsets_NoClientCode(): [ERROR : Unresolved java classifier: Insets]!
            public open fun getKeyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: KeyListener]!>!
            public open fun </*0*/ T : java.util.EventListener!> getListeners(/*0*/ p0: java.lang.Class<T!>!): kotlin.Array<(out) T!>!
            public open fun getLocale(): java.util.Locale!
            public open fun getLocation(): [ERROR : Unresolved java classifier: Point]!
            public open fun getLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            public open fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final fun getLocationOnScreen_NoTreeLock(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ open fun getLocationOnWindow(): [ERROR : Unresolved java classifier: Point]!
            public open fun getMaximumSize(): java.awt.Dimension!
            public open fun getMinimumSize(): java.awt.Dimension!
            public open fun getMouseListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseListener]!>!
            public open fun getMouseMotionListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseMotionListener]!>!
            public open fun getMousePosition(): [ERROR : Unresolved java classifier: Point]!
            public open fun getMouseWheelListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseWheelListener]!>!
            public open fun getName(): kotlin.String!
            public/*package*/ open fun getNativeContainer(): java.awt.Container!
            public/*package*/ final fun getNextFocusCandidate(): java.awt.Component!
            public/*package*/ final fun getNormalShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open fun getObjectLock(): kotlin.Any!
            public/*package*/ open fun getOpaqueShape(): [ERROR : Unresolved java classifier: Region]!
            public open fun getParent(): java.awt.Container!
            public/*package*/ final fun getParent_NoClientCode(): java.awt.Container!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getPeer(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public open fun getPreferredSize(): java.awt.Dimension!
            public open fun getPropertyChangeListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open fun getPropertyChangeListeners(/*0*/ p0: kotlin.String!): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public/*package*/ final fun getSiblingIndexAbove(): kotlin.Int
            public/*package*/ final fun getSiblingIndexBelow(): kotlin.Int
            public open fun getSize(): java.awt.Dimension!
            public open fun getSize(/*0*/ p0: java.awt.Dimension!): java.awt.Dimension!
            public open fun getToolkit(): [ERROR : Unresolved java classifier: Toolkit]!
            public/*package*/ final fun getToolkitImpl(): [ERROR : Unresolved java classifier: Toolkit]!
            public/*package*/ open fun getTraversalRoot(): java.awt.Container!
            public final fun getTreeLock(): kotlin.Any!
            public open fun getWidth(): kotlin.Int
            public open fun getX(): kotlin.Int
            public open fun getY(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun gotFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun handleEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public open fun hasFocus(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun hide(): kotlin.Unit
            public open fun imageUpdate(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public/*package*/ open fun initializeFocusTraversalKeys(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun inside(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public open fun invalidate(): kotlin.Unit
            public/*package*/ final fun invalidateIfValid(): kotlin.Unit
            public/*package*/ open fun invalidateParent(): kotlin.Unit
            public/*package*/ open fun isAutoFocusTransferOnDisposal(): kotlin.Boolean
            public open fun isBackgroundSet(): kotlin.Boolean
            public/*package*/ final fun isCoalescingEnabled(): kotlin.Boolean
            public open fun isCursorSet(): kotlin.Boolean
            public open fun isDisplayable(): kotlin.Boolean
            public open fun isDoubleBuffered(): kotlin.Boolean
            public open fun isEnabled(): kotlin.Boolean
            public/*package*/ final fun isEnabledImpl(): kotlin.Boolean
            public open fun isFocusCycleRoot(/*0*/ p0: java.awt.Container!): kotlin.Boolean
            public open fun isFocusOwner(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun isFocusTraversable(): kotlin.Boolean
            public/*package*/ final fun isFocusTraversableOverridden(): kotlin.Boolean
            public open fun isFocusable(): kotlin.Boolean
            public open fun isFontSet(): kotlin.Boolean
            public open fun isForegroundSet(): kotlin.Boolean
            public open fun isLightweight(): kotlin.Boolean
            public open fun isMaximumSizeSet(): kotlin.Boolean
            public open fun isMinimumSizeSet(): kotlin.Boolean
            public/*package*/ final fun isMixingNeeded(): kotlin.Boolean
            public/*package*/ final fun isNonOpaqueForMixing(): kotlin.Boolean
            public open fun isOpaque(): kotlin.Boolean
            public open fun isPreferredSizeSet(): kotlin.Boolean
            public/*package*/ open fun isRecursivelyVisible(): kotlin.Boolean
            private open fun isRequestFocusAccepted(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open fun isSameOrAncestorOf(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open fun isShowing(): kotlin.Boolean
            public open fun isValid(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open fun isVisible(): kotlin.Boolean
            public/*package*/ final fun isVisible_NoClientCode(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun keyDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun keyUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun layout(): kotlin.Unit
            public/*package*/ open fun lightweightPaint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open fun lightweightPrint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open fun list(): kotlin.Unit
            public open fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open fun list(/*0*/ p0: java.io.PrintStream!, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun locate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun location(): [ERROR : Unresolved java classifier: Point]!
            private open fun location_NoClientCode(): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun lostFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun minimumSize(): java.awt.Dimension!
            public/*package*/ open fun mixOnHiding(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ open fun mixOnReshaping(): kotlin.Unit
            public/*package*/ open fun mixOnShowing(): kotlin.Unit
            public/*package*/ open fun mixOnValidating(): kotlin.Unit
            public/*package*/ open fun mixOnZOrderChanging(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseDrag(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseEnter(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseExit(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseMove(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun mouseUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun move(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun nextFocus(): kotlin.Unit
            private open fun notifyNewBounds(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open fun numListening(/*0*/ p0: kotlin.Long): kotlin.Int
            public open fun paint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open fun paintAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open fun paintHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open fun paramString(): kotlin.String!
            public/*package*/ open fun pointRelativeToComponent(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun postEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public/*package*/ open fun postsOldMouseEvents(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun preferredSize(): java.awt.Dimension!
            public open fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open fun print(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open fun printAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open fun printHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open fun processComponentEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processHierarchyBoundsEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processHierarchyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processInputMethodEvent(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processMouseEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processMouseMotionEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processMouseWheelEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public/*package*/ final fun relocateComponent(): kotlin.Unit
            public open fun remove(/*0*/ p0: [ERROR : Unresolved java classifier: MenuComponent]!): kotlin.Unit
            public open fun removeComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open fun removeHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open fun removeHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            public open fun removeInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open fun removeKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open fun removeMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open fun removeMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open fun removeMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open fun removeNotify(): kotlin.Unit
            public open fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open fun removePropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open fun repaint(): kotlin.Unit
            public open fun repaint(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open fun repaint(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun repaint(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun repaintParentIfNeeded(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open fun requestFocus(): kotlin.Unit
            public/*package*/ open fun requestFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            protected/*protected and package*/ open fun requestFocus(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public/*package*/ open fun requestFocus(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ final fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public/*package*/ final fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public open fun requestFocusInWindow(): kotlin.Boolean
            public/*package*/ open fun requestFocusInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            protected/*protected and package*/ open fun requestFocusInWindow(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public/*package*/ open fun requestFocusInWindow(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun reshape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            private open fun reshapeNativePeer(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun resize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun resize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun revalidate(): kotlin.Unit
            public/*package*/ open fun setAutoFocusTransferOnDisposal(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public open fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
            public open fun setBounds(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open fun setBoundsOp(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public open fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
            public open fun setDropTarget(/*0*/ p0: [ERROR : Unresolved java classifier: DropTarget]!): kotlin.Unit
            public open fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setFocusTraversalKeys(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open fun setFocusTraversalKeysEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final fun setFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open fun setFocusable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
            public open fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public/*package*/ open fun setGraphicsConfiguration(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            public open fun setIgnoreRepaint(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setLocale(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            public open fun setLocation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun setMaximumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setMinimumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun setPreferredSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun show(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun show(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun size(): java.awt.Dimension!
            public/*package*/ final fun subtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final fun subtractAndApplyShapeBelowMe(): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!
            public open fun transferFocus(): kotlin.Unit
            public/*package*/ open fun transferFocus(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun transferFocusBackward(): kotlin.Unit
            public/*package*/ open fun transferFocusBackward(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun transferFocusUpCycle(): kotlin.Unit
            public open fun update(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ final fun updateCursorImmediately(): kotlin.Unit
            public/*package*/ open fun updateGraphicsData(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Boolean
            public/*package*/ open fun updateZOrder(): kotlin.Unit
            public open fun validate(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            public/*package*/ open class AWTTreeLock {
                public/*package*/ constructor AWTTreeLock()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            protected/*protected and package*/ abstract inner class AccessibleAWTComponent : java.io.Serializable {
                protected/*protected and package*/ constructor AccessibleAWTComponent()
                protected/*protected and package*/ final var accessibleAWTComponentHandler: [ERROR : Unresolved java classifier: ComponentListener]!
                protected/*protected and package*/ final var accessibleAWTFocusHandler: [ERROR : Unresolved java classifier: FocusListener]!
                public open fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
                public open fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
                public open fun getAccessibleChildrenCount(): kotlin.Int
                public open fun getAccessibleComponent(): [ERROR : Unresolved java classifier: AccessibleComponent]!
                public open fun getAccessibleDescription(): kotlin.String!
                public open fun getAccessibleIndexInParent(): kotlin.Int
                public open fun getAccessibleName(): kotlin.String!
                public open fun getAccessibleParent(): [ERROR : Unresolved java classifier: Accessible]!
                public open fun getAccessibleRole(): [ERROR : Unresolved java classifier: AccessibleRole]!
                public open fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
                public open fun getBackground(): [ERROR : Unresolved java classifier: Color]!
                public open fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
                public open fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
                public open fun getFont(): [ERROR : Unresolved java classifier: Font]!
                public open fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
                public open fun getForeground(): [ERROR : Unresolved java classifier: Color]!
                public open fun getLocale(): java.util.Locale!
                public open fun getLocation(): [ERROR : Unresolved java classifier: Point]!
                public open fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
                public open fun getSize(): java.awt.Dimension!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open fun isEnabled(): kotlin.Boolean
                public open fun isFocusTraversable(): kotlin.Boolean
                public open fun isShowing(): kotlin.Boolean
                public open fun isVisible(): kotlin.Boolean
                public open fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open fun requestFocus(): kotlin.Unit
                public open fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
                public open fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
                public open fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
                public open fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
                public open fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
                public open fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                protected/*protected and package*/ open inner class AccessibleAWTComponentHandler {
                    protected/*protected and package*/ constructor AccessibleAWTComponentHandler()
                    public open fun componentHidden(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
                    public open fun componentMoved(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
                    public open fun componentResized(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
                    public open fun componentShown(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                protected/*protected and package*/ open inner class AccessibleAWTFocusHandler {
                    protected/*protected and package*/ constructor AccessibleAWTFocusHandler()
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun focusGained(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
                    public open fun focusLost(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = 642321655757800191.toLong()
            }

            public final enum class BaselineResizeBehavior : kotlin.Enum<java.awt.Component.BaselineResizeBehavior!> {
                public enum entry CONSTANT_ASCENT : java.awt.Component.BaselineResizeBehavior {
                    private constructor CONSTANT_ASCENT()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Component.BaselineResizeBehavior!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CONSTANT_DESCENT : java.awt.Component.BaselineResizeBehavior {
                    private constructor CONSTANT_DESCENT()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Component.BaselineResizeBehavior!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CENTER_OFFSET : java.awt.Component.BaselineResizeBehavior {
                    private constructor CENTER_OFFSET()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Component.BaselineResizeBehavior!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OTHER : java.awt.Component.BaselineResizeBehavior {
                    private constructor OTHER()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Component.BaselineResizeBehavior!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor BaselineResizeBehavior()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Component.BaselineResizeBehavior!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.awt.Component.BaselineResizeBehavior
                public final /*synthesized*/ fun values(): kotlin.Array<java.awt.Component.BaselineResizeBehavior>
            }

            protected/*protected and package*/ open inner class BltBufferStrategy {
                protected/*protected and package*/ constructor BltBufferStrategy(/*0*/ p2: kotlin.Int, /*1*/ p3: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                protected/*protected and package*/ final var backBuffers: kotlin.Array<(out) [ERROR : Unresolved java classifier: VolatileImage]!>!
                protected/*protected and package*/ final var caps: [ERROR : Unresolved java classifier: BufferCapabilities]!
                protected/*protected and package*/ final var height: kotlin.Int
                private final var insets: [ERROR : Unresolved java classifier: Insets]!
                protected/*protected and package*/ final var validatedContents: kotlin.Boolean
                protected/*protected and package*/ final var width: kotlin.Int
                public open fun contentsLost(): kotlin.Boolean
                public open fun contentsRestored(): kotlin.Boolean
                protected/*protected and package*/ open fun createBackBuffers(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open fun dispose(): kotlin.Unit
                public/*package*/ open fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
                public open fun getCapabilities(): [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open fun getDrawGraphics(): [ERROR : Unresolved java classifier: Graphics]!
                protected/*protected and package*/ open fun revalidate(): kotlin.Unit
                public/*package*/ open fun revalidate(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open fun show(): kotlin.Unit
                public/*package*/ open fun showSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            }

            private open inner class BltSubRegionBufferStrategy : java.awt.Component.BltBufferStrategy {
                protected/*protected and package*/ constructor BltSubRegionBufferStrategy(/*0*/ p2: kotlin.Int, /*1*/ p3: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var backBuffers: kotlin.Array<(out) [ERROR : Unresolved java classifier: VolatileImage]!>!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var caps: [ERROR : Unresolved java classifier: BufferCapabilities]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var height: kotlin.Int
                invisible_fake final override /*1*/ /*fake_override*/ var insets: [ERROR : Unresolved java classifier: Insets]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var validatedContents: kotlin.Boolean
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var width: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun contentsLost(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun contentsRestored(): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun createBackBuffers(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun dispose(): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
                public open override /*1*/ /*fake_override*/ fun getCapabilities(): [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open override /*1*/ /*fake_override*/ fun getDrawGraphics(): [ERROR : Unresolved java classifier: Graphics]!
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun revalidate(): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun revalidate(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun show(): kotlin.Unit
                public open fun show(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
                public open fun showIfNotLost(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Boolean
                public/*package*/ open override /*1*/ /*fake_override*/ fun showSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            }

            private open class DummyRequestFocusController {
                private constructor DummyRequestFocusController()
                public open fun acceptRequestFocus(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Component!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean, /*4*/ p4: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            protected/*protected and package*/ open inner class FlipBufferStrategy {
                protected/*protected and package*/ constructor FlipBufferStrategy(/*0*/ p2: kotlin.Int, /*1*/ p3: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                protected/*protected and package*/ final var caps: [ERROR : Unresolved java classifier: BufferCapabilities]!
                protected/*protected and package*/ final var drawBuffer: [ERROR : Unresolved java classifier: Image]!
                protected/*protected and package*/ final var drawVBuffer: [ERROR : Unresolved java classifier: VolatileImage]!
                public/*package*/ final var height: kotlin.Int
                protected/*protected and package*/ final var numBuffers: kotlin.Int
                protected/*protected and package*/ final var validatedContents: kotlin.Boolean
                public/*package*/ final var width: kotlin.Int
                public open fun contentsLost(): kotlin.Boolean
                public open fun contentsRestored(): kotlin.Boolean
                protected/*protected and package*/ open fun createBuffers(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
                protected/*protected and package*/ open fun destroyBuffers(): kotlin.Unit
                public open fun dispose(): kotlin.Unit
                protected/*protected and package*/ open fun flip(/*0*/ p0: [ERROR : Unresolved java classifier: FlipContents]!): kotlin.Unit
                public/*package*/ open fun flipSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: FlipContents]!): kotlin.Unit
                protected/*protected and package*/ open fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
                public open fun getCapabilities(): [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open fun getDrawGraphics(): [ERROR : Unresolved java classifier: Graphics]!
                protected/*protected and package*/ open fun revalidate(): kotlin.Unit
                public/*package*/ open fun revalidate(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open fun show(): kotlin.Unit
                public/*package*/ open fun showSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
                private open fun updateInternalBuffers(): kotlin.Unit
            }

            private open inner class FlipSubRegionBufferStrategy : java.awt.Component.FlipBufferStrategy {
                protected/*protected and package*/ constructor FlipSubRegionBufferStrategy(/*0*/ p2: kotlin.Int, /*1*/ p3: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var caps: [ERROR : Unresolved java classifier: BufferCapabilities]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var drawBuffer: [ERROR : Unresolved java classifier: Image]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var drawVBuffer: [ERROR : Unresolved java classifier: VolatileImage]!
                public/*package*/ final override /*1*/ /*fake_override*/ var height: kotlin.Int
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var numBuffers: kotlin.Int
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var validatedContents: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var width: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun contentsLost(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun contentsRestored(): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun createBuffers(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun destroyBuffers(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun dispose(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun flip(/*0*/ p0: [ERROR : Unresolved java classifier: FlipContents]!): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun flipSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: FlipContents]!): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
                public open override /*1*/ /*fake_override*/ fun getCapabilities(): [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open override /*1*/ /*fake_override*/ fun getDrawGraphics(): [ERROR : Unresolved java classifier: Graphics]!
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun revalidate(): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun revalidate(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun show(): kotlin.Unit
                public open fun show(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
                public open fun showIfNotLost(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Boolean
                public/*package*/ open override /*1*/ /*fake_override*/ fun showSubRegion(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
                invisible_fake open override /*1*/ /*fake_override*/ fun updateInternalBuffers(): kotlin.Unit
            }

            private open inner class ProxyCapabilities {
                private constructor ProxyCapabilities(/*0*/ p2: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                private final var orig: [ERROR : Unresolved java classifier: BufferCapabilities]!
            }

            private open inner class SingleBufferStrategy {
                public constructor SingleBufferStrategy(/*0*/ p2: [ERROR : Unresolved java classifier: BufferCapabilities]!)
                private final var caps: [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open fun contentsLost(): kotlin.Boolean
                public open fun contentsRestored(): kotlin.Boolean
                public open fun getCapabilities(): [ERROR : Unresolved java classifier: BufferCapabilities]!
                public open fun getDrawGraphics(): [ERROR : Unresolved java classifier: Graphics]!
                public open fun show(): kotlin.Unit
            }

            // Static members
            public final val BOTTOM_ALIGNMENT: kotlin.Float = 1.0.toFloat()
            public final val CENTER_ALIGNMENT: kotlin.Float = 0.5.toFloat()
            private final val FOCUS_TRAVERSABLE_DEFAULT: kotlin.Int = 1
            private final val FOCUS_TRAVERSABLE_SET: kotlin.Int = 2
            private final val FOCUS_TRAVERSABLE_UNKNOWN: kotlin.Int = 0
            public final val LEFT_ALIGNMENT: kotlin.Float = 0.0.toFloat()
            public/*package*/ final val LOCK: kotlin.Any!
            public final val RIGHT_ALIGNMENT: kotlin.Float = 1.0.toFloat()
            public final val TOP_ALIGNMENT: kotlin.Float = 0.0.toFloat()
            public/*package*/ final val actionListenerK: kotlin.String = "actionL"
            public/*package*/ final val adjustmentListenerK: kotlin.String = "adjustmentL"
            private final val coalesceEventsParams: kotlin.Array<(out) java.lang.Class<*>!>!
            private final val coalesceMap: kotlin.(Mutable)Map<java.lang.Class<*>!, kotlin.Boolean!>!
            public/*package*/ final val componentListenerK: kotlin.String = "componentL"
            public/*package*/ final val containerListenerK: kotlin.String = "containerL"
            private final val eventLog: [ERROR : Unresolved java classifier: PlatformLogger]!
            public/*package*/ final val focusListenerK: kotlin.String = "focusL"
            private final val focusLog: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final val focusTraversalKeyPropertyNames: kotlin.Array<(out) kotlin.String!>!
            public/*package*/ final val hierarchyBoundsListenerK: kotlin.String = "hierarchyBoundsL"
            public/*package*/ final val hierarchyListenerK: kotlin.String = "hierarchyL"
            public/*package*/ final var incRate: kotlin.Int
            public/*package*/ final val inputMethodListenerK: kotlin.String = "inputMethodL"
            public/*package*/ final var isInc: kotlin.Boolean
            public/*package*/ final val itemListenerK: kotlin.String = "itemL"
            public/*package*/ final val keyListenerK: kotlin.String = "keyL"
            private final val log: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final val mixingLog: [ERROR : Unresolved java classifier: PlatformLogger]!
            public/*package*/ final val mouseListenerK: kotlin.String = "mouseL"
            public/*package*/ final val mouseMotionListenerK: kotlin.String = "mouseMotionL"
            public/*package*/ final val mouseWheelListenerK: kotlin.String = "mouseWheelL"
            public/*package*/ final val ownedWindowK: kotlin.String = "ownedL"
            private final var requestFocusController: [ERROR : Unresolved java classifier: RequestFocusController]!
            private final val serialVersionUID: kotlin.Long = -7644114512714619750.toLong()
            public/*package*/ final val textListenerK: kotlin.String = "textL"
            public/*package*/ final val windowFocusListenerK: kotlin.String = "windowFocusL"
            public/*package*/ final val windowListenerK: kotlin.String = "windowL"
            public/*package*/ final val windowStateListenerK: kotlin.String = "windowStateL"
            private open fun initIDs(): kotlin.Unit
            private open fun isCoalesceEventsOverriden(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            public/*package*/ open fun isInstanceOf(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.String!): kotlin.Boolean
            public/*package*/ open fun setRequestFocusController(/*0*/ p0: [ERROR : Unresolved java classifier: RequestFocusController]!): kotlin.Unit
        }

        public open class Container : java.awt.Component {
            public constructor Container()
            invisible_fake final override /*1*/ /*fake_override*/ var acc: [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ final override /*1*/ /*fake_override*/ var accessibleContext: [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ final override /*1*/ /*fake_override*/ var appContext: [ERROR : Unresolved java classifier: AppContext]!
            invisible_fake final override /*1*/ /*fake_override*/ var autoFocusTransferOnDisposal: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var background: [ERROR : Unresolved java classifier: Color]!
            public/*package*/ final override /*1*/ /*fake_override*/ var backgroundEraseDisabled: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var boundsOp: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var bufferStrategy: [ERROR : Unresolved java classifier: BufferStrategy]!
            invisible_fake final override /*1*/ /*fake_override*/ var changeSupport: [ERROR : Unresolved java classifier: PropertyChangeSupport]!
            invisible_fake final override /*1*/ /*fake_override*/ var coalescingEnabled: kotlin.Boolean
            private final var component: kotlin.(Mutable)List<java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentListener: [ERROR : Unresolved java classifier: ComponentListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentOrientation: [ERROR : Unresolved java classifier: ComponentOrientation]!
            invisible_fake final override /*1*/ /*fake_override*/ var componentSerializedDataVersion: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var compoundShape: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final var containerListener: [ERROR : Unresolved java classifier: ContainerListener]!
            private final var containerSerializedDataVersion: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var cursor: [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final var descendantsCount: kotlin.Int
            private final var dispatcher: [ERROR : Unresolved java classifier: LightweightDispatcher]!
            public/*package*/ final override /*1*/ /*fake_override*/ var dropTarget: [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ final override /*1*/ /*fake_override*/ var enabled: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var eventCache: kotlin.Array<(out) [ERROR : Unresolved java classifier: EventQueueItem]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var eventMask: kotlin.Long
            private final var focusCycleRoot: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var focusListener: [ERROR : Unresolved java classifier: FocusListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var focusTraversalKeys: kotlin.Array<(out) kotlin.(Mutable)Set<*>!>!
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalKeysEnabled: kotlin.Boolean
            private final var focusTraversalPolicy: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            private final var focusTraversalPolicyProvider: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusable: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var font: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var foreground: [ERROR : Unresolved java classifier: Color]!
            invisible_fake final override /*1*/ /*fake_override*/ var graphicsConfig: [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ var height: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyBoundsListener: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyListener: [ERROR : Unresolved java classifier: HierarchyListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var ignoreRepaint: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var inputMethodListener: [ERROR : Unresolved java classifier: InputMethodListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var isAddNotifyComplete: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var isFocusTraversableOverridden: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var isPacked: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var keyListener: [ERROR : Unresolved java classifier: KeyListener]!
            public/*package*/ final var layoutMgr: [ERROR : Unresolved java classifier: LayoutManager]!
            public/*package*/ final var listeningBoundsChildren: kotlin.Int
            public/*package*/ final var listeningChildren: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var locale: java.util.Locale!
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSizeSet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var minSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var minSizeSet: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var mixingCutoutRegion: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final var modalAppContext: [ERROR : Unresolved java classifier: AppContext]!
            public/*package*/ final var modalComp: java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseListener: [ERROR : Unresolved java classifier: MouseListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseMotionListener: [ERROR : Unresolved java classifier: MouseMotionListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseWheelListener: [ERROR : Unresolved java classifier: MouseWheelListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var name: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var nameExplicitlySet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var newEventsOnly: kotlin.Boolean
            private final var numOfHWComponents: kotlin.Int
            private final var numOfLWComponents: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var objectLock: kotlin.Any!
            public/*package*/ final override /*1*/ /*fake_override*/ var parent: java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ var peer: [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ final override /*1*/ /*fake_override*/ var peerFont: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var popups: [ERROR : Unresolved java classifier: Vector]!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSizeSet: kotlin.Boolean
            public/*package*/ final var preserveBackgroundColor: [ERROR : Unresolved java classifier: Color]!
            private final var printing: kotlin.Boolean
            private final var printingThreads: kotlin.(Mutable)Set<*>!
            invisible_fake final override /*1*/ /*fake_override*/ var valid: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var visible: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var width: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var windowClosingException: java.lang.RuntimeException!
            public/*package*/ final override /*1*/ /*fake_override*/ var x: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var y: kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun action(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: [ERROR : Unresolved java classifier: PopupMenu]!): kotlin.Unit
            public open fun add(/*0*/ p0: java.awt.Component!): java.awt.Component!
            public open fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public open fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open fun add(/*0*/ p0: kotlin.String!, /*1*/ p1: java.awt.Component!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun addComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open fun addContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            private open fun addDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            protected/*protected and package*/ open fun addImpl(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun addNotify(): kotlin.Unit
            public open override /*1*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ fun addPropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public/*package*/ open fun adjustDecendantsOnParent(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open fun adjustDescendants(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open fun adjustListeningChildren(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustListeningChildrenOnParent(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun applyComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun applyCompoundShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun applyCurrentShape(): kotlin.Unit
            invisible_fake final override /*1*/ /*fake_override*/ fun applyCurrentShapeBelowMe(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun areBoundsValid(): kotlin.Boolean
            public open override /*1*/ fun areFocusTraversalKeysSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun areInputMethodsEnabled(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun autoProcessMouseWheel(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun bounds(): [ERROR : Unresolved java classifier: Rectangle]!
            invisible_fake open override /*1*/ /*fake_override*/ fun calculateCurrentShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwner(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwnerRecursively(): kotlin.Boolean
            public/*package*/ open fun canContainFocusOwner(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            private open fun checkAddToSelf(/*0*/ p0: java.awt.Component!): kotlin.Unit
            private open fun checkAdding(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun checkCoalescing(): kotlin.Boolean
            public/*package*/ open override /*1*/ fun checkGD(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            private open fun checkNotAWindow(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun checkTreeLock(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkWindowClosingException(): kotlin.Boolean
            public/*package*/ open override /*1*/ fun clearCurrentFocusCycleRootOnHide(): kotlin.Unit
            public/*package*/ open override /*1*/ fun clearMostRecentFocusOwnerOnHide(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun coalesceEvents(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!, /*1*/ p1: [ERROR : Unresolved java classifier: AWTEvent]!): [ERROR : Unresolved java classifier: AWTEvent]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun constructComponentName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ fun containsFocus(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun countComponents(): kotlin.Int
            public/*package*/ open override /*1*/ fun countHierarchyMembers(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
            public/*package*/ final fun createChildHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ fun createHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: java.awt.Component!, /*2*/ p2: java.awt.Container!, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.Boolean): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: [ERROR : Unresolved java classifier: ImageProducer]!): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: VolatileImage]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: ImageCapabilities]!): [ERROR : Unresolved java classifier: VolatileImage]!
            public/*package*/ final fun decreaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun deliverEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun disable(): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun disableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun dispatchEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun dispatchEventImpl(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open fun dispatchEventToSelf(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun dispatchMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Boolean
            public open override /*1*/ fun doLayout(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun doSwingSerialization(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun enableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun enableInputMethods(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open override /*1*/ fun eventEnabled(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun eventTypeEnabled(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun findComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public/*package*/ final fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public/*package*/ final fun findComponentAtImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            private open fun findTraversalRoot(): java.awt.Container!
            public/*package*/ open override /*1*/ /*fake_override*/ fun findUnderMouseInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: PointerInfo]!): java.awt.Component!
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte, /*2*/ p2: kotlin.Byte): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char, /*2*/ p2: kotlin.Char): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float, /*2*/ p2: kotlin.Float): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short, /*2*/ p2: kotlin.Short): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun getAccessControlContext(): [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ open fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open fun getAccessibleChildrenCount(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getAccessibleContext(): [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
            public open override /*1*/ fun getAlignmentX(): kotlin.Float
            public open override /*1*/ fun getAlignmentY(): kotlin.Float
            invisible_fake open override /*1*/ /*fake_override*/ fun getAppliedShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getBaseline(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBaselineResizeBehavior(): java.awt.Component.BaselineResizeBehavior!
            private open fun getBottommostComponentIndex(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
            public open override /*1*/ /*fake_override*/ fun getBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): [ERROR : Unresolved java classifier: Rectangle]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBoundsOp(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBufferStrategy(): [ERROR : Unresolved java classifier: BufferStrategy]!
            public open override /*1*/ /*fake_override*/ fun getColorModel(): [ERROR : Unresolved java classifier: ColorModel]!
            public open fun getComponent(/*0*/ p0: kotlin.Int): java.awt.Component!
            public open override /*1*/ fun getComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open override /*1*/ fun getComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open fun getComponentCount(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getComponentListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ComponentListener]!>!
            public open override /*1*/ /*fake_override*/ fun getComponentOrientation(): [ERROR : Unresolved java classifier: ComponentOrientation]!
            public open fun getComponentZOrder(/*0*/ p0: java.awt.Component!): kotlin.Int
            public open fun getComponents(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ open fun getComponentsSync(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final fun getComponents_NoClientCode(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getContainer(): java.awt.Container!
            public open fun getContainerListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ContainerListener]!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getContainingWindow(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getCursor_NoClientCode(): [ERROR : Unresolved java classifier: Cursor]!
            public open override /*1*/ /*fake_override*/ fun getDropTarget(): [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ open fun getDropTargetEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getFocusCycleRootAncestor(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: FocusListener]!>!
            public open override /*1*/ fun getFocusTraversalKeys(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<java.awt.AWTKeyStroke!>!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalKeysEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<*>!
            public open fun getFocusTraversalPolicy(): [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
            public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFont_NoClientCode(): [ERROR : Unresolved java classifier: Font]!
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getGraphics(): [ERROR : Unresolved java classifier: Graphics]!
            public open override /*1*/ /*fake_override*/ fun getGraphicsConfiguration(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphicsConfiguration_NoClientCode(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphics_NoClientCode(): [ERROR : Unresolved java classifier: Graphics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getHWPeerAboveMe(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ open fun getHeavyweightContainer(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getHeight(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getHierarchyBoundsListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyBoundsListener]!>!
            public open override /*1*/ /*fake_override*/ fun getHierarchyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyListener]!>!
            public open override /*1*/ /*fake_override*/ fun getIgnoreRepaint(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun getInputContext(): [ERROR : Unresolved java classifier: InputContext]!
            public open override /*1*/ /*fake_override*/ fun getInputMethodListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: InputMethodListener]!>!
            public open override /*1*/ /*fake_override*/ fun getInputMethodRequests(): [ERROR : Unresolved java classifier: InputMethodRequests]!
            public open fun getInsets(): [ERROR : Unresolved java classifier: Insets]!
            invisible_fake open override /*1*/ /*fake_override*/ fun getInsets_NoClientCode(): [ERROR : Unresolved java classifier: Insets]!
            public open override /*1*/ /*fake_override*/ fun getKeyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: KeyListener]!>!
            public open fun getLayout(): [ERROR : Unresolved java classifier: LayoutManager]!
            public open override /*1*/ fun </*0*/ T : java.util.EventListener!> getListeners(/*0*/ p0: java.lang.Class<T!>!): kotlin.Array<(out) T!>!
            private open fun getListenersCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getLocale(): java.util.Locale!
            public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getLocationOnScreen_NoTreeLock(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getLocationOnWindow(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ fun getMaximumSize(): java.awt.Dimension!
            public open override /*1*/ fun getMinimumSize(): java.awt.Dimension!
            public/*package*/ open fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            private final /*synthesized*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            private open fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            private final /*synthesized*/ fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            private open fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getMouseListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMouseMotionListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseMotionListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMousePosition(): [ERROR : Unresolved java classifier: Point]!
            public open fun getMousePosition(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMouseWheelListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseWheelListener]!>!
            public open override /*1*/ /*fake_override*/ fun getName(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getNativeContainer(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNextFocusCandidate(): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNormalShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getObjectLock(): kotlin.Any!
            public/*package*/ final override /*1*/ fun getOpaqueShape(): [ERROR : Unresolved java classifier: Region]!
            public open override /*1*/ /*fake_override*/ fun getParent(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getParent_NoClientCode(): java.awt.Container!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getPeer(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public open override /*1*/ fun getPreferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(/*0*/ p0: kotlin.String!): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexAbove(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexBelow(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getSize(/*0*/ p0: java.awt.Dimension!): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getToolkit(): [ERROR : Unresolved java classifier: Toolkit]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getToolkitImpl(): [ERROR : Unresolved java classifier: Toolkit]!
            private open fun getTopmostComponentIndex(): kotlin.Int
            public/*package*/ final override /*1*/ fun getTraversalRoot(): java.awt.Container!
            public final override /*1*/ /*fake_override*/ fun getTreeLock(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun getWidth(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getX(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getY(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun gotFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun handleEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hasFocus(): kotlin.Boolean
            public/*package*/ final fun hasHeavyweightDescendants(): kotlin.Boolean
            public/*package*/ final fun hasLightweightDescendants(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun hide(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun imageUpdate(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public/*package*/ final fun increaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public/*package*/ open override /*1*/ fun initializeFocusTraversalKeys(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun insets(): [ERROR : Unresolved java classifier: Insets]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun inside(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public open override /*1*/ fun invalidate(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun invalidateIfValid(): kotlin.Unit
            public/*package*/ open override /*1*/ fun invalidateParent(): kotlin.Unit
            public/*package*/ open fun invalidateTree(): kotlin.Unit
            public open fun isAncestorOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isAutoFocusTransferOnDisposal(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isBackgroundSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isCoalescingEnabled(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isCursorSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDisplayable(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDoubleBuffered(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isEnabledImpl(): kotlin.Boolean
            public open fun isFocusCycleRoot(): kotlin.Boolean
            public open override /*1*/ fun isFocusCycleRoot(/*0*/ p0: java.awt.Container!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusOwner(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isFocusTraversableOverridden(): kotlin.Boolean
            public final fun isFocusTraversalPolicyProvider(): kotlin.Boolean
            public open fun isFocusTraversalPolicySet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusable(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFontSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isForegroundSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isLightweight(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMaximumSizeSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMinimumSizeSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isMixingNeeded(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isNonOpaqueForMixing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isOpaque(): kotlin.Boolean
            private open fun isParentOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isPreferredSizeSet(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isRecursivelyVisible(): kotlin.Boolean
            public/*package*/ final fun isRecursivelyVisibleUpToHeavyweightContainer(): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun isRequestFocusAccepted(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ fun isSameOrAncestorOf(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isShowing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isValid(): kotlin.Boolean
            public open fun isValidateRoot(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isVisible_NoClientCode(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun layout(): kotlin.Unit
            public/*package*/ open override /*1*/ fun lightweightPaint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun lightweightPrint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open override /*1*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open override /*1*/ fun list(/*0*/ p0: java.io.PrintStream!, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun locate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun location(): [ERROR : Unresolved java classifier: Point]!
            invisible_fake open override /*1*/ /*fake_override*/ fun location_NoClientCode(): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun lostFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun minimumSize(): java.awt.Dimension!
            public/*package*/ open override /*1*/ fun mixOnHiding(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ fun mixOnReshaping(): kotlin.Unit
            public/*package*/ open override /*1*/ fun mixOnShowing(): kotlin.Unit
            public/*package*/ open override /*1*/ fun mixOnValidating(): kotlin.Unit
            public/*package*/ open override /*1*/ fun mixOnZOrderChanging(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDrag(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseEnter(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseExit(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseMove(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun move(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun nextFocus(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun notifyNewBounds(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ fun numListening(/*0*/ p0: kotlin.Long): kotlin.Int
            public open override /*1*/ fun paint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paintAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open fun paintComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun paintHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ fun paramString(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun pointRelativeToComponent(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun postEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public/*package*/ open fun postProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun postsOldMouseEvents(): kotlin.Boolean
            public/*package*/ open fun preProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun preferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ fun print(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun printAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open fun printComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun printHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processComponentEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processContainerEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ fun processEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyBoundsEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processInputMethodEvent(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseMotionEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseWheelEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            public/*package*/ open fun proxyEnableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public/*package*/ final fun recursiveApplyCurrentShape(): kotlin.Unit
            public/*package*/ final fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ final fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            private open fun recursiveHideHeavyweightChildren(): kotlin.Unit
            private open fun recursiveRelocateHeavyweightChildren(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            private open fun recursiveShowHeavyweightChildren(): kotlin.Unit
            public/*package*/ final fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ final fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun relocateComponent(): kotlin.Unit
            public open fun remove(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public open override /*1*/ fun remove(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun removeAll(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open fun removeContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            private open fun removeDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun removeNotify(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun repaintParentIfNeeded(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            private open fun reparentChild(/*0*/ p0: java.awt.Component!): kotlin.Unit
            private open fun reparentTraverse(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerPeer]!, /*1*/ p1: java.awt.Container!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun requestFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocus(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun requestFocusInWindow(): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun reshape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reshapeNativePeer(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun revalidate(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setAutoFocusTransferOnDisposal(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setBoundsOp(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public open fun setComponentZOrder(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setDropTarget(/*0*/ p0: [ERROR : Unresolved java classifier: DropTarget]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setFocusCycleRoot(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun setFocusTraversalKeys(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalKeysEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open fun setFocusTraversalPolicy(/*0*/ p0: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!): kotlin.Unit
            public final fun setFocusTraversalPolicyProvider(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setGraphicsConfiguration(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setIgnoreRepaint(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setLayout(/*0*/ p0: [ERROR : Unresolved java classifier: LayoutManager]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocale(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMaximumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMinimumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setPreferredSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun show(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun show(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun size(): java.awt.Dimension!
            private open fun startLWModal(): kotlin.Unit
            private open fun stopLWModal(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShapeBelowMe(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun transferFocus(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocus(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun transferFocusBackward(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocusBackward(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun transferFocusDownCycle(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun transferFocusUpCycle(): kotlin.Unit
            public open override /*1*/ fun update(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun updateCursorImmediately(): kotlin.Unit
            public/*package*/ open override /*1*/ fun updateGraphicsData(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun updateZOrder(): kotlin.Unit
            public open override /*1*/ fun validate(): kotlin.Unit
            protected/*protected and package*/ open fun validateTree(): kotlin.Unit
            public/*package*/ final fun validateUnconditionally(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            protected/*protected and package*/ open inner class AccessibleAWTContainer : java.awt.Component.AccessibleAWTComponent {
                protected/*protected and package*/ constructor AccessibleAWTContainer()
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTComponentHandler: [ERROR : Unresolved java classifier: ComponentListener]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTFocusHandler: [ERROR : Unresolved java classifier: FocusListener]!
                protected/*protected and package*/ final var accessibleContainerHandler: [ERROR : Unresolved java classifier: ContainerListener]!
                public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ fun getAccessibleChildrenCount(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleComponent(): [ERROR : Unresolved java classifier: AccessibleComponent]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleDescription(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleParent(): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleRole(): [ERROR : Unresolved java classifier: AccessibleRole]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
                public open override /*1*/ /*fake_override*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
                public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
                public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
                public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
                public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getLocale(): java.util.Locale!
                public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isShowing(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                protected/*protected and package*/ open inner class AccessibleContainerHandler {
                    protected/*protected and package*/ constructor AccessibleContainerHandler()
                    public open fun componentAdded(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerEvent]!): kotlin.Unit
                    public open fun componentRemoved(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerEvent]!): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = 5081320404842566097.toLong()
            }

            public/*package*/ open class DropTargetEventTargetFilter : java.awt.Container.EventTargetFilter {
                private constructor DropTargetEventTargetFilter()
                public open override /*1*/ fun accept(/*0*/ p0: java.awt.Component!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val FILTER: java.awt.Container.EventTargetFilter!
            }

            public/*package*/ trait EventTargetFilter {
                public abstract fun accept(/*0*/ p0: java.awt.Component!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ open class MouseEventTargetFilter : java.awt.Container.EventTargetFilter {
                private constructor MouseEventTargetFilter()
                public open override /*1*/ fun accept(/*0*/ p0: java.awt.Component!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val FILTER: java.awt.Container.EventTargetFilter!
            }

            public/*package*/ final class WakingRunnable : java.lang.Runnable {
                public/*package*/ constructor WakingRunnable()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun run(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val EMPTY_ARRAY: kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final val INCLUDE_SELF: kotlin.Boolean = true
            public/*package*/ final val SEARCH_HEAVYWEIGHTS: kotlin.Boolean = true
            private final var descendUnconditionallyWhenValidating: kotlin.Boolean
            private final val eventLog: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final val isJavaAwtSmartInvalidate: kotlin.Boolean
            private final val log: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final val mixingLog: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            private final val serialVersionUID: kotlin.Long = 4613797578919906343.toLong()
            public/*package*/ final /*synthesized*/ fun EventTargetFilter(/*0*/ function: (java.awt.Component!) -> kotlin.Boolean): java.awt.Container.EventTargetFilter
            private open fun initIDs(): kotlin.Unit
            private open fun isRemoveNotifyNeeded(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: java.awt.Container!): kotlin.Boolean
        }

        public open class Dimension : java.io.Serializable {
            public constructor Dimension()
            public constructor Dimension(/*0*/ p0: java.awt.Dimension!)
            public constructor Dimension(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int)
            public final var height: kotlin.Int
            public final var width: kotlin.Int
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun getHeight(): kotlin.Double
            [ERROR : java.beans.Transient]() public open fun getSize(): java.awt.Dimension!
            public open fun getWidth(): kotlin.Double
            public open override /*1*/ fun hashCode(): kotlin.Int
            public open fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setSize(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Unit
            public open fun setSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!

            // Static members
            private final val serialVersionUID: kotlin.Long = 4723952579491349524.toLong()
            private open fun initIDs(): kotlin.Unit
        }

        public open class Frame : java.awt.Window {
            public constructor Frame()
            public constructor Frame(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!)
            public constructor Frame(/*0*/ p0: kotlin.String!)
            public constructor Frame(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: GraphicsConfiguration]!)
            invisible_fake final override /*1*/ /*fake_override*/ var acc: [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ final override /*1*/ /*fake_override*/ var accessibleContext: [ERROR : Unresolved java classifier: AccessibleContext]!
            invisible_fake final override /*1*/ /*fake_override*/ var alwaysOnTop: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var anchor: kotlin.Any!
            public/*package*/ final override /*1*/ /*fake_override*/ var appContext: [ERROR : Unresolved java classifier: AppContext]!
            invisible_fake final override /*1*/ /*fake_override*/ var autoFocusTransferOnDisposal: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var autoRequestFocus: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var background: [ERROR : Unresolved java classifier: Color]!
            public/*package*/ final override /*1*/ /*fake_override*/ var backgroundEraseDisabled: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var beforeFirstShow: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var boundsOp: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var bufferStrategy: [ERROR : Unresolved java classifier: BufferStrategy]!
            invisible_fake final override /*1*/ /*fake_override*/ var changeSupport: [ERROR : Unresolved java classifier: PropertyChangeSupport]!
            invisible_fake final override /*1*/ /*fake_override*/ var coalescingEnabled: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var component: kotlin.(Mutable)List<java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentListener: [ERROR : Unresolved java classifier: ComponentListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentOrientation: [ERROR : Unresolved java classifier: ComponentOrientation]!
            invisible_fake final override /*1*/ /*fake_override*/ var componentSerializedDataVersion: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var compoundShape: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final override /*1*/ /*fake_override*/ var containerListener: [ERROR : Unresolved java classifier: ContainerListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var containerSerializedDataVersion: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var cursor: [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final override /*1*/ /*fake_override*/ var descendantsCount: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var dispatcher: [ERROR : Unresolved java classifier: LightweightDispatcher]!
            invisible_fake final override /*1*/ /*fake_override*/ var disposing: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var dropTarget: [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ final override /*1*/ /*fake_override*/ var enabled: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var eventCache: kotlin.Array<(out) [ERROR : Unresolved java classifier: EventQueueItem]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var eventMask: kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ var focusCycleRoot: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var focusListener: [ERROR : Unresolved java classifier: FocusListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var focusMgr: [ERROR : Unresolved java classifier: FocusManager]!
            public/*package*/ final override /*1*/ /*fake_override*/ var focusTraversalKeys: kotlin.Array<(out) kotlin.(Mutable)Set<*>!>!
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalKeysEnabled: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalPolicy: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalPolicyProvider: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusable: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusableWindowState: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var font: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var foreground: [ERROR : Unresolved java classifier: Color]!
            private final var frameSerializedDataVersion: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var graphicsConfig: [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ var height: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyBoundsListener: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyListener: [ERROR : Unresolved java classifier: HierarchyListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var icons: kotlin.(Mutable)List<[ERROR : Unresolved java classifier: Image]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var ignoreRepaint: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var inputContext: [ERROR : Unresolved java classifier: InputContext]!
            invisible_fake final override /*1*/ /*fake_override*/ var inputContextLock: kotlin.Any!
            public/*package*/ final override /*1*/ /*fake_override*/ var inputMethodListener: [ERROR : Unresolved java classifier: InputMethodListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var isAddNotifyComplete: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var isFocusTraversableOverridden: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var isInShow: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var isPacked: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var isTrayIconWindow: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var keyListener: [ERROR : Unresolved java classifier: KeyListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var layoutMgr: [ERROR : Unresolved java classifier: LayoutManager]!
            public/*package*/ final override /*1*/ /*fake_override*/ var listeningBoundsChildren: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var listeningChildren: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var locale: java.util.Locale!
            invisible_fake final override /*1*/ /*fake_override*/ var locationByPlatform: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSizeSet: kotlin.Boolean
            public/*package*/ final var maximizedBounds: [ERROR : Unresolved java classifier: Rectangle]!
            public/*package*/ final var mbManagement: kotlin.Boolean
            public/*package*/ final var menuBar: [ERROR : Unresolved java classifier: MenuBar]!
            public/*package*/ final override /*1*/ /*fake_override*/ var minSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var minSizeSet: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var mixingCutoutRegion: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalAppContext: [ERROR : Unresolved java classifier: AppContext]!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalBlocker: [ERROR : Unresolved java classifier: Dialog]!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalComp: java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalExclusionType: [ERROR : Unresolved java classifier: ModalExclusionType]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseListener: [ERROR : Unresolved java classifier: MouseListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseMotionListener: [ERROR : Unresolved java classifier: MouseMotionListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseWheelListener: [ERROR : Unresolved java classifier: MouseWheelListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var name: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var nameExplicitlySet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var newEventsOnly: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var numOfHWComponents: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var numOfLWComponents: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var objectLock: kotlin.Any!
            invisible_fake final override /*1*/ /*fake_override*/ var opacity: kotlin.Float
            public/*package*/ final override /*1*/ /*fake_override*/ var ownedWindowList: [ERROR : Unresolved java classifier: Vector<WeakReference<Window>>]!
            public/*package*/ final var ownedWindows: [ERROR : Unresolved java classifier: Vector]!
            public/*package*/ final override /*1*/ /*fake_override*/ var parent: java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ var peer: [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ final override /*1*/ /*fake_override*/ var peerFont: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var popups: [ERROR : Unresolved java classifier: Vector]!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSizeSet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var preserveBackgroundColor: [ERROR : Unresolved java classifier: Color]!
            invisible_fake final override /*1*/ /*fake_override*/ var printing: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var printingThreads: kotlin.(Mutable)Set<*>!
            public/*package*/ final var resizable: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningAlignmentX: kotlin.Float
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningAlignmentY: kotlin.Float
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningHeight: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningPointX: kotlin.Double
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningPointY: kotlin.Double
            invisible_fake final override /*1*/ /*fake_override*/ var securityWarningWidth: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var shape: [ERROR : Unresolved java classifier: Shape]!
            public/*package*/ final override /*1*/ /*fake_override*/ var showWithParent: kotlin.Boolean
            private final override /*1*/ var state: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var syncLWRequests: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var temporaryLostComponent: java.awt.Component!
            public/*package*/ final var title: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var type: java.awt.Window.Type!
            public/*package*/ final var undecorated: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var valid: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var visible: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var warningString: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var weakThis: [ERROR : Unresolved java classifier: WeakReference<Window>]!
            public/*package*/ final override /*1*/ /*fake_override*/ var width: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var windowClosingException: java.lang.RuntimeException!
            public/*package*/ final override /*1*/ /*fake_override*/ var windowFocusListener: [ERROR : Unresolved java classifier: WindowFocusListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var windowListener: [ERROR : Unresolved java classifier: WindowListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var windowSerializedDataVersion: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var windowStateListener: [ERROR : Unresolved java classifier: WindowStateListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var x: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var y: kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun action(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: [ERROR : Unresolved java classifier: PopupMenu]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: kotlin.String!, /*1*/ p1: java.awt.Component!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun addComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun addDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun addImpl(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun addNotify(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun addOwnedWindow(/*0*/ p0: [ERROR : Unresolved java classifier: WeakReference]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addPropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun addToWindowList(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addWindowFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowFocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addWindowListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addWindowStateListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowStateListener]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustDecendantsOnParent(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustDescendants(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustListeningChildren(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustListeningChildrenOnParent(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun applyComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun applyCompoundShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun applyCurrentShape(): kotlin.Unit
            invisible_fake final override /*1*/ /*fake_override*/ fun applyCurrentShapeBelowMe(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun applyResourceBundle(/*0*/ p0: [ERROR : Unresolved java classifier: ResourceBundle]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun applyResourceBundle(/*0*/ p0: kotlin.String!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun areBoundsValid(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun areFocusTraversalKeysSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun areInputMethodsEnabled(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun autoProcessMouseWheel(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun bounds(): [ERROR : Unresolved java classifier: Rectangle]!
            invisible_fake open override /*1*/ /*fake_override*/ fun calculateCurrentShape(): [ERROR : Unresolved java classifier: Region]!
            invisible_fake open override /*1*/ /*fake_override*/ fun calculateSecurityWarningPosition(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double, /*3*/ p3: kotlin.Double): [ERROR : Unresolved java classifier: Point2D]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwner(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwnerRecursively(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun canContainFocusOwner(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun checkAddToSelf(/*0*/ p0: java.awt.Component!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun checkAdding(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun checkCoalescing(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkGD(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            invisible_fake open override /*1*/ /*fake_override*/ fun checkNotAWindow(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun checkTreeLock(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkWindowClosingException(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun clearCurrentFocusCycleRootOnHide(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun clearMostRecentFocusOwnerOnHide(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun closeSplashScreen(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun coalesceEvents(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!, /*1*/ p1: [ERROR : Unresolved java classifier: AWTEvent]!): [ERROR : Unresolved java classifier: AWTEvent]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun connectOwnedWindow(/*0*/ p0: java.awt.Window!): kotlin.Unit
            public/*package*/ open override /*1*/ fun constructComponentName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun containsFocus(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun countComponents(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun countHierarchyMembers(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun createChildHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun createHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: java.awt.Component!, /*2*/ p2: java.awt.Container!, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.Boolean): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: [ERROR : Unresolved java classifier: ImageProducer]!): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: VolatileImage]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: ImageCapabilities]!): [ERROR : Unresolved java classifier: VolatileImage]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun decreaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun deliverEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun deliverMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun deserializeResources(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun disable(): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun disableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun dispatchEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun dispatchEventImpl(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun dispatchEventToSelf(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun dispatchMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun dispose(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun disposeImpl(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun doDispose(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun doLayout(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun doSwingSerialization(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun enableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun enableInputMethods(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun eventEnabled(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun eventTypeEnabled(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun findComponentAtImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun findTraversalRoot(): java.awt.Container!
            public/*package*/ open override /*1*/ /*fake_override*/ fun findUnderMouseInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: PointerInfo]!): java.awt.Component!
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte, /*2*/ p2: kotlin.Byte): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char, /*2*/ p2: kotlin.Char): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float, /*2*/ p2: kotlin.Float): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short, /*2*/ p2: kotlin.Short): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun getAccessControlContext(): [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleChildrenCount(): kotlin.Int
            public open override /*1*/ fun getAccessibleContext(): [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
            public open override /*1*/ /*fake_override*/ fun getAlignmentX(): kotlin.Float
            public open override /*1*/ /*fake_override*/ fun getAlignmentY(): kotlin.Float
            invisible_fake open override /*1*/ /*fake_override*/ fun getAppliedShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getBaseline(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBaselineResizeBehavior(): java.awt.Component.BaselineResizeBehavior!
            invisible_fake open override /*1*/ /*fake_override*/ fun getBottommostComponentIndex(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
            public open override /*1*/ /*fake_override*/ fun getBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): [ERROR : Unresolved java classifier: Rectangle]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBoundsOp(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBufferStrategy(): [ERROR : Unresolved java classifier: BufferStrategy]!
            public open override /*1*/ /*fake_override*/ fun getColorModel(): [ERROR : Unresolved java classifier: ColorModel]!
            public open override /*1*/ /*fake_override*/ fun getComponent(/*0*/ p0: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentCount(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getComponentListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ComponentListener]!>!
            public open override /*1*/ /*fake_override*/ fun getComponentOrientation(): [ERROR : Unresolved java classifier: ComponentOrientation]!
            public open override /*1*/ /*fake_override*/ fun getComponentZOrder(/*0*/ p0: java.awt.Component!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getComponents(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getComponentsSync(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getComponents_NoClientCode(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getContainer(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getContainerListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ContainerListener]!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getContainingWindow(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getCursorType(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getCursor_NoClientCode(): [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getDocumentRoot(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getDropTarget(): [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getDropTargetEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public open fun getExtendedState(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getFocusCycleRootAncestor(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: FocusListener]!>!
            public open override /*1*/ /*fake_override*/ fun getFocusOwner(): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalKeys(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<java.awt.AWTKeyStroke!>!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalKeysEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<*>!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalPolicy(): [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            public open override /*1*/ /*fake_override*/ fun getFocusableWindowState(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
            public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFont_NoClientCode(): [ERROR : Unresolved java classifier: Font]!
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getGraphics(): [ERROR : Unresolved java classifier: Graphics]!
            public open override /*1*/ /*fake_override*/ fun getGraphicsConfiguration(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphicsConfiguration_NoClientCode(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphics_NoClientCode(): [ERROR : Unresolved java classifier: Graphics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getHWPeerAboveMe(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getHeavyweightContainer(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getHeight(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getHierarchyBoundsListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyBoundsListener]!>!
            public open override /*1*/ /*fake_override*/ fun getHierarchyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyListener]!>!
            public open fun getIconImage(): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun getIconImages(): kotlin.(Mutable)List<[ERROR : Unresolved java classifier: Image]!>!
            public open override /*1*/ /*fake_override*/ fun getIgnoreRepaint(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun getInputContext(): [ERROR : Unresolved java classifier: InputContext]!
            public open override /*1*/ /*fake_override*/ fun getInputMethodListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: InputMethodListener]!>!
            public open override /*1*/ /*fake_override*/ fun getInputMethodRequests(): [ERROR : Unresolved java classifier: InputMethodRequests]!
            public open override /*1*/ /*fake_override*/ fun getInsets(): [ERROR : Unresolved java classifier: Insets]!
            invisible_fake open override /*1*/ /*fake_override*/ fun getInsets_NoClientCode(): [ERROR : Unresolved java classifier: Insets]!
            public open override /*1*/ /*fake_override*/ fun getKeyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: KeyListener]!>!
            public open override /*1*/ /*fake_override*/ fun getLayout(): [ERROR : Unresolved java classifier: LayoutManager]!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T : java.util.EventListener!> getListeners(/*0*/ p0: java.lang.Class<T!>!): kotlin.Array<(out) T!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun getListenersCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getLocale(): java.util.Locale!
            public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getLocationOnScreen_NoTreeLock(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getLocationOnWindow(): [ERROR : Unresolved java classifier: Point]!
            public open fun getMaximizedBounds(): [ERROR : Unresolved java classifier: Rectangle]!
            public open override /*1*/ /*fake_override*/ fun getMaximumSize(): java.awt.Dimension!
            public open fun getMenuBar(): [ERROR : Unresolved java classifier: MenuBar]!
            public open override /*1*/ /*fake_override*/ fun getMinimumSize(): java.awt.Dimension!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getModalBlocker(): [ERROR : Unresolved java classifier: Dialog]!
            public open override /*1*/ /*fake_override*/ fun getModalExclusionType(): [ERROR : Unresolved java classifier: ModalExclusionType]!
            public open override /*1*/ /*fake_override*/ fun getMostRecentFocusOwner(): java.awt.Component!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            invisible_fake final override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            invisible_fake final override /*1*/ /*fake_override*/ fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getMouseListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMouseMotionListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseMotionListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMousePosition(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMousePosition(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMouseWheelListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseWheelListener]!>!
            public open override /*1*/ /*fake_override*/ fun getName(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getNativeContainer(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNextFocusCandidate(): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNormalShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getObjectLock(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun getOpacity(): kotlin.Float
            public/*package*/ final override /*1*/ /*fake_override*/ fun getOpaqueShape(): [ERROR : Unresolved java classifier: Region]!
            public open override /*1*/ /*fake_override*/ fun getOwnedWindows(): kotlin.Array<(out) java.awt.Window!>!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getOwnedWindows_NoClientCode(): kotlin.Array<(out) java.awt.Window!>!
            public open override /*1*/ /*fake_override*/ fun getOwner(): java.awt.Window!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getOwner_NoClientCode(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getParent(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getParent_NoClientCode(): java.awt.Container!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getPeer(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public open override /*1*/ /*fake_override*/ fun getPreferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(/*0*/ p0: kotlin.String!): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open override /*1*/ /*fake_override*/ fun getShape(): [ERROR : Unresolved java classifier: Shape]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexAbove(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexBelow(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getSize(/*0*/ p0: java.awt.Dimension!): java.awt.Dimension!
            public open fun getState(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun getTemporaryLostComponent(): java.awt.Component!
            public open fun getTitle(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getToolkit(): [ERROR : Unresolved java classifier: Toolkit]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getToolkitImpl(): [ERROR : Unresolved java classifier: Toolkit]!
            invisible_fake open override /*1*/ /*fake_override*/ fun getTopmostComponentIndex(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getTraversalRoot(): java.awt.Container!
            public final override /*1*/ /*fake_override*/ fun getTreeLock(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun getType(): java.awt.Window.Type!
            public final override /*1*/ /*fake_override*/ fun getWarningString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getWidth(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getWindowFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowFocusListener]!>!
            public open override /*1*/ /*fake_override*/ fun getWindowListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowListener]!>!
            public open override /*1*/ /*fake_override*/ fun getWindowStateListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowStateListener]!>!
            public open override /*1*/ /*fake_override*/ fun getX(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getY(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun gotFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun handleEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hasFocus(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun hasHeavyweightDescendants(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun hasLightweightDescendants(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun hide(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun imageUpdate(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun increaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun init(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            private open fun init(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun initDeserializedWindow(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun initGC(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun initializeFocusTraversalKeys(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun insets(): [ERROR : Unresolved java classifier: Insets]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun inside(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun invalidate(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun invalidateIfValid(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun invalidateParent(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun invalidateTree(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun isActive(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isAlwaysOnTop(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isAlwaysOnTopSupported(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isAncestorOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isAutoFocusTransferOnDisposal(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isAutoRequestFocus(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isBackgroundSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isCoalescingEnabled(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isCursorSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDisplayable(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isDisposing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDoubleBuffered(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isEnabledImpl(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isFocusCycleRoot(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusCycleRoot(/*0*/ p0: java.awt.Container!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusOwner(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isFocusTraversableOverridden(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isFocusTraversalPolicyProvider(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusTraversalPolicySet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusable(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isFocusableWindow(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocused(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFontSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isForegroundSet(): kotlin.Boolean
            private open fun isFrameStateSupported(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isLightweight(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isLocationByPlatform(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMaximumSizeSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMinimumSizeSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isMixingNeeded(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isModalBlocked(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isModalExcluded(/*0*/ p0: [ERROR : Unresolved java classifier: ModalExclusionType]!): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isNonOpaqueForMixing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isOpaque(): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun isParentOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isPreferredSizeSet(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isRecursivelyVisible(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isRecursivelyVisibleUpToHeavyweightContainer(): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun isRequestFocusAccepted(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public open fun isResizable(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isSameOrAncestorOf(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isShowing(): kotlin.Boolean
            public open fun isUndecorated(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isValid(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isValidateRoot(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isVisible_NoClientCode(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun layout(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun lightweightPaint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun lightweightPrint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun locate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun location(): [ERROR : Unresolved java classifier: Point]!
            invisible_fake open override /*1*/ /*fake_override*/ fun location_NoClientCode(): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun lostFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun minimumSize(): java.awt.Dimension!
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnHiding(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun mixOnReshaping(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnShowing(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnValidating(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnZOrderChanging(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDrag(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseEnter(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseExit(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseMove(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun move(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun nextFocus(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun notifyNewBounds(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun numListening(/*0*/ p0: kotlin.Long): kotlin.Int
            invisible_fake open override /*1*/ /*fake_override*/ fun ownedInit(/*0*/ p0: java.awt.Window!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun pack(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paintAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paintComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun paintHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ fun paramString(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun pointRelativeToComponent(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun postEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public/*package*/ open override /*1*/ fun postProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun postWindowEvent(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun postsOldMouseEvents(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun preProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun preferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun print(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun printAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun printComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun printHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processComponentEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processContainerEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyBoundsEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processInputMethodEvent(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseMotionEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseWheelEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processWindowEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processWindowFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processWindowStateEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun proxyEnableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveHideHeavyweightChildren(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveRelocateHeavyweightChildren(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveShowHeavyweightChildren(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun relocateComponent(): kotlin.Unit
            public open override /*1*/ fun remove(/*0*/ p0: [ERROR : Unresolved java classifier: MenuComponent]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun remove(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeAll(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun removeDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun removeFromWindowList(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun removeNotify(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun removeOwnedWindow(/*0*/ p0: [ERROR : Unresolved java classifier: WeakReference]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeWindowFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowFocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeWindowListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeWindowStateListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowStateListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun repaintParentIfNeeded(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reparentChild(/*0*/ p0: java.awt.Component!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reparentTraverse(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerPeer]!, /*1*/ p1: java.awt.Container!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun requestFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocus(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun requestFocusInWindow(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun reshape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reshapeNativePeer(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun revalidate(): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun setAlwaysOnTop(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setAutoFocusTransferOnDisposal(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setAutoRequestFocus(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setBoundsOp(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setClientSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setComponentZOrder(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun setCursor(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setDropTarget(/*0*/ p0: [ERROR : Unresolved java classifier: DropTarget]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setExtendedState(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun setFocusCycleRoot(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalKeys(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalKeysEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalPolicy(/*0*/ p0: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun setFocusTraversalPolicyProvider(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusableWindowState(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setGraphicsConfiguration(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            public open override /*1*/ fun setIconImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setIconImages(/*0*/ p0: (kotlin.MutableList<out [ERROR : Unresolved java classifier: Image]!>..kotlin.List<[ERROR : Unresolved java classifier: Image]!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setIgnoreRepaint(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLayout(/*0*/ p0: [ERROR : Unresolved java classifier: LayoutManager]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocale(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocationByPlatform(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocationRelativeTo(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public open fun setMaximizedBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMaximumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setMenuBar(/*0*/ p0: [ERROR : Unresolved java classifier: MenuBar]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMinimumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setModalBlocked(/*0*/ p0: [ERROR : Unresolved java classifier: Dialog]!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setModalExclusionType(/*0*/ p0: [ERROR : Unresolved java classifier: ModalExclusionType]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ fun setOpacity(/*0*/ p0: kotlin.Float): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setPreferredSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setResizable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun setShape(/*0*/ p0: [ERROR : Unresolved java classifier: Shape]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setTemporaryLostComponent(/*0*/ p0: java.awt.Component!): java.awt.Component!
            public open fun setTitle(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setType(/*0*/ p0: java.awt.Window.Type!): kotlin.Unit
            public open fun setUndecorated(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun setWarningString(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun show(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun show(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun size(): java.awt.Dimension!
            invisible_fake open override /*1*/ /*fake_override*/ fun startLWModal(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun stopLWModal(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShapeBelowMe(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toBack(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun toBack_NoClientCode(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toFront(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun toFront_NoClientCode(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun transferFocus(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocus(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun transferFocusBackward(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocusBackward(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun transferFocusDownCycle(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun transferFocusUpCycle(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun update(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun updateChildrenBlocking(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun updateCursorImmediately(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun updateGraphicsData(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun updateWindow(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun updateZOrder(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun validate(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun validateTree(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun validateUnconditionally(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            protected/*protected and package*/ open inner class AccessibleAWTFrame : java.awt.Window.AccessibleAWTWindow {
                protected/*protected and package*/ constructor AccessibleAWTFrame()
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTComponentHandler: [ERROR : Unresolved java classifier: ComponentListener]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTFocusHandler: [ERROR : Unresolved java classifier: FocusListener]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleContainerHandler: [ERROR : Unresolved java classifier: ContainerListener]!
                public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleChildrenCount(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleComponent(): [ERROR : Unresolved java classifier: AccessibleComponent]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleDescription(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleParent(): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ fun getAccessibleRole(): [ERROR : Unresolved java classifier: AccessibleRole]!
                public open override /*1*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
                public open override /*1*/ /*fake_override*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
                public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
                public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
                public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
                public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getLocale(): java.util.Locale!
                public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isShowing(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -6172960752956030250.toLong()
            }

            // Static members
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val CROSSHAIR_CURSOR: kotlin.Int = 1
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val DEFAULT_CURSOR: kotlin.Int = 0
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val E_RESIZE_CURSOR: kotlin.Int = 11
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val HAND_CURSOR: kotlin.Int = 12
            public final val ICONIFIED: kotlin.Int = 1
            public final val MAXIMIZED_BOTH: kotlin.Int = 6
            public final val MAXIMIZED_HORIZ: kotlin.Int = 2
            public final val MAXIMIZED_VERT: kotlin.Int = 4
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val MOVE_CURSOR: kotlin.Int = 13
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val NE_RESIZE_CURSOR: kotlin.Int = 7
            public final val NORMAL: kotlin.Int = 0
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val NW_RESIZE_CURSOR: kotlin.Int = 6
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val N_RESIZE_CURSOR: kotlin.Int = 8
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val SE_RESIZE_CURSOR: kotlin.Int = 5
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val SW_RESIZE_CURSOR: kotlin.Int = 4
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val S_RESIZE_CURSOR: kotlin.Int = 9
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val TEXT_CURSOR: kotlin.Int = 2
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val WAIT_CURSOR: kotlin.Int = 3
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val W_RESIZE_CURSOR: kotlin.Int = 10
            private final val base: kotlin.String = "frame"
            private final var nameCounter: kotlin.Int
            private final val serialVersionUID: kotlin.Long = 2673458971256075116.toLong()
            public open fun getFrames(): kotlin.Array<(out) java.awt.Frame!>!
            private open fun initIDs(): kotlin.Unit
        }

        public open class GridBagConstraints : kotlin.Cloneable, java.io.Serializable {
            public constructor GridBagConstraints()
            public constructor GridBagConstraints(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Double, /*5*/ p5: kotlin.Double, /*6*/ p6: kotlin.Int, /*7*/ p7: kotlin.Int, /*8*/ p8: [ERROR : Unresolved java classifier: Insets]!, /*9*/ p9: kotlin.Int, /*10*/ p10: kotlin.Int)
            public final var anchor: kotlin.Int
            public/*package*/ final var ascent: kotlin.Int
            public/*package*/ final var baselineResizeBehavior: java.awt.Component.BaselineResizeBehavior!
            public/*package*/ final var centerOffset: kotlin.Int
            public/*package*/ final var centerPadding: kotlin.Int
            public/*package*/ final var descent: kotlin.Int
            public final var fill: kotlin.Int
            public final var gridheight: kotlin.Int
            public final var gridwidth: kotlin.Int
            public final var gridx: kotlin.Int
            public final var gridy: kotlin.Int
            public final var insets: [ERROR : Unresolved java classifier: Insets]!
            public final var ipadx: kotlin.Int
            public final var ipady: kotlin.Int
            public/*package*/ final var minHeight: kotlin.Int
            public/*package*/ final var minWidth: kotlin.Int
            public/*package*/ final var tempHeight: kotlin.Int
            public/*package*/ final var tempWidth: kotlin.Int
            public/*package*/ final var tempX: kotlin.Int
            public/*package*/ final var tempY: kotlin.Int
            public final var weightx: kotlin.Double
            public final var weighty: kotlin.Double
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public/*package*/ open fun isVerticallyResizable(): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val ABOVE_BASELINE: kotlin.Int = 1024
            public final val ABOVE_BASELINE_LEADING: kotlin.Int = 1280
            public final val ABOVE_BASELINE_TRAILING: kotlin.Int = 1536
            public final val BASELINE: kotlin.Int = 256
            public final val BASELINE_LEADING: kotlin.Int = 512
            public final val BASELINE_TRAILING: kotlin.Int = 768
            public final val BELOW_BASELINE: kotlin.Int = 1792
            public final val BELOW_BASELINE_LEADING: kotlin.Int = 2048
            public final val BELOW_BASELINE_TRAILING: kotlin.Int = 2304
            public final val BOTH: kotlin.Int = 1
            public final val CENTER: kotlin.Int = 10
            public final val EAST: kotlin.Int = 13
            public final val FIRST_LINE_END: kotlin.Int = 24
            public final val FIRST_LINE_START: kotlin.Int = 23
            public final val HORIZONTAL: kotlin.Int = 2
            public final val LAST_LINE_END: kotlin.Int = 26
            public final val LAST_LINE_START: kotlin.Int = 25
            public final val LINE_END: kotlin.Int = 22
            public final val LINE_START: kotlin.Int = 21
            public final val NONE: kotlin.Int = 0
            public final val NORTH: kotlin.Int = 11
            public final val NORTHEAST: kotlin.Int = 12
            public final val NORTHWEST: kotlin.Int = 18
            public final val PAGE_END: kotlin.Int = 20
            public final val PAGE_START: kotlin.Int = 19
            public final val RELATIVE: kotlin.Int = -1
            public final val REMAINDER: kotlin.Int = 0
            public final val SOUTH: kotlin.Int = 15
            public final val SOUTHEAST: kotlin.Int = 14
            public final val SOUTHWEST: kotlin.Int = 16
            public final val VERTICAL: kotlin.Int = 3
            public final val WEST: kotlin.Int = 17
            private final val serialVersionUID: kotlin.Long = -1000070633030801713.toLong()
        }

        public open class Window : java.awt.Container {
            public/*package*/ constructor Window()
            public/*package*/ constructor Window(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!)
            public constructor Window(/*0*/ p0: java.awt.Frame!)
            public constructor Window(/*0*/ p0: java.awt.Window!)
            public constructor Window(/*0*/ p0: java.awt.Window!, /*1*/ p1: [ERROR : Unresolved java classifier: GraphicsConfiguration]!)
            invisible_fake final override /*1*/ /*fake_override*/ var acc: [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ final override /*1*/ /*fake_override*/ var accessibleContext: [ERROR : Unresolved java classifier: AccessibleContext]!
            private final var alwaysOnTop: kotlin.Boolean
            public/*package*/ final var anchor: kotlin.Any!
            public/*package*/ final override /*1*/ /*fake_override*/ var appContext: [ERROR : Unresolved java classifier: AppContext]!
            invisible_fake final override /*1*/ /*fake_override*/ var autoFocusTransferOnDisposal: kotlin.Boolean
            private final var autoRequestFocus: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var background: [ERROR : Unresolved java classifier: Color]!
            public/*package*/ final override /*1*/ /*fake_override*/ var backgroundEraseDisabled: kotlin.Boolean
            public/*package*/ final var beforeFirstShow: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var boundsOp: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var bufferStrategy: [ERROR : Unresolved java classifier: BufferStrategy]!
            invisible_fake final override /*1*/ /*fake_override*/ var changeSupport: [ERROR : Unresolved java classifier: PropertyChangeSupport]!
            invisible_fake final override /*1*/ /*fake_override*/ var coalescingEnabled: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var component: kotlin.(Mutable)List<java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentListener: [ERROR : Unresolved java classifier: ComponentListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var componentOrientation: [ERROR : Unresolved java classifier: ComponentOrientation]!
            invisible_fake final override /*1*/ /*fake_override*/ var componentSerializedDataVersion: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var compoundShape: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final override /*1*/ /*fake_override*/ var containerListener: [ERROR : Unresolved java classifier: ContainerListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var containerSerializedDataVersion: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var cursor: [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final override /*1*/ /*fake_override*/ var descendantsCount: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var dispatcher: [ERROR : Unresolved java classifier: LightweightDispatcher]!
            private final var disposing: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var dropTarget: [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ final override /*1*/ /*fake_override*/ var enabled: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var eventCache: kotlin.Array<(out) [ERROR : Unresolved java classifier: EventQueueItem]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var eventMask: kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ var focusCycleRoot: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var focusListener: [ERROR : Unresolved java classifier: FocusListener]!
            private final var focusMgr: [ERROR : Unresolved java classifier: FocusManager]!
            public/*package*/ final override /*1*/ /*fake_override*/ var focusTraversalKeys: kotlin.Array<(out) kotlin.(Mutable)Set<*>!>!
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalKeysEnabled: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalPolicy: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            invisible_fake final override /*1*/ /*fake_override*/ var focusTraversalPolicyProvider: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var focusable: kotlin.Boolean
            private final var focusableWindowState: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var font: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var foreground: [ERROR : Unresolved java classifier: Color]!
            invisible_fake final override /*1*/ /*fake_override*/ var graphicsConfig: [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ var height: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyBoundsListener: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var hierarchyListener: [ERROR : Unresolved java classifier: HierarchyListener]!
            public/*package*/ final var icons: kotlin.(Mutable)List<[ERROR : Unresolved java classifier: Image]!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var ignoreRepaint: kotlin.Boolean
            public/*package*/ final var inputContext: [ERROR : Unresolved java classifier: InputContext]!
            private final var inputContextLock: kotlin.Any!
            public/*package*/ final override /*1*/ /*fake_override*/ var inputMethodListener: [ERROR : Unresolved java classifier: InputMethodListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var isAddNotifyComplete: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var isFocusTraversableOverridden: kotlin.Int
            public/*package*/ final var isInShow: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var isPacked: kotlin.Boolean
            public/*package*/ final var isTrayIconWindow: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var keyListener: [ERROR : Unresolved java classifier: KeyListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var layoutMgr: [ERROR : Unresolved java classifier: LayoutManager]!
            public/*package*/ final override /*1*/ /*fake_override*/ var listeningBoundsChildren: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var listeningChildren: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var locale: java.util.Locale!
            private final var locationByPlatform: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var maxSizeSet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var minSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var minSizeSet: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var mixingCutoutRegion: [ERROR : Unresolved java classifier: Region]!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalAppContext: [ERROR : Unresolved java classifier: AppContext]!
            public/*package*/ final var modalBlocker: [ERROR : Unresolved java classifier: Dialog]!
            public/*package*/ final override /*1*/ /*fake_override*/ var modalComp: java.awt.Component!
            public/*package*/ final var modalExclusionType: [ERROR : Unresolved java classifier: ModalExclusionType]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseListener: [ERROR : Unresolved java classifier: MouseListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseMotionListener: [ERROR : Unresolved java classifier: MouseMotionListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var mouseWheelListener: [ERROR : Unresolved java classifier: MouseWheelListener]!
            invisible_fake final override /*1*/ /*fake_override*/ var name: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var nameExplicitlySet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var newEventsOnly: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var numOfHWComponents: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var numOfLWComponents: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var objectLock: kotlin.Any!
            private final var opacity: kotlin.Float
            public/*package*/ final var ownedWindowList: [ERROR : Unresolved java classifier: Vector<WeakReference<Window>>]!
            public/*package*/ final override /*1*/ /*fake_override*/ var parent: java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ var peer: [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ final override /*1*/ /*fake_override*/ var peerFont: [ERROR : Unresolved java classifier: Font]!
            public/*package*/ final override /*1*/ /*fake_override*/ var popups: [ERROR : Unresolved java classifier: Vector]!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSize: java.awt.Dimension!
            public/*package*/ final override /*1*/ /*fake_override*/ var prefSizeSet: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var preserveBackgroundColor: [ERROR : Unresolved java classifier: Color]!
            invisible_fake final override /*1*/ /*fake_override*/ var printing: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var printingThreads: kotlin.(Mutable)Set<*>!
            private final var securityWarningAlignmentX: kotlin.Float
            private final var securityWarningAlignmentY: kotlin.Float
            private final var securityWarningHeight: kotlin.Int
            private final var securityWarningPointX: kotlin.Double
            private final var securityWarningPointY: kotlin.Double
            private final var securityWarningWidth: kotlin.Int
            private final var shape: [ERROR : Unresolved java classifier: Shape]!
            public/*package*/ final var showWithParent: kotlin.Boolean
            public/*package*/ final var state: kotlin.Int
            public/*package*/ final var syncLWRequests: kotlin.Boolean
            private final var temporaryLostComponent: java.awt.Component!
            private final var type: java.awt.Window.Type!
            invisible_fake final override /*1*/ /*fake_override*/ var valid: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var visible: kotlin.Boolean
            public/*package*/ final var warningString: kotlin.String!
            private final var weakThis: [ERROR : Unresolved java classifier: WeakReference<Window>]!
            public/*package*/ final override /*1*/ /*fake_override*/ var width: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var windowClosingException: java.lang.RuntimeException!
            public/*package*/ final var windowFocusListener: [ERROR : Unresolved java classifier: WindowFocusListener]!
            public/*package*/ final var windowListener: [ERROR : Unresolved java classifier: WindowListener]!
            private final var windowSerializedDataVersion: kotlin.Int
            public/*package*/ final var windowStateListener: [ERROR : Unresolved java classifier: WindowStateListener]!
            public/*package*/ final override /*1*/ /*fake_override*/ var x: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var y: kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun action(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: [ERROR : Unresolved java classifier: PopupMenu]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ p0: kotlin.String!, /*1*/ p1: java.awt.Component!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun addComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun addDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun addImpl(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun addNotify(): kotlin.Unit
            public/*package*/ open fun addOwnedWindow(/*0*/ p0: [ERROR : Unresolved java classifier: WeakReference]!): kotlin.Unit
            public open override /*1*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ fun addPropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            private open fun addToWindowList(): kotlin.Unit
            public open fun addWindowFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowFocusListener]!): kotlin.Unit
            public open fun addWindowListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowListener]!): kotlin.Unit
            public open fun addWindowStateListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowStateListener]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun adjustDecendantsOnParent(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustDescendants(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun adjustListeningChildren(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ fun adjustListeningChildrenOnParent(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun applyComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public/*package*/ final override /*1*/ fun applyCompoundShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ fun applyCurrentShape(): kotlin.Unit
            invisible_fake final override /*1*/ /*fake_override*/ fun applyCurrentShapeBelowMe(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun applyResourceBundle(/*0*/ p0: [ERROR : Unresolved java classifier: ResourceBundle]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun applyResourceBundle(/*0*/ p0: kotlin.String!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun areBoundsValid(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun areFocusTraversalKeysSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun areInputMethodsEnabled(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun autoProcessMouseWheel(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun bounds(): [ERROR : Unresolved java classifier: Rectangle]!
            invisible_fake open override /*1*/ /*fake_override*/ fun calculateCurrentShape(): [ERROR : Unresolved java classifier: Region]!
            private open fun calculateSecurityWarningPosition(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double, /*3*/ p3: kotlin.Double): [ERROR : Unresolved java classifier: Point2D]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwner(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun canBeFocusOwnerRecursively(): kotlin.Boolean
            public/*package*/ open override /*1*/ fun canContainFocusOwner(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun checkAddToSelf(/*0*/ p0: java.awt.Component!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun checkAdding(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun checkCoalescing(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkGD(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun checkImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Int
            invisible_fake open override /*1*/ /*fake_override*/ fun checkNotAWindow(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun checkTreeLock(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkWindowClosingException(): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun clearCurrentFocusCycleRootOnHide(): kotlin.Unit
            public/*package*/ final override /*1*/ fun clearMostRecentFocusOwnerOnHide(): kotlin.Unit
            public/*package*/ final fun closeSplashScreen(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun coalesceEvents(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!, /*1*/ p1: [ERROR : Unresolved java classifier: AWTEvent]!): [ERROR : Unresolved java classifier: AWTEvent]!
            public/*package*/ open fun connectOwnedWindow(/*0*/ p0: java.awt.Window!): kotlin.Unit
            public/*package*/ open override /*1*/ fun constructComponentName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun containsFocus(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun countComponents(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun countHierarchyMembers(): kotlin.Int
            public open override /*1*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun createBufferStrategy(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BufferCapabilities]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun createChildHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun createHierarchyEvents(/*0*/ p0: kotlin.Int, /*1*/ p1: java.awt.Component!, /*2*/ p2: java.awt.Container!, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.Boolean): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: [ERROR : Unresolved java classifier: ImageProducer]!): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: VolatileImage]!
            public open override /*1*/ /*fake_override*/ fun createVolatileImage(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: ImageCapabilities]!): [ERROR : Unresolved java classifier: VolatileImage]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun decreaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun deliverEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Unit
            public/*package*/ open fun deliverMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            private open fun deserializeResources(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun disable(): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun disableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun dispatchEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun dispatchEventImpl(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun dispatchEventToSelf(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun dispatchMouseWheelToAncestor(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Boolean
            public open fun dispose(): kotlin.Unit
            public/*package*/ open fun disposeImpl(): kotlin.Unit
            public/*package*/ open fun doDispose(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun doLayout(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun doSwingSerialization(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun enable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun enableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun enableInputMethods(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open override /*1*/ fun eventEnabled(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun eventTypeEnabled(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun findComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun findComponentAtImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun findTraversalRoot(): java.awt.Container!
            public/*package*/ open override /*1*/ /*fake_override*/ fun findUnderMouseInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: PointerInfo]!): java.awt.Component!
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte, /*2*/ p2: kotlin.Byte): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char, /*2*/ p2: kotlin.Char): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float, /*2*/ p2: kotlin.Float): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun firePropertyChange(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short, /*2*/ p2: kotlin.Short): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun getAccessControlContext(): [ERROR : Unresolved java classifier: AccessControlContext]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleChildrenCount(): kotlin.Int
            public open override /*1*/ fun getAccessibleContext(): [ERROR : Unresolved java classifier: AccessibleContext]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
            public/*package*/ open override /*1*/ /*fake_override*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
            public open override /*1*/ /*fake_override*/ fun getAlignmentX(): kotlin.Float
            public open override /*1*/ /*fake_override*/ fun getAlignmentY(): kotlin.Float
            invisible_fake open override /*1*/ /*fake_override*/ fun getAppliedShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBackBuffer(): [ERROR : Unresolved java classifier: Image]!
            public open override /*1*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getBaseline(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBaselineResizeBehavior(): java.awt.Component.BaselineResizeBehavior!
            invisible_fake open override /*1*/ /*fake_override*/ fun getBottommostComponentIndex(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
            public open override /*1*/ /*fake_override*/ fun getBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): [ERROR : Unresolved java classifier: Rectangle]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getBoundsOp(): kotlin.Int
            public open override /*1*/ fun getBufferStrategy(): [ERROR : Unresolved java classifier: BufferStrategy]!
            public open override /*1*/ /*fake_override*/ fun getColorModel(): [ERROR : Unresolved java classifier: ColorModel]!
            public open override /*1*/ /*fake_override*/ fun getComponent(/*0*/ p0: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getComponentCount(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getComponentListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ComponentListener]!>!
            public open override /*1*/ /*fake_override*/ fun getComponentOrientation(): [ERROR : Unresolved java classifier: ComponentOrientation]!
            public open override /*1*/ /*fake_override*/ fun getComponentZOrder(/*0*/ p0: java.awt.Component!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getComponents(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getComponentsSync(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getComponents_NoClientCode(): kotlin.Array<(out) java.awt.Component!>!
            public/*package*/ final override /*1*/ fun getContainer(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getContainerListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: ContainerListener]!>!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getContainingWindow(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getCursor_NoClientCode(): [ERROR : Unresolved java classifier: Cursor]!
            public/*package*/ open fun getDocumentRoot(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getDropTarget(): [ERROR : Unresolved java classifier: DropTarget]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getDropTargetEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            public final override /*1*/ fun getFocusCycleRootAncestor(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: FocusListener]!>!
            public open fun getFocusOwner(): java.awt.Component!
            public open override /*1*/ fun getFocusTraversalKeys(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<java.awt.AWTKeyStroke!>!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalKeysEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int): kotlin.(Mutable)Set<*>!
            public open override /*1*/ /*fake_override*/ fun getFocusTraversalPolicy(): [ERROR : Unresolved java classifier: FocusTraversalPolicy]!
            public open fun getFocusableWindowState(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
            public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getFont_NoClientCode(): [ERROR : Unresolved java classifier: Font]!
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
            public open override /*1*/ /*fake_override*/ fun getGraphics(): [ERROR : Unresolved java classifier: Graphics]!
            public open override /*1*/ /*fake_override*/ fun getGraphicsConfiguration(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphicsConfiguration_NoClientCode(): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getGraphics_NoClientCode(): [ERROR : Unresolved java classifier: Graphics]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getHWPeerAboveMe(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getHeavyweightContainer(): java.awt.Container!
            public open override /*1*/ /*fake_override*/ fun getHeight(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getHierarchyBoundsListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyBoundsListener]!>!
            public open override /*1*/ /*fake_override*/ fun getHierarchyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: HierarchyListener]!>!
            public open fun getIconImages(): kotlin.(Mutable)List<[ERROR : Unresolved java classifier: Image]!>!
            public open override /*1*/ /*fake_override*/ fun getIgnoreRepaint(): kotlin.Boolean
            public open override /*1*/ fun getInputContext(): [ERROR : Unresolved java classifier: InputContext]!
            public open override /*1*/ /*fake_override*/ fun getInputMethodListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: InputMethodListener]!>!
            public open override /*1*/ /*fake_override*/ fun getInputMethodRequests(): [ERROR : Unresolved java classifier: InputMethodRequests]!
            public open override /*1*/ /*fake_override*/ fun getInsets(): [ERROR : Unresolved java classifier: Insets]!
            invisible_fake open override /*1*/ /*fake_override*/ fun getInsets_NoClientCode(): [ERROR : Unresolved java classifier: Insets]!
            public open override /*1*/ /*fake_override*/ fun getKeyListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: KeyListener]!>!
            public open override /*1*/ /*fake_override*/ fun getLayout(): [ERROR : Unresolved java classifier: LayoutManager]!
            public open override /*1*/ fun </*0*/ T : java.util.EventListener!> getListeners(/*0*/ p0: java.lang.Class<T!>!): kotlin.Array<(out) T!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun getListenersCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Int
            public open override /*1*/ fun getLocale(): java.util.Locale!
            public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getLocationOnScreen_NoTreeLock(): [ERROR : Unresolved java classifier: Point]!
            public/*package*/ final override /*1*/ fun getLocationOnWindow(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMaximumSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getMinimumSize(): java.awt.Dimension!
            public/*package*/ open fun getModalBlocker(): [ERROR : Unresolved java classifier: Dialog]!
            public open fun getModalExclusionType(): [ERROR : Unresolved java classifier: ModalExclusionType]!
            public open fun getMostRecentFocusOwner(): java.awt.Component!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): java.awt.Component!
            invisible_fake final override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun getMouseEventTarget(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean): java.awt.Component!
            invisible_fake final override /*1*/ /*fake_override*/ fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: ((java.awt.Component!) -> kotlin.Boolean)!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            invisible_fake open override /*1*/ /*fake_override*/ fun getMouseEventTargetImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean, /*3*/ p3: java.awt.Container.EventTargetFilter!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: kotlin.Boolean): java.awt.Component!
            public open override /*1*/ /*fake_override*/ fun getMouseListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMouseMotionListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseMotionListener]!>!
            public open override /*1*/ /*fake_override*/ fun getMousePosition(): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMousePosition(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: Point]!
            public open override /*1*/ /*fake_override*/ fun getMouseWheelListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: MouseWheelListener]!>!
            public open override /*1*/ /*fake_override*/ fun getName(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getNativeContainer(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNextFocusCandidate(): java.awt.Component!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getNormalShape(): [ERROR : Unresolved java classifier: Region]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun getObjectLock(): kotlin.Any!
            public open fun getOpacity(): kotlin.Float
            public/*package*/ final override /*1*/ /*fake_override*/ fun getOpaqueShape(): [ERROR : Unresolved java classifier: Region]!
            public open fun getOwnedWindows(): kotlin.Array<(out) java.awt.Window!>!
            public/*package*/ final fun getOwnedWindows_NoClientCode(): kotlin.Array<(out) java.awt.Window!>!
            public open fun getOwner(): java.awt.Window!
            public/*package*/ final fun getOwner_NoClientCode(): java.awt.Window!
            public open override /*1*/ /*fake_override*/ fun getParent(): java.awt.Container!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getParent_NoClientCode(): java.awt.Container!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getPeer(): [ERROR : Unresolved java classifier: ComponentPeer]!
            public open override /*1*/ /*fake_override*/ fun getPreferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open override /*1*/ /*fake_override*/ fun getPropertyChangeListeners(/*0*/ p0: kotlin.String!): kotlin.Array<(out) [ERROR : Unresolved java classifier: PropertyChangeListener]!>!
            public open fun getShape(): [ERROR : Unresolved java classifier: Shape]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexAbove(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSiblingIndexBelow(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun getSize(/*0*/ p0: java.awt.Dimension!): java.awt.Dimension!
            public/*package*/ open fun getTemporaryLostComponent(): java.awt.Component!
            public open override /*1*/ fun getToolkit(): [ERROR : Unresolved java classifier: Toolkit]!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getToolkitImpl(): [ERROR : Unresolved java classifier: Toolkit]!
            invisible_fake open override /*1*/ /*fake_override*/ fun getTopmostComponentIndex(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun getTraversalRoot(): java.awt.Container!
            public final override /*1*/ /*fake_override*/ fun getTreeLock(): kotlin.Any!
            public open fun getType(): java.awt.Window.Type!
            public final fun getWarningString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getWidth(): kotlin.Int
            public open fun getWindowFocusListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowFocusListener]!>!
            public open fun getWindowListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowListener]!>!
            public open fun getWindowStateListeners(): kotlin.Array<(out) [ERROR : Unresolved java classifier: WindowStateListener]!>!
            public open override /*1*/ /*fake_override*/ fun getX(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getY(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun gotFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun handleEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hasFocus(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun hasHeavyweightDescendants(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun hasLightweightDescendants(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun hide(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun imageUpdate(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun increaseComponentCount(/*0*/ p0: java.awt.Component!): kotlin.Unit
            private open fun init(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            private open fun initDeserializedWindow(): kotlin.Unit
            private open fun initGC(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): [ERROR : Unresolved java classifier: GraphicsConfiguration]!
            public/*package*/ open override /*1*/ /*fake_override*/ fun initializeFocusTraversalKeys(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun insets(): [ERROR : Unresolved java classifier: Insets]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun inside(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun invalidate(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun invalidateIfValid(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun invalidateParent(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun invalidateTree(): kotlin.Unit
            public open fun isActive(): kotlin.Boolean
            public final fun isAlwaysOnTop(): kotlin.Boolean
            public open fun isAlwaysOnTopSupported(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isAncestorOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isAutoFocusTransferOnDisposal(): kotlin.Boolean
            public open fun isAutoRequestFocus(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isBackgroundSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isCoalescingEnabled(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isCursorSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDisplayable(): kotlin.Boolean
            public/*package*/ open fun isDisposing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isDoubleBuffered(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isEnabledImpl(): kotlin.Boolean
            public final override /*1*/ fun isFocusCycleRoot(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusCycleRoot(/*0*/ p0: java.awt.Container!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusOwner(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isFocusTraversableOverridden(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isFocusTraversalPolicyProvider(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusTraversalPolicySet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFocusable(): kotlin.Boolean
            public final fun isFocusableWindow(): kotlin.Boolean
            public open fun isFocused(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isFontSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isForegroundSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isLightweight(): kotlin.Boolean
            public open fun isLocationByPlatform(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMaximumSizeSet(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isMinimumSizeSet(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isMixingNeeded(): kotlin.Boolean
            public/*package*/ open fun isModalBlocked(): kotlin.Boolean
            public/*package*/ open fun isModalExcluded(/*0*/ p0: [ERROR : Unresolved java classifier: ModalExclusionType]!): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isNonOpaqueForMixing(): kotlin.Boolean
            public open override /*1*/ fun isOpaque(): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun isParentOf(/*0*/ p0: java.awt.Component!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isPreferredSizeSet(): kotlin.Boolean
            public/*package*/ open override /*1*/ fun isRecursivelyVisible(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isRecursivelyVisibleUpToHeavyweightContainer(): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun isRequestFocusAccepted(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun isSameOrAncestorOf(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ fun isShowing(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isValid(): kotlin.Boolean
            public open override /*1*/ fun isValidateRoot(): kotlin.Boolean
            [ERROR : java.beans.Transient]() public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isVisible_NoClientCode(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun keyUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun layout(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun lightweightPaint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun lightweightPrint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun locate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.awt.Component!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun location(): [ERROR : Unresolved java classifier: Point]!
            invisible_fake open override /*1*/ /*fake_override*/ fun location_NoClientCode(): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun lostFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun minimumSize(): java.awt.Dimension!
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnHiding(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ fun mixOnReshaping(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnShowing(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnValidating(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun mixOnZOrderChanging(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDown(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseDrag(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseEnter(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseExit(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseMove(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun mouseUp(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun move(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun nextFocus(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun notifyNewBounds(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun numListening(/*0*/ p0: kotlin.Long): kotlin.Int
            private open fun ownedInit(/*0*/ p0: java.awt.Window!): kotlin.Unit
            public open fun pack(): kotlin.Unit
            public open override /*1*/ fun paint(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paintAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun paintComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun paintHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun paramString(): kotlin.String!
            public/*package*/ open override /*1*/ /*fake_override*/ fun pointRelativeToComponent(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Point]!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun postEvent(/*0*/ p0: [ERROR : Unresolved java classifier: Event]!): kotlin.Boolean
            public/*package*/ open override /*1*/ fun postProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            public/*package*/ open fun postWindowEvent(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun postsOldMouseEvents(): kotlin.Boolean
            public/*package*/ open override /*1*/ fun preProcessKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun preferredSize(): java.awt.Dimension!
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun prepareImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: ImageObserver]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun print(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun printAll(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun printComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun printHeavyweightComponents(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processComponentEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processContainerEvent(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ fun processEvent(/*0*/ p0: [ERROR : Unresolved java classifier: AWTEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: FocusEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyBoundsEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processHierarchyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processInputMethodEvent(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processKeyEvent(/*0*/ p0: [ERROR : Unresolved java classifier: KeyEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseMotionEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseEvent]!): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun processMouseWheelEvent(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processWindowEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processWindowFocusEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            protected/*protected and package*/ open fun processWindowStateEvent(/*0*/ p0: [ERROR : Unresolved java classifier: WindowEvent]!): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun proxyEnableEvents(/*0*/ p0: kotlin.Long): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveApplyCurrentShape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveHideHeavyweightChildren(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveRelocateHeavyweightChildren(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun recursiveShowHeavyweightChildren(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun recursiveSubtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun relocateComponent(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun remove(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun remove(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeAll(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeComponentListener(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeContainerListener(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerListener]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun removeDelicately(/*0*/ p0: java.awt.Component!, /*1*/ p1: java.awt.Container!, /*2*/ p2: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
            private open fun removeFromWindowList(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyBoundsListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyBoundsListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeHierarchyListener(/*0*/ p0: [ERROR : Unresolved java classifier: HierarchyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeInputMethodListener(/*0*/ p0: [ERROR : Unresolved java classifier: InputMethodListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeKeyListener(/*0*/ p0: [ERROR : Unresolved java classifier: KeyListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseMotionListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseMotionListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removeMouseWheelListener(/*0*/ p0: [ERROR : Unresolved java classifier: MouseWheelListener]!): kotlin.Unit
            public open override /*1*/ fun removeNotify(): kotlin.Unit
            public/*package*/ open fun removeOwnedWindow(/*0*/ p0: [ERROR : Unresolved java classifier: WeakReference]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
            public open fun removeWindowFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowFocusListener]!): kotlin.Unit
            public open fun removeWindowListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowListener]!): kotlin.Unit
            public open fun removeWindowStateListener(/*0*/ p0: [ERROR : Unresolved java classifier: WindowStateListener]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun repaint(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun repaintParentIfNeeded(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reparentChild(/*0*/ p0: java.awt.Component!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reparentTraverse(/*0*/ p0: [ERROR : Unresolved java classifier: ContainerPeer]!, /*1*/ p1: java.awt.Container!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun requestFocus(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocus(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun requestFocusHelper(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean, /*2*/ p2: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun requestFocusInWindow(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun requestFocusInWindow(/*0*/ p0: kotlin.Boolean, /*1*/ p1: [ERROR : Unresolved java classifier: Cause]!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun reshape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun reshapeNativePeer(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun resize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun revalidate(): kotlin.Unit
            public final fun setAlwaysOnTop(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setAutoFocusTransferOnDisposal(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setAutoRequestFocus(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public open override /*1*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
            public open override /*1*/ fun setBounds(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setBoundsOp(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open fun setClientSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setComponentOrientation(/*0*/ p0: [ERROR : Unresolved java classifier: ComponentOrientation]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setComponentZOrder(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setDropTarget(/*0*/ p0: [ERROR : Unresolved java classifier: DropTarget]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public final override /*1*/ fun setFocusCycleRoot(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalKeys(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalKeysEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setFocusTraversalKeys_NoIDCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: (kotlin.MutableSet<out java.awt.AWTKeyStroke!>..kotlin.Set<java.awt.AWTKeyStroke!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusTraversalPolicy(/*0*/ p0: [ERROR : Unresolved java classifier: FocusTraversalPolicy]!): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun setFocusTraversalPolicyProvider(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFocusable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setFocusableWindowState(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
            public/*package*/ open override /*1*/ fun setGraphicsConfiguration(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Unit
            public open fun setIconImage(/*0*/ p0: [ERROR : Unresolved java classifier: Image]!): kotlin.Unit
            public open fun setIconImages(/*0*/ p0: (kotlin.MutableList<out [ERROR : Unresolved java classifier: Image]!>..kotlin.List<[ERROR : Unresolved java classifier: Image]!>?)): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setIgnoreRepaint(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLayout(/*0*/ p0: [ERROR : Unresolved java classifier: LayoutManager]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLocale(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open override /*1*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
            public open override /*1*/ fun setLocation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun setLocationByPlatform(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setLocationRelativeTo(/*0*/ p0: java.awt.Component!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMaximumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ fun setMinimumSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public/*package*/ open fun setModalBlocked(/*0*/ p0: [ERROR : Unresolved java classifier: Dialog]!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open fun setModalExclusionType(/*0*/ p0: [ERROR : Unresolved java classifier: ModalExclusionType]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun setOpacity(/*0*/ p0: kotlin.Float): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setPreferredSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open fun setShape(/*0*/ p0: [ERROR : Unresolved java classifier: Shape]!): kotlin.Unit
            public open override /*1*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
            public open override /*1*/ fun setSize(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open fun setTemporaryLostComponent(/*0*/ p0: java.awt.Component!): java.awt.Component!
            public open fun setType(/*0*/ p0: java.awt.Window.Type!): kotlin.Unit
            public open override /*1*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            private open fun setWarningString(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun show(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun show(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun size(): java.awt.Dimension!
            invisible_fake open override /*1*/ /*fake_override*/ fun startLWModal(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun stopLWModal(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShape(/*0*/ p0: [ERROR : Unresolved java classifier: Region]!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun subtractAndApplyShapeBelowMe(): kotlin.Unit
            public open fun toBack(): kotlin.Unit
            public/*package*/ final fun toBack_NoClientCode(): kotlin.Unit
            public open fun toFront(): kotlin.Unit
            public/*package*/ final fun toFront_NoClientCode(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun transferFocus(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocus(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun transferFocusBackward(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun transferFocusBackward(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun transferFocusDownCycle(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun transferFocusUpCycle(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun update(/*0*/ p0: [ERROR : Unresolved java classifier: Graphics]!): kotlin.Unit
            public/*package*/ open fun updateChildrenBlocking(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun updateCursorImmediately(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun updateGraphicsData(/*0*/ p0: [ERROR : Unresolved java classifier: GraphicsConfiguration]!): kotlin.Boolean
            private open fun updateWindow(): kotlin.Unit
            public/*package*/ open override /*1*/ fun updateZOrder(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun validate(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun validateTree(): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun validateUnconditionally(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            protected/*protected and package*/ open inner class AccessibleAWTWindow : java.awt.Container.AccessibleAWTContainer {
                protected/*protected and package*/ constructor AccessibleAWTWindow()
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTComponentHandler: [ERROR : Unresolved java classifier: ComponentListener]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleAWTFocusHandler: [ERROR : Unresolved java classifier: FocusListener]!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var accessibleContainerHandler: [ERROR : Unresolved java classifier: ContainerListener]!
                public open override /*1*/ /*fake_override*/ fun addFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addPropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun getAccessibleAt(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleChild(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleChildrenCount(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleComponent(): [ERROR : Unresolved java classifier: AccessibleComponent]!
                public open override /*1*/ /*fake_override*/ fun getAccessibleDescription(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleIndexInParent(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun getAccessibleName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun getAccessibleParent(): [ERROR : Unresolved java classifier: Accessible]!
                public open override /*1*/ fun getAccessibleRole(): [ERROR : Unresolved java classifier: AccessibleRole]!
                public open override /*1*/ fun getAccessibleStateSet(): [ERROR : Unresolved java classifier: AccessibleStateSet]!
                public open override /*1*/ /*fake_override*/ fun getBackground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getBounds(): [ERROR : Unresolved java classifier: Rectangle]!
                public open override /*1*/ /*fake_override*/ fun getCursor(): [ERROR : Unresolved java classifier: Cursor]!
                public open override /*1*/ /*fake_override*/ fun getFont(): [ERROR : Unresolved java classifier: Font]!
                public open override /*1*/ /*fake_override*/ fun getFontMetrics(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): [ERROR : Unresolved java classifier: FontMetrics]!
                public open override /*1*/ /*fake_override*/ fun getForeground(): [ERROR : Unresolved java classifier: Color]!
                public open override /*1*/ /*fake_override*/ fun getLocale(): java.util.Locale!
                public open override /*1*/ /*fake_override*/ fun getLocation(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getLocationOnScreen(): [ERROR : Unresolved java classifier: Point]!
                public open override /*1*/ /*fake_override*/ fun getSize(): java.awt.Dimension!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEnabled(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isFocusTraversable(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isShowing(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isVisible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeFocusListener(/*0*/ p0: [ERROR : Unresolved java classifier: FocusListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun removePropertyChangeListener(/*0*/ p0: [ERROR : Unresolved java classifier: PropertyChangeListener]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun requestFocus(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBackground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setBounds(/*0*/ p0: [ERROR : Unresolved java classifier: Rectangle]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setCursor(/*0*/ p0: [ERROR : Unresolved java classifier: Cursor]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setEnabled(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setFont(/*0*/ p0: [ERROR : Unresolved java classifier: Font]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setForeground(/*0*/ p0: [ERROR : Unresolved java classifier: Color]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setLocation(/*0*/ p0: [ERROR : Unresolved java classifier: Point]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setSize(/*0*/ p0: java.awt.Dimension!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setVisible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 4215068635060671780.toLong()
            }

            public final enum class Type : kotlin.Enum<java.awt.Window.Type!> {
                public enum entry NORMAL : java.awt.Window.Type {
                    private constructor NORMAL()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Window.Type!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry UTILITY : java.awt.Window.Type {
                    private constructor UTILITY()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Window.Type!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry POPUP : java.awt.Window.Type {
                    private constructor POPUP()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Window.Type!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor Type()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.awt.Window.Type!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.awt.Window.Type
                public final /*synthesized*/ fun values(): kotlin.Array<java.awt.Window.Type>
            }

            public/*package*/ open class WindowDisposerRecord {
                public/*package*/ constructor WindowDisposerRecord(/*0*/ p0: [ERROR : Unresolved java classifier: AppContext]!, /*1*/ p1: java.awt.Window!)
                public/*package*/ final val context: [ERROR : Unresolved java classifier: WeakReference<AppContext>]!
                public/*package*/ final val owner: [ERROR : Unresolved java classifier: WeakReference<Window>]!
                public/*package*/ final val weakThis: [ERROR : Unresolved java classifier: WeakReference]!
                public open fun dispose(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            public/*package*/ final val OPENED: kotlin.Int = 1
            private final val allWindows: [ERROR : Unresolved java classifier: IdentityArrayList<Window>]!
            private final val base: kotlin.String = "win"
            private final val beforeFirstWindowShown: java.util.concurrent.atomic.AtomicBoolean!
            private final val locationByPlatformProp: kotlin.Boolean
            private final val log: [ERROR : Unresolved java classifier: PlatformLogger]!
            private final var nameCounter: kotlin.Int
            private final val serialVersionUID: kotlin.Long = 4497834738069338734.toLong()
            public/*package*/ final var systemSyncLWRequests: kotlin.Boolean
            public/*package*/ open fun getAllUnblockedWindows(): [ERROR : Unresolved java classifier: IdentityArrayList<Window>]!
            public/*package*/ open fun getAllWindows(): [ERROR : Unresolved java classifier: IdentityArrayList<Window>]!
            public open fun getOwnerlessWindows(): kotlin.Array<(out) java.awt.Window!>!
            public open fun getWindows(): kotlin.Array<(out) java.awt.Window!>!
            private open fun getWindows(/*0*/ p0: [ERROR : Unresolved java classifier: AppContext]!): kotlin.Array<(out) java.awt.Window!>!
            private open fun initIDs(): kotlin.Unit
            private open fun limit(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.Double): kotlin.Double
            private open fun removeFromWindowList(/*0*/ p0: [ERROR : Unresolved java classifier: AppContext]!, /*1*/ p1: [ERROR : Unresolved java classifier: WeakReference]!): kotlin.Unit
            private open fun setLayersOpaque(/*0*/ p0: java.awt.Component!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open fun updateChildFocusableWindowState(/*0*/ p0: java.awt.Window!): kotlin.Unit
        }

        package java.awt.event {
            public /*synthesized*/ fun ActionListener(/*0*/ function: (java.awt.event.ActionEvent!) -> kotlin.Unit): java.awt.event.ActionListener

            public open class ActionEvent {
                public constructor ActionEvent(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!)
                public constructor ActionEvent(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Int)
                public constructor ActionEvent(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.Int)
                public/*package*/ final var actionCommand: kotlin.String!
                public/*package*/ final var modifiers: kotlin.Int
                public/*package*/ final var `when`: kotlin.Long
                public open fun getActionCommand(): kotlin.String!
                public open fun getModifiers(): kotlin.Int
                public open fun getWhen(): kotlin.Long
                public open fun paramString(): kotlin.String!

                // Static members
                public final val ACTION_FIRST: kotlin.Int = 1001
                public final val ACTION_LAST: kotlin.Int = 1001
                public final val ACTION_PERFORMED: kotlin.Int = 1001
                public final val ALT_MASK: kotlin.Int = 8
                public final val CTRL_MASK: kotlin.Int = 2
                public final val META_MASK: kotlin.Int = 4
                public final val SHIFT_MASK: kotlin.Int = 1
                private final val serialVersionUID: kotlin.Long = -7671078796273832149.toLong()
            }

            public trait ActionListener : java.util.EventListener {
                public abstract fun actionPerformed(/*0*/ p0: java.awt.event.ActionEvent!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }
        }
    }

    package java.beans {

        package java.beans.beancontext {
            public /*synthesized*/ fun BeanContextServiceRevokedListener(/*0*/ function: ([ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!) -> kotlin.Unit): java.beans.beancontext.BeanContextServiceRevokedListener

            public trait BeanContextServiceRevokedListener : java.util.EventListener {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract fun serviceRevoked(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public open class BeanContextServicesSupport {
                public constructor BeanContextServicesSupport()
                public constructor BeanContextServicesSupport(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!)
                public constructor BeanContextServicesSupport(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: java.util.Locale!)
                public constructor BeanContextServicesSupport(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: java.util.Locale!, /*2*/ p2: kotlin.Boolean)
                public constructor BeanContextServicesSupport(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: java.util.Locale!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean)
                protected/*protected and package*/ final var bcsListeners: java.util.ArrayList<*>!
                protected/*protected and package*/ final var proxy: java.beans.beancontext.BeanContextServicesSupport.BCSSProxyServiceProvider!
                protected/*protected and package*/ final var serializable: kotlin.Int
                protected/*protected and package*/ final var services: java.util.HashMap<*, *>!
                public open fun addBeanContextServicesListener(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServicesListener]!): kotlin.Unit
                public open fun addService(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!): kotlin.Boolean
                protected/*protected and package*/ open fun addService(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*2*/ p2: kotlin.Boolean): kotlin.Boolean
                protected/*protected and package*/ open fun bcsPreDeserializationHook(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                protected/*protected and package*/ open fun bcsPreSerializationHook(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit
                protected/*protected and package*/ open fun childJustRemovedHook(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: BCSChild]!): kotlin.Unit
                protected/*protected and package*/ open fun createBCSChild(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): [ERROR : Unresolved java classifier: BCSChild]!
                protected/*protected and package*/ open fun createBCSSServiceProvider(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!): java.beans.beancontext.BeanContextServicesSupport.BCSSServiceProvider!
                protected/*protected and package*/ final fun fireServiceAdded(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceAvailableEvent]!): kotlin.Unit
                protected/*protected and package*/ final fun fireServiceAdded(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
                protected/*protected and package*/ final fun fireServiceRevoked(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!): kotlin.Unit
                protected/*protected and package*/ final fun fireServiceRevoked(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                public open fun getBeanContextServicesPeer(): [ERROR : Unresolved java classifier: BeanContextServices]!
                public open fun getCurrentServiceClasses(): kotlin.(Mutable)Iterator<*>!
                public open fun getCurrentServiceSelectors(/*0*/ p0: java.lang.Class<*>!): kotlin.(Mutable)Iterator<*>!
                public final /*synthesized*/ fun getService(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextChild]!, /*1*/ p1: kotlin.Any!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: kotlin.Any!, /*4*/ p4: (([ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!) -> kotlin.Unit)!): kotlin.Any!
                public open fun getService(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextChild]!, /*1*/ p1: kotlin.Any!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: kotlin.Any!, /*4*/ p4: java.beans.beancontext.BeanContextServiceRevokedListener!): kotlin.Any!
                public open fun hasService(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
                public open fun initialize(): kotlin.Unit
                protected/*protected and package*/ open fun initializeBeanContextResources(): kotlin.Unit
                private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                protected/*protected and package*/ open fun releaseBeanContextResources(): kotlin.Unit
                public open fun releaseService(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextChild]!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
                public open fun removeBeanContextServicesListener(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServicesListener]!): kotlin.Unit
                public open fun revokeService(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
                public open fun serviceAvailable(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceAvailableEvent]!): kotlin.Unit
                public open fun serviceRevoked(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!): kotlin.Unit
                private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                protected/*protected and package*/ open inner class BCSSChild {
                    public/*package*/ constructor BCSSChild(/*0*/ p2: kotlin.Any!, /*1*/ p3: kotlin.Any!)
                    private final var serviceClasses: java.util.HashMap<*, *>!
                    private final var serviceRequestors: java.util.HashMap<*, *>!
                    public/*package*/ open fun cleanupReferences(): kotlin.Unit
                    public/*package*/ open fun releaseService(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                    public/*package*/ open fun revokeAllDelegatedServicesNow(): kotlin.Unit
                    public/*package*/ open fun revokeService(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.Unit
                    public/*package*/ final /*synthesized*/ fun usingService(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: (([ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!) -> kotlin.Unit)!): kotlin.Unit
                    public/*package*/ open fun usingService(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*4*/ p4: kotlin.Boolean, /*5*/ p5: java.beans.beancontext.BeanContextServiceRevokedListener!): kotlin.Unit

                    public/*package*/ open inner class BCSSCServiceClassRef {
                        public/*package*/ constructor BCSSCServiceClassRef(/*0*/ p2: java.lang.Class<*>!, /*1*/ p3: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*2*/ p4: kotlin.Boolean)
                        public/*package*/ final var delegateProvider: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                        public/*package*/ final var delegateRefs: kotlin.Int
                        public/*package*/ final var requestors: java.util.HashMap<*, *>!
                        public/*package*/ final var serviceClass: java.lang.Class<*>!
                        public/*package*/ final var serviceProvider: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                        public/*package*/ final var serviceRefs: kotlin.Int
                        public/*package*/ open fun addRef(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                        public/*package*/ final /*synthesized*/ fun addRequestor(/*0*/ p0: kotlin.Any!, /*1*/ p1: (([ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!) -> kotlin.Unit)!): kotlin.Unit
                        public/*package*/ open fun addRequestor(/*0*/ p0: kotlin.Any!, /*1*/ p1: java.beans.beancontext.BeanContextServiceRevokedListener!): kotlin.Unit
                        public/*package*/ open fun cloneOfEntries(): kotlin.(Mutable)Iterator<*>!
                        public/*package*/ open fun entries(): kotlin.(Mutable)Iterator<*>!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public/*package*/ open fun getDelegateProvider(): [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                        public/*package*/ open fun getDelegateRefs(): kotlin.Int
                        public/*package*/ open fun getRefs(): kotlin.Int
                        public/*package*/ open fun getServiceClass(): java.lang.Class<*>!
                        public/*package*/ open fun getServiceProvider(): [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                        public/*package*/ open fun getServiceRefs(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public/*package*/ open fun isDelegated(): kotlin.Boolean
                        public/*package*/ open fun isEmpty(): kotlin.Boolean
                        public/*package*/ open fun releaseRef(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                        public/*package*/ open fun removeRequestor(/*0*/ p0: kotlin.Any!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        public/*package*/ open fun verifyAndMaybeSetProvider(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                        public/*package*/ final /*synthesized*/ fun verifyRequestor(/*0*/ p0: kotlin.Any!, /*1*/ p1: (([ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!) -> kotlin.Unit)!): kotlin.Unit
                        public/*package*/ open fun verifyRequestor(/*0*/ p0: kotlin.Any!, /*1*/ p1: java.beans.beancontext.BeanContextServiceRevokedListener!): kotlin.Unit
                    }

                    public/*package*/ open inner class BCSSCServiceRef {
                        public/*package*/ constructor BCSSCServiceRef(/*0*/ p2: java.beans.beancontext.BeanContextServicesSupport.BCSSChild.BCSSCServiceClassRef!, /*1*/ p3: kotlin.Boolean)
                        public/*package*/ final var delegated: kotlin.Boolean
                        public/*package*/ final var refCnt: kotlin.Int
                        public/*package*/ final var serviceClassRef: java.beans.beancontext.BeanContextServicesSupport.BCSSChild.BCSSCServiceClassRef!
                        public/*package*/ open fun addRef(): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public/*package*/ open fun getServiceClassRef(): java.beans.beancontext.BeanContextServicesSupport.BCSSChild.BCSSCServiceClassRef!
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public/*package*/ open fun isDelegated(): kotlin.Boolean
                        public/*package*/ open fun release(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    }

                    // Static members
                    private final val serialVersionUID: kotlin.Long = -3263851306889194873.toLong()
                }

                protected/*protected and package*/ open inner class BCSSProxyServiceProvider : java.beans.beancontext.BeanContextServiceRevokedListener {
                    public/*package*/ constructor BCSSProxyServiceProvider(/*0*/ p2: [ERROR : Unresolved java classifier: BeanContextServices]!)
                    private final var nestingCtxt: [ERROR : Unresolved java classifier: BeanContextServices]!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun getCurrentServiceSelectors(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: java.lang.Class<*>!): kotlin.(Mutable)Iterator<*>!
                    public open fun getService(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: kotlin.Any!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: kotlin.Any!): kotlin.Any!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun releaseService(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServices]!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Any!): kotlin.Unit
                    public open override /*1*/ fun serviceRevoked(/*0*/ p0: [ERROR : Unresolved java classifier: BeanContextServiceRevokedEvent]!): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                protected/*protected static*/ open class BCSSServiceProvider : java.io.Serializable {
                    public/*package*/ constructor BCSSServiceProvider(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!)
                    protected/*protected and package*/ final var serviceProvider: [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    protected/*protected and package*/ open fun getServiceProvider(): [ERROR : Unresolved java classifier: BeanContextServiceProvider]!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                    // Static members
                    private final val serialVersionUID: kotlin.Long = 861278251667444782.toLong()
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = -8494482757288719206.toLong()
                protected/*protected static*/ final fun getChildBeanContextServicesListener(/*0*/ p0: kotlin.Any!): [ERROR : Unresolved java classifier: BeanContextServicesListener]!
            }
        }
    }

    package java.io {
        public /*synthesized*/ fun Closeable(/*0*/ function: () -> kotlin.Unit): java.io.Closeable
        public /*synthesized*/ fun FileFilter(/*0*/ function: (java.io.File!) -> kotlin.Boolean): java.io.FileFilter
        public /*synthesized*/ fun FilenameFilter(/*0*/ function: (java.io.File!, kotlin.String!) -> kotlin.Boolean): java.io.FilenameFilter

        public open class BufferedInputStream {
            public constructor BufferedInputStream(/*0*/ p0: java.io.InputStream!)
            public constructor BufferedInputStream(/*0*/ p0: java.io.InputStream!, /*1*/ p1: kotlin.Int)
            protected/*protected and package*/ final var buf: kotlin.ByteArray!
            protected/*protected and package*/ final var count: kotlin.Int
            protected/*protected and package*/ final var marklimit: kotlin.Int
            protected/*protected and package*/ final var markpos: kotlin.Int
            protected/*protected and package*/ final var pos: kotlin.Int
            public open fun available(): kotlin.Int
            public open fun close(): kotlin.Unit
            private open fun fill(): kotlin.Unit
            private open fun getBufIfOpen(): kotlin.ByteArray!
            private open fun getInIfOpen(): java.io.InputStream!
            public open fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun markSupported(): kotlin.Boolean
            public open fun read(): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            private open fun read1(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun reset(): kotlin.Unit
            public open fun skip(/*0*/ p0: kotlin.Long): kotlin.Long

            // Static members
            private final val bufUpdater: java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.io.BufferedInputStream!, kotlin.ByteArray!>!
            private final var defaultBufferSize: kotlin.Int
        }

        public open class BufferedOutputStream : java.io.FilterOutputStream {
            public constructor BufferedOutputStream(/*0*/ p0: java.io.OutputStream!)
            public constructor BufferedOutputStream(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.Int)
            protected/*protected and package*/ final var buf: kotlin.ByteArray!
            protected/*protected and package*/ final var count: kotlin.Int
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var out: java.io.OutputStream!
            public open override /*1*/ /*fake_override*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun flush(): kotlin.Unit
            private open fun flushBuffer(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
        }

        public open class BufferedReader : java.io.Reader {
            public constructor BufferedReader(/*0*/ p0: java.io.Reader!)
            public constructor BufferedReader(/*0*/ p0: java.io.Reader!, /*1*/ p1: kotlin.Int)
            private final var cb: kotlin.CharArray!
            private final var `in`: java.io.Reader!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            private final var markedChar: kotlin.Int
            private final var markedSkipLF: kotlin.Boolean
            private final var nChars: kotlin.Int
            private final var nextChar: kotlin.Int
            private final var readAheadLimit: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var skipBuffer: kotlin.CharArray!
            private final var skipLF: kotlin.Boolean
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun ensureOpen(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            private open fun fill(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun markSupported(): kotlin.Boolean
            public open override /*1*/ fun read(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.CharArray!): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            private open fun read1(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun readLine(): kotlin.String!
            public/*package*/ open fun readLine(/*0*/ p0: kotlin.Boolean): kotlin.String!
            public open override /*1*/ fun ready(): kotlin.Boolean
            public open override /*1*/ fun reset(): kotlin.Unit
            public open override /*1*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val INVALIDATED: kotlin.Int = -2
            private final val UNMARKED: kotlin.Int = -1
            private final var defaultCharBufferSize: kotlin.Int
            private final var defaultExpectedLineLength: kotlin.Int
        }

        public open class BufferedWriter : java.io.Writer {
            public constructor BufferedWriter(/*0*/ p0: java.io.Writer!)
            public constructor BufferedWriter(/*0*/ p0: java.io.Writer!, /*1*/ p1: kotlin.Int)
            private final var cb: kotlin.CharArray!
            private final var lineSeparator: kotlin.String!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            private final var nChars: kotlin.Int
            private final var nextChar: kotlin.Int
            private final var out: java.io.Writer!
            invisible_fake final override /*1*/ /*fake_override*/ var writeBuffer: kotlin.CharArray!
            invisible_fake final override /*1*/ /*fake_override*/ val writeBufferSize: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.Char): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.io.Writer!
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun ensureOpen(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun flush(): kotlin.Unit
            public/*package*/ open fun flushBuffer(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun min(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun newLine(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit

            // Static members
            private final var defaultCharBufferSize: kotlin.Int
        }

        public open class ByteArrayInputStream : java.io.InputStream {
            public constructor ByteArrayInputStream(/*0*/ p0: kotlin.ByteArray!)
            public constructor ByteArrayInputStream(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            protected/*protected and package*/ final var buf: kotlin.ByteArray!
            protected/*protected and package*/ final var count: kotlin.Int
            protected/*protected and package*/ final var mark: kotlin.Int
            protected/*protected and package*/ final var pos: kotlin.Int
            public open override /*1*/ fun available(): kotlin.Int
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun markSupported(): kotlin.Boolean
            public open override /*1*/ fun read(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open override /*1*/ fun reset(): kotlin.Unit
            public open override /*1*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class ByteArrayOutputStream : java.io.OutputStream {
            public constructor ByteArrayOutputStream()
            public constructor ByteArrayOutputStream(/*0*/ p0: kotlin.Int)
            protected/*protected and package*/ final var buf: kotlin.ByteArray!
            protected/*protected and package*/ final var count: kotlin.Int
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun ensureCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun flush(): kotlin.Unit
            private open fun grow(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun reset(): kotlin.Unit
            public open fun size(): kotlin.Int
            public open fun toByteArray(): kotlin.ByteArray!
            public open override /*1*/ fun toString(): kotlin.String!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun toString(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.String!): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun writeTo(/*0*/ p0: java.io.OutputStream!): kotlin.Unit
        }

        public trait Closeable : java.lang.AutoCloseable {
            public abstract override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class DataInputStream {
            public constructor DataInputStream(/*0*/ p0: java.io.InputStream!)
            private final var bytearr: kotlin.ByteArray!
            private final var chararr: kotlin.CharArray!
            private final var lineBuffer: kotlin.CharArray!
            private final var readBuffer: kotlin.ByteArray!
            public final fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public final fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public final fun readBoolean(): kotlin.Boolean
            public final fun readByte(): kotlin.Byte
            public final fun readChar(): kotlin.Char
            public final fun readDouble(): kotlin.Double
            public final fun readFloat(): kotlin.Float
            public final fun readFully(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public final fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final fun readInt(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final fun readLine(): kotlin.String!
            public final fun readLong(): kotlin.Long
            public final fun readShort(): kotlin.Short
            public final fun readUTF(): kotlin.String!
            public final fun readUnsignedByte(): kotlin.Int
            public final fun readUnsignedShort(): kotlin.Int
            public final fun skipBytes(/*0*/ p0: kotlin.Int): kotlin.Int

            // Static members
            public final fun readUTF(/*0*/ p0: [ERROR : Unresolved java classifier: DataInput]!): kotlin.String!
        }

        public open class EOFException : java.io.IOException {
            public constructor EOFException()
            public constructor EOFException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 6433858223774886977.toLong()
        }

        public trait Externalizable : java.io.Serializable {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun readExternal(/*0*/ p0: java.io.ObjectInput!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun writeExternal(/*0*/ p0: java.io.ObjectOutput!): kotlin.Unit
        }

        public open class File : java.io.Serializable, kotlin.Comparable<java.io.File!> {
            public constructor File(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.String!)
            public constructor File(/*0*/ p0: java.net.URI!)
            public constructor File(/*0*/ p0: kotlin.String!)
            private constructor File(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.File!)
            private constructor File(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int)
            public constructor File(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            private final var filePath: [ERROR : Unresolved java classifier: Path]!
            private final var path: kotlin.String!
            private final var prefixLength: kotlin.Int
            public open fun canExecute(): kotlin.Boolean
            public open fun canRead(): kotlin.Boolean
            public open fun canWrite(): kotlin.Boolean
            public open override /*1*/ fun compareTo(/*0*/ other: java.io.File!): kotlin.Int
            public open fun createNewFile(): kotlin.Boolean
            public open fun delete(): kotlin.Boolean
            public open fun deleteOnExit(): kotlin.Unit
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun exists(): kotlin.Boolean
            public open fun getAbsoluteFile(): java.io.File!
            public open fun getAbsolutePath(): kotlin.String!
            public open fun getCanonicalFile(): java.io.File!
            public open fun getCanonicalPath(): kotlin.String!
            public open fun getFreeSpace(): kotlin.Long
            public open fun getName(): kotlin.String!
            public open fun getParent(): kotlin.String!
            public open fun getParentFile(): java.io.File!
            public open fun getPath(): kotlin.String!
            public/*package*/ open fun getPrefixLength(): kotlin.Int
            public open fun getTotalSpace(): kotlin.Long
            public open fun getUsableSpace(): kotlin.Long
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun isAbsolute(): kotlin.Boolean
            public open fun isDirectory(): kotlin.Boolean
            public open fun isFile(): kotlin.Boolean
            public open fun isHidden(): kotlin.Boolean
            public open fun lastModified(): kotlin.Long
            public open fun length(): kotlin.Long
            public open fun list(): kotlin.Array<(out) kotlin.String!>!
            public final /*synthesized*/ fun list(/*0*/ filter: ((java.io.File!, kotlin.String!) -> kotlin.Boolean)!): kotlin.Array<(out) kotlin.String!>!
            public open fun list(/*0*/ filter: java.io.FilenameFilter!): kotlin.Array<(out) kotlin.String!>!
            public open fun listFiles(): kotlin.Array<(out) java.io.File!>!
            public final /*synthesized*/ fun listFiles(/*0*/ filter: ((java.io.File!) -> kotlin.Boolean)!): kotlin.Array<(out) java.io.File!>!
            public final /*synthesized*/ fun listFiles(/*0*/ filter: ((java.io.File!, kotlin.String!) -> kotlin.Boolean)!): kotlin.Array<(out) java.io.File!>!
            public open fun listFiles(/*0*/ filter: java.io.FileFilter!): kotlin.Array<(out) java.io.File!>!
            public open fun listFiles(/*0*/ filter: java.io.FilenameFilter!): kotlin.Array<(out) java.io.File!>!
            public open fun mkdir(): kotlin.Boolean
            public open fun mkdirs(): kotlin.Boolean
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open fun renameTo(/*0*/ p0: java.io.File!): kotlin.Boolean
            public open fun setExecutable(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun setExecutable(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open fun setLastModified(/*0*/ p0: kotlin.Long): kotlin.Boolean
            public open fun setReadOnly(): kotlin.Boolean
            public open fun setReadable(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun setReadable(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open fun setWritable(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open fun setWritable(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open fun toPath(): [ERROR : Unresolved java classifier: Path]!
            public open override /*2*/ fun toString(): kotlin.String!
            public open fun toURI(): java.net.URI!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun toURL(): java.net.URL!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private open class TempDirectory {
                private constructor TempDirectory()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val random: [ERROR : Unresolved java classifier: SecureRandom]!
                private final val tmpdir: java.io.File!
                public/*package*/ open fun generateFile(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.io.File!): java.io.File!
                public/*package*/ open fun location(): java.io.File!
            }

            // Static members
            private final var fs: [ERROR : Unresolved java classifier: FileSystem]!
            public final val pathSeparator: kotlin.String!
            public final val pathSeparatorChar: kotlin.Char
            public final val separator: kotlin.String!
            public final val separatorChar: kotlin.Char
            private final val serialVersionUID: kotlin.Long = 301077366599181567.toLong()
            public open fun createTempFile(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): java.io.File!
            public open fun createTempFile(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.io.File!): java.io.File!
            public open fun listRoots(): kotlin.Array<(out) java.io.File!>!
            private open fun slashify(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.String!
        }

        public trait FileFilter {
            public abstract fun accept(/*0*/ p0: java.io.File!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class FileInputStream : java.io.InputStream {
            public constructor FileInputStream(/*0*/ p0: [ERROR : Unresolved java classifier: FileDescriptor]!)
            public constructor FileInputStream(/*0*/ p0: java.io.File!)
            public constructor FileInputStream(/*0*/ p0: kotlin.String!)
            private final var channel: [ERROR : Unresolved java classifier: FileChannel]!
            private final val closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            private final val fd: [ERROR : Unresolved java classifier: FileDescriptor]!
            public open override /*1*/ fun available(): kotlin.Int
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun close0(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            protected/*protected and package*/ open fun finalize(): kotlin.Unit
            public open fun getChannel(): [ERROR : Unresolved java classifier: FileChannel]!
            public final fun getFD(): [ERROR : Unresolved java classifier: FileDescriptor]!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
            private open fun open(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ fun read(): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            private open fun readBytes(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
            public open override /*1*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val runningFinalize: java.lang.ThreadLocal<kotlin.Boolean!>!
            private open fun initIDs(): kotlin.Unit
            private open fun isRunningFinalize(): kotlin.Boolean
        }

        public open class FileNotFoundException : java.io.IOException {
            public constructor FileNotFoundException()
            public constructor FileNotFoundException(/*0*/ p0: kotlin.String!)
            private constructor FileNotFoundException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -897856973823710492.toLong()
        }

        public open class FileOutputStream : java.io.OutputStream {
            public constructor FileOutputStream(/*0*/ p0: [ERROR : Unresolved java classifier: FileDescriptor]!)
            public constructor FileOutputStream(/*0*/ p0: java.io.File!)
            public constructor FileOutputStream(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.Boolean)
            public constructor FileOutputStream(/*0*/ p0: kotlin.String!)
            public constructor FileOutputStream(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean)
            private final val append: kotlin.Boolean
            private final var channel: [ERROR : Unresolved java classifier: FileChannel]!
            private final val closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            private final val fd: [ERROR : Unresolved java classifier: FileDescriptor]!
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun close0(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            protected/*protected and package*/ open fun finalize(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun flush(): kotlin.Unit
            public open fun getChannel(): [ERROR : Unresolved java classifier: FileChannel]!
            public final fun getFD(): [ERROR : Unresolved java classifier: FileDescriptor]!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun open(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun write(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            private open fun writeBytes(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean): kotlin.Unit

            // Static members
            private final val runningFinalize: java.lang.ThreadLocal<kotlin.Boolean!>!
            private open fun initIDs(): kotlin.Unit
            private open fun isRunningFinalize(): kotlin.Boolean
        }

        public open class FileReader : java.io.InputStreamReader {
            public constructor FileReader(/*0*/ p0: [ERROR : Unresolved java classifier: FileDescriptor]!)
            public constructor FileReader(/*0*/ p0: java.io.File!)
            public constructor FileReader(/*0*/ p0: kotlin.String!)
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            invisible_fake final override /*1*/ /*fake_override*/ val sd: [ERROR : Unresolved java classifier: StreamDecoder]!
            invisible_fake final override /*1*/ /*fake_override*/ var skipBuffer: kotlin.CharArray!
            public open override /*1*/ /*fake_override*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun getEncoding(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun read(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.CharArray!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun ready(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class FileWriter : java.io.OutputStreamWriter {
            public constructor FileWriter(/*0*/ p0: [ERROR : Unresolved java classifier: FileDescriptor]!)
            public constructor FileWriter(/*0*/ p0: java.io.File!)
            public constructor FileWriter(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.Boolean)
            public constructor FileWriter(/*0*/ p0: kotlin.String!)
            public constructor FileWriter(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean)
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            invisible_fake final override /*1*/ /*fake_override*/ val se: [ERROR : Unresolved java classifier: StreamEncoder]!
            invisible_fake final override /*1*/ /*fake_override*/ var writeBuffer: kotlin.CharArray!
            invisible_fake final override /*1*/ /*fake_override*/ val writeBufferSize: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.Char): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun flush(): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun flushBuffer(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun getEncoding(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
        }

        public trait FilenameFilter {
            public abstract fun accept(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.String!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class FilterOutputStream : java.io.OutputStream {
            public constructor FilterOutputStream(/*0*/ p0: java.io.OutputStream!)
            protected/*protected and package*/ final var out: java.io.OutputStream!
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun flush(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
        }

        public open class IOException : java.lang.Exception {
            public constructor IOException()
            public constructor IOException(/*0*/ p0: kotlin.String!)
            public constructor IOException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor IOException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 7818375828146090155.toLong()
        }

        public abstract class InputStream : java.io.Closeable {
            public constructor InputStream()
            public open fun available(): kotlin.Int
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun markSupported(): kotlin.Boolean
            public abstract fun read(): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun reset(): kotlin.Unit
            public open fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val MAX_SKIP_BUFFER_SIZE: kotlin.Int = 2048
        }

        public open class InputStreamReader : java.io.Reader {
            public constructor InputStreamReader(/*0*/ p0: java.io.InputStream!)
            public constructor InputStreamReader(/*0*/ p0: java.io.InputStream!, /*1*/ p1: [ERROR : Unresolved java classifier: CharsetDecoder]!)
            public constructor InputStreamReader(/*0*/ p0: java.io.InputStream!, /*1*/ p1: java.nio.charset.Charset!)
            public constructor InputStreamReader(/*0*/ p0: java.io.InputStream!, /*1*/ p1: kotlin.String!)
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            private final val sd: [ERROR : Unresolved java classifier: StreamDecoder]!
            invisible_fake final override /*1*/ /*fake_override*/ var skipBuffer: kotlin.CharArray!
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getEncoding(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
            public open override /*1*/ fun read(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.CharArray!): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open override /*1*/ fun ready(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait ObjectInput : java.lang.AutoCloseable {
            public abstract fun available(): kotlin.Int
            public abstract override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun read(): kotlin.Int
            public abstract fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public abstract fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public abstract fun readObject(): kotlin.Any!
            public abstract fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class ObjectInputStream : java.io.InputStream, java.io.ObjectInput {
            protected/*protected and package*/ constructor ObjectInputStream()
            public constructor ObjectInputStream(/*0*/ p0: java.io.InputStream!)
            private final val bin: java.io.ObjectInputStream.BlockDataInputStream!
            private final var closed: kotlin.Boolean
            private final var curContext: [ERROR : Unresolved java classifier: SerialCallbackContext]!
            private final var defaultDataEnd: kotlin.Boolean
            private final var depth: kotlin.Int
            private final val enableOverride: kotlin.Boolean
            private final var enableResolve: kotlin.Boolean
            private final val handles: java.io.ObjectInputStream.HandleTable!
            private final var passHandle: kotlin.Int
            private final var primVals: kotlin.ByteArray!
            private final val vlist: java.io.ObjectInputStream.ValidationList!
            public open override /*2*/ fun available(): kotlin.Int
            private open fun checkResolve(/*0*/ p0: kotlin.Any!): kotlin.Any!
            private open fun clear(): kotlin.Unit
            public open override /*2*/ fun close(): kotlin.Unit
            private open fun defaultReadFields(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            public open fun defaultReadObject(): kotlin.Unit
            protected/*protected and package*/ open fun enableResolveObject(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            private open fun handleReset(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
            public open override /*2*/ fun read(): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open override /*2*/ fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            private open fun readArray(/*0*/ p0: kotlin.Boolean): kotlin.Any!
            public open fun readBoolean(): kotlin.Boolean
            public open fun readByte(): kotlin.Byte
            public open fun readChar(): kotlin.Char
            private open fun readClass(/*0*/ p0: kotlin.Boolean): java.lang.Class<*>!
            private open fun readClassDesc(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: ObjectStreamClass]!
            protected/*protected and package*/ open fun readClassDescriptor(): [ERROR : Unresolved java classifier: ObjectStreamClass]!
            public open fun readDouble(): kotlin.Double
            private open fun readEnum(/*0*/ p0: kotlin.Boolean): kotlin.Enum<*>!
            private open fun readExternalData(/*0*/ p0: java.io.Externalizable!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            private open fun readFatalException(): java.io.IOException!
            public open fun readFields(): java.io.ObjectInputStream.GetField!
            public open fun readFloat(): kotlin.Float
            public open fun readFully(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            private open fun readHandle(/*0*/ p0: kotlin.Boolean): kotlin.Any!
            public open fun readInt(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun readLine(): kotlin.String!
            public open fun readLong(): kotlin.Long
            private open fun readNonProxyDesc(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: ObjectStreamClass]!
            private open fun readNull(): kotlin.Any!
            public final override /*1*/ fun readObject(): kotlin.Any!
            private open fun readObject0(/*0*/ p0: kotlin.Boolean): kotlin.Any!
            protected/*protected and package*/ open fun readObjectOverride(): kotlin.Any!
            private open fun readOrdinaryObject(/*0*/ p0: kotlin.Boolean): kotlin.Any!
            private open fun readProxyDesc(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: ObjectStreamClass]!
            private open fun readSerialData(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            public open fun readShort(): kotlin.Short
            protected/*protected and package*/ open fun readStreamHeader(): kotlin.Unit
            private open fun readString(/*0*/ p0: kotlin.Boolean): kotlin.String!
            public/*package*/ open fun readTypeString(): kotlin.String!
            public open fun readUTF(): kotlin.String!
            public open fun readUnshared(): kotlin.Any!
            public open fun readUnsignedByte(): kotlin.Int
            public open fun readUnsignedShort(): kotlin.Int
            public open fun registerValidation(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectInputValidation]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
            protected/*protected and package*/ open fun resolveClass(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectStreamClass]!): java.lang.Class<*>!
            protected/*protected and package*/ open fun resolveObject(/*0*/ p0: kotlin.Any!): kotlin.Any!
            protected/*protected and package*/ open fun resolveProxyClass(/*0*/ p0: kotlin.Array<(out) kotlin.String!>!): java.lang.Class<*>!
            public open override /*2*/ /*fake_override*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun skipBytes(/*0*/ p0: kotlin.Int): kotlin.Int
            private open fun skipCustomData(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            private open fun verifySubclass(): kotlin.Unit

            private open inner class BlockDataInputStream : java.io.InputStream {
                public/*package*/ constructor BlockDataInputStream(/*0*/ p2: java.io.InputStream!)
                private final var blkmode: kotlin.Boolean
                private final val buf: kotlin.ByteArray!
                private final val cbuf: kotlin.CharArray!
                private final val din: java.io.DataInputStream!
                private final var end: kotlin.Int
                private final val hbuf: kotlin.ByteArray!
                private final val `in`: java.io.ObjectInputStream.PeekInputStream!
                private final var pos: kotlin.Int
                private final var unread: kotlin.Int
                public open override /*1*/ fun available(): kotlin.Int
                public open override /*1*/ fun close(): kotlin.Unit
                public/*package*/ open fun currentBlockRemaining(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ open fun getBlockDataMode(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
                public/*package*/ open fun peek(): kotlin.Int
                public/*package*/ open fun peekByte(): kotlin.Byte
                public open override /*1*/ fun read(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
                public open override /*1*/ fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
                public/*package*/ open fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean): kotlin.Int
                private open fun readBlockHeader(/*0*/ p0: kotlin.Boolean): kotlin.Int
                public open fun readBoolean(): kotlin.Boolean
                public/*package*/ open fun readBooleans(/*0*/ p0: kotlin.BooleanArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readByte(): kotlin.Byte
                public open fun readChar(): kotlin.Char
                public/*package*/ open fun readChars(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readDouble(): kotlin.Double
                public/*package*/ open fun readDoubles(/*0*/ p0: kotlin.DoubleArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readFloat(): kotlin.Float
                public/*package*/ open fun readFloats(/*0*/ p0: kotlin.FloatArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readFully(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
                public open fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean): kotlin.Unit
                public open fun readInt(): kotlin.Int
                public/*package*/ open fun readInts(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readLine(): kotlin.String!
                public open fun readLong(): kotlin.Long
                public/*package*/ open fun readLongUTF(): kotlin.String!
                public/*package*/ open fun readLongs(/*0*/ p0: kotlin.LongArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readShort(): kotlin.Short
                public/*package*/ open fun readShorts(/*0*/ p0: kotlin.ShortArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun readUTF(): kotlin.String!
                private open fun readUTFBody(/*0*/ p0: kotlin.Long): kotlin.String!
                private open fun readUTFChar(/*0*/ p0: java.lang.StringBuilder!, /*1*/ p1: kotlin.Long): kotlin.Int
                private open fun readUTFSpan(/*0*/ p0: java.lang.StringBuilder!, /*1*/ p1: kotlin.Long): kotlin.Long
                public open fun readUnsignedByte(): kotlin.Int
                public open fun readUnsignedShort(): kotlin.Int
                private open fun refill(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
                public/*package*/ open fun setBlockDataMode(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
                public/*package*/ open fun skipBlockData(): kotlin.Unit
                public open fun skipBytes(/*0*/ p0: kotlin.Int): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val CHAR_BUF_SIZE: kotlin.Int = 256
                private final val HEADER_BLOCKED: kotlin.Int = -2
                private final val MAX_BLOCK_SIZE: kotlin.Int = 1024
                private final val MAX_HEADER_SIZE: kotlin.Int = 5
            }

            private open class Caches {
                private constructor Caches()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val subclassAudits: [ERROR : Unresolved java classifier: ConcurrentMap<WeakClassKey, Boolean>]!
                public/*package*/ final val subclassAuditsQueue: [ERROR : Unresolved java classifier: ReferenceQueue<Class<?>>]!
            }

            public abstract class GetField {
                public constructor GetField()
                public abstract fun defaulted(/*0*/ p0: kotlin.String!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Any!
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Byte
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char): kotlin.Char
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Double
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Float
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long
                public abstract fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Short
                public abstract fun getObjectStreamClass(): [ERROR : Unresolved java classifier: ObjectStreamClass]!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class GetFieldImpl : java.io.ObjectInputStream.GetField {
                public/*package*/ constructor GetFieldImpl(/*0*/ p2: [ERROR : Unresolved java classifier: ObjectStreamClass]!)
                private final val desc: [ERROR : Unresolved java classifier: ObjectStreamClass]!
                private final val objHandles: kotlin.IntArray!
                private final val objVals: kotlin.Array<(out) kotlin.Any!>!
                private final val primVals: kotlin.ByteArray!
                public open override /*1*/ fun defaulted(/*0*/ p0: kotlin.String!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Any!
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Byte
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char): kotlin.Char
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Double
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Float
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long
                public open override /*1*/ fun get(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Short
                private open fun getFieldOffset(/*0*/ p0: kotlin.String!, /*1*/ p1: java.lang.Class<*>!): kotlin.Int
                public open override /*1*/ fun getObjectStreamClass(): [ERROR : Unresolved java classifier: ObjectStreamClass]!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun readFields(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class HandleTable {
                public/*package*/ constructor HandleTable(/*0*/ p0: kotlin.Int)
                public/*package*/ final var deps: kotlin.Array<(out) java.io.ObjectInputStream.HandleTable.HandleList!>!
                public/*package*/ final var entries: kotlin.Array<(out) kotlin.Any!>!
                public/*package*/ final var lowDep: kotlin.Int
                public/*package*/ final var size: kotlin.Int
                public/*package*/ final var status: kotlin.ByteArray!
                public/*package*/ open fun assign(/*0*/ p0: kotlin.Any!): kotlin.Int
                public/*package*/ open fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ open fun finish(/*0*/ p0: kotlin.Int): kotlin.Unit
                private open fun grow(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun lookupException(/*0*/ p0: kotlin.Int): java.lang.ClassNotFoundException!
                public/*package*/ open fun lookupObject(/*0*/ p0: kotlin.Int): kotlin.Any!
                public/*package*/ open fun markDependency(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public/*package*/ open fun markException(/*0*/ p0: kotlin.Int, /*1*/ p1: java.lang.ClassNotFoundException!): kotlin.Unit
                public/*package*/ open fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public/*package*/ open fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                private open class HandleList {
                    public constructor HandleList()
                    private final var list: kotlin.IntArray!
                    private final var size: kotlin.Int
                    public open fun add(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun get(/*0*/ p0: kotlin.Int): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun size(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                // Static members
                private final val STATUS_EXCEPTION: kotlin.Byte = 3.toByte()
                private final val STATUS_OK: kotlin.Byte = 1.toByte()
                private final val STATUS_UNKNOWN: kotlin.Byte = 2.toByte()
            }

            private open class PeekInputStream : java.io.InputStream {
                public/*package*/ constructor PeekInputStream(/*0*/ p0: java.io.InputStream!)
                private final val `in`: java.io.InputStream!
                private final var peekb: kotlin.Int
                public open override /*1*/ fun available(): kotlin.Int
                public open override /*1*/ fun close(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun markSupported(): kotlin.Boolean
                public/*package*/ open fun peek(): kotlin.Int
                public open override /*1*/ fun read(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
                public open override /*1*/ fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
                public/*package*/ open fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun reset(): kotlin.Unit
                public open override /*1*/ fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class ValidationList {
                public/*package*/ constructor ValidationList()
                private final var list: java.io.ObjectInputStream.ValidationList.Callback!
                public open fun clear(): kotlin.Unit
                public/*package*/ open fun doCallbacks(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun register(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectInputValidation]!, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                private open class Callback {
                    public/*package*/ constructor Callback(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectInputValidation]!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.io.ObjectInputStream.ValidationList.Callback!, /*3*/ p3: [ERROR : Unresolved java classifier: AccessControlContext]!)
                    public/*package*/ final val acc: [ERROR : Unresolved java classifier: AccessControlContext]!
                    public/*package*/ final var next: java.io.ObjectInputStream.ValidationList.Callback!
                    public/*package*/ final val obj: [ERROR : Unresolved java classifier: ObjectInputValidation]!
                    public/*package*/ final val priority: kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }
            }

            // Static members
            private final val NULL_HANDLE: kotlin.Int = -1
            private final val primClasses: java.util.HashMap<kotlin.String!, java.lang.Class<*>!>!
            private final val unsharedMarker: kotlin.Any!
            private open fun auditSubclass(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            private open fun bytesToDoubles(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.DoubleArray!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun bytesToFloats(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.FloatArray!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun cloneArray(/*0*/ p0: kotlin.Any!): kotlin.Any!
            private open fun latestUserDefinedLoader(): java.lang.ClassLoader!
        }

        public trait ObjectOutput : java.lang.AutoCloseable {
            public abstract override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun flush(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public abstract fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun writeObject(/*0*/ p0: kotlin.Any!): kotlin.Unit
        }

        public open class ObjectOutputStream : java.io.OutputStream, java.io.ObjectOutput {
            protected/*protected and package*/ constructor ObjectOutputStream()
            public constructor ObjectOutputStream(/*0*/ p0: java.io.OutputStream!)
            private final val bout: java.io.ObjectOutputStream.BlockDataOutputStream!
            private final var curContext: [ERROR : Unresolved java classifier: SerialCallbackContext]!
            private final var curPut: java.io.ObjectOutputStream.PutFieldImpl!
            private final val debugInfoStack: java.io.ObjectOutputStream.DebugTraceInfoStack!
            private final var depth: kotlin.Int
            private final val enableOverride: kotlin.Boolean
            private final var enableReplace: kotlin.Boolean
            private final val handles: java.io.ObjectOutputStream.HandleTable!
            private final var primVals: kotlin.ByteArray!
            private final var protocol: kotlin.Int
            private final val subs: java.io.ObjectOutputStream.ReplaceTable!
            protected/*protected and package*/ open fun annotateClass(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
            protected/*protected and package*/ open fun annotateProxyClass(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
            private open fun clear(): kotlin.Unit
            public open override /*2*/ fun close(): kotlin.Unit
            private open fun defaultWriteFields(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            public open fun defaultWriteObject(): kotlin.Unit
            protected/*protected and package*/ open fun drain(): kotlin.Unit
            protected/*protected and package*/ open fun enableReplaceObject(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ fun flush(): kotlin.Unit
            public/*package*/ open fun getProtocolVersion(): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun putFields(): java.io.ObjectOutputStream.PutField!
            protected/*protected and package*/ open fun replaceObject(/*0*/ p0: kotlin.Any!): kotlin.Any!
            public open fun reset(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            public open fun useProtocolVersion(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun verifySubclass(): kotlin.Unit
            public open override /*2*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*2*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun writeArray(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open fun writeBoolean(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun writeByte(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun writeBytes(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun writeChar(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun writeChars(/*0*/ p0: kotlin.String!): kotlin.Unit
            private open fun writeClass(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            private open fun writeClassDesc(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ open fun writeClassDescriptor(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            public open fun writeDouble(/*0*/ p0: kotlin.Double): kotlin.Unit
            private open fun writeEnum(/*0*/ p0: kotlin.Enum<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            private open fun writeExternalData(/*0*/ p0: java.io.Externalizable!): kotlin.Unit
            private open fun writeFatalException(/*0*/ p0: java.io.IOException!): kotlin.Unit
            public open fun writeFields(): kotlin.Unit
            public open fun writeFloat(/*0*/ p0: kotlin.Float): kotlin.Unit
            private open fun writeHandle(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun writeInt(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun writeLong(/*0*/ p0: kotlin.Long): kotlin.Unit
            private open fun writeNonProxyDesc(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            private open fun writeNull(): kotlin.Unit
            public final override /*1*/ fun writeObject(/*0*/ p0: kotlin.Any!): kotlin.Unit
            private open fun writeObject0(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ open fun writeObjectOverride(/*0*/ p0: kotlin.Any!): kotlin.Unit
            private open fun writeOrdinaryObject(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            private open fun writeProxyDesc(/*0*/ p0: [ERROR : Unresolved java classifier: ObjectStreamClass]!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            private open fun writeSerialData(/*0*/ p0: kotlin.Any!, /*1*/ p1: [ERROR : Unresolved java classifier: ObjectStreamClass]!): kotlin.Unit
            public open fun writeShort(/*0*/ p0: kotlin.Int): kotlin.Unit
            protected/*protected and package*/ open fun writeStreamHeader(): kotlin.Unit
            private open fun writeString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open fun writeTypeString(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun writeUTF(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun writeUnshared(/*0*/ p0: kotlin.Any!): kotlin.Unit

            private open class BlockDataOutputStream : java.io.OutputStream {
                public/*package*/ constructor BlockDataOutputStream(/*0*/ p0: java.io.OutputStream!)
                private final var blkmode: kotlin.Boolean
                private final val buf: kotlin.ByteArray!
                private final val cbuf: kotlin.CharArray!
                private final val dout: [ERROR : Unresolved java classifier: DataOutputStream]!
                private final val hbuf: kotlin.ByteArray!
                private final val out: java.io.OutputStream!
                private final var pos: kotlin.Int
                public open override /*1*/ fun close(): kotlin.Unit
                public/*package*/ open fun drain(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun flush(): kotlin.Unit
                public/*package*/ open fun getBlockDataMode(): kotlin.Boolean
                public/*package*/ open fun getUTFLength(/*0*/ p0: kotlin.String!): kotlin.Long
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun setBlockDataMode(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
                public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public/*package*/ open fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
                private open fun writeBlockHeader(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open fun writeBoolean(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public/*package*/ open fun writeBooleans(/*0*/ p0: kotlin.BooleanArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeByte(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open fun writeBytes(/*0*/ p0: kotlin.String!): kotlin.Unit
                public open fun writeChar(/*0*/ p0: kotlin.Int): kotlin.Unit
                public/*package*/ open fun writeChars(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeChars(/*0*/ p0: kotlin.String!): kotlin.Unit
                public open fun writeDouble(/*0*/ p0: kotlin.Double): kotlin.Unit
                public/*package*/ open fun writeDoubles(/*0*/ p0: kotlin.DoubleArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeFloat(/*0*/ p0: kotlin.Float): kotlin.Unit
                public/*package*/ open fun writeFloats(/*0*/ p0: kotlin.FloatArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeInt(/*0*/ p0: kotlin.Int): kotlin.Unit
                public/*package*/ open fun writeInts(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeLong(/*0*/ p0: kotlin.Long): kotlin.Unit
                public/*package*/ open fun writeLongUTF(/*0*/ p0: kotlin.String!): kotlin.Unit
                public/*package*/ open fun writeLongUTF(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public/*package*/ open fun writeLongs(/*0*/ p0: kotlin.LongArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeShort(/*0*/ p0: kotlin.Int): kotlin.Unit
                public/*package*/ open fun writeShorts(/*0*/ p0: kotlin.ShortArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun writeUTF(/*0*/ p0: kotlin.String!): kotlin.Unit
                public/*package*/ open fun writeUTF(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
                private open fun writeUTFBody(/*0*/ p0: kotlin.String!): kotlin.Unit

                // Static members
                private final val CHAR_BUF_SIZE: kotlin.Int = 256
                private final val MAX_BLOCK_SIZE: kotlin.Int = 1024
                private final val MAX_HEADER_SIZE: kotlin.Int = 5
            }

            private open class Caches {
                private constructor Caches()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val subclassAudits: [ERROR : Unresolved java classifier: ConcurrentMap<WeakClassKey, Boolean>]!
                public/*package*/ final val subclassAuditsQueue: [ERROR : Unresolved java classifier: ReferenceQueue<Class<?>>]!
            }

            private open class DebugTraceInfoStack {
                public/*package*/ constructor DebugTraceInfoStack()
                private final val stack: kotlin.(Mutable)List<kotlin.String!>!
                public/*package*/ open fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun pop(): kotlin.Unit
                public/*package*/ open fun push(/*0*/ p0: kotlin.String!): kotlin.Unit
                public open override /*1*/ fun toString(): kotlin.String!
            }

            private open class HandleTable {
                public/*package*/ constructor HandleTable(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float)
                private final val loadFactor: kotlin.Float
                private final var next: kotlin.IntArray!
                private final var objs: kotlin.Array<(out) kotlin.Any!>!
                private final var size: kotlin.Int
                private final var spine: kotlin.IntArray!
                private final var threshold: kotlin.Int
                public/*package*/ open fun assign(/*0*/ p0: kotlin.Any!): kotlin.Int
                public/*package*/ open fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                private open fun growEntries(): kotlin.Unit
                private open fun growSpine(): kotlin.Unit
                private open fun hash(/*0*/ p0: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                private open fun insert(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Unit
                public/*package*/ open fun lookup(/*0*/ p0: kotlin.Any!): kotlin.Int
                public/*package*/ open fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public abstract class PutField {
                public constructor PutField()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public abstract fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public abstract fun write(/*0*/ p0: java.io.ObjectOutput!): kotlin.Unit
            }

            private open inner class PutFieldImpl : java.io.ObjectOutputStream.PutField {
                public/*package*/ constructor PutFieldImpl(/*0*/ p2: [ERROR : Unresolved java classifier: ObjectStreamClass]!)
                private final val desc: [ERROR : Unresolved java classifier: ObjectStreamClass]!
                private final val objVals: kotlin.Array<(out) kotlin.Any!>!
                private final val primVals: kotlin.ByteArray!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                private open fun getFieldOffset(/*0*/ p0: kotlin.String!, /*1*/ p1: java.lang.Class<*>!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Char): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public open override /*1*/ fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*1*/ fun write(/*0*/ p0: java.io.ObjectOutput!): kotlin.Unit
                public/*package*/ open fun writeFields(): kotlin.Unit
            }

            private open class ReplaceTable {
                public/*package*/ constructor ReplaceTable(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float)
                private final val htab: java.io.ObjectOutputStream.HandleTable!
                private final var reps: kotlin.Array<(out) kotlin.Any!>!
                public/*package*/ open fun assign(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public/*package*/ open fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                private open fun grow(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun lookup(/*0*/ p0: kotlin.Any!): kotlin.Any!
                public/*package*/ open fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val extendedDebugInfo: kotlin.Boolean
            private open fun auditSubclass(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            private open fun doublesToBytes(/*0*/ p0: kotlin.DoubleArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.ByteArray!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun floatsToBytes(/*0*/ p0: kotlin.FloatArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.ByteArray!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
        }

        public abstract class ObjectStreamException : java.io.IOException {
            protected/*protected and package*/ constructor ObjectStreamException()
            protected/*protected and package*/ constructor ObjectStreamException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 7260898174833392607.toLong()
        }

        public abstract class OutputStream : java.io.Closeable {
            public constructor OutputStream()
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun flush(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
        }

        public open class OutputStreamWriter : java.io.Writer {
            public constructor OutputStreamWriter(/*0*/ p0: java.io.OutputStream!)
            public constructor OutputStreamWriter(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: [ERROR : Unresolved java classifier: CharsetEncoder]!)
            public constructor OutputStreamWriter(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: java.nio.charset.Charset!)
            public constructor OutputStreamWriter(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!)
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var lock: kotlin.Any!
            private final val se: [ERROR : Unresolved java classifier: StreamEncoder]!
            invisible_fake final override /*1*/ /*fake_override*/ var writeBuffer: kotlin.CharArray!
            invisible_fake final override /*1*/ /*fake_override*/ val writeBufferSize: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.Char): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.io.Writer!
            public open override /*1*/ /*fake_override*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.io.Writer!
            public open override /*1*/ fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun flush(): kotlin.Unit
            public/*package*/ open fun flushBuffer(): kotlin.Unit
            public open fun getEncoding(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
        }

        public open class PrintStream : java.io.FilterOutputStream, java.lang.Appendable, java.io.Closeable {
            public constructor PrintStream(/*0*/ p0: java.io.File!)
            public constructor PrintStream(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.String!)
            public constructor PrintStream(/*0*/ p0: java.io.OutputStream!)
            public constructor PrintStream(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.Boolean)
            public constructor PrintStream(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.String!)
            private constructor PrintStream(/*0*/ p0: kotlin.Boolean, /*1*/ p1: java.io.OutputStream!)
            private constructor PrintStream(/*0*/ p0: kotlin.Boolean, /*1*/ p1: java.io.OutputStream!, /*2*/ p2: java.nio.charset.Charset!)
            private constructor PrintStream(/*0*/ p0: kotlin.Boolean, /*1*/ p1: java.nio.charset.Charset!, /*2*/ p2: java.io.OutputStream!)
            public constructor PrintStream(/*0*/ p0: kotlin.String!)
            public constructor PrintStream(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            private final val autoFlush: kotlin.Boolean
            private final var charOut: java.io.OutputStreamWriter!
            private final var closing: kotlin.Boolean
            private final var formatter: [ERROR : Unresolved java classifier: Formatter]!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var out: java.io.OutputStream!
            private final var textOut: java.io.BufferedWriter!
            private final var trouble: kotlin.Boolean
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Char): java.io.PrintStream!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.io.PrintStream!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.io.PrintStream!
            public open fun checkError(): kotlin.Boolean
            protected/*protected and package*/ open fun clearError(): kotlin.Unit
            public open override /*2*/ fun close(): kotlin.Unit
            private open fun ensureOpen(): kotlin.Unit
            public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun flush(): kotlin.Unit
            public open fun format(/*0*/ p0: java.util.Locale!, /*1*/ p1: kotlin.String!, /*2*/ vararg p2: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): java.io.PrintStream!
            public open fun format(/*0*/ p0: kotlin.String!, /*1*/ vararg p1: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): java.io.PrintStream!
            public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun newLine(): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Any!): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Char): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Double): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Float): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun print(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun printf(/*0*/ p0: java.util.Locale!, /*1*/ p1: kotlin.String!, /*2*/ vararg p2: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): java.io.PrintStream!
            public open fun printf(/*0*/ p0: kotlin.String!, /*1*/ vararg p1: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): java.io.PrintStream!
            public open fun println(): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Any!): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Char): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Double): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Float): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.String!): kotlin.Unit
            protected/*protected and package*/ open fun setError(): kotlin.Unit
            public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ /*fake_override*/ fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            private open fun write(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public open override /*1*/ fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun write(/*0*/ p0: kotlin.String!): kotlin.Unit

            // Static members
            private open fun </*0*/ T> requireNonNull(/*0*/ p0: T!, /*1*/ p1: kotlin.String!): T!
            private open fun toCharset(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
        }

        public open class RandomAccessFile : java.io.Closeable {
            public constructor RandomAccessFile(/*0*/ p0: java.io.File!, /*1*/ p1: kotlin.String!)
            public constructor RandomAccessFile(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            private final var channel: [ERROR : Unresolved java classifier: FileChannel]!
            private final var closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            private final var fd: [ERROR : Unresolved java classifier: FileDescriptor]!
            private final var rw: kotlin.Boolean
            public open override /*1*/ fun close(): kotlin.Unit
            private open fun close0(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final fun getChannel(): [ERROR : Unresolved java classifier: FileChannel]!
            public final fun getFD(): [ERROR : Unresolved java classifier: FileDescriptor]!
            public open fun getFilePointer(): kotlin.Long
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun length(): kotlin.Long
            private open fun open(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun read(): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public final fun readBoolean(): kotlin.Boolean
            public final fun readByte(): kotlin.Byte
            private open fun readBytes(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public final fun readChar(): kotlin.Char
            public final fun readDouble(): kotlin.Double
            public final fun readFloat(): kotlin.Float
            public final fun readFully(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public final fun readFully(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final fun readInt(): kotlin.Int
            public final fun readLine(): kotlin.String!
            public final fun readLong(): kotlin.Long
            public final fun readShort(): kotlin.Short
            public final fun readUTF(): kotlin.String!
            public final fun readUnsignedByte(): kotlin.Int
            public final fun readUnsignedShort(): kotlin.Int
            public open fun seek(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun setLength(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun skipBytes(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public open fun write(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final fun writeBoolean(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public final fun writeByte(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun writeBytes(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final fun writeBytes(/*0*/ p0: kotlin.String!): kotlin.Unit
            public final fun writeChar(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final fun writeChars(/*0*/ p0: kotlin.String!): kotlin.Unit
            public final fun writeDouble(/*0*/ p0: kotlin.Double): kotlin.Unit
            public final fun writeFloat(/*0*/ p0: kotlin.Float): kotlin.Unit
            public final fun writeInt(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final fun writeLong(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final fun writeShort(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final fun writeUTF(/*0*/ p0: kotlin.String!): kotlin.Unit

            // Static members
            private final val O_DSYNC: kotlin.Int = 8
            private final val O_RDONLY: kotlin.Int = 1
            private final val O_RDWR: kotlin.Int = 2
            private final val O_SYNC: kotlin.Int = 4
            private open fun initIDs(): kotlin.Unit
        }

        public abstract class Reader : java.lang.Readable, java.io.Closeable {
            protected/*protected and package*/ constructor Reader()
            protected/*protected and package*/ constructor Reader(/*0*/ p0: kotlin.Any!)
            protected/*protected and package*/ final var lock: kotlin.Any!
            private final var skipBuffer: kotlin.CharArray!
            public abstract override /*1*/ fun close(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun mark(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun markSupported(): kotlin.Boolean
            public open fun read(): kotlin.Int
            public open override /*1*/ fun read(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): kotlin.Int
            public open fun read(/*0*/ p0: kotlin.CharArray!): kotlin.Int
            public abstract fun read(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun ready(): kotlin.Boolean
            public open fun reset(): kotlin.Unit
            public open fun skip(/*0*/ p0: kotlin.Long): kotlin.Long
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val maxSkipBufferSize: kotlin.Int = 8192
        }

        public trait Serializable {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public abstract class Writer : java.lang.Appendable, java.io.Closeable {
            protected/*protected and package*/ constructor Writer()
            protected/*protected and package*/ constructor Writer(/*0*/ p0: kotlin.Any!)
            protected/*protected and package*/ final var lock: kotlin.Any!
            private final var writeBuffer: kotlin.CharArray!
            private final val writeBufferSize: kotlin.Int = 1024
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Char): java.io.Writer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.io.Writer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.io.Writer!
            public abstract override /*1*/ fun close(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun flush(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            public open fun write(/*0*/ p0: kotlin.CharArray!): kotlin.Unit
            public abstract fun write(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun write(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
        }
    }

    package java.lang {
        public /*synthesized*/ fun AutoCloseable(/*0*/ function: () -> kotlin.Unit): java.lang.AutoCloseable
        public /*synthesized*/ fun </*0*/ T> Comparable(/*0*/ function: (T!) -> kotlin.Int): java.lang.Comparable<T>
        public /*synthesized*/ fun </*0*/ T> Iterable(/*0*/ function: () -> kotlin.(Mutable)Iterator<T!>!): java.lang.Iterable<T>
        public /*synthesized*/ fun Readable(/*0*/ function: ([ERROR : Unresolved java classifier: CharBuffer]!) -> kotlin.Int): java.lang.Readable
        public /*synthesized*/ fun Runnable(/*0*/ function: () -> kotlin.Unit): java.lang.Runnable

        public/*package*/ abstract class AbstractStringBuilder : java.lang.Appendable, kotlin.CharSequence {
            public/*package*/ constructor AbstractStringBuilder()
            public/*package*/ constructor AbstractStringBuilder(/*0*/ p0: kotlin.Int)
            public/*package*/ final var count: kotlin.Int
            public/*package*/ final var value: kotlin.CharArray!
            public open fun append(/*0*/ p0: java.lang.StringBuffer!): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Any!): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Boolean): java.lang.AbstractStringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Char): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.CharArray!): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.AbstractStringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.lang.AbstractStringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Double): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Float): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.Long): java.lang.AbstractStringBuilder!
            public open fun append(/*0*/ p0: kotlin.String!): java.lang.AbstractStringBuilder!
            public open fun appendCodePoint(/*0*/ p0: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun capacity(): kotlin.Int
            public open override /*1*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
            public open fun codePointAt(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun codePointBefore(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun codePointCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun delete(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun deleteCharAt(/*0*/ p0: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun ensureCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun ensureCapacityInternal(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open fun expandCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun getChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ final fun getValue(): kotlin.CharArray!
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): java.lang.AbstractStringBuilder!
            public open fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): java.lang.AbstractStringBuilder!
            public open fun lastIndexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun lastIndexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun length(): kotlin.Int
            public open fun offsetByCodePoints(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun replace(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): java.lang.AbstractStringBuilder!
            public open fun reverse(): java.lang.AbstractStringBuilder!
            public open fun setCharAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): kotlin.Unit
            public open fun setLength(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence!
            public open fun substring(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun substring(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            public abstract override /*2*/ fun toString(): kotlin.String!
            public open fun trimToSize(): kotlin.Unit
        }

        public trait Appendable {
            public abstract fun append(/*0*/ p0: kotlin.Char): java.lang.Appendable!
            public abstract fun append(/*0*/ p0: kotlin.CharSequence!): java.lang.Appendable!
            public abstract fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.Appendable!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class ArithmeticException : java.lang.RuntimeException {
            public constructor ArithmeticException()
            public constructor ArithmeticException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 2256477558314496007.toLong()
        }

        public open class ArrayIndexOutOfBoundsException : java.lang.IndexOutOfBoundsException {
            public constructor ArrayIndexOutOfBoundsException()
            public constructor ArrayIndexOutOfBoundsException(/*0*/ p0: kotlin.Int)
            public constructor ArrayIndexOutOfBoundsException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -5116101128118950844.toLong()
        }

        public open class ArrayStoreException : java.lang.RuntimeException {
            public constructor ArrayStoreException()
            public constructor ArrayStoreException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -4522193890499838241.toLong()
        }

        public open class AssertionError : java.lang.Error {
            public constructor AssertionError()
            public constructor AssertionError(/*0*/ p0: kotlin.Any!)
            public constructor AssertionError(/*0*/ p0: kotlin.Boolean)
            public constructor AssertionError(/*0*/ p0: kotlin.Char)
            public constructor AssertionError(/*0*/ p0: kotlin.Double)
            public constructor AssertionError(/*0*/ p0: kotlin.Float)
            public constructor AssertionError(/*0*/ p0: kotlin.Int)
            public constructor AssertionError(/*0*/ p0: kotlin.Long)
            private constructor AssertionError(/*0*/ p0: kotlin.String!)
            public constructor AssertionError(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -5013299493970297370.toLong()
        }

        public trait AutoCloseable {
            public abstract fun close(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public final class Boolean : java.io.Serializable, kotlin.Comparable<kotlin.Boolean!> {
            public constructor Boolean(/*0*/ p0: kotlin.Boolean)
            public constructor Boolean(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Boolean
            public open fun booleanValue(): kotlin.Boolean
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Boolean!): kotlin.Int
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open override /*2*/ fun toString(): kotlin.String!

            // Static members
            public final val FALSE: kotlin.Boolean!
            public final val TRUE: kotlin.Boolean!
            public final val TYPE: java.lang.Class<kotlin.Boolean!>!
            private final val serialVersionUID: kotlin.Long = -3665804199014368530.toLong()
            public open fun compare(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Int
            public open fun getBoolean(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun parseBoolean(/*0*/ p0: kotlin.String!): kotlin.Boolean
            private open fun toBoolean(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun toString(/*0*/ p0: kotlin.Boolean): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Boolean): kotlin.Boolean!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Boolean!
        }

        public final class Byte : kotlin.Number, kotlin.Comparable<kotlin.Byte!> {
            public constructor Byte(/*0*/ p0: kotlin.Byte)
            public constructor Byte(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Byte
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Byte!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            private open class ByteCache {
                private constructor ByteCache()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val cache: kotlin.Array<(out) kotlin.Byte!>!
            }

            // Static members
            public final val MAX_VALUE: kotlin.Byte = 127.toByte()
            public final val MIN_VALUE: kotlin.Byte = -128.toByte()
            public final val SIZE: kotlin.Int = 8
            public final val TYPE: java.lang.Class<kotlin.Byte!>!
            private final val serialVersionUID: kotlin.Long = -7183698231559129828.toLong()
            public open fun compare(/*0*/ p0: kotlin.Byte, /*1*/ p1: kotlin.Byte): kotlin.Int
            public open fun decode(/*0*/ p0: kotlin.String!): kotlin.Byte!
            public open fun parseByte(/*0*/ p0: kotlin.String!): kotlin.Byte
            public open fun parseByte(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Byte
            public open fun toString(/*0*/ p0: kotlin.Byte): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Byte): kotlin.Byte!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Byte!
            public open fun valueOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Byte!
        }

        public trait CharSequence {
            public abstract fun charAt(/*0*/ p0: kotlin.Int): kotlin.Char
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun length(): kotlin.Int
            public abstract fun subSequence(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.CharSequence!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public final class Character : java.io.Serializable, kotlin.Comparable<kotlin.Char!> {
            public constructor Character(/*0*/ p0: kotlin.Char)
            private final val value: kotlin.Char
            public open fun charValue(): kotlin.Char
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Char!): kotlin.Int
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open override /*2*/ fun toString(): kotlin.String!

            private open class CharacterCache {
                private constructor CharacterCache()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val cache: kotlin.Array<(out) kotlin.Char!>!
            }

            public open class Subset {
                protected/*protected and package*/ constructor Subset(/*0*/ p0: kotlin.String!)
                private final var name: kotlin.String!
                public final override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public final override /*1*/ fun hashCode(): kotlin.Int
                public final override /*1*/ fun toString(): kotlin.String!
            }

            public final class UnicodeBlock : java.lang.Character.Subset {
                private constructor UnicodeBlock(/*0*/ p0: kotlin.String!)
                private constructor UnicodeBlock(/*0*/ p0: kotlin.String!, /*1*/ vararg p1: kotlin.String! /*kotlin.Array<(out) kotlin.String!>!*/)
                private constructor UnicodeBlock(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
                invisible_fake final override /*1*/ /*fake_override*/ var name: kotlin.String!
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun toString(): kotlin.String!

                // Static members
                public final val AEGEAN_NUMBERS: java.lang.Character.UnicodeBlock!
                public final val ALCHEMICAL_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val ALPHABETIC_PRESENTATION_FORMS: java.lang.Character.UnicodeBlock!
                public final val ANCIENT_GREEK_MUSICAL_NOTATION: java.lang.Character.UnicodeBlock!
                public final val ANCIENT_GREEK_NUMBERS: java.lang.Character.UnicodeBlock!
                public final val ANCIENT_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val ARABIC: java.lang.Character.UnicodeBlock!
                public final val ARABIC_PRESENTATION_FORMS_A: java.lang.Character.UnicodeBlock!
                public final val ARABIC_PRESENTATION_FORMS_B: java.lang.Character.UnicodeBlock!
                public final val ARABIC_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val ARMENIAN: java.lang.Character.UnicodeBlock!
                public final val ARROWS: java.lang.Character.UnicodeBlock!
                public final val AVESTAN: java.lang.Character.UnicodeBlock!
                public final val BALINESE: java.lang.Character.UnicodeBlock!
                public final val BAMUM: java.lang.Character.UnicodeBlock!
                public final val BAMUM_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val BASIC_LATIN: java.lang.Character.UnicodeBlock!
                public final val BATAK: java.lang.Character.UnicodeBlock!
                public final val BENGALI: java.lang.Character.UnicodeBlock!
                public final val BLOCK_ELEMENTS: java.lang.Character.UnicodeBlock!
                public final val BOPOMOFO: java.lang.Character.UnicodeBlock!
                public final val BOPOMOFO_EXTENDED: java.lang.Character.UnicodeBlock!
                public final val BOX_DRAWING: java.lang.Character.UnicodeBlock!
                public final val BRAHMI: java.lang.Character.UnicodeBlock!
                public final val BRAILLE_PATTERNS: java.lang.Character.UnicodeBlock!
                public final val BUGINESE: java.lang.Character.UnicodeBlock!
                public final val BUHID: java.lang.Character.UnicodeBlock!
                public final val BYZANTINE_MUSICAL_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val CARIAN: java.lang.Character.UnicodeBlock!
                public final val CHAM: java.lang.Character.UnicodeBlock!
                public final val CHEROKEE: java.lang.Character.UnicodeBlock!
                public final val CJK_COMPATIBILITY: java.lang.Character.UnicodeBlock!
                public final val CJK_COMPATIBILITY_FORMS: java.lang.Character.UnicodeBlock!
                public final val CJK_COMPATIBILITY_IDEOGRAPHS: java.lang.Character.UnicodeBlock!
                public final val CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val CJK_RADICALS_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val CJK_STROKES: java.lang.Character.UnicodeBlock!
                public final val CJK_SYMBOLS_AND_PUNCTUATION: java.lang.Character.UnicodeBlock!
                public final val CJK_UNIFIED_IDEOGRAPHS: java.lang.Character.UnicodeBlock!
                public final val CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A: java.lang.Character.UnicodeBlock!
                public final val CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B: java.lang.Character.UnicodeBlock!
                public final val CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C: java.lang.Character.UnicodeBlock!
                public final val CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D: java.lang.Character.UnicodeBlock!
                public final val COMBINING_DIACRITICAL_MARKS: java.lang.Character.UnicodeBlock!
                public final val COMBINING_DIACRITICAL_MARKS_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val COMBINING_HALF_MARKS: java.lang.Character.UnicodeBlock!
                public final val COMBINING_MARKS_FOR_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val COMMON_INDIC_NUMBER_FORMS: java.lang.Character.UnicodeBlock!
                public final val CONTROL_PICTURES: java.lang.Character.UnicodeBlock!
                public final val COPTIC: java.lang.Character.UnicodeBlock!
                public final val COUNTING_ROD_NUMERALS: java.lang.Character.UnicodeBlock!
                public final val CUNEIFORM: java.lang.Character.UnicodeBlock!
                public final val CUNEIFORM_NUMBERS_AND_PUNCTUATION: java.lang.Character.UnicodeBlock!
                public final val CURRENCY_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val CYPRIOT_SYLLABARY: java.lang.Character.UnicodeBlock!
                public final val CYRILLIC: java.lang.Character.UnicodeBlock!
                public final val CYRILLIC_EXTENDED_A: java.lang.Character.UnicodeBlock!
                public final val CYRILLIC_EXTENDED_B: java.lang.Character.UnicodeBlock!
                public final val CYRILLIC_SUPPLEMENTARY: java.lang.Character.UnicodeBlock!
                public final val DESERET: java.lang.Character.UnicodeBlock!
                public final val DEVANAGARI: java.lang.Character.UnicodeBlock!
                public final val DEVANAGARI_EXTENDED: java.lang.Character.UnicodeBlock!
                public final val DINGBATS: java.lang.Character.UnicodeBlock!
                public final val DOMINO_TILES: java.lang.Character.UnicodeBlock!
                public final val EGYPTIAN_HIEROGLYPHS: java.lang.Character.UnicodeBlock!
                public final val EMOTICONS: java.lang.Character.UnicodeBlock!
                public final val ENCLOSED_ALPHANUMERICS: java.lang.Character.UnicodeBlock!
                public final val ENCLOSED_ALPHANUMERIC_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val ENCLOSED_CJK_LETTERS_AND_MONTHS: java.lang.Character.UnicodeBlock!
                public final val ENCLOSED_IDEOGRAPHIC_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val ETHIOPIC: java.lang.Character.UnicodeBlock!
                public final val ETHIOPIC_EXTENDED: java.lang.Character.UnicodeBlock!
                public final val ETHIOPIC_EXTENDED_A: java.lang.Character.UnicodeBlock!
                public final val ETHIOPIC_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val GENERAL_PUNCTUATION: java.lang.Character.UnicodeBlock!
                public final val GEOMETRIC_SHAPES: java.lang.Character.UnicodeBlock!
                public final val GEORGIAN: java.lang.Character.UnicodeBlock!
                public final val GEORGIAN_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val GLAGOLITIC: java.lang.Character.UnicodeBlock!
                public final val GOTHIC: java.lang.Character.UnicodeBlock!
                public final val GREEK: java.lang.Character.UnicodeBlock!
                public final val GREEK_EXTENDED: java.lang.Character.UnicodeBlock!
                public final val GUJARATI: java.lang.Character.UnicodeBlock!
                public final val GURMUKHI: java.lang.Character.UnicodeBlock!
                public final val HALFWIDTH_AND_FULLWIDTH_FORMS: java.lang.Character.UnicodeBlock!
                public final val HANGUL_COMPATIBILITY_JAMO: java.lang.Character.UnicodeBlock!
                public final val HANGUL_JAMO: java.lang.Character.UnicodeBlock!
                public final val HANGUL_JAMO_EXTENDED_A: java.lang.Character.UnicodeBlock!
                public final val HANGUL_JAMO_EXTENDED_B: java.lang.Character.UnicodeBlock!
                public final val HANGUL_SYLLABLES: java.lang.Character.UnicodeBlock!
                public final val HANUNOO: java.lang.Character.UnicodeBlock!
                public final val HEBREW: java.lang.Character.UnicodeBlock!
                public final val HIGH_PRIVATE_USE_SURROGATES: java.lang.Character.UnicodeBlock!
                public final val HIGH_SURROGATES: java.lang.Character.UnicodeBlock!
                public final val HIRAGANA: java.lang.Character.UnicodeBlock!
                public final val IDEOGRAPHIC_DESCRIPTION_CHARACTERS: java.lang.Character.UnicodeBlock!
                public final val IMPERIAL_ARAMAIC: java.lang.Character.UnicodeBlock!
                public final val INSCRIPTIONAL_PAHLAVI: java.lang.Character.UnicodeBlock!
                public final val INSCRIPTIONAL_PARTHIAN: java.lang.Character.UnicodeBlock!
                public final val IPA_EXTENSIONS: java.lang.Character.UnicodeBlock!
                public final val JAVANESE: java.lang.Character.UnicodeBlock!
                public final val KAITHI: java.lang.Character.UnicodeBlock!
                public final val KANA_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val KANBUN: java.lang.Character.UnicodeBlock!
                public final val KANGXI_RADICALS: java.lang.Character.UnicodeBlock!
                public final val KANNADA: java.lang.Character.UnicodeBlock!
                public final val KATAKANA: java.lang.Character.UnicodeBlock!
                public final val KATAKANA_PHONETIC_EXTENSIONS: java.lang.Character.UnicodeBlock!
                public final val KAYAH_LI: java.lang.Character.UnicodeBlock!
                public final val KHAROSHTHI: java.lang.Character.UnicodeBlock!
                public final val KHMER: java.lang.Character.UnicodeBlock!
                public final val KHMER_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val LAO: java.lang.Character.UnicodeBlock!
                public final val LATIN_1_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val LATIN_EXTENDED_A: java.lang.Character.UnicodeBlock!
                public final val LATIN_EXTENDED_ADDITIONAL: java.lang.Character.UnicodeBlock!
                public final val LATIN_EXTENDED_B: java.lang.Character.UnicodeBlock!
                public final val LATIN_EXTENDED_C: java.lang.Character.UnicodeBlock!
                public final val LATIN_EXTENDED_D: java.lang.Character.UnicodeBlock!
                public final val LEPCHA: java.lang.Character.UnicodeBlock!
                public final val LETTERLIKE_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val LIMBU: java.lang.Character.UnicodeBlock!
                public final val LINEAR_B_IDEOGRAMS: java.lang.Character.UnicodeBlock!
                public final val LINEAR_B_SYLLABARY: java.lang.Character.UnicodeBlock!
                public final val LISU: java.lang.Character.UnicodeBlock!
                public final val LOW_SURROGATES: java.lang.Character.UnicodeBlock!
                public final val LYCIAN: java.lang.Character.UnicodeBlock!
                public final val LYDIAN: java.lang.Character.UnicodeBlock!
                public final val MAHJONG_TILES: java.lang.Character.UnicodeBlock!
                public final val MALAYALAM: java.lang.Character.UnicodeBlock!
                public final val MANDAIC: java.lang.Character.UnicodeBlock!
                public final val MATHEMATICAL_ALPHANUMERIC_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val MATHEMATICAL_OPERATORS: java.lang.Character.UnicodeBlock!
                public final val MEETEI_MAYEK: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_SYMBOLS_AND_ARROWS: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS: java.lang.Character.UnicodeBlock!
                public final val MISCELLANEOUS_TECHNICAL: java.lang.Character.UnicodeBlock!
                public final val MODIFIER_TONE_LETTERS: java.lang.Character.UnicodeBlock!
                public final val MONGOLIAN: java.lang.Character.UnicodeBlock!
                public final val MUSICAL_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val MYANMAR: java.lang.Character.UnicodeBlock!
                public final val MYANMAR_EXTENDED_A: java.lang.Character.UnicodeBlock!
                public final val NEW_TAI_LUE: java.lang.Character.UnicodeBlock!
                public final val NKO: java.lang.Character.UnicodeBlock!
                public final val NUMBER_FORMS: java.lang.Character.UnicodeBlock!
                public final val OGHAM: java.lang.Character.UnicodeBlock!
                public final val OLD_ITALIC: java.lang.Character.UnicodeBlock!
                public final val OLD_PERSIAN: java.lang.Character.UnicodeBlock!
                public final val OLD_SOUTH_ARABIAN: java.lang.Character.UnicodeBlock!
                public final val OLD_TURKIC: java.lang.Character.UnicodeBlock!
                public final val OL_CHIKI: java.lang.Character.UnicodeBlock!
                public final val OPTICAL_CHARACTER_RECOGNITION: java.lang.Character.UnicodeBlock!
                public final val ORIYA: java.lang.Character.UnicodeBlock!
                public final val OSMANYA: java.lang.Character.UnicodeBlock!
                public final val PHAGS_PA: java.lang.Character.UnicodeBlock!
                public final val PHAISTOS_DISC: java.lang.Character.UnicodeBlock!
                public final val PHOENICIAN: java.lang.Character.UnicodeBlock!
                public final val PHONETIC_EXTENSIONS: java.lang.Character.UnicodeBlock!
                public final val PHONETIC_EXTENSIONS_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val PLAYING_CARDS: java.lang.Character.UnicodeBlock!
                public final val PRIVATE_USE_AREA: java.lang.Character.UnicodeBlock!
                public final val REJANG: java.lang.Character.UnicodeBlock!
                public final val RUMI_NUMERAL_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val RUNIC: java.lang.Character.UnicodeBlock!
                public final val SAMARITAN: java.lang.Character.UnicodeBlock!
                public final val SAURASHTRA: java.lang.Character.UnicodeBlock!
                public final val SHAVIAN: java.lang.Character.UnicodeBlock!
                public final val SINHALA: java.lang.Character.UnicodeBlock!
                public final val SMALL_FORM_VARIANTS: java.lang.Character.UnicodeBlock!
                public final val SPACING_MODIFIER_LETTERS: java.lang.Character.UnicodeBlock!
                public final val SPECIALS: java.lang.Character.UnicodeBlock!
                public final val SUNDANESE: java.lang.Character.UnicodeBlock!
                public final val SUPERSCRIPTS_AND_SUBSCRIPTS: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTAL_ARROWS_A: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTAL_ARROWS_B: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTAL_MATHEMATICAL_OPERATORS: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTAL_PUNCTUATION: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTARY_PRIVATE_USE_AREA_A: java.lang.Character.UnicodeBlock!
                public final val SUPPLEMENTARY_PRIVATE_USE_AREA_B: java.lang.Character.UnicodeBlock!
                kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final val SURROGATES_AREA: java.lang.Character.UnicodeBlock!
                public final val SYLOTI_NAGRI: java.lang.Character.UnicodeBlock!
                public final val SYRIAC: java.lang.Character.UnicodeBlock!
                public final val TAGALOG: java.lang.Character.UnicodeBlock!
                public final val TAGBANWA: java.lang.Character.UnicodeBlock!
                public final val TAGS: java.lang.Character.UnicodeBlock!
                public final val TAI_LE: java.lang.Character.UnicodeBlock!
                public final val TAI_THAM: java.lang.Character.UnicodeBlock!
                public final val TAI_VIET: java.lang.Character.UnicodeBlock!
                public final val TAI_XUAN_JING_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val TAMIL: java.lang.Character.UnicodeBlock!
                public final val TELUGU: java.lang.Character.UnicodeBlock!
                public final val THAANA: java.lang.Character.UnicodeBlock!
                public final val THAI: java.lang.Character.UnicodeBlock!
                public final val TIBETAN: java.lang.Character.UnicodeBlock!
                public final val TIFINAGH: java.lang.Character.UnicodeBlock!
                public final val TRANSPORT_AND_MAP_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val UGARITIC: java.lang.Character.UnicodeBlock!
                public final val UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS: java.lang.Character.UnicodeBlock!
                public final val UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED: java.lang.Character.UnicodeBlock!
                public final val VAI: java.lang.Character.UnicodeBlock!
                public final val VARIATION_SELECTORS: java.lang.Character.UnicodeBlock!
                public final val VARIATION_SELECTORS_SUPPLEMENT: java.lang.Character.UnicodeBlock!
                public final val VEDIC_EXTENSIONS: java.lang.Character.UnicodeBlock!
                public final val VERTICAL_FORMS: java.lang.Character.UnicodeBlock!
                public final val YIJING_HEXAGRAM_SYMBOLS: java.lang.Character.UnicodeBlock!
                public final val YI_RADICALS: java.lang.Character.UnicodeBlock!
                public final val YI_SYLLABLES: java.lang.Character.UnicodeBlock!
                private final val blockStarts: kotlin.IntArray!
                private final val blocks: kotlin.Array<(out) java.lang.Character.UnicodeBlock!>!
                private final var map: kotlin.(Mutable)Map<kotlin.String!, java.lang.Character.UnicodeBlock!>!
                public final fun forName(/*0*/ p0: kotlin.String!): java.lang.Character.UnicodeBlock!
                public open fun of(/*0*/ p0: kotlin.Char): java.lang.Character.UnicodeBlock!
                public open fun of(/*0*/ p0: kotlin.Int): java.lang.Character.UnicodeBlock!
            }

            public final enum class UnicodeScript : kotlin.Enum<java.lang.Character.UnicodeScript!> {
                public enum entry COMMON : java.lang.Character.UnicodeScript {
                    private constructor COMMON()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LATIN : java.lang.Character.UnicodeScript {
                    private constructor LATIN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GREEK : java.lang.Character.UnicodeScript {
                    private constructor GREEK()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CYRILLIC : java.lang.Character.UnicodeScript {
                    private constructor CYRILLIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry ARMENIAN : java.lang.Character.UnicodeScript {
                    private constructor ARMENIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HEBREW : java.lang.Character.UnicodeScript {
                    private constructor HEBREW()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry ARABIC : java.lang.Character.UnicodeScript {
                    private constructor ARABIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SYRIAC : java.lang.Character.UnicodeScript {
                    private constructor SYRIAC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry THAANA : java.lang.Character.UnicodeScript {
                    private constructor THAANA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry DEVANAGARI : java.lang.Character.UnicodeScript {
                    private constructor DEVANAGARI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BENGALI : java.lang.Character.UnicodeScript {
                    private constructor BENGALI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GURMUKHI : java.lang.Character.UnicodeScript {
                    private constructor GURMUKHI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GUJARATI : java.lang.Character.UnicodeScript {
                    private constructor GUJARATI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry ORIYA : java.lang.Character.UnicodeScript {
                    private constructor ORIYA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAMIL : java.lang.Character.UnicodeScript {
                    private constructor TAMIL()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TELUGU : java.lang.Character.UnicodeScript {
                    private constructor TELUGU()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KANNADA : java.lang.Character.UnicodeScript {
                    private constructor KANNADA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MALAYALAM : java.lang.Character.UnicodeScript {
                    private constructor MALAYALAM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SINHALA : java.lang.Character.UnicodeScript {
                    private constructor SINHALA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry THAI : java.lang.Character.UnicodeScript {
                    private constructor THAI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LAO : java.lang.Character.UnicodeScript {
                    private constructor LAO()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TIBETAN : java.lang.Character.UnicodeScript {
                    private constructor TIBETAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MYANMAR : java.lang.Character.UnicodeScript {
                    private constructor MYANMAR()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GEORGIAN : java.lang.Character.UnicodeScript {
                    private constructor GEORGIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HANGUL : java.lang.Character.UnicodeScript {
                    private constructor HANGUL()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry ETHIOPIC : java.lang.Character.UnicodeScript {
                    private constructor ETHIOPIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CHEROKEE : java.lang.Character.UnicodeScript {
                    private constructor CHEROKEE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CANADIAN_ABORIGINAL : java.lang.Character.UnicodeScript {
                    private constructor CANADIAN_ABORIGINAL()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OGHAM : java.lang.Character.UnicodeScript {
                    private constructor OGHAM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry RUNIC : java.lang.Character.UnicodeScript {
                    private constructor RUNIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KHMER : java.lang.Character.UnicodeScript {
                    private constructor KHMER()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MONGOLIAN : java.lang.Character.UnicodeScript {
                    private constructor MONGOLIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HIRAGANA : java.lang.Character.UnicodeScript {
                    private constructor HIRAGANA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KATAKANA : java.lang.Character.UnicodeScript {
                    private constructor KATAKANA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BOPOMOFO : java.lang.Character.UnicodeScript {
                    private constructor BOPOMOFO()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HAN : java.lang.Character.UnicodeScript {
                    private constructor HAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry YI : java.lang.Character.UnicodeScript {
                    private constructor YI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OLD_ITALIC : java.lang.Character.UnicodeScript {
                    private constructor OLD_ITALIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GOTHIC : java.lang.Character.UnicodeScript {
                    private constructor GOTHIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry DESERET : java.lang.Character.UnicodeScript {
                    private constructor DESERET()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry INHERITED : java.lang.Character.UnicodeScript {
                    private constructor INHERITED()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAGALOG : java.lang.Character.UnicodeScript {
                    private constructor TAGALOG()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HANUNOO : java.lang.Character.UnicodeScript {
                    private constructor HANUNOO()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BUHID : java.lang.Character.UnicodeScript {
                    private constructor BUHID()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAGBANWA : java.lang.Character.UnicodeScript {
                    private constructor TAGBANWA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LIMBU : java.lang.Character.UnicodeScript {
                    private constructor LIMBU()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAI_LE : java.lang.Character.UnicodeScript {
                    private constructor TAI_LE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LINEAR_B : java.lang.Character.UnicodeScript {
                    private constructor LINEAR_B()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry UGARITIC : java.lang.Character.UnicodeScript {
                    private constructor UGARITIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SHAVIAN : java.lang.Character.UnicodeScript {
                    private constructor SHAVIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OSMANYA : java.lang.Character.UnicodeScript {
                    private constructor OSMANYA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CYPRIOT : java.lang.Character.UnicodeScript {
                    private constructor CYPRIOT()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BRAILLE : java.lang.Character.UnicodeScript {
                    private constructor BRAILLE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BUGINESE : java.lang.Character.UnicodeScript {
                    private constructor BUGINESE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry COPTIC : java.lang.Character.UnicodeScript {
                    private constructor COPTIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry NEW_TAI_LUE : java.lang.Character.UnicodeScript {
                    private constructor NEW_TAI_LUE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry GLAGOLITIC : java.lang.Character.UnicodeScript {
                    private constructor GLAGOLITIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TIFINAGH : java.lang.Character.UnicodeScript {
                    private constructor TIFINAGH()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SYLOTI_NAGRI : java.lang.Character.UnicodeScript {
                    private constructor SYLOTI_NAGRI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OLD_PERSIAN : java.lang.Character.UnicodeScript {
                    private constructor OLD_PERSIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KHAROSHTHI : java.lang.Character.UnicodeScript {
                    private constructor KHAROSHTHI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BALINESE : java.lang.Character.UnicodeScript {
                    private constructor BALINESE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CUNEIFORM : java.lang.Character.UnicodeScript {
                    private constructor CUNEIFORM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry PHOENICIAN : java.lang.Character.UnicodeScript {
                    private constructor PHOENICIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry PHAGS_PA : java.lang.Character.UnicodeScript {
                    private constructor PHAGS_PA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry NKO : java.lang.Character.UnicodeScript {
                    private constructor NKO()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SUNDANESE : java.lang.Character.UnicodeScript {
                    private constructor SUNDANESE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BATAK : java.lang.Character.UnicodeScript {
                    private constructor BATAK()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LEPCHA : java.lang.Character.UnicodeScript {
                    private constructor LEPCHA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OL_CHIKI : java.lang.Character.UnicodeScript {
                    private constructor OL_CHIKI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry VAI : java.lang.Character.UnicodeScript {
                    private constructor VAI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SAURASHTRA : java.lang.Character.UnicodeScript {
                    private constructor SAURASHTRA()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KAYAH_LI : java.lang.Character.UnicodeScript {
                    private constructor KAYAH_LI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry REJANG : java.lang.Character.UnicodeScript {
                    private constructor REJANG()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LYCIAN : java.lang.Character.UnicodeScript {
                    private constructor LYCIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CARIAN : java.lang.Character.UnicodeScript {
                    private constructor CARIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LYDIAN : java.lang.Character.UnicodeScript {
                    private constructor LYDIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CHAM : java.lang.Character.UnicodeScript {
                    private constructor CHAM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAI_THAM : java.lang.Character.UnicodeScript {
                    private constructor TAI_THAM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TAI_VIET : java.lang.Character.UnicodeScript {
                    private constructor TAI_VIET()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry AVESTAN : java.lang.Character.UnicodeScript {
                    private constructor AVESTAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry EGYPTIAN_HIEROGLYPHS : java.lang.Character.UnicodeScript {
                    private constructor EGYPTIAN_HIEROGLYPHS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SAMARITAN : java.lang.Character.UnicodeScript {
                    private constructor SAMARITAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MANDAIC : java.lang.Character.UnicodeScript {
                    private constructor MANDAIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LISU : java.lang.Character.UnicodeScript {
                    private constructor LISU()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BAMUM : java.lang.Character.UnicodeScript {
                    private constructor BAMUM()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry JAVANESE : java.lang.Character.UnicodeScript {
                    private constructor JAVANESE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MEETEI_MAYEK : java.lang.Character.UnicodeScript {
                    private constructor MEETEI_MAYEK()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry IMPERIAL_ARAMAIC : java.lang.Character.UnicodeScript {
                    private constructor IMPERIAL_ARAMAIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OLD_SOUTH_ARABIAN : java.lang.Character.UnicodeScript {
                    private constructor OLD_SOUTH_ARABIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry INSCRIPTIONAL_PARTHIAN : java.lang.Character.UnicodeScript {
                    private constructor INSCRIPTIONAL_PARTHIAN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry INSCRIPTIONAL_PAHLAVI : java.lang.Character.UnicodeScript {
                    private constructor INSCRIPTIONAL_PAHLAVI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry OLD_TURKIC : java.lang.Character.UnicodeScript {
                    private constructor OLD_TURKIC()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BRAHMI : java.lang.Character.UnicodeScript {
                    private constructor BRAHMI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry KAITHI : java.lang.Character.UnicodeScript {
                    private constructor KAITHI()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry UNKNOWN : java.lang.Character.UnicodeScript {
                    private constructor UNKNOWN()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor UnicodeScript()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Character.UnicodeScript!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final var aliases: java.util.HashMap<kotlin.String!, java.lang.Character.UnicodeScript!>!
                private final val scriptStarts: kotlin.IntArray!
                private final val scripts: kotlin.Array<(out) java.lang.Character.UnicodeScript!>!
                public final fun forName(/*0*/ p0: kotlin.String!): java.lang.Character.UnicodeScript!
                public open fun of(/*0*/ p0: kotlin.Int): java.lang.Character.UnicodeScript!
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.lang.Character.UnicodeScript
                public final /*synthesized*/ fun values(): kotlin.Array<java.lang.Character.UnicodeScript>
            }

            // Static members
            public final val COMBINING_SPACING_MARK: kotlin.Byte = 8.toByte()
            public final val CONNECTOR_PUNCTUATION: kotlin.Byte = 23.toByte()
            public final val CONTROL: kotlin.Byte = 15.toByte()
            public final val CURRENCY_SYMBOL: kotlin.Byte = 26.toByte()
            public final val DASH_PUNCTUATION: kotlin.Byte = 20.toByte()
            public final val DECIMAL_DIGIT_NUMBER: kotlin.Byte = 9.toByte()
            public final val DIRECTIONALITY_ARABIC_NUMBER: kotlin.Byte = 6.toByte()
            public final val DIRECTIONALITY_BOUNDARY_NEUTRAL: kotlin.Byte = 9.toByte()
            public final val DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: kotlin.Byte = 7.toByte()
            public final val DIRECTIONALITY_EUROPEAN_NUMBER: kotlin.Byte = 3.toByte()
            public final val DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: kotlin.Byte = 4.toByte()
            public final val DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: kotlin.Byte = 5.toByte()
            public final val DIRECTIONALITY_LEFT_TO_RIGHT: kotlin.Byte = 0.toByte()
            public final val DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: kotlin.Byte = 14.toByte()
            public final val DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: kotlin.Byte = 15.toByte()
            public final val DIRECTIONALITY_NONSPACING_MARK: kotlin.Byte = 8.toByte()
            public final val DIRECTIONALITY_OTHER_NEUTRALS: kotlin.Byte = 13.toByte()
            public final val DIRECTIONALITY_PARAGRAPH_SEPARATOR: kotlin.Byte = 10.toByte()
            public final val DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: kotlin.Byte = 18.toByte()
            public final val DIRECTIONALITY_RIGHT_TO_LEFT: kotlin.Byte = 1.toByte()
            public final val DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: kotlin.Byte = 2.toByte()
            public final val DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: kotlin.Byte = 16.toByte()
            public final val DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: kotlin.Byte = 17.toByte()
            public final val DIRECTIONALITY_SEGMENT_SEPARATOR: kotlin.Byte = 11.toByte()
            public final val DIRECTIONALITY_UNDEFINED: kotlin.Byte = -1.toByte()
            public final val DIRECTIONALITY_WHITESPACE: kotlin.Byte = 12.toByte()
            public final val ENCLOSING_MARK: kotlin.Byte = 7.toByte()
            public final val END_PUNCTUATION: kotlin.Byte = 22.toByte()
            public/*package*/ final val ERROR: kotlin.Int = -1
            public final val FINAL_QUOTE_PUNCTUATION: kotlin.Byte = 30.toByte()
            public final val FORMAT: kotlin.Byte = 16.toByte()
            public final val INITIAL_QUOTE_PUNCTUATION: kotlin.Byte = 29.toByte()
            public final val LETTER_NUMBER: kotlin.Byte = 10.toByte()
            public final val LINE_SEPARATOR: kotlin.Byte = 13.toByte()
            public final val LOWERCASE_LETTER: kotlin.Byte = 2.toByte()
            public final val MATH_SYMBOL: kotlin.Byte = 25.toByte()
            public final val MAX_CODE_POINT: kotlin.Int = 1114111
            public final val MAX_HIGH_SURROGATE: kotlin.Char = \uDBFF ('?')
            public final val MAX_LOW_SURROGATE: kotlin.Char = \uDFFF ('?')
            public final val MAX_RADIX: kotlin.Int = 36
            public final val MAX_SURROGATE: kotlin.Char = \uDFFF ('?')
            public final val MAX_VALUE: kotlin.Char = \uFFFF ('?')
            public final val MIN_CODE_POINT: kotlin.Int = 0
            public final val MIN_HIGH_SURROGATE: kotlin.Char = \uD800 ('?')
            public final val MIN_LOW_SURROGATE: kotlin.Char = \uDC00 ('?')
            public final val MIN_RADIX: kotlin.Int = 2
            public final val MIN_SUPPLEMENTARY_CODE_POINT: kotlin.Int = 65536
            public final val MIN_SURROGATE: kotlin.Char = \uD800 ('?')
            public final val MIN_VALUE: kotlin.Char = \u0000 ('?')
            public final val MODIFIER_LETTER: kotlin.Byte = 4.toByte()
            public final val MODIFIER_SYMBOL: kotlin.Byte = 27.toByte()
            public final val NON_SPACING_MARK: kotlin.Byte = 6.toByte()
            public final val OTHER_LETTER: kotlin.Byte = 5.toByte()
            public final val OTHER_NUMBER: kotlin.Byte = 11.toByte()
            public final val OTHER_PUNCTUATION: kotlin.Byte = 24.toByte()
            public final val OTHER_SYMBOL: kotlin.Byte = 28.toByte()
            public final val PARAGRAPH_SEPARATOR: kotlin.Byte = 14.toByte()
            public final val PRIVATE_USE: kotlin.Byte = 18.toByte()
            public final val SIZE: kotlin.Int = 16
            public final val SPACE_SEPARATOR: kotlin.Byte = 12.toByte()
            public final val START_PUNCTUATION: kotlin.Byte = 21.toByte()
            public final val SURROGATE: kotlin.Byte = 19.toByte()
            public final val TITLECASE_LETTER: kotlin.Byte = 3.toByte()
            public final val TYPE: java.lang.Class<kotlin.Char!>!
            public final val UNASSIGNED: kotlin.Byte = 0.toByte()
            public final val UPPERCASE_LETTER: kotlin.Byte = 1.toByte()
            private final val serialVersionUID: kotlin.Long = 3786198910865385080.toLong()
            public open fun charCount(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun codePointAt(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun codePointAt(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun codePointAt(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int): kotlin.Int
            public/*package*/ open fun codePointAtImpl(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun codePointBefore(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun codePointBefore(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun codePointBefore(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int): kotlin.Int
            public/*package*/ open fun codePointBeforeImpl(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun codePointCount(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun codePointCount(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public/*package*/ open fun codePointCountImpl(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun compare(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Int
            public open fun digit(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun digit(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun forDigit(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Char
            public open fun getDirectionality(/*0*/ p0: kotlin.Char): kotlin.Byte
            public open fun getDirectionality(/*0*/ p0: kotlin.Int): kotlin.Byte
            public open fun getName(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun getNumericValue(/*0*/ p0: kotlin.Char): kotlin.Int
            public open fun getNumericValue(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun getType(/*0*/ p0: kotlin.Char): kotlin.Int
            public open fun getType(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun highSurrogate(/*0*/ p0: kotlin.Int): kotlin.Char
            public open fun isAlphabetic(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isBmpCodePoint(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isDefined(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isDefined(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isDigit(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isDigit(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isHighSurrogate(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isISOControl(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isISOControl(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isIdentifierIgnorable(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isIdentifierIgnorable(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isIdeographic(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isJavaIdentifierPart(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isJavaIdentifierPart(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isJavaIdentifierStart(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isJavaIdentifierStart(/*0*/ p0: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun isJavaLetter(/*0*/ p0: kotlin.Char): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun isJavaLetterOrDigit(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isLetter(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isLetter(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isLetterOrDigit(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isLetterOrDigit(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isLowSurrogate(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isLowerCase(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isLowerCase(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isMirrored(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isMirrored(/*0*/ p0: kotlin.Int): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun isSpace(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isSpaceChar(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isSpaceChar(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isSupplementaryCodePoint(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isSurrogate(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isSurrogatePair(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Boolean
            public open fun isTitleCase(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isTitleCase(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isUnicodeIdentifierPart(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isUnicodeIdentifierPart(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isUnicodeIdentifierStart(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isUnicodeIdentifierStart(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isUpperCase(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isUpperCase(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isValidCodePoint(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isWhitespace(/*0*/ p0: kotlin.Char): kotlin.Boolean
            public open fun isWhitespace(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun lowSurrogate(/*0*/ p0: kotlin.Int): kotlin.Char
            public open fun offsetByCodePoints(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Int
            public open fun offsetByCodePoints(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Int
            public/*package*/ open fun offsetByCodePointsImpl(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Int
            public open fun reverseBytes(/*0*/ p0: kotlin.Char): kotlin.Char
            public open fun toChars(/*0*/ p0: kotlin.Int): kotlin.CharArray!
            public open fun toChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!, /*2*/ p2: kotlin.Int): kotlin.Int
            public open fun toCodePoint(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Int
            public open fun toLowerCase(/*0*/ p0: kotlin.Char): kotlin.Char
            public open fun toLowerCase(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun toString(/*0*/ p0: kotlin.Char): kotlin.String!
            public/*package*/ open fun toSurrogates(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun toTitleCase(/*0*/ p0: kotlin.Char): kotlin.Char
            public open fun toTitleCase(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun toUpperCase(/*0*/ p0: kotlin.Char): kotlin.Char
            public open fun toUpperCase(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ open fun toUpperCaseCharArray(/*0*/ p0: kotlin.Int): kotlin.CharArray!
            public/*package*/ open fun toUpperCaseEx(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun valueOf(/*0*/ p0: kotlin.Char): kotlin.Char!
        }

        public final class Class</*0*/ T> : java.io.Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, java.lang.reflect.AnnotatedElement {
            private constructor Class</*0*/ T>()
            private final var annotationType: [ERROR : Unresolved java classifier: AnnotationType]!
            private final var annotations: kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
            private final var cachedConstructor: java.lang.reflect.Constructor<T!>!
            private final var classRedefinedCount: kotlin.Int
            public/*package*/ final var classValueMap: [ERROR : Unresolved java classifier: ClassValueMap]!
            private final var declaredAnnotations: kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
            private final var declaredConstructors: [ERROR : Unresolved java classifier: SoftReference<Constructor<T>[]>]!
            private final var declaredFields: [ERROR : Unresolved java classifier: SoftReference<Field[]>]!
            private final var declaredMethods: [ERROR : Unresolved java classifier: SoftReference<Method[]>]!
            private final var declaredPublicFields: [ERROR : Unresolved java classifier: SoftReference<Field[]>]!
            private final var declaredPublicMethods: [ERROR : Unresolved java classifier: SoftReference<Method[]>]!
            private final var enumConstantDirectory: kotlin.(Mutable)Map<kotlin.String!, T!>!
            private final var enumConstants: kotlin.Array<(out) T!>!
            private final var genericInfo: [ERROR : Unresolved java classifier: ClassRepository]!
            private final var lastRedefinedCount: kotlin.Int
            private final var name: kotlin.String!
            private final var newInstanceCallerCache: java.lang.Class<*>!
            private final var publicConstructors: [ERROR : Unresolved java classifier: SoftReference<Constructor<T>[]>]!
            private final var publicFields: [ERROR : Unresolved java classifier: SoftReference<Field[]>]!
            private final var publicMethods: [ERROR : Unresolved java classifier: SoftReference<Method[]>]!
            public open fun </*0*/ U> asSubclass(/*0*/ p0: java.lang.Class<U!>!): java.lang.Class<out U!>!
            private open fun cannotCastMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
            public open fun cast(/*0*/ p0: kotlin.Any!): T!
            private open fun checkMemberAccess(/*0*/ p0: kotlin.Int, /*1*/ p1: java.lang.ClassLoader!): kotlin.Unit
            private open fun clearCachesOnClassRedefinition(): kotlin.Unit
            public open fun desiredAssertionStatus(): kotlin.Boolean
            public/*package*/ open fun enumConstantDirectory(): kotlin.(Mutable)Map<kotlin.String!, T!>!
            public open override /*4*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun </*0*/ A : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<A!>!): A!
            public/*package*/ open fun getAnnotationType(): [ERROR : Unresolved java classifier: AnnotationType]!
            public open override /*1*/ fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
            public open fun getCanonicalName(): kotlin.String!
            public open fun getClassLoader(): java.lang.ClassLoader!
            public/*package*/ open fun getClassLoader0(): java.lang.ClassLoader!
            public open fun getClasses(): kotlin.Array<(out) java.lang.Class<*>!>!
            public open fun getComponentType(): java.lang.Class<*>!
            public/*package*/ open fun getConstantPool(): [ERROR : Unresolved java classifier: ConstantPool]!
            public open fun getConstructor(/*0*/ vararg parameterTypes: java.lang.Class<*>! /*kotlin.Array<(out) java.lang.Class<*>!>!*/): java.lang.reflect.Constructor<T!>!
            private open fun getConstructor0(/*0*/ p0: kotlin.Array<(out) java.lang.Class<*>!>!, /*1*/ p1: kotlin.Int): java.lang.reflect.Constructor<T!>!
            public open fun getConstructors(): kotlin.Array<(out) java.lang.reflect.Constructor<*>!>!
            public open override /*1*/ fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
            public open fun getDeclaredClasses(): kotlin.Array<(out) java.lang.Class<*>!>!
            private open fun getDeclaredClasses0(): kotlin.Array<(out) java.lang.Class<*>!>!
            public open fun getDeclaredConstructor(/*0*/ vararg parameterTypes: java.lang.Class<*>! /*kotlin.Array<(out) java.lang.Class<*>!>!*/): java.lang.reflect.Constructor<T!>!
            public open fun getDeclaredConstructors(): kotlin.Array<(out) java.lang.reflect.Constructor<*>!>!
            private open fun getDeclaredConstructors0(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Constructor<T!>!>!
            public open fun getDeclaredField(/*0*/ name: kotlin.String!): java.lang.reflect.Field!
            public open fun getDeclaredFields(): kotlin.Array<(out) java.lang.reflect.Field!>!
            private open fun getDeclaredFields0(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Field!>!
            public open fun getDeclaredMethod(/*0*/ name: kotlin.String!, /*1*/ vararg parameterTypes: java.lang.Class<*>! /*kotlin.Array<(out) java.lang.Class<*>!>!*/): java.lang.reflect.Method!
            public open fun getDeclaredMethods(): kotlin.Array<(out) java.lang.reflect.Method!>!
            private open fun getDeclaredMethods0(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Method!>!
            public open fun getDeclaringClass(): java.lang.Class<*>!
            public open fun getEnclosingClass(): java.lang.Class<*>!
            public open fun getEnclosingConstructor(): java.lang.reflect.Constructor<*>!
            public open fun getEnclosingMethod(): java.lang.reflect.Method!
            private open fun getEnclosingMethod0(): kotlin.Array<(out) kotlin.Any!>!
            private open fun getEnclosingMethodInfo(): java.lang.Class.EnclosingMethodInfo!
            public open fun getEnumConstants(): kotlin.Array<(out) T!>!
            public/*package*/ open fun getEnumConstantsShared(): kotlin.Array<(out) T!>!
            private open fun getFactory(): [ERROR : Unresolved java classifier: GenericsFactory]!
            public open fun getField(/*0*/ p0: kotlin.String!): java.lang.reflect.Field!
            private open fun getField0(/*0*/ p0: kotlin.String!): java.lang.reflect.Field!
            public open fun getFields(): kotlin.Array<(out) java.lang.reflect.Field!>!
            private open fun getGenericInfo(): [ERROR : Unresolved java classifier: ClassRepository]!
            public open fun getGenericInterfaces(): kotlin.Array<(out) java.lang.reflect.Type!>!
            private open fun getGenericSignature(): kotlin.String!
            public open fun getGenericSuperclass(): java.lang.reflect.Type!
            public open fun getInterfaces(): kotlin.Array<(out) java.lang.Class<*>!>!
            public open fun getMethod(/*0*/ name: kotlin.String!, /*1*/ vararg parameterTypes: java.lang.Class<*>! /*kotlin.Array<(out) java.lang.Class<*>!>!*/): java.lang.reflect.Method!
            private open fun getMethod0(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) java.lang.Class<*>!>!): java.lang.reflect.Method!
            public open fun getMethods(): kotlin.Array<(out) java.lang.reflect.Method!>!
            public open fun getModifiers(): kotlin.Int
            public open fun getName(): kotlin.String!
            private open fun getName0(): kotlin.String!
            public open fun getPackage(): [ERROR : Unresolved java classifier: Package]!
            public open fun getProtectionDomain(): [ERROR : Unresolved java classifier: ProtectionDomain]!
            private open fun getProtectionDomain0(): [ERROR : Unresolved java classifier: ProtectionDomain]!
            private open fun getRawAnnotations(): kotlin.ByteArray!
            public open fun getResource(/*0*/ name: kotlin.String!): java.net.URL!
            public open fun getResourceAsStream(/*0*/ name: kotlin.String!): java.io.InputStream!
            public open fun getSigners(): kotlin.Array<(out) kotlin.Any!>!
            private open fun getSimpleBinaryName(): kotlin.String!
            public open fun getSimpleName(): kotlin.String!
            public open fun getSuperclass(): java.lang.Class<in T!>!
            public open override /*1*/ fun getTypeParameters(): kotlin.Array<(out) [ERROR : Unresolved java classifier: TypeVariable<Class<T>>]!>!
            public open override /*4*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun initAnnotationsIfNecessary(): kotlin.Unit
            public open fun isAnnotation(): kotlin.Boolean
            public open override /*1*/ fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
            public open fun isAnonymousClass(): kotlin.Boolean
            public open fun isArray(): kotlin.Boolean
            public open fun isAssignableFrom(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            public open fun isEnum(): kotlin.Boolean
            public open fun isInstance(/*0*/ obj: kotlin.Any!): kotlin.Boolean
            public open fun isInterface(): kotlin.Boolean
            public open fun isLocalClass(): kotlin.Boolean
            private open fun isLocalOrAnonymousClass(): kotlin.Boolean
            public open fun isMemberClass(): kotlin.Boolean
            public open fun isPrimitive(): kotlin.Boolean
            public open fun isSynthetic(): kotlin.Boolean
            public open fun newInstance(): T!
            private open fun newInstance0(): T!
            private open fun privateGetDeclaredConstructors(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Constructor<T!>!>!
            private open fun privateGetDeclaredFields(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Field!>!
            private open fun privateGetDeclaredMethods(/*0*/ p0: kotlin.Boolean): kotlin.Array<(out) java.lang.reflect.Method!>!
            private open fun privateGetPublicFields(/*0*/ p0: kotlin.(Mutable)Set<java.lang.Class<*>!>!): kotlin.Array<(out) java.lang.reflect.Field!>!
            private open fun privateGetPublicMethods(): kotlin.Array<(out) java.lang.reflect.Method!>!
            private open fun resolveName(/*0*/ p0: kotlin.String!): kotlin.String!
            private open fun searchFields(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Field!>!, /*1*/ p1: kotlin.String!): java.lang.reflect.Field!
            public/*package*/ open fun setAnnotationType(/*0*/ p0: [ERROR : Unresolved java classifier: AnnotationType]!): kotlin.Unit
            public/*package*/ open fun setProtectionDomain0(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!): kotlin.Unit
            public/*package*/ open fun setSigners(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!): kotlin.Unit
            public open override /*4*/ fun toString(): kotlin.String!

            private final class EnclosingMethodInfo {
                private constructor EnclosingMethodInfo(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!)
                private final var descriptor: kotlin.String!
                private final var enclosingClass: java.lang.Class<*>!
                private final var name: kotlin.String!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ open fun getDescriptor(): kotlin.String!
                public/*package*/ open fun getEnclosingClass(): java.lang.Class<*>!
                public/*package*/ open fun getName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun isConstructor(): kotlin.Boolean
                public/*package*/ open fun isMethod(): kotlin.Boolean
                public/*package*/ open fun isPartial(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ open class MethodArray {
                public/*package*/ constructor MethodArray()
                private final var length: kotlin.Int
                private final var methods: kotlin.Array<(out) java.lang.reflect.Method!>!
                public/*package*/ open fun add(/*0*/ p0: java.lang.reflect.Method!): kotlin.Unit
                public/*package*/ open fun addAll(/*0*/ p0: java.lang.Class.MethodArray!): kotlin.Unit
                public/*package*/ open fun addAll(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Method!>!): kotlin.Unit
                public/*package*/ open fun addAllIfNotPresent(/*0*/ p0: java.lang.Class.MethodArray!): kotlin.Unit
                public/*package*/ open fun addIfNotPresent(/*0*/ p0: java.lang.reflect.Method!): kotlin.Unit
                public/*package*/ open fun compactAndTrim(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ open fun get(/*0*/ p0: kotlin.Int): java.lang.reflect.Method!
                public/*package*/ open fun getArray(): kotlin.Array<(out) java.lang.reflect.Method!>!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun length(): kotlin.Int
                public/*package*/ open fun removeByNameAndSignature(/*0*/ p0: java.lang.reflect.Method!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val ANNOTATION: kotlin.Int = 8192
            private final val ENUM: kotlin.Int = 16384
            private final val SYNTHETIC: kotlin.Int = 4096
            private final var allPermDomain: [ERROR : Unresolved java classifier: ProtectionDomain]!
            private final var initted: kotlin.Boolean
            private final var reflectionFactory: [ERROR : Unresolved java classifier: ReflectionFactory]!
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            private final val serialVersionUID: kotlin.Long = 3206093459760846163.toLong()
            private final var useCaches: kotlin.Boolean
            private open fun addAll(/*0*/ p0: kotlin.(Mutable)Collection<java.lang.reflect.Field!>!, /*1*/ p1: kotlin.Array<(out) java.lang.reflect.Field!>!): kotlin.Unit
            private open fun argumentTypesToString(/*0*/ p0: kotlin.Array<(out) java.lang.Class<*>!>!): kotlin.String!
            private open fun arrayContentsEq(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!): kotlin.Boolean
            private open fun checkInitted(): kotlin.Unit
            private open fun </*0*/ U> copyConstructors(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Constructor<U!>!>!): kotlin.Array<(out) java.lang.reflect.Constructor<U!>!>!
            private open fun copyFields(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Field!>!): kotlin.Array<(out) java.lang.reflect.Field!>!
            private open fun copyMethods(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Method!>!): kotlin.Array<(out) java.lang.reflect.Method!>!
            private open fun desiredAssertionStatus0(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            public open fun forName(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            public open fun forName(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: java.lang.ClassLoader!): java.lang.Class<*>!
            private open fun forName0(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: java.lang.ClassLoader!): java.lang.Class<*>!
            public/*package*/ open fun getPrimitiveClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            private open fun getReflectionFactory(): [ERROR : Unresolved java classifier: ReflectionFactory]!
            private open fun isAsciiDigit(/*0*/ p0: kotlin.Char): kotlin.Boolean
            private open fun registerNatives(): kotlin.Unit
            private open fun searchMethods(/*0*/ p0: kotlin.Array<(out) java.lang.reflect.Method!>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Array<(out) java.lang.Class<*>!>!): java.lang.reflect.Method!
            private open fun toClass(/*0*/ p0: java.lang.reflect.Type!): java.lang.Class<*>!
        }

        public open class ClassCastException : java.lang.RuntimeException {
            public constructor ClassCastException()
            public constructor ClassCastException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -9223365651070458532.toLong()
        }

        public abstract class ClassLoader {
            protected/*protected and package*/ constructor ClassLoader()
            protected/*protected and package*/ constructor ClassLoader(/*0*/ p0: java.lang.ClassLoader!)
            private constructor ClassLoader(/*0*/ p0: java.lang.Void!, /*1*/ p1: java.lang.ClassLoader!)
            public/*package*/ final val assertionLock: kotlin.Any!
            public/*package*/ final var classAssertionStatus: kotlin.(Mutable)Map<kotlin.String!, kotlin.Boolean!>!
            private final val classes: [ERROR : Unresolved java classifier: Vector<Class<?>>]!
            private final var defaultAssertionStatus: kotlin.Boolean
            private final val defaultDomain: [ERROR : Unresolved java classifier: ProtectionDomain]!
            private final val domains: kotlin.(Mutable)Set<[ERROR : Unresolved java classifier: ProtectionDomain]!>!
            private final var nativeLibraries: [ERROR : Unresolved java classifier: Vector<NativeLibrary>]!
            private final val package2certs: kotlin.(Mutable)Map<kotlin.String!, kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!>!
            private final var packageAssertionStatus: kotlin.(Mutable)Map<kotlin.String!, kotlin.Boolean!>!
            private final val packages: java.util.HashMap<kotlin.String!, [ERROR : Unresolved java classifier: Package]!>!
            private final val parallelLockMap: [ERROR : Unresolved java classifier: ConcurrentHashMap<String, Object>]!
            private final val parent: java.lang.ClassLoader!
            public/*package*/ open fun addClass(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
            private open fun checkCerts(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: CodeSource]!): kotlin.Unit
            private open fun checkName(/*0*/ p0: kotlin.String!): kotlin.Boolean
            private open fun checkPackageAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: ProtectionDomain]!): kotlin.Unit
            public open fun clearAssertionStatus(): kotlin.Unit
            private open fun compareCerts(/*0*/ p0: kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!, /*1*/ p1: kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) protected/*protected and package*/ final fun defineClass(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.Class<*>!
            protected/*protected and package*/ final fun defineClass(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: ByteBuffer]!, /*2*/ p2: [ERROR : Unresolved java classifier: ProtectionDomain]!): java.lang.Class<*>!
            protected/*protected and package*/ final fun defineClass(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.Class<*>!
            protected/*protected and package*/ final fun defineClass(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: ProtectionDomain]!): java.lang.Class<*>!
            private open fun defineClass0(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: ProtectionDomain]!): java.lang.Class<*>!
            private open fun defineClass1(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: ProtectionDomain]!, /*5*/ p5: kotlin.String!): java.lang.Class<*>!
            private open fun defineClass2(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: ByteBuffer]!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: ProtectionDomain]!, /*5*/ p5: kotlin.String!): java.lang.Class<*>!
            private open fun defineClassSourceLocation(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!): kotlin.String!
            protected/*protected and package*/ open fun definePackage(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.String!, /*6*/ p6: kotlin.String!, /*7*/ p7: java.net.URL!): [ERROR : Unresolved java classifier: Package]!
            private open fun defineTransformedClass(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: [ERROR : Unresolved java classifier: ProtectionDomain]!, /*5*/ p5: [ERROR : Unresolved java classifier: ClassFormatError]!, /*6*/ p6: kotlin.String!): java.lang.Class<*>!
            public/*package*/ open fun desiredAssertionStatus(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            private open fun findBootstrapClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            private open fun findBootstrapClassOrNull(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            protected/*protected and package*/ open fun findClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            protected/*protected and package*/ open fun findLibrary(/*0*/ p0: kotlin.String!): kotlin.String!
            protected/*protected and package*/ final fun findLoadedClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            private final fun findLoadedClass0(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            protected/*protected and package*/ open fun findResource(/*0*/ p0: kotlin.String!): java.net.URL!
            protected/*protected and package*/ open fun findResources(/*0*/ p0: kotlin.String!): java.util.Enumeration<java.net.URL!>!
            protected/*protected and package*/ final fun findSystemClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            protected/*protected and package*/ open fun getClassLoadingLock(/*0*/ p0: kotlin.String!): kotlin.Any!
            protected/*protected and package*/ open fun getPackage(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: Package]!
            protected/*protected and package*/ open fun getPackages(): kotlin.Array<(out) [ERROR : Unresolved java classifier: Package]!>!
            public final fun getParent(): java.lang.ClassLoader!
            public open fun getResource(/*0*/ p0: kotlin.String!): java.net.URL!
            public open fun getResourceAsStream(/*0*/ p0: kotlin.String!): java.io.InputStream!
            public open fun getResources(/*0*/ p0: kotlin.String!): java.util.Enumeration<java.net.URL!>!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun initializeJavaAssertionMaps(): kotlin.Unit
            public/*package*/ open fun isAncestor(/*0*/ p0: java.lang.ClassLoader!): kotlin.Boolean
            public open fun loadClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            protected/*protected and package*/ open fun loadClass(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): java.lang.Class<*>!
            private open fun loadClassInternal(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            private open fun postDefineClass(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: ProtectionDomain]!): kotlin.Unit
            private open fun preDefineClass(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: ProtectionDomain]!): [ERROR : Unresolved java classifier: ProtectionDomain]!
            protected/*protected and package*/ final fun resolveClass(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
            private open fun resolveClass0(/*0*/ p0: java.lang.Class<*>!): kotlin.Unit
            public open fun setClassAssertionStatus(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public open fun setDefaultAssertionStatus(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setPackageAssertionStatus(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            protected/*protected and package*/ final fun setSigners(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            public/*package*/ open class NativeLibrary {
                public constructor NativeLibrary(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.String!)
                private final var fromClass: java.lang.Class<*>!
                public/*package*/ final var handle: kotlin.Long
                private final var jniVersion: kotlin.Int
                public/*package*/ final var name: kotlin.String!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                protected/*protected and package*/ open fun finalize(): kotlin.Unit
                public/*package*/ open fun find(/*0*/ p0: kotlin.String!): kotlin.Long
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun load(/*0*/ p0: kotlin.String!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ open fun unload(): kotlin.Unit

                // Static members
                public/*package*/ open fun getFromClass(): java.lang.Class<*>!
            }

            private open class ParallelLoaders {
                private constructor ParallelLoaders()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val loaderTypes: kotlin.(Mutable)Set<java.lang.Class<out java.lang.ClassLoader!>!>!
                public/*package*/ open fun isRegistered(/*0*/ p0: java.lang.Class<out java.lang.ClassLoader!>!): kotlin.Boolean
                public/*package*/ open fun register(/*0*/ p0: java.lang.Class<out java.lang.ClassLoader!>!): kotlin.Boolean
            }

            // Static members
            private final var loadedLibraryNames: [ERROR : Unresolved java classifier: Vector<String>]!
            private final var nativeLibraryContext: [ERROR : Unresolved java classifier: Stack<NativeLibrary>]!
            private final val nocerts: kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!
            private final var scl: java.lang.ClassLoader!
            private final var sclSet: kotlin.Boolean
            private final var sys_paths: kotlin.Array<(out) kotlin.String!>!
            private final var systemNativeLibraries: [ERROR : Unresolved java classifier: Vector<NativeLibrary>]!
            private final var usr_paths: kotlin.Array<(out) kotlin.String!>!
            private open fun checkCreateClassLoader(): java.lang.Void!
            public/*package*/ open fun findNative(/*0*/ p0: java.lang.ClassLoader!, /*1*/ p1: kotlin.String!): kotlin.Long
            public/*package*/ open fun getBootstrapClassPath(): [ERROR : Unresolved java classifier: URLClassPath]!
            private open fun getBootstrapResource(/*0*/ p0: kotlin.String!): java.net.URL!
            private open fun getBootstrapResources(/*0*/ p0: kotlin.String!): java.util.Enumeration<java.net.URL!>!
            private open fun getCaller(/*0*/ p0: kotlin.Int): java.lang.Class<out java.lang.ClassLoader!>!
            public/*package*/ open fun getCallerClassLoader(): java.lang.ClassLoader!
            public open fun getSystemClassLoader(): java.lang.ClassLoader!
            public open fun getSystemResource(/*0*/ p0: kotlin.String!): java.net.URL!
            public open fun getSystemResourceAsStream(/*0*/ p0: kotlin.String!): java.io.InputStream!
            public open fun getSystemResources(/*0*/ p0: kotlin.String!): java.util.Enumeration<java.net.URL!>!
            private open fun initSystemClassLoader(): kotlin.Unit
            private open fun initializePath(/*0*/ p0: kotlin.String!): kotlin.Array<(out) kotlin.String!>!
            public/*package*/ open fun loadLibrary(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            private open fun loadLibrary0(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.io.File!): kotlin.Boolean
            private open fun loadLibrary1(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.io.File!): kotlin.Boolean
            protected/*protected static*/ open fun registerAsParallelCapable(): kotlin.Boolean
            private open fun registerNatives(): kotlin.Unit
            private open fun retrieveDirectives(): [ERROR : Unresolved java classifier: AssertionStatusDirectives]!
        }

        public open class ClassNotFoundException {
            public constructor ClassNotFoundException()
            public constructor ClassNotFoundException(/*0*/ p0: kotlin.String!)
            public constructor ClassNotFoundException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            private final var ex: kotlin.Throwable!
            public open fun getCause(): kotlin.Throwable!
            public open fun getException(): kotlin.Throwable!

            // Static members
            private final val serialVersionUID: kotlin.Long = 9176873029745254542.toLong()
        }

        public open class CloneNotSupportedException : java.lang.Exception {
            public constructor CloneNotSupportedException()
            public constructor CloneNotSupportedException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 5195511250079656443.toLong()
        }

        public trait Cloneable {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Comparable</*0*/ T> {
            public abstract fun compareTo(/*0*/ p0: T!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        java.lang.annotation.Documented() java.lang.annotation.Retention(value = RetentionPolicy.RUNTIME: java.lang.annotation.RetentionPolicy) java.lang.annotation.Target(value = {ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE}: kotlin.Array<out java.lang.annotation.ElementType>) public final annotation class Deprecated : kotlin.Annotation {
            public constructor Deprecated()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public final class Double : kotlin.Number, kotlin.Comparable<kotlin.Double!> {
            public constructor Double(/*0*/ p0: kotlin.Double)
            public constructor Double(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Double
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Double!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun isInfinite(): kotlin.Boolean
            public open fun isNaN(): kotlin.Boolean
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            // Static members
            public final val MAX_EXPONENT: kotlin.Int = 1023
            public final val MAX_VALUE: kotlin.Double = 1.7976931348623157E308.toDouble()
            public final val MIN_EXPONENT: kotlin.Int = -1022
            public final val MIN_NORMAL: kotlin.Double = 2.2250738585072014E-308.toDouble()
            public final val MIN_VALUE: kotlin.Double = 4.9E-324.toDouble()
            public final val NEGATIVE_INFINITY: kotlin.Double
            public final val NaN: kotlin.Double
            public final val POSITIVE_INFINITY: kotlin.Double
            public final val SIZE: kotlin.Int = 64
            public final val TYPE: java.lang.Class<kotlin.Double!>!
            private final val serialVersionUID: kotlin.Long = -9172774392245257468.toLong()
            public open fun compare(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Int
            public open fun doubleToLongBits(/*0*/ p0: kotlin.Double): kotlin.Long
            public open fun doubleToRawLongBits(/*0*/ p0: kotlin.Double): kotlin.Long
            public open fun isInfinite(/*0*/ p0: kotlin.Double): kotlin.Boolean
            public open fun isNaN(/*0*/ p0: kotlin.Double): kotlin.Boolean
            public open fun longBitsToDouble(/*0*/ p0: kotlin.Long): kotlin.Double
            public open fun parseDouble(/*0*/ p0: kotlin.String!): kotlin.Double
            public open fun toHexString(/*0*/ p0: kotlin.Double): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Double): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Double): kotlin.Double!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Double!
        }

        public abstract class Enum</*0*/ E : kotlin.Enum<E!>!> : kotlin.Comparable<E!>, java.io.Serializable {
            protected/*protected and package*/ constructor Enum</*0*/ E : kotlin.Enum<E!>!>(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int)
            private final val name: kotlin.String!
            private final val ordinal: kotlin.Int
            protected/*protected and package*/ final fun clone(): kotlin.Any!
            public final override /*1*/ fun compareTo(/*0*/ other: E!): kotlin.Int
            public final override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            protected/*protected and package*/ final fun finalize(): kotlin.Unit
            public final fun getDeclaringClass(): java.lang.Class<E!>!
            public final override /*2*/ fun hashCode(): kotlin.Int
            public final fun name(): kotlin.String!
            public final fun ordinal(): kotlin.Int
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            private open fun readObjectNoData(): kotlin.Unit
            public open override /*2*/ fun toString(): kotlin.String!

            // Static members
            public open fun </*0*/ T : kotlin.Enum<T!>!> valueOf(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: kotlin.String!): T!
        }

        public open class Error : kotlin.Throwable {
            public constructor Error()
            public constructor Error(/*0*/ p0: kotlin.String!)
            public constructor Error(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            protected/*protected and package*/ constructor Error(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean)
            public constructor Error(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 4980196508277280342.toLong()
        }

        public open class Exception : kotlin.Throwable {
            public constructor Exception()
            public constructor Exception(/*0*/ p0: kotlin.String!)
            public constructor Exception(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            protected/*protected and package*/ constructor Exception(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean)
            public constructor Exception(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -3387516993124229948.toLong()
        }

        public final class Float : kotlin.Number, kotlin.Comparable<kotlin.Float!> {
            public constructor Float(/*0*/ p0: kotlin.Double)
            public constructor Float(/*0*/ p0: kotlin.Float)
            public constructor Float(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Float
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Float!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun isInfinite(): kotlin.Boolean
            public open fun isNaN(): kotlin.Boolean
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            // Static members
            public final val MAX_EXPONENT: kotlin.Int = 127
            public final val MAX_VALUE: kotlin.Float = 3.4028235E38.toFloat()
            public final val MIN_EXPONENT: kotlin.Int = -126
            public final val MIN_NORMAL: kotlin.Float = 1.17549435E-38.toFloat()
            public final val MIN_VALUE: kotlin.Float = 1.4E-45.toFloat()
            public final val NEGATIVE_INFINITY: kotlin.Float
            public final val NaN: kotlin.Float
            public final val POSITIVE_INFINITY: kotlin.Float
            public final val SIZE: kotlin.Int = 32
            public final val TYPE: java.lang.Class<kotlin.Float!>!
            private final val serialVersionUID: kotlin.Long = -2671257302660747028.toLong()
            public open fun compare(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Float): kotlin.Int
            public open fun floatToIntBits(/*0*/ p0: kotlin.Float): kotlin.Int
            public open fun floatToRawIntBits(/*0*/ p0: kotlin.Float): kotlin.Int
            public open fun intBitsToFloat(/*0*/ p0: kotlin.Int): kotlin.Float
            public open fun isInfinite(/*0*/ p0: kotlin.Float): kotlin.Boolean
            public open fun isNaN(/*0*/ p0: kotlin.Float): kotlin.Boolean
            public open fun parseFloat(/*0*/ p0: kotlin.String!): kotlin.Float
            public open fun toHexString(/*0*/ p0: kotlin.Float): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Float): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Float): kotlin.Float!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Float!
        }

        public open class IllegalAccessException {
            public constructor IllegalAccessException()
            public constructor IllegalAccessException(/*0*/ p0: kotlin.String!)

            // Static members
            private final val serialVersionUID: kotlin.Long = 6616958222490762034.toLong()
        }

        public open class IllegalArgumentException : java.lang.RuntimeException {
            public constructor IllegalArgumentException()
            public constructor IllegalArgumentException(/*0*/ p0: kotlin.String!)
            public constructor IllegalArgumentException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor IllegalArgumentException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -5365630128856068164.toLong()
        }

        public open class IllegalStateException : java.lang.RuntimeException {
            public constructor IllegalStateException()
            public constructor IllegalStateException(/*0*/ p0: kotlin.String!)
            public constructor IllegalStateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor IllegalStateException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -1848914673093119416.toLong()
        }

        public open class IndexOutOfBoundsException : java.lang.RuntimeException {
            public constructor IndexOutOfBoundsException()
            public constructor IndexOutOfBoundsException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 234122996006267687.toLong()
        }

        public final class Integer : kotlin.Number, kotlin.Comparable<kotlin.Int!> {
            public constructor Integer(/*0*/ p0: kotlin.Int)
            public constructor Integer(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Int
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Int!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            private open class IntegerCache {
                private constructor IntegerCache()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val cache: kotlin.Array<(out) kotlin.Int!>!
                public/*package*/ final val high: kotlin.Int
                public/*package*/ final val low: kotlin.Int = -128
            }

            // Static members
            public/*package*/ final val DigitOnes: kotlin.CharArray!
            public/*package*/ final val DigitTens: kotlin.CharArray!
            public final val MAX_VALUE: kotlin.Int = 2147483647
            public final val MIN_VALUE: kotlin.Int = -2147483648
            public final val SIZE: kotlin.Int = 32
            public final val TYPE: java.lang.Class<kotlin.Int!>!
            public/*package*/ final val digits: kotlin.CharArray!
            private final val serialVersionUID: kotlin.Long = 1360826667806852920.toLong()
            public/*package*/ final val sizeTable: kotlin.IntArray!
            public open fun bitCount(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun compare(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun decode(/*0*/ p0: kotlin.String!): kotlin.Int!
            public/*package*/ open fun getChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!): kotlin.Unit
            public open fun getInteger(/*0*/ p0: kotlin.String!): kotlin.Int!
            public open fun getInteger(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int!
            public open fun getInteger(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int!): kotlin.Int!
            public open fun highestOneBit(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun lowestOneBit(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun numberOfLeadingZeros(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun numberOfTrailingZeros(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun parseInt(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun parseInt(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun reverse(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun reverseBytes(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun rotateLeft(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun rotateRight(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun signum(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ open fun stringSize(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun toBinaryString(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun toHexString(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun toOctalString(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            private open fun toUnsignedString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Int): kotlin.Int!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Int!
            public open fun valueOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int!
        }

        public trait Iterable</*0*/ T> {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun iterator(): kotlin.(Mutable)Iterator<T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public final class Long : kotlin.Number, kotlin.Comparable<kotlin.Long!> {
            public constructor Long(/*0*/ p0: kotlin.Long)
            public constructor Long(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Long
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Long!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            private open class LongCache {
                private constructor LongCache()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val cache: kotlin.Array<(out) kotlin.Long!>!
            }

            // Static members
            public final val MAX_VALUE: kotlin.Long = 9223372036854775807.toLong()
            public final val MIN_VALUE: kotlin.Long = -9223372036854775808.toLong()
            public final val SIZE: kotlin.Int = 64
            public final val TYPE: java.lang.Class<kotlin.Long!>!
            private final val serialVersionUID: kotlin.Long = 4290774380558885855.toLong()
            public open fun bitCount(/*0*/ p0: kotlin.Long): kotlin.Int
            public open fun compare(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
            public open fun decode(/*0*/ p0: kotlin.String!): kotlin.Long!
            public/*package*/ open fun getChars(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!): kotlin.Unit
            public open fun getLong(/*0*/ p0: kotlin.String!): kotlin.Long!
            public open fun getLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long!
            public open fun getLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long!): kotlin.Long!
            public open fun highestOneBit(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun lowestOneBit(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun numberOfLeadingZeros(/*0*/ p0: kotlin.Long): kotlin.Int
            public open fun numberOfTrailingZeros(/*0*/ p0: kotlin.Long): kotlin.Int
            public open fun parseLong(/*0*/ p0: kotlin.String!): kotlin.Long
            public open fun parseLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Long
            public open fun reverse(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun reverseBytes(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun rotateLeft(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Long
            public open fun rotateRight(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Long
            public open fun signum(/*0*/ p0: kotlin.Long): kotlin.Int
            public/*package*/ open fun stringSize(/*0*/ p0: kotlin.Long): kotlin.Int
            public open fun toBinaryString(/*0*/ p0: kotlin.Long): kotlin.String!
            public open fun toHexString(/*0*/ p0: kotlin.Long): kotlin.String!
            public open fun toOctalString(/*0*/ p0: kotlin.Long): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Long): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.String!
            private open fun toUnsignedString(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Long): kotlin.Long!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Long!
            public open fun valueOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Long!
        }

        public final class Math {
            private constructor Math()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val E: kotlin.Double = 2.718281828459045.toDouble()
            public final val PI: kotlin.Double = 3.141592653589793.toDouble()
            private final var negativeZeroDoubleBits: kotlin.Long
            private final var negativeZeroFloatBits: kotlin.Long
            private final var randomNumberGenerator: java.util.Random!
            public open fun IEEEremainder(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun abs(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun abs(/*0*/ p0: kotlin.Float): kotlin.Float
            public open fun abs(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun abs(/*0*/ p0: kotlin.Long): kotlin.Long
            public open fun acos(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun asin(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun atan(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun atan2(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun cbrt(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun ceil(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun copySign(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun copySign(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Float): kotlin.Float
            public open fun cos(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun cosh(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun exp(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun expm1(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun floor(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun getExponent(/*0*/ p0: kotlin.Double): kotlin.Int
            public open fun getExponent(/*0*/ p0: kotlin.Float): kotlin.Int
            public open fun hypot(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            private open fun initRNG(): java.util.Random!
            public open fun log(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun log10(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun log1p(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun max(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun max(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Float): kotlin.Float
            public open fun max(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun max(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Long
            public open fun min(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun min(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Float): kotlin.Float
            public open fun min(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun min(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Long
            public open fun nextAfter(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun nextAfter(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Double): kotlin.Float
            public open fun nextUp(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun nextUp(/*0*/ p0: kotlin.Float): kotlin.Float
            public open fun pow(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Double): kotlin.Double
            public open fun random(): kotlin.Double
            public open fun rint(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun round(/*0*/ p0: kotlin.Double): kotlin.Long
            public open fun round(/*0*/ p0: kotlin.Float): kotlin.Int
            public open fun scalb(/*0*/ p0: kotlin.Double, /*1*/ p1: kotlin.Int): kotlin.Double
            public open fun scalb(/*0*/ p0: kotlin.Float, /*1*/ p1: kotlin.Int): kotlin.Float
            public open fun signum(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun signum(/*0*/ p0: kotlin.Float): kotlin.Float
            public open fun sin(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun sinh(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun sqrt(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun tan(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun tanh(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun toDegrees(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun toRadians(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun ulp(/*0*/ p0: kotlin.Double): kotlin.Double
            public open fun ulp(/*0*/ p0: kotlin.Float): kotlin.Float
        }

        public open class NegativeArraySizeException : java.lang.RuntimeException {
            public constructor NegativeArraySizeException()
            public constructor NegativeArraySizeException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -8960118058596991861.toLong()
        }

        public open class NoSuchFieldException {
            public constructor NoSuchFieldException()
            public constructor NoSuchFieldException(/*0*/ p0: kotlin.String!)

            // Static members
            private final val serialVersionUID: kotlin.Long = -6143714805279938260.toLong()
        }

        public open class NullPointerException : java.lang.RuntimeException {
            public constructor NullPointerException()
            public constructor NullPointerException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 5162710183389028792.toLong()
        }

        public abstract class Number : java.io.Serializable {
            public constructor Number()
            public open fun byteValue(): kotlin.Byte
            public abstract fun doubleValue(): kotlin.Double
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun floatValue(): kotlin.Float
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun intValue(): kotlin.Int
            public abstract fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -8742448824652078965.toLong()
        }

        public open class NumberFormatException : java.lang.IllegalArgumentException {
            public constructor NumberFormatException()
            public constructor NumberFormatException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -2848938806368998894.toLong()
            public/*package*/ open fun forInputString(/*0*/ p0: kotlin.String!): java.lang.NumberFormatException!
        }

        public open class Object {
            public constructor Object()
            protected/*protected and package*/ open fun clone(): kotlin.Any!
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            protected/*protected and package*/ open fun finalize(): kotlin.Unit
            public final fun getClass(): java.lang.Class<*>!
            public open override /*1*/ fun hashCode(): kotlin.Int
            public final fun notify(): kotlin.Unit
            public final fun notifyAll(): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!
            public final fun wait(): kotlin.Unit
            public final fun wait(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final fun wait(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit

            // Static members
            private open fun registerNatives(): kotlin.Unit
        }

        java.lang.annotation.Target(value = {ElementType.METHOD}: kotlin.Array<out java.lang.annotation.ElementType>) java.lang.annotation.Retention(value = RetentionPolicy.SOURCE: java.lang.annotation.RetentionPolicy) public final annotation class Override : kotlin.Annotation {
            public constructor Override()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Readable {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun read(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Runnable {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun run(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class RuntimeException : java.lang.Exception {
            public constructor RuntimeException()
            public constructor RuntimeException(/*0*/ p0: kotlin.String!)
            public constructor RuntimeException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            protected/*protected and package*/ constructor RuntimeException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean)
            public constructor RuntimeException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -7034897190745766939.toLong()
        }

        public final class Short : kotlin.Number, kotlin.Comparable<kotlin.Short!> {
            public constructor Short(/*0*/ p0: kotlin.Short)
            public constructor Short(/*0*/ p0: kotlin.String!)
            private final val value: kotlin.Short
            public open fun byteValue(): kotlin.Byte
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Short!): kotlin.Int
            public open fun doubleValue(): kotlin.Double
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun floatValue(): kotlin.Float
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun intValue(): kotlin.Int
            public open fun longValue(): kotlin.Long
            public open fun shortValue(): kotlin.Short
            public open override /*2*/ fun toString(): kotlin.String!

            private open class ShortCache {
                private constructor ShortCache()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val cache: kotlin.Array<(out) kotlin.Short!>!
            }

            // Static members
            public final val MAX_VALUE: kotlin.Short = 32767.toShort()
            public final val MIN_VALUE: kotlin.Short = -32768.toShort()
            public final val SIZE: kotlin.Int = 16
            public final val TYPE: java.lang.Class<kotlin.Short!>!
            private final val serialVersionUID: kotlin.Long = 7515723908773894738.toLong()
            public open fun compare(/*0*/ p0: kotlin.Short, /*1*/ p1: kotlin.Short): kotlin.Int
            public open fun decode(/*0*/ p0: kotlin.String!): kotlin.Short!
            public open fun parseShort(/*0*/ p0: kotlin.String!): kotlin.Short
            public open fun parseShort(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Short
            public open fun reverseBytes(/*0*/ p0: kotlin.Short): kotlin.Short
            public open fun toString(/*0*/ p0: kotlin.Short): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Short): kotlin.Short!
            public open fun valueOf(/*0*/ p0: kotlin.String!): kotlin.Short!
            public open fun valueOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Short!
        }

        public final class String : java.io.Serializable, kotlin.Comparable<kotlin.String!>, kotlin.CharSequence {
            public constructor String()
            public constructor String(/*0*/ p0: java.lang.StringBuffer!)
            public constructor String(/*0*/ p0: java.lang.StringBuilder!)
            public constructor String(/*0*/ p0: kotlin.ByteArray!)
            public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: java.nio.charset.Charset!)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int)
            public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: java.nio.charset.Charset!)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int)
            public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.String!)
            public constructor String(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.String!)
            public constructor String(/*0*/ p0: kotlin.CharArray!)
            public/*package*/ constructor String(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Boolean)
            public constructor String(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public/*package*/ constructor String(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!)
            public constructor String(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor String(/*0*/ p0: kotlin.String!)
            private final var hash: kotlin.Int
            private final var hash32: kotlin.Int
            private final val value: kotlin.CharArray!
            public open override /*1*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
            public open fun codePointAt(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun codePointBefore(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun codePointCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun compareTo(/*0*/ other: kotlin.String!): kotlin.Int
            public open fun compareToIgnoreCase(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun concat(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun contains(/*0*/ p0: kotlin.CharSequence!): kotlin.Boolean
            public open fun contentEquals(/*0*/ p0: java.lang.StringBuffer!): kotlin.Boolean
            public open fun contentEquals(/*0*/ p0: kotlin.CharSequence!): kotlin.Boolean
            public open fun endsWith(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun equalsIgnoreCase(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun getBytes(): kotlin.ByteArray!
            public open fun getBytes(/*0*/ p0: java.nio.charset.Charset!): kotlin.ByteArray!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getBytes(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.ByteArray!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open fun getBytes(/*0*/ p0: kotlin.String!): kotlin.ByteArray!
            public/*package*/ open fun getChars(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun getChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open fun hash32(): kotlin.Int
            public open override /*3*/ fun hashCode(): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun indexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun indexOfSupplementary(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun intern(): kotlin.String!
            public open fun isEmpty(): kotlin.Boolean
            public open fun lastIndexOf(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun lastIndexOf(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun lastIndexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open fun lastIndexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun lastIndexOfSupplementary(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun length(): kotlin.Int
            public open fun matches(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun offsetByCodePoints(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun regionMatches(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Boolean
            public open fun regionMatches(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Boolean
            public open fun replace(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.String!
            public open fun replace(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.CharSequence!): kotlin.String!
            public open fun replaceAll(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun replaceFirst(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun split(/*0*/ regex: kotlin.String!): kotlin.Array<(out) kotlin.String!>!
            public open fun split(/*0*/ regex: kotlin.String!, /*1*/ limit: kotlin.Int): kotlin.Array<(out) kotlin.String!>!
            public open fun startsWith(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun startsWith(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public open override /*1*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence!
            public open fun substring(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun substring(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            public open fun toCharArray(): kotlin.CharArray!
            public open fun toLowerCase(): kotlin.String!
            public open fun toLowerCase(/*0*/ locale: java.util.Locale!): kotlin.String!
            public open override /*3*/ fun toString(): kotlin.String!
            public open fun toUpperCase(): kotlin.String!
            public open fun toUpperCase(/*0*/ locale: java.util.Locale!): kotlin.String!
            public open fun trim(): kotlin.String!

            private open class CaseInsensitiveComparator : java.util.Comparator<kotlin.String!>, java.io.Serializable {
                private constructor CaseInsensitiveComparator()
                public open override /*1*/ fun compare(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 8575799808933029326.toLong()
            }

            // Static members
            public final val CASE_INSENSITIVE_ORDER: java.util.Comparator<kotlin.String!>!
            private final val HASHING_SEED: kotlin.Int
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            private final val serialVersionUID: kotlin.Long = -6849794470754667710.toLong()
            private open fun checkBounds(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun copyValueOf(/*0*/ p0: kotlin.CharArray!): kotlin.String!
            public open fun copyValueOf(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.String!
            public open fun format(/*0*/ p0: java.util.Locale!, /*1*/ p1: kotlin.String!, /*2*/ vararg p2: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): kotlin.String!
            public open fun format(/*0*/ p0: kotlin.String!, /*1*/ vararg p1: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): kotlin.String!
            public/*package*/ open fun indexOf(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.CharArray!, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.Int): kotlin.Int
            public/*package*/ open fun lastIndexOf(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.CharArray!, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.Int): kotlin.Int
            public open fun valueOf(/*0*/ p0: kotlin.Any!): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Boolean): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Char): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.CharArray!): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Double): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Float): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun valueOf(/*0*/ p0: kotlin.Long): kotlin.String!
        }

        public final class StringBuffer : java.lang.AbstractStringBuilder, java.io.Serializable, kotlin.CharSequence {
            public constructor StringBuffer()
            public constructor StringBuffer(/*0*/ p0: kotlin.CharSequence!)
            public constructor StringBuffer(/*0*/ p0: kotlin.Int)
            public constructor StringBuffer(/*0*/ p0: kotlin.String!)
            public/*package*/ final override /*1*/ /*fake_override*/ var count: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var value: kotlin.CharArray!
            public open override /*1*/ fun append(/*0*/ p0: java.lang.StringBuffer!): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Any!): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Boolean): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Char): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharArray!): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Double): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Float): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Long): java.lang.StringBuffer!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.String!): java.lang.StringBuffer!
            public open override /*1*/ fun appendCodePoint(/*0*/ p0: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun capacity(): kotlin.Int
            public open override /*2*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
            public open override /*1*/ fun codePointAt(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ fun codePointBefore(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ fun codePointCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun delete(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun deleteCharAt(/*0*/ p0: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun ensureCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun ensureCapacityInternal(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun expandCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun getChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun getValue(): kotlin.CharArray!
            public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun indexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open override /*1*/ fun indexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): java.lang.StringBuffer!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): java.lang.StringBuffer!
            public open override /*1*/ fun lastIndexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open override /*1*/ fun lastIndexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*2*/ fun length(): kotlin.Int
            public open override /*1*/ fun offsetByCodePoints(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*1*/ fun replace(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): java.lang.StringBuffer!
            public open override /*1*/ fun reverse(): java.lang.StringBuffer!
            public open override /*1*/ fun setCharAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): kotlin.Unit
            public open override /*1*/ fun setLength(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence!
            public open override /*1*/ fun substring(/*0*/ p0: kotlin.Int): kotlin.String!
            public open override /*1*/ fun substring(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            public open override /*3*/ fun toString(): kotlin.String!
            public open override /*1*/ fun trimToSize(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            public/*package*/ final val serialVersionUID: kotlin.Long = 3388685877147921107.toLong()
        }

        public final class StringBuilder : java.lang.AbstractStringBuilder, java.io.Serializable, kotlin.CharSequence {
            public constructor StringBuilder()
            public constructor StringBuilder(/*0*/ p0: kotlin.CharSequence!)
            public constructor StringBuilder(/*0*/ p0: kotlin.Int)
            public constructor StringBuilder(/*0*/ p0: kotlin.String!)
            public/*package*/ final override /*1*/ /*fake_override*/ var count: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var value: kotlin.CharArray!
            public open override /*1*/ fun append(/*0*/ p0: java.lang.StringBuffer!): java.lang.StringBuilder!
            private open fun append(/*0*/ p0: java.lang.StringBuilder!): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Any!): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Boolean): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Char): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharArray!): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.CharSequence!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Double): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Float): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.Long): java.lang.StringBuilder!
            public open override /*1*/ fun append(/*0*/ p0: kotlin.String!): java.lang.StringBuilder!
            public open override /*1*/ fun appendCodePoint(/*0*/ p0: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ /*fake_override*/ fun capacity(): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
            public open override /*1*/ /*fake_override*/ fun codePointAt(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun codePointBefore(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun codePointCount(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun delete(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun deleteCharAt(/*0*/ p0: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ /*fake_override*/ fun ensureCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun ensureCapacityInternal(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun expandCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun getChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.CharArray!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun getValue(): kotlin.CharArray!
            public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun indexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open override /*1*/ fun indexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.CharSequence!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): java.lang.StringBuilder!
            public open override /*1*/ fun insert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): java.lang.StringBuilder!
            public open override /*1*/ fun lastIndexOf(/*0*/ p0: kotlin.String!): kotlin.Int
            public open override /*1*/ fun lastIndexOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun length(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun offsetByCodePoints(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*1*/ fun replace(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): java.lang.StringBuilder!
            public open override /*1*/ fun reverse(): java.lang.StringBuilder!
            public open override /*1*/ /*fake_override*/ fun setCharAt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Char): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLength(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence
            public open override /*1*/ /*fake_override*/ fun substring(/*0*/ p0: kotlin.Int): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun substring(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
            public open override /*3*/ fun toString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun trimToSize(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 4383685877147921099.toLong()
        }

        java.lang.annotation.Target(value = {ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE}: kotlin.Array<out java.lang.annotation.ElementType>) java.lang.annotation.Retention(value = RetentionPolicy.SOURCE: java.lang.annotation.RetentionPolicy) public final annotation class SuppressWarnings : kotlin.Annotation {
            public constructor SuppressWarnings(/*0*/ vararg value: kotlin.String /*kotlin.Array<out kotlin.String>*/)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun value(): kotlin.Array<kotlin.String>
        }

        public final class System {
            private constructor System()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final var cons: [ERROR : Unresolved java classifier: Console]!
            public final val err: java.io.PrintStream!
            public final val `in`: java.io.InputStream!
            private final var lineSeparator: kotlin.String!
            public final val out: java.io.PrintStream!
            private final var props: java.util.Properties!
            private final var security: [ERROR : Unresolved java classifier: SecurityManager]!
            public open fun arraycopy(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun checkIO(): kotlin.Unit
            private open fun checkKey(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun clearProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun console(): [ERROR : Unresolved java classifier: Console]!
            public open fun currentTimeMillis(): kotlin.Long
            public open fun exit(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun gc(): kotlin.Unit
            public/*package*/ open fun getCallerClass(): java.lang.Class<*>!
            public open fun getProperties(): java.util.Properties!
            public open fun getProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun getSecurityManager(): [ERROR : Unresolved java classifier: SecurityManager]!
            public open fun getenv(): kotlin.(Mutable)Map<kotlin.String!, kotlin.String!>!
            public open fun getenv(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun identityHashCode(/*0*/ p0: kotlin.Any!): kotlin.Int
            public open fun inheritedChannel(): [ERROR : Unresolved java classifier: Channel]!
            private open fun initProperties(/*0*/ p0: java.util.Properties!): java.util.Properties!
            private open fun initializeSystemClass(): kotlin.Unit
            public open fun lineSeparator(): kotlin.String!
            public open fun load(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun loadLibrary(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun mapLibraryName(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun nanoTime(): kotlin.Long
            private open fun registerNatives(): kotlin.Unit
            public open fun runFinalization(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun runFinalizersOnExit(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setErr(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            private open fun setErr0(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open fun setIn(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            private open fun setIn0(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            private open fun setJavaLangAccess(): kotlin.Unit
            public open fun setOut(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            private open fun setOut0(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open fun setProperties(/*0*/ p0: java.util.Properties!): kotlin.Unit
            public open fun setProperty(/*0*/ key: kotlin.String!, /*1*/ value: kotlin.String!): kotlin.String!
            public open fun setSecurityManager(/*0*/ p0: [ERROR : Unresolved java classifier: SecurityManager]!): kotlin.Unit
            private open fun setSecurityManager0(/*0*/ p0: [ERROR : Unresolved java classifier: SecurityManager]!): kotlin.Unit
        }

        public open class Thread : java.lang.Runnable {
            public constructor Thread()
            public /*synthesized*/ constructor Thread(/*0*/ p0: (() -> kotlin.Unit)!)
            public /*synthesized*/ constructor Thread(/*0*/ p0: (() -> kotlin.Unit)!, /*1*/ p1: kotlin.String!)
            public /*synthesized*/ constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: (() -> kotlin.Unit)!)
            public /*synthesized*/ constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: (() -> kotlin.Unit)!, /*2*/ p2: kotlin.String!)
            public /*synthesized*/ constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: (() -> kotlin.Unit)!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Long)
            public constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: java.lang.Runnable!)
            public constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: java.lang.Runnable!, /*2*/ p2: kotlin.String!)
            public constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: java.lang.Runnable!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Long)
            public constructor Thread(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: kotlin.String!)
            public constructor Thread(/*0*/ p0: java.lang.Runnable!)
            public constructor Thread(/*0*/ p0: java.lang.Runnable!, /*1*/ p1: kotlin.String!)
            public constructor Thread(/*0*/ p0: kotlin.String!)
            private final var blocker: [ERROR : Unresolved java classifier: Interruptible]!
            private final val blockerLock: kotlin.Any!
            private final var contextClassLoader: java.lang.ClassLoader!
            private final var daemon: kotlin.Boolean
            private final var eetop: kotlin.Long
            private final var group: [ERROR : Unresolved java classifier: ThreadGroup]!
            public/*package*/ final var inheritableThreadLocals: java.lang.ThreadLocal.ThreadLocalMap!
            private final var inheritedAccessControlContext: [ERROR : Unresolved java classifier: AccessControlContext]!
            private final var name: kotlin.CharArray!
            private final var nativeParkEventPointer: kotlin.Long
            public/*package*/ final var parkBlocker: kotlin.Any!
            private final var priority: kotlin.Int
            private final var single_step: kotlin.Boolean
            private final var stackSize: kotlin.Long
            private final var stillborn: kotlin.Boolean
            private final var target: java.lang.Runnable!
            public/*package*/ final var threadLocals: java.lang.ThreadLocal.ThreadLocalMap!
            private final var threadQ: java.lang.Thread!
            private final var threadStatus: kotlin.Int
            private final var tid: kotlin.Long
            private final var uncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler!
            public/*package*/ open fun blockedOn(/*0*/ p0: [ERROR : Unresolved java classifier: Interruptible]!): kotlin.Unit
            public final fun checkAccess(): kotlin.Unit
            protected/*protected and package*/ open fun clone(): kotlin.Any!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun countStackFrames(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun destroy(): kotlin.Unit
            private open fun dispatchUncaughtException(/*0*/ p0: kotlin.Throwable!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            private open fun exit(): kotlin.Unit
            public open fun getContextClassLoader(): java.lang.ClassLoader!
            public open fun getId(): kotlin.Long
            public final fun getName(): kotlin.String!
            public final fun getPriority(): kotlin.Int
            public open fun getStackTrace(): kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            public open fun getState(): java.lang.Thread.State!
            public final fun getThreadGroup(): [ERROR : Unresolved java classifier: ThreadGroup]!
            public open fun getUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private final /*synthesized*/ fun init(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: (() -> kotlin.Unit)!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Long): kotlin.Unit
            private open fun init(/*0*/ p0: [ERROR : Unresolved java classifier: ThreadGroup]!, /*1*/ p1: java.lang.Runnable!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Long): kotlin.Unit
            public open fun interrupt(): kotlin.Unit
            private open fun interrupt0(): kotlin.Unit
            public final fun isAlive(): kotlin.Boolean
            public final fun isDaemon(): kotlin.Boolean
            public open fun isInterrupted(): kotlin.Boolean
            private open fun isInterrupted(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
            public final fun join(): kotlin.Unit
            public final fun join(/*0*/ p0: kotlin.Long): kotlin.Unit
            public final fun join(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final fun resume(): kotlin.Unit
            private open fun resume0(): kotlin.Unit
            public open override /*1*/ fun run(): kotlin.Unit
            public open fun setContextClassLoader(/*0*/ p0: java.lang.ClassLoader!): kotlin.Unit
            public final fun setDaemon(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public final fun setName(/*0*/ p0: kotlin.String!): kotlin.Unit
            private open fun setNativeName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public final fun setPriority(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun setPriority0(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final /*synthesized*/ fun setUncaughtExceptionHandler(/*0*/ p0: ((java.lang.Thread!, kotlin.Throwable!) -> kotlin.Unit)!): kotlin.Unit
            public open fun setUncaughtExceptionHandler(/*0*/ p0: java.lang.Thread.UncaughtExceptionHandler!): kotlin.Unit
            public open fun start(): kotlin.Unit
            private open fun start0(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final fun stop(): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final fun stop(/*0*/ p0: kotlin.Throwable!): kotlin.Unit
            private open fun stop0(/*0*/ p0: kotlin.Any!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public final fun suspend(): kotlin.Unit
            private open fun suspend0(): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!

            private open class Caches {
                private constructor Caches()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val subclassAudits: [ERROR : Unresolved java classifier: ConcurrentMap<WeakClassKey, Boolean>]!
                public/*package*/ final val subclassAuditsQueue: [ERROR : Unresolved java classifier: ReferenceQueue<Class<?>>]!
            }

            public final enum class State : kotlin.Enum<java.lang.Thread.State!> {
                public enum entry NEW : java.lang.Thread.State {
                    private constructor NEW()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry RUNNABLE : java.lang.Thread.State {
                    private constructor RUNNABLE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry BLOCKED : java.lang.Thread.State {
                    private constructor BLOCKED()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry WAITING : java.lang.Thread.State {
                    private constructor WAITING()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TIMED_WAITING : java.lang.Thread.State {
                    private constructor TIMED_WAITING()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry TERMINATED : java.lang.Thread.State {
                    private constructor TERMINATED()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor State()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.Thread.State!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.lang.Thread.State
                public final /*synthesized*/ fun values(): kotlin.Array<java.lang.Thread.State>
            }

            public trait UncaughtExceptionHandler {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public abstract fun uncaughtException(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Throwable!): kotlin.Unit
            }

            public/*package*/ open class WeakClassKey {
                public/*package*/ constructor WeakClassKey(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: [ERROR : Unresolved java classifier: ReferenceQueue<Class<?>>]!)
                private final val hash: kotlin.Int
                public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun hashCode(): kotlin.Int
            }

            // Static members
            private final val EMPTY_STACK_TRACE: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            public final val MAX_PRIORITY: kotlin.Int = 10
            public final val MIN_PRIORITY: kotlin.Int = 1
            public final val NORM_PRIORITY: kotlin.Int = 5
            private final val SUBCLASS_IMPLEMENTATION_PERMISSION: [ERROR : Unresolved java classifier: RuntimePermission]!
            private final var defaultUncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler!
            private final var threadInitNumber: kotlin.Int
            private final var threadSeqNumber: kotlin.Long
            public final /*synthesized*/ fun UncaughtExceptionHandler(/*0*/ function: (java.lang.Thread!, kotlin.Throwable!) -> kotlin.Unit): java.lang.Thread.UncaughtExceptionHandler
            public open fun activeCount(): kotlin.Int
            private open fun auditSubclass(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            public open fun currentThread(): java.lang.Thread!
            public open fun dumpStack(): kotlin.Unit
            private open fun dumpThreads(/*0*/ p0: kotlin.Array<(out) java.lang.Thread!>!): kotlin.Array<(out) kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!>!
            public open fun enumerate(/*0*/ tarray: kotlin.Array<(out) java.lang.Thread!>!): kotlin.Int
            public open fun getAllStackTraces(): kotlin.(Mutable)Map<java.lang.Thread!, kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!>!
            public open fun getDefaultUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler!
            private open fun getThreads(): kotlin.Array<(out) java.lang.Thread!>!
            public open fun holdsLock(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public open fun interrupted(): kotlin.Boolean
            private open fun isCCLOverridden(/*0*/ p0: java.lang.Class<*>!): kotlin.Boolean
            private open fun nextThreadID(): kotlin.Long
            private open fun nextThreadNum(): kotlin.Int
            public/*package*/ open fun processQueue(/*0*/ p0: [ERROR : Unresolved java classifier: ReferenceQueue<Class<?>>]!, /*1*/ p1: [ERROR : Unresolved java classifier: ConcurrentMap<? extends WeakReference<Class<?>>, ?>]!): kotlin.Unit
            private open fun registerNatives(): kotlin.Unit
            public final /*synthesized*/ fun setDefaultUncaughtExceptionHandler(/*0*/ p0: ((java.lang.Thread!, kotlin.Throwable!) -> kotlin.Unit)!): kotlin.Unit
            public open fun setDefaultUncaughtExceptionHandler(/*0*/ p0: java.lang.Thread.UncaughtExceptionHandler!): kotlin.Unit
            public open fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun sleep(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun yield(): kotlin.Unit
        }

        public open class ThreadLocal</*0*/ T> {
            public constructor ThreadLocal</*0*/ T>()
            private final val threadLocalHashCode: kotlin.Int
            public/*package*/ open fun childValue(/*0*/ p0: T!): T!
            public/*package*/ open fun createMap(/*0*/ p0: java.lang.Thread!, /*1*/ p1: T!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun get(): T!
            public/*package*/ open fun getMap(/*0*/ p0: java.lang.Thread!): java.lang.ThreadLocal.ThreadLocalMap!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ open fun initialValue(): T!
            public open fun remove(): kotlin.Unit
            public open fun set(/*0*/ p0: T!): kotlin.Unit
            private open fun setInitialValue(): T!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            public/*package*/ open class ThreadLocalMap {
                private constructor ThreadLocalMap(/*0*/ p0: java.lang.ThreadLocal.ThreadLocalMap!)
                public/*package*/ constructor ThreadLocalMap(/*0*/ p0: java.lang.ThreadLocal<*>!, /*1*/ p1: kotlin.Any!)
                private final var size: kotlin.Int
                private final var table: kotlin.Array<(out) java.lang.ThreadLocal.ThreadLocalMap.Entry!>!
                private final var threshold: kotlin.Int
                private open fun cleanSomeSlots(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                private open fun expungeStaleEntries(): kotlin.Unit
                private open fun expungeStaleEntry(/*0*/ p0: kotlin.Int): kotlin.Int
                private open fun getEntry(/*0*/ p0: java.lang.ThreadLocal<*>!): java.lang.ThreadLocal.ThreadLocalMap.Entry!
                private open fun getEntryAfterMiss(/*0*/ p0: java.lang.ThreadLocal<*>!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.lang.ThreadLocal.ThreadLocalMap.Entry!): java.lang.ThreadLocal.ThreadLocalMap.Entry!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                private open fun rehash(): kotlin.Unit
                private open fun remove(/*0*/ p0: java.lang.ThreadLocal<*>!): kotlin.Unit
                private open fun replaceStaleEntry(/*0*/ p0: java.lang.ThreadLocal<*>!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
                private open fun resize(): kotlin.Unit
                private open fun set(/*0*/ p0: java.lang.ThreadLocal<*>!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                private open fun setThreshold(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                public/*package*/ open class Entry {
                    public/*package*/ constructor Entry(/*0*/ p0: java.lang.ThreadLocal<*>!, /*1*/ p1: kotlin.Any!)
                    public/*package*/ final var value: kotlin.Any!
                }

                // Static members
                private final val INITIAL_CAPACITY: kotlin.Int = 16
                private open fun nextIndex(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun prevIndex(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            }

            // Static members
            private final val HASH_INCREMENT: kotlin.Int = 1640531527
            private final var nextHashCode: java.util.concurrent.atomic.AtomicInteger!
            public/*package*/ open fun createInheritedMap(/*0*/ p0: java.lang.ThreadLocal.ThreadLocalMap!): java.lang.ThreadLocal.ThreadLocalMap!
            private open fun nextHashCode(): kotlin.Int
        }

        public open class Throwable : java.io.Serializable {
            public constructor Throwable()
            public constructor Throwable(/*0*/ p0: kotlin.String!)
            public constructor Throwable(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            protected/*protected and package*/ constructor Throwable(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean)
            public constructor Throwable(/*0*/ p0: kotlin.Throwable!)
            private final var backtrace: kotlin.Any!
            private final var cause: kotlin.Throwable!
            private final var detailMessage: kotlin.String!
            private final var stackTrace: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            private final var suppressedExceptions: kotlin.(Mutable)List<kotlin.Throwable!>!
            public final fun addSuppressed(/*0*/ p0: kotlin.Throwable!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun fillInStackTrace(): kotlin.Throwable!
            private open fun fillInStackTrace(/*0*/ p0: kotlin.Int): kotlin.Throwable!
            public open fun getCause(): kotlin.Throwable!
            public open fun getLocalizedMessage(): kotlin.String!
            public open fun getMessage(): kotlin.String!
            private open fun getOurStackTrace(): kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            public open fun getStackTrace(): kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            public/*package*/ open fun getStackTraceDepth(): kotlin.Int
            public/*package*/ open fun getStackTraceElement(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: StackTraceElement]!
            public final fun getSuppressed(): kotlin.Array<(out) kotlin.Throwable!>!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun initCause(/*0*/ p0: kotlin.Throwable!): kotlin.Throwable!
            private open fun printEnclosedStackTrace(/*0*/ p0: java.lang.Throwable.PrintStreamOrWriter!, /*1*/ p1: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.(Mutable)Set<kotlin.Throwable!>!): kotlin.Unit
            public open fun printStackTrace(): kotlin.Unit
            public open fun printStackTrace(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open fun printStackTrace(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            private open fun printStackTrace(/*0*/ p0: java.lang.Throwable.PrintStreamOrWriter!): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open fun setStackTrace(/*0*/ p0: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private abstract class PrintStreamOrWriter {
                private constructor PrintStreamOrWriter()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ abstract fun lock(): kotlin.Any!
                public/*package*/ abstract fun println(/*0*/ p0: kotlin.Any!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class SentinelHolder {
                private constructor SentinelHolder()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final val STACK_TRACE_ELEMENT_SENTINEL: [ERROR : Unresolved java classifier: StackTraceElement]!
                public final val STACK_TRACE_SENTINEL: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            }

            private open class WrappedPrintStream : java.lang.Throwable.PrintStreamOrWriter {
                public/*package*/ constructor WrappedPrintStream(/*0*/ p0: java.io.PrintStream!)
                private final val printStream: java.io.PrintStream!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open override /*1*/ fun lock(): kotlin.Any!
                public/*package*/ open override /*1*/ fun println(/*0*/ p0: kotlin.Any!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class WrappedPrintWriter : java.lang.Throwable.PrintStreamOrWriter {
                public/*package*/ constructor WrappedPrintWriter(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!)
                private final val printWriter: [ERROR : Unresolved java classifier: PrintWriter]!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open override /*1*/ fun lock(): kotlin.Any!
                public/*package*/ open override /*1*/ fun println(/*0*/ p0: kotlin.Any!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val CAUSE_CAPTION: kotlin.String = "Caused by: "
            private final val EMPTY_THROWABLE_ARRAY: kotlin.Array<(out) kotlin.Throwable!>!
            private final val NULL_CAUSE_MESSAGE: kotlin.String = "Cannot suppress a null exception."
            private final val SELF_SUPPRESSION_MESSAGE: kotlin.String = "Self-suppression not permitted"
            private final val SUPPRESSED_CAPTION: kotlin.String = "Suppressed: "
            private final val SUPPRESSED_SENTINEL: kotlin.(Mutable)List<kotlin.Throwable!>!
            private final val UNASSIGNED_STACK: kotlin.Array<(out) [ERROR : Unresolved java classifier: StackTraceElement]!>!
            private final val serialVersionUID: kotlin.Long = -3042686055658047285.toLong()
        }

        public open class UnsupportedOperationException : java.lang.RuntimeException {
            public constructor UnsupportedOperationException()
            public constructor UnsupportedOperationException(/*0*/ p0: kotlin.String!)
            public constructor UnsupportedOperationException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor UnsupportedOperationException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -1242599979055084673.toLong()
        }

        public final class Void {
            private constructor Void()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val TYPE: java.lang.Class<java.lang.Void!>!
        }

        package java.lang.annotation {
            public /*synthesized*/ fun Annotation(/*0*/ function: () -> java.lang.Class<out kotlin.Annotation!>!): java.lang.annotation.Annotation

            public trait Annotation {
                public abstract fun annotationType(): java.lang.Class<out kotlin.Annotation!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public open class AnnotationFormatError : java.lang.Error {
                public constructor AnnotationFormatError(/*0*/ p0: kotlin.String!)
                public constructor AnnotationFormatError(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
                public constructor AnnotationFormatError(/*0*/ p0: kotlin.Throwable!)
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
                public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -4256701562333669892.toLong()
            }

            public open class AnnotationTypeMismatchException : java.lang.RuntimeException {
                public constructor AnnotationTypeMismatchException(/*0*/ p0: java.lang.reflect.Method!, /*1*/ p1: kotlin.String!)
                private final val element: java.lang.reflect.Method!
                private final val foundType: kotlin.String!
                public open fun element(): java.lang.reflect.Method!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open fun foundType(): kotlin.String!
                public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
                public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 8125925355765570191.toLong()
            }

            java.lang.annotation.Documented() java.lang.annotation.Retention(value = RetentionPolicy.RUNTIME: java.lang.annotation.RetentionPolicy) java.lang.annotation.Target(value = {ElementType.ANNOTATION_TYPE}: kotlin.Array<out java.lang.annotation.ElementType>) public final annotation class Documented : kotlin.Annotation {
                public constructor Documented()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public final enum class ElementType : kotlin.Enum<java.lang.annotation.ElementType!> {
                public enum entry TYPE : java.lang.annotation.ElementType {
                    private constructor TYPE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry FIELD : java.lang.annotation.ElementType {
                    private constructor FIELD()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry METHOD : java.lang.annotation.ElementType {
                    private constructor METHOD()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry PARAMETER : java.lang.annotation.ElementType {
                    private constructor PARAMETER()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CONSTRUCTOR : java.lang.annotation.ElementType {
                    private constructor CONSTRUCTOR()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry LOCAL_VARIABLE : java.lang.annotation.ElementType {
                    private constructor LOCAL_VARIABLE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry ANNOTATION_TYPE : java.lang.annotation.ElementType {
                    private constructor ANNOTATION_TYPE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry PACKAGE : java.lang.annotation.ElementType {
                    private constructor PACKAGE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor ElementType()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.ElementType!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.lang.annotation.ElementType
                public final /*synthesized*/ fun values(): kotlin.Array<java.lang.annotation.ElementType>
            }

            public open class IncompleteAnnotationException : java.lang.RuntimeException {
                public constructor IncompleteAnnotationException(/*0*/ p0: java.lang.Class<out kotlin.Annotation!>!, /*1*/ p1: kotlin.String!)
                private final var annotationType: java.lang.Class<*>!
                private final var elementName: kotlin.String!
                public open fun annotationType(): java.lang.Class<out kotlin.Annotation!>!
                public open fun elementName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
                public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 8445097402741811912.toLong()
            }

            java.lang.annotation.Documented() java.lang.annotation.Retention(value = RetentionPolicy.RUNTIME: java.lang.annotation.RetentionPolicy) java.lang.annotation.Target(value = {ElementType.ANNOTATION_TYPE}: kotlin.Array<out java.lang.annotation.ElementType>) public final annotation class Inherited : kotlin.Annotation {
                public constructor Inherited()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            java.lang.annotation.Documented() java.lang.annotation.Retention(value = RetentionPolicy.RUNTIME: java.lang.annotation.RetentionPolicy) java.lang.annotation.Target(value = {ElementType.ANNOTATION_TYPE}: kotlin.Array<out java.lang.annotation.ElementType>) public final annotation class Retention : kotlin.Annotation {
                public constructor Retention(/*0*/ value: java.lang.annotation.RetentionPolicy)
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public abstract fun value(): java.lang.annotation.RetentionPolicy
            }

            public final enum class RetentionPolicy : kotlin.Enum<java.lang.annotation.RetentionPolicy!> {
                public enum entry SOURCE : java.lang.annotation.RetentionPolicy {
                    private constructor SOURCE()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.RetentionPolicy!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry CLASS : java.lang.annotation.RetentionPolicy {
                    private constructor CLASS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.RetentionPolicy!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry RUNTIME : java.lang.annotation.RetentionPolicy {
                    private constructor RUNTIME()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.RetentionPolicy!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor RetentionPolicy()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.lang.annotation.RetentionPolicy!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.lang.annotation.RetentionPolicy
                public final /*synthesized*/ fun values(): kotlin.Array<java.lang.annotation.RetentionPolicy>
            }

            java.lang.annotation.Documented() java.lang.annotation.Retention(value = RetentionPolicy.RUNTIME: java.lang.annotation.RetentionPolicy) java.lang.annotation.Target(value = {ElementType.ANNOTATION_TYPE}: kotlin.Array<out java.lang.annotation.ElementType>) public final annotation class Target : kotlin.Annotation {
                public constructor Target(/*0*/ vararg value: java.lang.annotation.ElementType /*kotlin.Array<out java.lang.annotation.ElementType>*/)
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public abstract fun value(): kotlin.Array<java.lang.annotation.ElementType>
            }
        }

        package java.lang.reflect {
            public /*synthesized*/ fun GenericDeclaration(/*0*/ function: () -> kotlin.Array<(out) [ERROR : Unresolved java classifier: TypeVariable<?>]!>!): java.lang.reflect.GenericDeclaration

            public open class AccessibleObject : java.lang.reflect.AnnotatedElement {
                protected/*protected and package*/ constructor AccessibleObject()
                public/*package*/ final var override: kotlin.Boolean
                public/*package*/ final var securityCheckCache: kotlin.Any!
                public/*package*/ open fun checkAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun </*0*/ T : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<T!>!): T!
                public open override /*1*/ fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open fun isAccessible(): kotlin.Boolean
                public open override /*1*/ fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
                public open fun setAccessible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public/*package*/ open fun slowCheckMemberAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int, /*4*/ p4: java.lang.Class<*>!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val ACCESS_PERMISSION: [ERROR : Unresolved java classifier: Permission]!
                public/*package*/ final val reflectionFactory: [ERROR : Unresolved java classifier: ReflectionFactory]!
                public open fun setAccessible(/*0*/ array: kotlin.Array<(out) java.lang.reflect.AccessibleObject!>!, /*1*/ flag: kotlin.Boolean): kotlin.Unit
                private open fun setAccessible0(/*0*/ p0: java.lang.reflect.AccessibleObject!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            }

            public trait AnnotatedElement {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public abstract fun </*0*/ T : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<T!>!): T!
                public abstract fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public abstract fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public final class Array {
                private constructor Array()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public open fun get(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Any!
                public open fun getBoolean(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                public open fun getByte(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Byte
                public open fun getChar(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Char
                public open fun getDouble(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Double
                public open fun getFloat(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Float
                public open fun getInt(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Int
                public open fun getLength(/*0*/ p0: kotlin.Any!): kotlin.Int
                public open fun getLong(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Long
                public open fun getShort(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Short
                private open fun multiNewArray(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.IntArray!): kotlin.Any!
                private open fun newArray(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.Int): kotlin.Any!
                public open fun newInstance(/*0*/ componentType: java.lang.Class<*>!, /*1*/ length: kotlin.Int): kotlin.Any!
                public open fun newInstance(/*0*/ componentType: java.lang.Class<*>!, /*1*/ vararg dimensions: kotlin.Int /*kotlin.IntArray!*/): kotlin.Any!
                public open fun set(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Any!): kotlin.Unit
                public open fun setBoolean(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): kotlin.Unit
                public open fun setByte(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Byte): kotlin.Unit
                public open fun setChar(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Char): kotlin.Unit
                public open fun setDouble(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Double): kotlin.Unit
                public open fun setFloat(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Float): kotlin.Unit
                public open fun setInt(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open fun setLong(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Long): kotlin.Unit
                public open fun setShort(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Short): kotlin.Unit
            }

            public final class Constructor</*0*/ T> : java.lang.reflect.AccessibleObject, java.lang.reflect.GenericDeclaration, java.lang.reflect.Member {
                public/*package*/ constructor Constructor</*0*/ T>(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: kotlin.Array<(out) java.lang.Class<*>!>!, /*2*/ p2: kotlin.Array<(out) java.lang.Class<*>!>!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.String!, /*6*/ p6: kotlin.ByteArray!, /*7*/ p7: kotlin.ByteArray!)
                private final var annotations: kotlin.ByteArray!
                private final var clazz: java.lang.Class<T!>!
                private final var constructorAccessor: [ERROR : Unresolved java classifier: ConstructorAccessor]!
                private final var declaredAnnotations: kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                private final var exceptionTypes: kotlin.Array<(out) java.lang.Class<*>!>!
                private final var genericInfo: [ERROR : Unresolved java classifier: ConstructorRepository]!
                private final var modifiers: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var override: kotlin.Boolean
                private final var parameterAnnotations: kotlin.ByteArray!
                private final var parameterTypes: kotlin.Array<(out) java.lang.Class<*>!>!
                private final var root: java.lang.reflect.Constructor<T!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var securityCheckCache: kotlin.Any!
                private final var signature: kotlin.String!
                private final var slot: kotlin.Int
                private open fun acquireConstructorAccessor(): [ERROR : Unresolved java classifier: ConstructorAccessor]!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int): kotlin.Unit
                public/*package*/ open fun copy(): java.lang.reflect.Constructor<T!>!
                private open fun declaredAnnotations(): kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun </*0*/ T : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<T!>!): T!
                public open override /*1*/ /*fake_override*/ fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public/*package*/ open fun getConstructorAccessor(): [ERROR : Unresolved java classifier: ConstructorAccessor]!
                public open override /*1*/ fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ fun getDeclaringClass(): java.lang.Class<T!>!
                public open fun getExceptionTypes(): kotlin.Array<(out) java.lang.Class<*>!>!
                private open fun getFactory(): [ERROR : Unresolved java classifier: GenericsFactory]!
                public open fun getGenericExceptionTypes(): kotlin.Array<(out) java.lang.reflect.Type!>!
                private open fun getGenericInfo(): [ERROR : Unresolved java classifier: ConstructorRepository]!
                public open fun getGenericParameterTypes(): kotlin.Array<(out) java.lang.reflect.Type!>!
                public open override /*1*/ fun getModifiers(): kotlin.Int
                public open override /*1*/ fun getName(): kotlin.String!
                public open fun getParameterAnnotations(): kotlin.Array<(out) kotlin.Array<(out) kotlin.Annotation!>!>!
                public open fun getParameterTypes(): kotlin.Array<(out) java.lang.Class<*>!>!
                public/*package*/ open fun getRawAnnotations(): kotlin.ByteArray!
                public/*package*/ open fun getRawParameterAnnotations(): kotlin.ByteArray!
                public/*package*/ open fun getSignature(): kotlin.String!
                public/*package*/ open fun getSlot(): kotlin.Int
                public open override /*1*/ fun getTypeParameters(): kotlin.Array<(out) [ERROR : Unresolved java classifier: TypeVariable<Constructor<T>>]!>!
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isAccessible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
                public open override /*1*/ fun isSynthetic(): kotlin.Boolean
                public open fun isVarArgs(): kotlin.Boolean
                public open fun newInstance(/*0*/ vararg p0: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): T!
                public open override /*1*/ /*fake_override*/ fun setAccessible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public/*package*/ open fun setConstructorAccessor(/*0*/ p0: [ERROR : Unresolved java classifier: ConstructorAccessor]!): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun slowCheckMemberAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int, /*4*/ p4: java.lang.Class<*>!): kotlin.Unit
                public open fun toGenericString(): kotlin.String!
                public open override /*3*/ fun toString(): kotlin.String!
            }

            public final class Field : java.lang.reflect.AccessibleObject, java.lang.reflect.Member {
                public/*package*/ constructor Field(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.lang.Class<*>!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.String!, /*6*/ p6: kotlin.ByteArray!)
                private final var annotations: kotlin.ByteArray!
                private final var clazz: java.lang.Class<*>!
                private final var declaredAnnotations: kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                private final var fieldAccessor: [ERROR : Unresolved java classifier: FieldAccessor]!
                private final var genericInfo: [ERROR : Unresolved java classifier: FieldRepository]!
                private final var modifiers: kotlin.Int
                private final var name: kotlin.String!
                public/*package*/ final override /*1*/ /*fake_override*/ var override: kotlin.Boolean
                private final var overrideFieldAccessor: [ERROR : Unresolved java classifier: FieldAccessor]!
                private final var root: java.lang.reflect.Field!
                public/*package*/ final override /*1*/ /*fake_override*/ var securityCheckCache: kotlin.Any!
                private final var signature: kotlin.String!
                private final var slot: kotlin.Int
                private final var type: java.lang.Class<*>!
                private open fun acquireFieldAccessor(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: FieldAccessor]!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int): kotlin.Unit
                public/*package*/ open fun copy(): java.lang.reflect.Field!
                private open fun declaredAnnotations(): kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                private open fun doSecurityCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open fun get(/*0*/ p0: kotlin.Any!): kotlin.Any!
                public open override /*1*/ fun </*0*/ T : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<T!>!): T!
                public open override /*1*/ /*fake_override*/ fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open fun getBoolean(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public open fun getByte(/*0*/ p0: kotlin.Any!): kotlin.Byte
                public open fun getChar(/*0*/ p0: kotlin.Any!): kotlin.Char
                public open override /*1*/ fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ fun getDeclaringClass(): java.lang.Class<*>!
                public open fun getDouble(/*0*/ p0: kotlin.Any!): kotlin.Double
                private open fun getFactory(): [ERROR : Unresolved java classifier: GenericsFactory]!
                private open fun getFieldAccessor(/*0*/ p0: kotlin.Any!): [ERROR : Unresolved java classifier: FieldAccessor]!
                private open fun getFieldAccessor(/*0*/ p0: kotlin.Boolean): [ERROR : Unresolved java classifier: FieldAccessor]!
                public open fun getFloat(/*0*/ p0: kotlin.Any!): kotlin.Float
                private open fun getGenericInfo(): [ERROR : Unresolved java classifier: FieldRepository]!
                private open fun getGenericSignature(): kotlin.String!
                public open fun getGenericType(): java.lang.reflect.Type!
                public open fun getInt(/*0*/ p0: kotlin.Any!): kotlin.Int
                public open fun getLong(/*0*/ p0: kotlin.Any!): kotlin.Long
                public open override /*1*/ fun getModifiers(): kotlin.Int
                public open override /*1*/ fun getName(): kotlin.String!
                public open fun getShort(/*0*/ p0: kotlin.Any!): kotlin.Short
                public open fun getType(): java.lang.Class<*>!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isAccessible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
                public open fun isEnumConstant(): kotlin.Boolean
                public open override /*1*/ fun isSynthetic(): kotlin.Boolean
                public open fun set(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun setAccessible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public open fun setBoolean(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                public open fun setByte(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Byte): kotlin.Unit
                public open fun setChar(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Char): kotlin.Unit
                public open fun setDouble(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Double): kotlin.Unit
                private open fun setFieldAccessor(/*0*/ p0: [ERROR : Unresolved java classifier: FieldAccessor]!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                public open fun setFloat(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Float): kotlin.Unit
                public open fun setInt(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open fun setLong(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public open fun setShort(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Short): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun slowCheckMemberAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int, /*4*/ p4: java.lang.Class<*>!): kotlin.Unit
                public open fun toGenericString(): kotlin.String!
                public open override /*2*/ fun toString(): kotlin.String!

                // Static members
                public/*package*/ open fun getTypeName(/*0*/ p0: java.lang.Class<*>!): kotlin.String!
            }

            public trait GenericDeclaration {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public abstract fun getTypeParameters(): kotlin.Array<(out) [ERROR : Unresolved java classifier: TypeVariable<?>]!>!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public trait Member {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public abstract fun getDeclaringClass(): java.lang.Class<*>!
                public abstract fun getModifiers(): kotlin.Int
                public abstract fun getName(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract fun isSynthetic(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final val DECLARED: kotlin.Int = 1
                public final val PUBLIC: kotlin.Int = 0
            }

            public final class Method : java.lang.reflect.AccessibleObject, java.lang.reflect.GenericDeclaration, java.lang.reflect.Member {
                public/*package*/ constructor Method(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Array<(out) java.lang.Class<*>!>!, /*3*/ p3: java.lang.Class<*>!, /*4*/ p4: kotlin.Array<(out) java.lang.Class<*>!>!, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.Int, /*7*/ p7: kotlin.String!, /*8*/ p8: kotlin.ByteArray!, /*9*/ p9: kotlin.ByteArray!, /*10*/ p10: kotlin.ByteArray!)
                private final var annotationDefault: kotlin.ByteArray!
                private final var annotations: kotlin.ByteArray!
                private final var clazz: java.lang.Class<*>!
                private final var declaredAnnotations: kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                private final var exceptionTypes: kotlin.Array<(out) java.lang.Class<*>!>!
                private final var genericInfo: [ERROR : Unresolved java classifier: MethodRepository]!
                private final var methodAccessor: [ERROR : Unresolved java classifier: MethodAccessor]!
                private final var modifiers: kotlin.Int
                private final var name: kotlin.String!
                public/*package*/ final override /*1*/ /*fake_override*/ var override: kotlin.Boolean
                private final var parameterAnnotations: kotlin.ByteArray!
                private final var parameterTypes: kotlin.Array<(out) java.lang.Class<*>!>!
                private final var returnType: java.lang.Class<*>!
                private final var root: java.lang.reflect.Method!
                public/*package*/ final override /*1*/ /*fake_override*/ var securityCheckCache: kotlin.Any!
                private final var signature: kotlin.String!
                private final var slot: kotlin.Int
                private open fun acquireMethodAccessor(): [ERROR : Unresolved java classifier: MethodAccessor]!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int): kotlin.Unit
                public/*package*/ open fun copy(): java.lang.reflect.Method!
                private open fun declaredAnnotations(): kotlin.(Mutable)Map<java.lang.Class<out kotlin.Annotation!>!, kotlin.Annotation!>!
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun </*0*/ T : kotlin.Annotation!> getAnnotation(/*0*/ annotationClass: java.lang.Class<T!>!): T!
                public open override /*1*/ /*fake_override*/ fun getAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ fun getDeclaredAnnotations(): kotlin.Array<(out) kotlin.Annotation!>!
                public open override /*1*/ fun getDeclaringClass(): java.lang.Class<*>!
                public open fun getDefaultValue(): kotlin.Any!
                public open fun getExceptionTypes(): kotlin.Array<(out) java.lang.Class<*>!>!
                private open fun getFactory(): [ERROR : Unresolved java classifier: GenericsFactory]!
                public open fun getGenericExceptionTypes(): kotlin.Array<(out) java.lang.reflect.Type!>!
                private open fun getGenericInfo(): [ERROR : Unresolved java classifier: MethodRepository]!
                public open fun getGenericParameterTypes(): kotlin.Array<(out) java.lang.reflect.Type!>!
                public open fun getGenericReturnType(): java.lang.reflect.Type!
                private open fun getGenericSignature(): kotlin.String!
                public/*package*/ open fun getMethodAccessor(): [ERROR : Unresolved java classifier: MethodAccessor]!
                public open override /*1*/ fun getModifiers(): kotlin.Int
                public open override /*1*/ fun getName(): kotlin.String!
                public open fun getParameterAnnotations(): kotlin.Array<(out) kotlin.Array<(out) kotlin.Annotation!>!>!
                public open fun getParameterTypes(): kotlin.Array<(out) java.lang.Class<*>!>!
                public open fun getReturnType(): java.lang.Class<*>!
                public open override /*1*/ fun getTypeParameters(): kotlin.Array<(out) [ERROR : Unresolved java classifier: TypeVariable<Method>]!>!
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open fun invoke(/*0*/ p0: kotlin.Any!, /*1*/ vararg p1: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun isAccessible(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isAnnotationPresent(/*0*/ annotationClass: java.lang.Class<out kotlin.Annotation!>!): kotlin.Boolean
                public open fun isBridge(): kotlin.Boolean
                public open override /*1*/ fun isSynthetic(): kotlin.Boolean
                public open fun isVarArgs(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun setAccessible(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                public/*package*/ open fun setMethodAccessor(/*0*/ p0: [ERROR : Unresolved java classifier: MethodAccessor]!): kotlin.Unit
                public/*package*/ open override /*1*/ /*fake_override*/ fun slowCheckMemberAccess(/*0*/ p0: java.lang.Class<*>!, /*1*/ p1: java.lang.Class<*>!, /*2*/ p2: kotlin.Any!, /*3*/ p3: kotlin.Int, /*4*/ p4: java.lang.Class<*>!): kotlin.Unit
                public open fun toGenericString(): kotlin.String!
                public open override /*3*/ fun toString(): kotlin.String!
            }

            public trait Type {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }
        }
    }

    package java.net {

        public open class ConnectException : java.net.SocketException {
            public constructor ConnectException()
            public constructor ConnectException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 3831404271622369215.toLong()
        }

        public final class DatagramPacket {
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int)
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: SocketAddress]!)
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.net.InetAddress!, /*3*/ p3: kotlin.Int)
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: [ERROR : Unresolved java classifier: SocketAddress]!)
            public constructor DatagramPacket(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: java.net.InetAddress!, /*4*/ p4: kotlin.Int)
            public/*package*/ final var address: java.net.InetAddress!
            public/*package*/ final var buf: kotlin.ByteArray!
            public/*package*/ final var bufLength: kotlin.Int
            public/*package*/ final var length: kotlin.Int
            public/*package*/ final var offset: kotlin.Int
            public/*package*/ final var port: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getAddress(): java.net.InetAddress!
            public open fun getData(): kotlin.ByteArray!
            public open fun getLength(): kotlin.Int
            public open fun getOffset(): kotlin.Int
            public open fun getPort(): kotlin.Int
            public open fun getSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun setAddress(/*0*/ p0: java.net.InetAddress!): kotlin.Unit
            public open fun setData(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open fun setData(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun setLength(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setPort(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setSocketAddress(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private open fun init(): kotlin.Unit
        }

        public open class DatagramSocket : java.io.Closeable {
            public constructor DatagramSocket()
            protected/*protected and package*/ constructor DatagramSocket(/*0*/ p0: [ERROR : Unresolved java classifier: DatagramSocketImpl]!)
            public constructor DatagramSocket(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!)
            public constructor DatagramSocket(/*0*/ p0: kotlin.Int)
            public constructor DatagramSocket(/*0*/ p0: kotlin.Int, /*1*/ p1: java.net.InetAddress!)
            private final var bound: kotlin.Boolean
            private final var closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            public/*package*/ final var connectState: kotlin.Int
            public/*package*/ final var connectedAddress: java.net.InetAddress!
            public/*package*/ final var connectedPort: kotlin.Int
            private final var created: kotlin.Boolean
            public/*package*/ final var impl: [ERROR : Unresolved java classifier: DatagramSocketImpl]!
            public/*package*/ final var oldImpl: kotlin.Boolean
            public open fun bind(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            public/*package*/ open fun checkAddress(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.String!): kotlin.Unit
            private open fun checkOldImpl(): kotlin.Unit
            public open override /*1*/ fun close(): kotlin.Unit
            public open fun connect(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            public open fun connect(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int): kotlin.Unit
            private open fun connectInternal(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open fun createImpl(): kotlin.Unit
            public open fun disconnect(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getBroadcast(): kotlin.Boolean
            public open fun getChannel(): [ERROR : Unresolved java classifier: DatagramChannel]!
            public/*package*/ open fun getImpl(): [ERROR : Unresolved java classifier: DatagramSocketImpl]!
            public open fun getInetAddress(): java.net.InetAddress!
            public open fun getLocalAddress(): java.net.InetAddress!
            public open fun getLocalPort(): kotlin.Int
            public open fun getLocalSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open fun getPort(): kotlin.Int
            public open fun getReceiveBufferSize(): kotlin.Int
            public open fun getRemoteSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open fun getReuseAddress(): kotlin.Boolean
            public open fun getSendBufferSize(): kotlin.Int
            public open fun getSoTimeout(): kotlin.Int
            public open fun getTrafficClass(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun isBound(): kotlin.Boolean
            public open fun isClosed(): kotlin.Boolean
            public open fun isConnected(): kotlin.Boolean
            public open fun receive(/*0*/ p0: java.net.DatagramPacket!): kotlin.Unit
            public open fun send(/*0*/ p0: java.net.DatagramPacket!): kotlin.Unit
            public open fun setBroadcast(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setReceiveBufferSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setReuseAddress(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setSendBufferSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setSoTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setTrafficClass(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val ST_CONNECTED: kotlin.Int = 1
            public/*package*/ final val ST_CONNECTED_NO_IMPL: kotlin.Int = 2
            public/*package*/ final val ST_NOT_CONNECTED: kotlin.Int = 0
            public/*package*/ final var factory: [ERROR : Unresolved java classifier: DatagramSocketImplFactory]!
            public/*package*/ final var implClass: java.lang.Class<*>!
            public open fun setDatagramSocketImplFactory(/*0*/ p0: [ERROR : Unresolved java classifier: DatagramSocketImplFactory]!): kotlin.Unit
        }

        public open class InetAddress : java.io.Serializable {
            public/*package*/ constructor InetAddress()
            public/*package*/ final var address: kotlin.Int
            private final var canonicalHostName: kotlin.String!
            public/*package*/ final var family: kotlin.Int
            public/*package*/ final var hostName: kotlin.String!
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun getAddress(): kotlin.ByteArray!
            public open fun getCanonicalHostName(): kotlin.String!
            public open fun getHostAddress(): kotlin.String!
            public open fun getHostName(): kotlin.String!
            public/*package*/ open fun getHostName(/*0*/ p0: kotlin.Boolean): kotlin.String!
            public open override /*1*/ fun hashCode(): kotlin.Int
            public open fun isAnyLocalAddress(): kotlin.Boolean
            public open fun isLinkLocalAddress(): kotlin.Boolean
            public open fun isLoopbackAddress(): kotlin.Boolean
            public open fun isMCGlobal(): kotlin.Boolean
            public open fun isMCLinkLocal(): kotlin.Boolean
            public open fun isMCNodeLocal(): kotlin.Boolean
            public open fun isMCOrgLocal(): kotlin.Boolean
            public open fun isMCSiteLocal(): kotlin.Boolean
            public open fun isMulticastAddress(): kotlin.Boolean
            public open fun isReachable(/*0*/ p0: [ERROR : Unresolved java classifier: NetworkInterface]!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
            public open fun isReachable(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isSiteLocalAddress(): kotlin.Boolean
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            private open fun readObjectNoData(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            private open fun readResolve(): kotlin.Any!
            public open override /*1*/ fun toString(): kotlin.String!

            public/*package*/ final class Cache {
                public constructor Cache(/*0*/ p0: java.net.InetAddress.Cache.Type!)
                private final var cache: [ERROR : Unresolved java classifier: LinkedHashMap<String, CacheEntry>]!
                private final var type: java.net.InetAddress.Cache.Type!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open fun get(/*0*/ p0: kotlin.String!): java.net.InetAddress.CacheEntry!
                private open fun getPolicy(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open fun put(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) java.net.InetAddress!>!): java.net.InetAddress.Cache!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                public/*package*/ final enum class Type : kotlin.Enum<java.net.InetAddress.Cache.Type!> {
                    public enum entry Positive : java.net.InetAddress.Cache.Type {
                        private constructor Positive()
                        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.net.InetAddress.Cache.Type!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    }

                    public enum entry Negative : java.net.InetAddress.Cache.Type {
                        private constructor Negative()
                        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.net.InetAddress.Cache.Type!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    }

                    private constructor Type()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.net.InetAddress.Cache.Type!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                    // Static members
                    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.net.InetAddress.Cache.Type
                    public final /*synthesized*/ fun values(): kotlin.Array<java.net.InetAddress.Cache.Type>
                }
            }

            public/*package*/ final class CacheEntry {
                public/*package*/ constructor CacheEntry(/*0*/ p0: kotlin.Array<(out) java.net.InetAddress!>!, /*1*/ p1: kotlin.Long)
                public/*package*/ final var addresses: kotlin.Array<(out) java.net.InetAddress!>!
                public/*package*/ final var expiration: kotlin.Long
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            public/*package*/ final val IPv4: kotlin.Int = 1
            public/*package*/ final val IPv6: kotlin.Int = 2
            private final var addressCache: java.net.InetAddress.Cache!
            private final var addressCacheInit: kotlin.Boolean
            private final val cacheLock: kotlin.Any!
            private final var cacheTime: kotlin.Long
            private final var cachedLocalHost: java.net.InetAddress!
            public/*package*/ final var impl: java.net.InetAddressImpl!
            private final val lookupTable: java.util.HashMap<kotlin.String!, java.lang.Void!>!
            private final val maxCacheTime: kotlin.Long = 5000.toLong()
            private final var nameServices: kotlin.(Mutable)List<[ERROR : Unresolved java classifier: NameService]!>!
            private final var negativeCache: java.net.InetAddress.Cache!
            public/*package*/ final var preferIPv6Address: kotlin.Boolean
            private final val serialVersionUID: kotlin.Long = 3286316764910316507.toLong()
            public/*package*/ final var unknown_array: kotlin.Array<(out) java.net.InetAddress!>!
            public/*package*/ open fun anyLocalAddress(): java.net.InetAddress!
            private open fun cacheAddresses(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) java.net.InetAddress!>!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            private open fun cacheInitIfNeeded(): kotlin.Unit
            private open fun checkLookupTable(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.net.InetAddress!>!
            private open fun checkNumericZone(/*0*/ p0: kotlin.String!): kotlin.Int
            private open fun createNSProvider(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: NameService]!
            private open fun getAddressesFromNameService(/*0*/ p0: kotlin.String!, /*1*/ p1: java.net.InetAddress!): kotlin.Array<(out) java.net.InetAddress!>!
            public open fun getAllByName(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.net.InetAddress!>!
            private open fun getAllByName(/*0*/ p0: kotlin.String!, /*1*/ p1: java.net.InetAddress!): kotlin.Array<(out) java.net.InetAddress!>!
            private open fun getAllByName0(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.net.InetAddress!>!
            private open fun getAllByName0(/*0*/ p0: kotlin.String!, /*1*/ p1: java.net.InetAddress!, /*2*/ p2: kotlin.Boolean): kotlin.Array<(out) java.net.InetAddress!>!
            public/*package*/ open fun getAllByName0(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Array<(out) java.net.InetAddress!>!
            public open fun getByAddress(/*0*/ p0: kotlin.ByteArray!): java.net.InetAddress!
            public open fun getByAddress(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!): java.net.InetAddress!
            public open fun getByName(/*0*/ p0: kotlin.String!): java.net.InetAddress!
            private open fun getByName(/*0*/ p0: kotlin.String!, /*1*/ p1: java.net.InetAddress!): java.net.InetAddress!
            private open fun getCachedAddresses(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.net.InetAddress!>!
            private open fun getHostFromNameService(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Boolean): kotlin.String!
            public open fun getLocalHost(): java.net.InetAddress!
            public open fun getLoopbackAddress(): java.net.InetAddress!
            private open fun init(): kotlin.Unit
            public/*package*/ open fun loadImpl(/*0*/ p0: kotlin.String!): java.net.InetAddressImpl!
            private open fun updateLookupTable(/*0*/ p0: kotlin.String!): kotlin.Unit
        }

        public/*package*/ trait InetAddressImpl {
            public abstract fun anyLocalAddress(): java.net.InetAddress!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getHostByAddr(/*0*/ p0: kotlin.ByteArray!): kotlin.String!
            public abstract fun getLocalHostName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun isReachable(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: NetworkInterface]!, /*3*/ p3: kotlin.Int): kotlin.Boolean
            public abstract fun lookupAllHostAddr(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.net.InetAddress!>!
            public abstract fun loopbackAddress(): java.net.InetAddress!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class MalformedURLException : java.io.IOException {
            public constructor MalformedURLException()
            public constructor MalformedURLException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -182787522200415866.toLong()
        }

        public open class ServerSocket : java.io.Closeable {
            public constructor ServerSocket()
            public/*package*/ constructor ServerSocket(/*0*/ p0: [ERROR : Unresolved java classifier: SocketImpl]!)
            public constructor ServerSocket(/*0*/ p0: kotlin.Int)
            public constructor ServerSocket(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int)
            public constructor ServerSocket(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: java.net.InetAddress!)
            private final var bound: kotlin.Boolean
            private final var closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            private final var created: kotlin.Boolean
            private final var impl: [ERROR : Unresolved java classifier: SocketImpl]!
            private final var oldImpl: kotlin.Boolean
            public open fun accept(): java.net.Socket!
            public open fun bind(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            public open fun bind(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            private open fun checkOldImpl(): kotlin.Unit
            public open override /*1*/ fun close(): kotlin.Unit
            public/*package*/ open fun createImpl(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getChannel(): [ERROR : Unresolved java classifier: ServerSocketChannel]!
            public/*package*/ open fun getImpl(): [ERROR : Unresolved java classifier: SocketImpl]!
            public open fun getInetAddress(): java.net.InetAddress!
            public open fun getLocalPort(): kotlin.Int
            public open fun getLocalSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open fun getReceiveBufferSize(): kotlin.Int
            public open fun getReuseAddress(): kotlin.Boolean
            public open fun getSoTimeout(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ final fun implAccept(/*0*/ p0: java.net.Socket!): kotlin.Unit
            public open fun isBound(): kotlin.Boolean
            public open fun isClosed(): kotlin.Boolean
            public/*package*/ open fun setBound(): kotlin.Unit
            public/*package*/ open fun setCreated(): kotlin.Unit
            private open fun setImpl(): kotlin.Unit
            public open fun setPerformancePreferences(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun setReceiveBufferSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setReuseAddress(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setSoTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!

            // Static members
            private final var factory: [ERROR : Unresolved java classifier: SocketImplFactory]!
            public open fun setSocketFactory(/*0*/ p0: [ERROR : Unresolved java classifier: SocketImplFactory]!): kotlin.Unit
        }

        public open class Socket : java.io.Closeable {
            public constructor Socket()
            public constructor Socket(/*0*/ p0: [ERROR : Unresolved java classifier: Proxy]!)
            private constructor Socket(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!, /*1*/ p1: [ERROR : Unresolved java classifier: SocketAddress]!, /*2*/ p2: kotlin.Boolean)
            protected/*protected and package*/ constructor Socket(/*0*/ p0: [ERROR : Unresolved java classifier: SocketImpl]!)
            public constructor Socket(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int)
            public constructor Socket(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.net.InetAddress!, /*3*/ p3: kotlin.Int)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Socket(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean)
            public constructor Socket(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int)
            public constructor Socket(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.net.InetAddress!, /*3*/ p3: kotlin.Int)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Socket(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean)
            private final var bound: kotlin.Boolean
            private final var closeLock: kotlin.Any!
            private final var closed: kotlin.Boolean
            private final var connected: kotlin.Boolean
            private final var created: kotlin.Boolean
            public/*package*/ final var impl: [ERROR : Unresolved java classifier: SocketImpl]!
            private final var oldImpl: kotlin.Boolean
            private final var shutIn: kotlin.Boolean
            private final var shutOut: kotlin.Boolean
            public open fun bind(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            private open fun checkAddress(/*0*/ p0: java.net.InetAddress!, /*1*/ p1: kotlin.String!): kotlin.Unit
            private open fun checkOldImpl(): kotlin.Unit
            public open override /*1*/ fun close(): kotlin.Unit
            public open fun connect(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!): kotlin.Unit
            public open fun connect(/*0*/ p0: [ERROR : Unresolved java classifier: SocketAddress]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ open fun createImpl(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getChannel(): [ERROR : Unresolved java classifier: SocketChannel]!
            public/*package*/ open fun getImpl(): [ERROR : Unresolved java classifier: SocketImpl]!
            public open fun getInetAddress(): java.net.InetAddress!
            public open fun getInputStream(): java.io.InputStream!
            public open fun getKeepAlive(): kotlin.Boolean
            public open fun getLocalAddress(): java.net.InetAddress!
            public open fun getLocalPort(): kotlin.Int
            public open fun getLocalSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open fun getOOBInline(): kotlin.Boolean
            public open fun getOutputStream(): java.io.OutputStream!
            public open fun getPort(): kotlin.Int
            public open fun getReceiveBufferSize(): kotlin.Int
            public open fun getRemoteSocketAddress(): [ERROR : Unresolved java classifier: SocketAddress]!
            public open fun getReuseAddress(): kotlin.Boolean
            public open fun getSendBufferSize(): kotlin.Int
            public open fun getSoLinger(): kotlin.Int
            public open fun getSoTimeout(): kotlin.Int
            public open fun getTcpNoDelay(): kotlin.Boolean
            public open fun getTrafficClass(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun isBound(): kotlin.Boolean
            public open fun isClosed(): kotlin.Boolean
            public open fun isConnected(): kotlin.Boolean
            public open fun isInputShutdown(): kotlin.Boolean
            public open fun isOutputShutdown(): kotlin.Boolean
            public/*package*/ final fun postAccept(): kotlin.Unit
            public open fun sendUrgentData(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ open fun setBound(): kotlin.Unit
            public/*package*/ open fun setConnected(): kotlin.Unit
            public/*package*/ open fun setCreated(): kotlin.Unit
            public/*package*/ open fun setImpl(): kotlin.Unit
            public open fun setKeepAlive(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setOOBInline(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setPerformancePreferences(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun setReceiveBufferSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setReuseAddress(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setSendBufferSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setSoLinger(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun setSoTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setTcpNoDelay(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setTrafficClass(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun shutdownInput(): kotlin.Unit
            public open fun shutdownOutput(): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!

            // Static members
            private final var factory: [ERROR : Unresolved java classifier: SocketImplFactory]!
            public open fun setSocketImplFactory(/*0*/ p0: [ERROR : Unresolved java classifier: SocketImplFactory]!): kotlin.Unit
        }

        public open class SocketException : java.io.IOException {
            public constructor SocketException()
            public constructor SocketException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -5935874303556886934.toLong()
        }

        public final class URI : kotlin.Comparable<java.net.URI!>, java.io.Serializable {
            private constructor URI()
            public constructor URI(/*0*/ p0: kotlin.String!)
            public constructor URI(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!)
            public constructor URI(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.String!, /*6*/ p6: kotlin.String!)
            public constructor URI(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!)
            public constructor URI(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!)
            private final var authority: kotlin.String!
            private final var decodedAuthority: kotlin.String!
            private final var decodedFragment: kotlin.String!
            private final var decodedPath: kotlin.String!
            private final var decodedQuery: kotlin.String!
            private final var decodedSchemeSpecificPart: kotlin.String!
            private final var decodedUserInfo: kotlin.String!
            private final var fragment: kotlin.String!
            private final var hash: kotlin.Int
            private final var host: kotlin.String!
            private final var path: kotlin.String!
            private final var port: kotlin.Int
            private final var query: kotlin.String!
            private final var scheme: kotlin.String!
            private final var schemeSpecificPart: kotlin.String!
            private final var string: kotlin.String!
            private final var userInfo: kotlin.String!
            private open fun appendAuthority(/*0*/ p0: java.lang.StringBuffer!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun appendFragment(/*0*/ p0: java.lang.StringBuffer!, /*1*/ p1: kotlin.String!): kotlin.Unit
            private open fun appendSchemeSpecificPart(/*0*/ p0: java.lang.StringBuffer!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.String!, /*7*/ p7: kotlin.String!): kotlin.Unit
            public open override /*1*/ fun compareTo(/*0*/ other: java.net.URI!): kotlin.Int
            private open fun defineSchemeSpecificPart(): kotlin.Unit
            private open fun defineString(): kotlin.Unit
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun getAuthority(): kotlin.String!
            public open fun getFragment(): kotlin.String!
            public open fun getHost(): kotlin.String!
            public open fun getPath(): kotlin.String!
            public open fun getPort(): kotlin.Int
            public open fun getQuery(): kotlin.String!
            public open fun getRawAuthority(): kotlin.String!
            public open fun getRawFragment(): kotlin.String!
            public open fun getRawPath(): kotlin.String!
            public open fun getRawQuery(): kotlin.String!
            public open fun getRawSchemeSpecificPart(): kotlin.String!
            public open fun getRawUserInfo(): kotlin.String!
            public open fun getScheme(): kotlin.String!
            public open fun getSchemeSpecificPart(): kotlin.String!
            public open fun getUserInfo(): kotlin.String!
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open fun isAbsolute(): kotlin.Boolean
            public open fun isOpaque(): kotlin.Boolean
            public open fun normalize(): java.net.URI!
            public open fun parseServerAuthority(): java.net.URI!
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open fun relativize(/*0*/ p0: java.net.URI!): java.net.URI!
            public open fun resolve(/*0*/ p0: java.net.URI!): java.net.URI!
            public open fun resolve(/*0*/ p0: kotlin.String!): java.net.URI!
            public open fun toASCIIString(): kotlin.String!
            public open override /*2*/ fun toString(): kotlin.String!
            private open fun toString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.String!, /*7*/ p7: kotlin.String!, /*8*/ p8: kotlin.String!): kotlin.String!
            public open fun toURL(): java.net.URL!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private open inner class Parser {
                public/*package*/ constructor Parser(/*0*/ p2: kotlin.String!)
                private final var input: kotlin.String!
                private final var ipv6byteCount: kotlin.Int
                private final var requireServerAuthority: kotlin.Boolean
                private open fun at(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Char): kotlin.Boolean
                private open fun at(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Boolean
                private open fun charAt(/*0*/ p0: kotlin.Int): kotlin.Char
                private open fun checkChar(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long, /*3*/ p3: kotlin.String!): kotlin.Unit
                private open fun checkChars(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Long, /*3*/ p3: kotlin.Long, /*4*/ p4: kotlin.String!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                private open fun fail(/*0*/ p0: kotlin.String!): kotlin.Unit
                private open fun fail(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
                private open fun failExpecting(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
                private open fun failExpecting(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun parse(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                private open fun parseAuthority(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun parseHierarchical(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun parseHostname(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun parseIPv4Address(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun parseIPv6Reference(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun parseServer(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun scan(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Char): kotlin.Int
                private open fun scan(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Long, /*3*/ p3: kotlin.Long): kotlin.Int
                private open fun scan(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): kotlin.Int
                private open fun scanByte(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun scanEscape(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Char): kotlin.Int
                private open fun scanHexPost(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun scanHexSeq(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                private open fun scanIPv4Address(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Boolean): kotlin.Int
                private open fun substring(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.String!
                private open fun takeIPv4Address(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val H_ALPHA: kotlin.Long
            private final val H_ALPHANUM: kotlin.Long
            private final val H_DASH: kotlin.Long
            private final val H_DIGIT: kotlin.Long = 0.toLong()
            private final val H_DOT: kotlin.Long
            private final val H_ESCAPED: kotlin.Long = 0.toLong()
            private final val H_HEX: kotlin.Long
            private final val H_LEFT_BRACKET: kotlin.Long
            private final val H_LOWALPHA: kotlin.Long
            private final val H_MARK: kotlin.Long
            private final val H_PATH: kotlin.Long
            private final val H_PCHAR: kotlin.Long
            private final val H_REG_NAME: kotlin.Long
            private final val H_RESERVED: kotlin.Long
            private final val H_SCHEME: kotlin.Long
            private final val H_SERVER: kotlin.Long
            private final val H_SERVER_PERCENT: kotlin.Long
            private final val H_UNRESERVED: kotlin.Long
            private final val H_UPALPHA: kotlin.Long
            private final val H_URIC: kotlin.Long
            private final val H_URIC_NO_SLASH: kotlin.Long
            private final val H_USERINFO: kotlin.Long
            private final val L_ALPHA: kotlin.Long = 0.toLong()
            private final val L_ALPHANUM: kotlin.Long
            private final val L_DASH: kotlin.Long
            private final val L_DIGIT: kotlin.Long
            private final val L_DOT: kotlin.Long
            private final val L_ESCAPED: kotlin.Long = 1.toLong()
            private final val L_HEX: kotlin.Long
            private final val L_LEFT_BRACKET: kotlin.Long
            private final val L_LOWALPHA: kotlin.Long = 0.toLong()
            private final val L_MARK: kotlin.Long
            private final val L_PATH: kotlin.Long
            private final val L_PCHAR: kotlin.Long
            private final val L_REG_NAME: kotlin.Long
            private final val L_RESERVED: kotlin.Long
            private final val L_SCHEME: kotlin.Long
            private final val L_SERVER: kotlin.Long
            private final val L_SERVER_PERCENT: kotlin.Long
            private final val L_UNRESERVED: kotlin.Long
            private final val L_UPALPHA: kotlin.Long = 0.toLong()
            private final val L_URIC: kotlin.Long
            private final val L_URIC_NO_SLASH: kotlin.Long
            private final val L_USERINFO: kotlin.Long
            private final val hexDigits: kotlin.CharArray!
            public/*package*/ final val serialVersionUID: kotlin.Long = -6052424284110960213.toLong()
            private open fun appendEncoded(/*0*/ p0: java.lang.StringBuffer!, /*1*/ p1: kotlin.Char): kotlin.Unit
            private open fun appendEscape(/*0*/ p0: java.lang.StringBuffer!, /*1*/ p1: kotlin.Byte): kotlin.Unit
            private open fun checkPath(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.Unit
            private open fun compare(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Int
            private open fun compareIgnoringCase(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Int
            public open fun create(/*0*/ p0: kotlin.String!): java.net.URI!
            private open fun decode(/*0*/ p0: kotlin.Char): kotlin.Int
            private open fun decode(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Byte
            private open fun decode(/*0*/ p0: kotlin.String!): kotlin.String!
            private open fun encode(/*0*/ p0: kotlin.String!): kotlin.String!
            private open fun equal(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Boolean
            private open fun equalIgnoringCase(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Boolean
            private open fun hash(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Int
            private open fun hashIgnoringCase(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Int
            private open fun highMask(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Long
            private open fun highMask(/*0*/ p0: kotlin.String!): kotlin.Long
            private open fun join(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.IntArray!): kotlin.Int
            private open fun lowMask(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Char): kotlin.Long
            private open fun lowMask(/*0*/ p0: kotlin.String!): kotlin.Long
            private open fun match(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
            private open fun maybeAddLeadingDot(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.IntArray!): kotlin.Unit
            private open fun needsNormalization(/*0*/ p0: kotlin.String!): kotlin.Int
            private open fun normalize(/*0*/ p0: java.net.URI!): java.net.URI!
            private open fun normalize(/*0*/ p0: kotlin.String!): kotlin.String!
            private open fun quote(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.String!
            private open fun relativize(/*0*/ p0: java.net.URI!, /*1*/ p1: java.net.URI!): java.net.URI!
            private open fun removeDots(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.IntArray!): kotlin.Unit
            private open fun resolve(/*0*/ p0: java.net.URI!, /*1*/ p1: java.net.URI!): java.net.URI!
            private open fun resolvePath(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean): kotlin.String!
            private open fun split(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.IntArray!): kotlin.Unit
            private open fun toLower(/*0*/ p0: kotlin.Char): kotlin.Int
        }

        public final class URL : java.io.Serializable {
            public constructor URL(/*0*/ p0: java.net.URL!, /*1*/ p1: kotlin.String!)
            public constructor URL(/*0*/ p0: java.net.URL!, /*1*/ p1: kotlin.String!, /*2*/ p2: [ERROR : Unresolved java classifier: URLStreamHandler]!)
            public constructor URL(/*0*/ p0: kotlin.String!)
            public constructor URL(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.String!)
            public constructor URL(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.String!, /*4*/ p4: [ERROR : Unresolved java classifier: URLStreamHandler]!)
            public constructor URL(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!)
            private final var authority: kotlin.String!
            private final var file: kotlin.String!
            public/*package*/ final var handler: [ERROR : Unresolved java classifier: URLStreamHandler]!
            private final var hashCode: kotlin.Int
            private final var host: kotlin.String!
            public/*package*/ final var hostAddress: java.net.InetAddress!
            private final var path: kotlin.String!
            private final var port: kotlin.Int
            private final var protocol: kotlin.String!
            private final var query: kotlin.String!
            private final var ref: kotlin.String!
            private final var userInfo: kotlin.String!
            private open fun checkSpecifyHandler(/*0*/ p0: [ERROR : Unresolved java classifier: SecurityManager]!): kotlin.Unit
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun getAuthority(): kotlin.String!
            public final fun getContent(): kotlin.Any!
            public final fun getContent(/*0*/ p0: kotlin.Array<(out) java.lang.Class<*>!>!): kotlin.Any!
            public open fun getDefaultPort(): kotlin.Int
            public open fun getFile(): kotlin.String!
            public open fun getHost(): kotlin.String!
            public open fun getPath(): kotlin.String!
            public open fun getPort(): kotlin.Int
            public open fun getProtocol(): kotlin.String!
            public open fun getQuery(): kotlin.String!
            public open fun getRef(): kotlin.String!
            public open fun getUserInfo(): kotlin.String!
            public open override /*1*/ fun hashCode(): kotlin.Int
            private open fun isValidProtocol(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun openConnection(): java.net.URLConnection!
            public open fun openConnection(/*0*/ p0: [ERROR : Unresolved java classifier: Proxy]!): java.net.URLConnection!
            public final fun openStream(): java.io.InputStream!
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open fun sameFile(/*0*/ p0: java.net.URL!): kotlin.Boolean
            protected/*protected and package*/ open fun set(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!): kotlin.Unit
            protected/*protected and package*/ open fun set(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.String!, /*6*/ p6: kotlin.String!, /*7*/ p7: kotlin.String!): kotlin.Unit
            public open fun toExternalForm(): kotlin.String!
            public open override /*1*/ fun toString(): kotlin.String!
            public open fun toURI(): java.net.URI!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            private final val ENABLE_GOPHER_PROP: kotlin.String = "jdk.net.registerGopherProtocol"
            private final val GOPHER: kotlin.String = "gopher"
            private final val JDK_PACKAGE_PREFIX: kotlin.String = "sun.net.www.protocol"
            private final val enableGopher: kotlin.Boolean
            public/*package*/ final var factory: [ERROR : Unresolved java classifier: URLStreamHandlerFactory]!
            public/*package*/ final var handlers: [ERROR : Unresolved java classifier: Hashtable]!
            private final val protocolPathProp: kotlin.String = "java.protocol.handler.pkgs"
            public/*package*/ final val serialVersionUID: kotlin.Long = -7627629688361524110.toLong()
            private final var streamHandlerLock: kotlin.Any!
            public/*package*/ open fun getURLStreamHandler(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: URLStreamHandler]!
            public open fun setURLStreamHandlerFactory(/*0*/ p0: [ERROR : Unresolved java classifier: URLStreamHandlerFactory]!): kotlin.Unit
        }

        public abstract class URLConnection {
            protected/*protected and package*/ constructor URLConnection(/*0*/ p0: java.net.URL!)
            protected/*protected and package*/ final var allowUserInteraction: kotlin.Boolean
            private final var connectTimeout: kotlin.Int
            protected/*protected and package*/ final var connected: kotlin.Boolean
            protected/*protected and package*/ final var doInput: kotlin.Boolean
            protected/*protected and package*/ final var doOutput: kotlin.Boolean
            protected/*protected and package*/ final var ifModifiedSince: kotlin.Long
            private final var readTimeout: kotlin.Int
            private final var requests: [ERROR : Unresolved java classifier: MessageHeader]!
            protected/*protected and package*/ final var url: java.net.URL!
            protected/*protected and package*/ final var useCaches: kotlin.Boolean
            public open fun addRequestProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun connect(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getAllowUserInteraction(): kotlin.Boolean
            public open fun getConnectTimeout(): kotlin.Int
            public open fun getContent(): kotlin.Any!
            public open fun getContent(/*0*/ p0: kotlin.Array<(out) java.lang.Class<*>!>!): kotlin.Any!
            public open fun getContentEncoding(): kotlin.String!
            public/*package*/ open fun getContentHandler(): [ERROR : Unresolved java classifier: ContentHandler]!
            private open fun getContentHandlerPkgPrefixes(): kotlin.String!
            public open fun getContentLength(): kotlin.Int
            public open fun getContentLengthLong(): kotlin.Long
            public open fun getContentType(): kotlin.String!
            public open fun getDate(): kotlin.Long
            public open fun getDefaultUseCaches(): kotlin.Boolean
            public open fun getDoInput(): kotlin.Boolean
            public open fun getDoOutput(): kotlin.Boolean
            public open fun getExpiration(): kotlin.Long
            public open fun getHeaderField(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun getHeaderField(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getHeaderFieldDate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long
            public open fun getHeaderFieldInt(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public open fun getHeaderFieldKey(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun getHeaderFieldLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long
            public open fun getHeaderFields(): kotlin.(Mutable)Map<kotlin.String!, kotlin.(Mutable)List<kotlin.String!>!>!
            public open fun getIfModifiedSince(): kotlin.Long
            public open fun getInputStream(): java.io.InputStream!
            public open fun getLastModified(): kotlin.Long
            public open fun getOutputStream(): java.io.OutputStream!
            public open fun getPermission(): [ERROR : Unresolved java classifier: Permission]!
            public open fun getReadTimeout(): kotlin.Int
            public open fun getRequestProperties(): kotlin.(Mutable)Map<kotlin.String!, kotlin.(Mutable)List<kotlin.String!>!>!
            public open fun getRequestProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getURL(): java.net.URL!
            public open fun getUseCaches(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            private open fun lookupContentHandlerClassFor(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: ContentHandler]!
            public open fun setAllowUserInteraction(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setConnectTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setDefaultUseCaches(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setDoInput(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setDoOutput(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setIfModifiedSince(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun setReadTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setRequestProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open fun setUseCaches(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            private open fun stripOffParameters(/*0*/ p0: kotlin.String!): kotlin.String!
            public open override /*1*/ fun toString(): kotlin.String!
            private open fun typeToPackageName(/*0*/ p0: kotlin.String!): kotlin.String!

            // Static members
            private final val contentClassPrefix: kotlin.String = "sun.net.www.content"
            private final val contentPathProp: kotlin.String = "java.content.handler.pkgs"
            private final var defaultAllowUserInteraction: kotlin.Boolean
            private final var defaultUseCaches: kotlin.Boolean
            public/*package*/ final var factory: [ERROR : Unresolved java classifier: ContentHandlerFactory]!
            private final var fileNameMap: [ERROR : Unresolved java classifier: FileNameMap]!
            private final var fileNameMapLoaded: kotlin.Boolean
            private final var handlers: [ERROR : Unresolved java classifier: Hashtable]!
            private open fun checkfpx(/*0*/ p0: java.io.InputStream!): kotlin.Boolean
            public open fun getDefaultAllowUserInteraction(): kotlin.Boolean
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getDefaultRequestProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getFileNameMap(): [ERROR : Unresolved java classifier: FileNameMap]!
            public open fun guessContentTypeFromName(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun guessContentTypeFromStream(/*0*/ p0: java.io.InputStream!): kotlin.String!
            private open fun readBytes(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: java.io.InputStream!): kotlin.Int
            public open fun setContentHandlerFactory(/*0*/ p0: [ERROR : Unresolved java classifier: ContentHandlerFactory]!): kotlin.Unit
            public open fun setDefaultAllowUserInteraction(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setDefaultRequestProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open fun setFileNameMap(/*0*/ p0: [ERROR : Unresolved java classifier: FileNameMap]!): kotlin.Unit
            private open fun skipForward(/*0*/ p0: java.io.InputStream!, /*1*/ p1: kotlin.Long): kotlin.Long
        }

        public open class UnknownHostException : java.io.IOException {
            public constructor UnknownHostException()
            public constructor UnknownHostException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -4639126076052875403.toLong()
        }
    }

    package java.nio {

        package java.nio.charset {

            public abstract class Charset : kotlin.Comparable<java.nio.charset.Charset!> {
                protected/*protected and package*/ constructor Charset(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!)
                private final var aliasSet: kotlin.(Mutable)Set<kotlin.String!>!
                private final val aliases: kotlin.Array<(out) kotlin.String!>!
                private final val name: kotlin.String!
                public final fun aliases(): kotlin.(Mutable)Set<kotlin.String!>!
                public open fun canEncode(): kotlin.Boolean
                public final override /*1*/ fun compareTo(/*0*/ other: java.nio.charset.Charset!): kotlin.Int
                public abstract fun contains(/*0*/ p0: java.nio.charset.Charset!): kotlin.Boolean
                public final fun decode(/*0*/ p0: [ERROR : Unresolved java classifier: ByteBuffer]!): [ERROR : Unresolved java classifier: CharBuffer]!
                public open fun displayName(): kotlin.String!
                public open fun displayName(/*0*/ p0: java.util.Locale!): kotlin.String!
                public final fun encode(/*0*/ p0: [ERROR : Unresolved java classifier: CharBuffer]!): [ERROR : Unresolved java classifier: ByteBuffer]!
                public final fun encode(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: ByteBuffer]!
                public final override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public final override /*1*/ fun hashCode(): kotlin.Int
                public final fun isRegistered(): kotlin.Boolean
                public final fun name(): kotlin.String!
                public abstract fun newDecoder(): [ERROR : Unresolved java classifier: CharsetDecoder]!
                public abstract fun newEncoder(): [ERROR : Unresolved java classifier: CharsetEncoder]!
                public final override /*1*/ fun toString(): kotlin.String!

                // Static members
                private final var bugLevel: kotlin.String!
                private final var cache1: kotlin.Array<(out) kotlin.Any!>!
                private final var cache2: kotlin.Array<(out) kotlin.Any!>!
                private final var defaultCharset: java.nio.charset.Charset!
                private final var extendedProvider: [ERROR : Unresolved java classifier: CharsetProvider]!
                private final var extendedProviderLock: kotlin.Any!
                private final var extendedProviderProbed: kotlin.Boolean
                private final var gate: java.lang.ThreadLocal<java.lang.ThreadLocal<*>!>!
                private final var standardProvider: [ERROR : Unresolved java classifier: CharsetProvider]!
                public/*package*/ open fun atBugLevel(/*0*/ p0: kotlin.String!): kotlin.Boolean
                public open fun availableCharsets(): java.util.SortedMap<kotlin.String!, java.nio.charset.Charset!>!
                private open fun cache(/*0*/ p0: kotlin.String!, /*1*/ p1: java.nio.charset.Charset!): kotlin.Unit
                private open fun checkName(/*0*/ p0: kotlin.String!): kotlin.Unit
                public open fun defaultCharset(): java.nio.charset.Charset!
                public open fun forName(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
                public open fun isSupported(/*0*/ p0: kotlin.String!): kotlin.Boolean
                private open fun lookup(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
                private open fun lookup2(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
                private open fun lookupExtendedCharset(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
                private open fun lookupViaProviders(/*0*/ p0: kotlin.String!): java.nio.charset.Charset!
                private open fun probeExtendedProvider(): kotlin.Unit
                private open fun providers(): kotlin.(Mutable)Iterator<*>!
                private open fun put(/*0*/ p0: kotlin.(Mutable)Iterator<java.nio.charset.Charset!>!, /*1*/ p1: kotlin.(Mutable)Map<kotlin.String!, java.nio.charset.Charset!>!): kotlin.Unit
            }
        }
    }

    package java.rmi {

        public trait Remote {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class RemoteException : java.io.IOException {
            public constructor RemoteException()
            public constructor RemoteException(/*0*/ p0: kotlin.String!)
            public constructor RemoteException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public final var detail: kotlin.Throwable!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun getCause(): kotlin.Throwable!
            public open override /*1*/ fun getMessage(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -5148567311918794206.toLong()
        }
    }

    package java.security {

        public open class GeneralSecurityException : java.lang.Exception {
            public constructor GeneralSecurityException()
            public constructor GeneralSecurityException(/*0*/ p0: kotlin.String!)
            public constructor GeneralSecurityException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor GeneralSecurityException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 894798122053539237.toLong()
        }

        kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public abstract class Identity : java.io.Serializable {
            protected/*protected and package*/ constructor Identity()
            public constructor Identity(/*0*/ p0: kotlin.String!)
            public constructor Identity(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: IdentityScope]!)
            public/*package*/ final var certificates: [ERROR : Unresolved java classifier: Vector<Certificate>]!
            public/*package*/ final var info: kotlin.String!
            private final var name: kotlin.String!
            private final var publicKey: [ERROR : Unresolved java classifier: PublicKey]!
            public/*package*/ final var scope: [ERROR : Unresolved java classifier: IdentityScope]!
            public open fun addCertificate(/*0*/ p0: [ERROR : Unresolved java classifier: Certificate]!): kotlin.Unit
            public open fun certificates(): kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!
            public final override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public/*package*/ open fun fullName(): kotlin.String!
            public open fun getInfo(): kotlin.String!
            public final fun getName(): kotlin.String!
            public open fun getPublicKey(): [ERROR : Unresolved java classifier: PublicKey]!
            public final fun getScope(): [ERROR : Unresolved java classifier: IdentityScope]!
            public open override /*1*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ open fun identityEquals(/*0*/ p0: java.security.Identity!): kotlin.Boolean
            private open fun keyEquals(/*0*/ p0: [ERROR : Unresolved java classifier: Key]!, /*1*/ p1: [ERROR : Unresolved java classifier: Key]!): kotlin.Boolean
            public/*package*/ open fun printCertificates(): kotlin.String!
            public/*package*/ open fun printKeys(): kotlin.String!
            public open fun removeCertificate(/*0*/ p0: [ERROR : Unresolved java classifier: Certificate]!): kotlin.Unit
            public open fun setInfo(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun setPublicKey(/*0*/ p0: [ERROR : Unresolved java classifier: PublicKey]!): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Boolean): kotlin.String!

            // Static members
            private final val serialVersionUID: kotlin.Long = 3609922007826600659.toLong()
            private open fun check(/*0*/ p0: kotlin.String!): kotlin.Unit
        }

        public open class NoSuchAlgorithmException : java.security.GeneralSecurityException {
            public constructor NoSuchAlgorithmException()
            public constructor NoSuchAlgorithmException(/*0*/ p0: kotlin.String!)
            public constructor NoSuchAlgorithmException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor NoSuchAlgorithmException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -7443947487218346562.toLong()
        }

        public abstract class Policy {
            public constructor Policy()
            private final var pdMapping: [ERROR : Unresolved java classifier: WeakHashMap<Key, PermissionCollection>]!
            private open fun addStaticPerms(/*0*/ p0: [ERROR : Unresolved java classifier: PermissionCollection]!, /*1*/ p1: [ERROR : Unresolved java classifier: PermissionCollection]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getParameters(): java.security.Policy.Parameters!
            public open fun getPermissions(/*0*/ p0: [ERROR : Unresolved java classifier: CodeSource]!): [ERROR : Unresolved java classifier: PermissionCollection]!
            public open fun getPermissions(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!): [ERROR : Unresolved java classifier: PermissionCollection]!
            public open fun getProvider(): java.security.Provider!
            public open fun getType(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun implies(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!, /*1*/ p1: [ERROR : Unresolved java classifier: Permission]!): kotlin.Boolean
            public open fun refresh(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            public trait Parameters {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class PolicyDelegate : java.security.Policy {
                private constructor PolicyDelegate(/*0*/ p0: [ERROR : Unresolved java classifier: PolicySpi]!, /*1*/ p1: java.security.Provider!, /*2*/ p2: kotlin.String!, /*3*/ p3: java.security.Policy.Parameters!)
                private final var p: java.security.Provider!
                private final var params: java.security.Policy.Parameters!
                invisible_fake final override /*1*/ /*fake_override*/ var pdMapping: [ERROR : Unresolved java classifier: WeakHashMap<Key, PermissionCollection>]!
                private final var spi: [ERROR : Unresolved java classifier: PolicySpi]!
                private final var type: kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun addStaticPerms(/*0*/ p0: [ERROR : Unresolved java classifier: PermissionCollection]!, /*1*/ p1: [ERROR : Unresolved java classifier: PermissionCollection]!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun getParameters(): java.security.Policy.Parameters!
                public open override /*2*/ fun getPermissions(/*0*/ p0: [ERROR : Unresolved java classifier: CodeSource]!): [ERROR : Unresolved java classifier: PermissionCollection]!
                public open override /*2*/ fun getPermissions(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!): [ERROR : Unresolved java classifier: PermissionCollection]!
                public open override /*1*/ fun getProvider(): java.security.Provider!
                public open override /*1*/ fun getType(): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun implies(/*0*/ p0: [ERROR : Unresolved java classifier: ProtectionDomain]!, /*1*/ p1: [ERROR : Unresolved java classifier: Permission]!): kotlin.Boolean
                public open override /*1*/ fun refresh(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class PolicyInfo {
                public/*package*/ constructor PolicyInfo(/*0*/ p0: java.security.Policy!, /*1*/ p1: kotlin.Boolean)
                public/*package*/ final val initialized: kotlin.Boolean
                public/*package*/ final val policy: java.security.Policy!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class UnsupportedEmptyCollection {
                public constructor UnsupportedEmptyCollection()
                private final var perms: [ERROR : Unresolved java classifier: Permissions]!
                public open fun add(/*0*/ p0: [ERROR : Unresolved java classifier: Permission]!): kotlin.Unit
                public open fun elements(): java.util.Enumeration<[ERROR : Unresolved java classifier: Permission]!>!
                public open fun implies(/*0*/ p0: [ERROR : Unresolved java classifier: Permission]!): kotlin.Boolean
            }

            // Static members
            public final val UNSUPPORTED_EMPTY_COLLECTION: [ERROR : Unresolved java classifier: PermissionCollection]!
            private final val debug: [ERROR : Unresolved java classifier: Debug]!
            private final var policy: java.util.concurrent.atomic.AtomicReference<java.security.Policy.PolicyInfo!>!
            private open fun checkPermission(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun getInstance(/*0*/ p0: kotlin.String!, /*1*/ p1: java.security.Policy.Parameters!): java.security.Policy!
            public open fun getInstance(/*0*/ p0: kotlin.String!, /*1*/ p1: java.security.Policy.Parameters!, /*2*/ p2: java.security.Provider!): java.security.Policy!
            public open fun getInstance(/*0*/ p0: kotlin.String!, /*1*/ p1: java.security.Policy.Parameters!, /*2*/ p2: kotlin.String!): java.security.Policy!
            public open fun getPolicy(): java.security.Policy!
            public/*package*/ open fun getPolicyNoCheck(): java.security.Policy!
            private open fun handleException(/*0*/ p0: java.security.NoSuchAlgorithmException!): java.security.Policy!
            private open fun initPolicy(/*0*/ p0: java.security.Policy!): kotlin.Unit
            public/*package*/ open fun isSet(): kotlin.Boolean
            public open fun setPolicy(/*0*/ p0: java.security.Policy!): kotlin.Unit
        }

        public abstract class Provider : java.util.Properties {
            protected/*protected and package*/ constructor Provider(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double, /*2*/ p2: kotlin.String!)
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var defaults: java.util.Properties!
            private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<kotlin.Any!, kotlin.Any!>!>!
            private final var entrySetCallCount: kotlin.Int
            private final var info: kotlin.String!
            private final var initialized: kotlin.Boolean
            private final var legacyChanged: kotlin.Boolean
            private final var legacyMap: kotlin.(Mutable)Map<java.security.Provider.ServiceKey!, java.security.Provider.Service!>!
            private final var legacyStrings: kotlin.(Mutable)Map<kotlin.String!, kotlin.String!>!
            private final var name: kotlin.String!
            private final var serviceMap: kotlin.(Mutable)Map<java.security.Provider.ServiceKey!, java.security.Provider.Service!>!
            private final var serviceSet: kotlin.(Mutable)Set<java.security.Provider.Service!>!
            private final var servicesChanged: kotlin.Boolean
            private final var version: kotlin.Double
            private open fun check(/*0*/ p0: kotlin.String!): kotlin.Unit
            private open fun checkInitialized(): kotlin.Unit
            public open fun clear(): kotlin.Unit
            public open fun elements(): java.util.Enumeration<kotlin.Any!>!
            private open fun ensureLegacyParsed(): kotlin.Unit
            public open fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<kotlin.Any!, kotlin.Any!>!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun enumerate(/*0*/ p0: [ERROR : Unresolved java classifier: Hashtable]!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun enumerateStringProperties(/*0*/ p0: [ERROR : Unresolved java classifier: Hashtable<String, String>]!): kotlin.Unit
            public open fun get(/*0*/ p0: kotlin.Any!): kotlin.Any!
            public open fun getInfo(): kotlin.String!
            public open fun getName(): kotlin.String!
            public open override /*1*/ fun getProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun getService(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): java.security.Provider.Service!
            public open fun getServices(): kotlin.(Mutable)Set<java.security.Provider.Service!>!
            private open fun getTypeAndAlgorithm(/*0*/ p0: kotlin.String!): kotlin.Array<(out) kotlin.String!>!
            public open fun getVersion(): kotlin.Double
            private open fun implClear(): kotlin.Unit
            private open fun implPut(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Any!
            private open fun implPutAll(/*0*/ p0: kotlin.(Mutable)Map<*, *>!): kotlin.Unit
            private open fun implRemove(/*0*/ p0: kotlin.Any!): kotlin.Any!
            private open fun implRemoveService(/*0*/ p0: java.security.Provider.Service!): kotlin.Unit
            public open fun keySet(): kotlin.(Mutable)Set<kotlin.Any!>!
            public open fun keys(): java.util.Enumeration<kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open override /*1*/ fun load(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun load(/*0*/ p0: java.io.Reader!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun load0(/*0*/ p0: java.util.Properties.LineReader!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun loadConvert(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.CharArray!): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun loadFromXML(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            private open fun parseLegacyPut(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun propertyNames(): java.util.Enumeration<*>!
            public open fun put(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Any!
            public open fun putAll(/*0*/ p0: kotlin.(Mutable)Map<*, *>!): kotlin.Unit
            private open fun putId(): kotlin.Unit
            private open fun putPropertyStrings(/*0*/ p0: java.security.Provider.Service!): kotlin.Unit
            protected/*protected and package*/ open fun putService(/*0*/ p0: java.security.Provider.Service!): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open fun remove(/*0*/ p0: kotlin.Any!): kotlin.Any!
            private open fun removeInvalidServices(/*0*/ p0: kotlin.(Mutable)Map<java.security.Provider.ServiceKey!, java.security.Provider.Service!>!): kotlin.Unit
            private open fun removePropertyStrings(/*0*/ p0: java.security.Provider.Service!): kotlin.Unit
            protected/*protected and package*/ open fun removeService(/*0*/ p0: java.security.Provider.Service!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun save(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun saveConvert(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun setProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun store(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun store(/*0*/ p0: java.io.Writer!, /*1*/ p1: kotlin.String!): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun store0(/*0*/ p0: java.io.BufferedWriter!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun storeToXML(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun storeToXML(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun stringPropertyNames(): kotlin.(Mutable)Set<kotlin.String!>!
            public open override /*1*/ fun toString(): kotlin.String!
            public open fun values(): kotlin.(Mutable)Collection<kotlin.Any!>!

            private open class EngineDescription {
                public/*package*/ constructor EngineDescription(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.String!)
                private final var constructorParameterClass: java.lang.Class<*>!
                public/*package*/ final val constructorParameterClassName: kotlin.String!
                public/*package*/ final val name: kotlin.String!
                public/*package*/ final val supportsParameter: kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ open fun getConstructorParameterClass(): java.lang.Class<*>!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public open class Service {
                private constructor Service(/*0*/ p0: java.security.Provider!)
                public constructor Service(/*0*/ p0: java.security.Provider!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.(Mutable)List<kotlin.String!>!, /*5*/ p5: kotlin.(Mutable)Map<kotlin.String!, kotlin.String!>!)
                private final var algorithm: kotlin.String!
                private final var aliases: kotlin.(Mutable)List<kotlin.String!>!
                private final var attributes: kotlin.(Mutable)Map<java.security.Provider.UString!, kotlin.String!>!
                private final var className: kotlin.String!
                private final var classRef: [ERROR : Unresolved java classifier: Reference<Class>]!
                private final var hasKeyAttributes: kotlin.Boolean!
                private final val provider: java.security.Provider!
                private final var registered: kotlin.Boolean
                private final var supportedClasses: kotlin.Array<(out) java.lang.Class<*>!>!
                private final var supportedFormats: kotlin.Array<(out) kotlin.String!>!
                private final var type: kotlin.String!
                private open fun addAlias(/*0*/ p0: kotlin.String!): kotlin.Unit
                public/*package*/ open fun addAttribute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final fun getAlgorithm(): kotlin.String!
                private final fun getAliases(): kotlin.(Mutable)List<kotlin.String!>!
                public final fun getAttribute(/*0*/ p0: kotlin.String!): kotlin.String!
                public final fun getClassName(): kotlin.String!
                private open fun getImplClass(): java.lang.Class<*>!
                private open fun getKeyClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
                public final fun getProvider(): java.security.Provider!
                public final fun getType(): kotlin.String!
                private open fun hasKeyAttributes(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                private open fun isValid(): kotlin.Boolean
                public open fun newInstance(/*0*/ p0: kotlin.Any!): kotlin.Any!
                private open fun newInstanceGeneric(/*0*/ p0: kotlin.Any!): kotlin.Any!
                private open fun supportsKeyClass(/*0*/ p0: [ERROR : Unresolved java classifier: Key]!): kotlin.Boolean
                private open fun supportsKeyFormat(/*0*/ p0: [ERROR : Unresolved java classifier: Key]!): kotlin.Boolean
                public open fun supportsParameter(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun toString(): kotlin.String!

                // Static members
                private final val CLASS0: kotlin.Array<(out) java.lang.Class<*>!>!
            }

            private open class ServiceKey {
                private constructor ServiceKey(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean)
                private final val algorithm: kotlin.String!
                private final val originalAlgorithm: kotlin.String!
                private final val type: kotlin.String!
                public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun matches(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class UString {
                public/*package*/ constructor UString(/*0*/ p0: kotlin.String!)
                public/*package*/ final val lowerString: kotlin.String!
                public/*package*/ final val string: kotlin.String!
                public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun toString(): kotlin.String!
            }

            // Static members
            private final val ALIAS_LENGTH: kotlin.Int
            private final val ALIAS_PREFIX: kotlin.String = "Alg.Alias."
            private final val ALIAS_PREFIX_LOWER: kotlin.String = "alg.alias."
            private final val debug: [ERROR : Unresolved java classifier: Debug]!
            private final val knownEngines: kotlin.(Mutable)Map<kotlin.String!, java.security.Provider.EngineDescription!>!
            private final var previousKey: java.security.Provider.ServiceKey!
            public/*package*/ final val serialVersionUID: kotlin.Long = -4298000515446427739.toLong()
            private open fun addEngine(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.String!): kotlin.Unit
            private open fun getEngineName(/*0*/ p0: kotlin.String!): kotlin.String!
        }

        public final class Security {
            private constructor Security()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            private open class ProviderProperty {
                private constructor ProviderProperty()
                public/*package*/ final var className: kotlin.String!
                public/*package*/ final var provider: java.security.Provider!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final var props: java.util.Properties!
            private final val sdebug: [ERROR : Unresolved java classifier: Debug]!
            private final val spiMap: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!
            public open fun addProvider(/*0*/ p0: java.security.Provider!): kotlin.Int
            private open fun check(/*0*/ p0: kotlin.String!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getAlgorithmProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun getAlgorithms(/*0*/ p0: kotlin.String!): kotlin.(Mutable)Set<kotlin.String!>!
            private open fun getAllQualifyingCandidates(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Array<(out) java.security.Provider!>!): [ERROR : Unresolved java classifier: LinkedHashSet<Provider>]!
            public/*package*/ open fun getFilterComponents(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Array<(out) kotlin.String!>!
            public/*package*/ open fun getImpl(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.security.Provider!): kotlin.Array<(out) kotlin.Any!>!
            public/*package*/ open fun getImpl(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.security.Provider!, /*3*/ p3: kotlin.Any!): kotlin.Array<(out) kotlin.Any!>!
            public/*package*/ open fun getImpl(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.Array<(out) kotlin.Any!>!
            public/*package*/ open fun getImpl(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Any!): kotlin.Array<(out) kotlin.Any!>!
            public open fun getProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getProvider(/*0*/ p0: kotlin.String!): java.security.Provider!
            private open fun getProviderProperty(/*0*/ p0: kotlin.String!): java.security.Security.ProviderProperty!
            private open fun getProviderProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: java.security.Provider!): kotlin.String!
            public open fun getProviders(): kotlin.Array<(out) java.security.Provider!>!
            public open fun getProviders(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, kotlin.String!>!): kotlin.Array<(out) java.security.Provider!>!
            public open fun getProviders(/*0*/ p0: kotlin.String!): kotlin.Array<(out) java.security.Provider!>!
            private open fun getProvidersNotUsingCache(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.Array<(out) java.security.Provider!>!): [ERROR : Unresolved java classifier: LinkedHashSet<Provider>]!
            private open fun getSpiClass(/*0*/ p0: kotlin.String!): java.lang.Class<*>!
            private open fun initialize(): kotlin.Unit
            private open fun initializeStatic(): kotlin.Unit
            public open fun insertProviderAt(/*0*/ p0: java.security.Provider!, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun invalidateSMCache(/*0*/ p0: kotlin.String!): kotlin.Unit
            private open fun isConstraintSatisfied(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.Boolean
            private open fun isCriterionSatisfied(/*0*/ p0: java.security.Provider!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!): kotlin.Boolean
            private open fun isStandardAttr(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public open fun removeProvider(/*0*/ p0: kotlin.String!): kotlin.Unit
            private open fun securityPropFile(/*0*/ p0: kotlin.String!): java.io.File!
            public open fun setProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
        }

        kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public abstract class Signer : java.security.Identity {
            protected/*protected and package*/ constructor Signer()
            public constructor Signer(/*0*/ p0: kotlin.String!)
            public constructor Signer(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: IdentityScope]!)
            public/*package*/ final override /*1*/ /*fake_override*/ var certificates: [ERROR : Unresolved java classifier: Vector<Certificate>]!
            public/*package*/ final override /*1*/ /*fake_override*/ var info: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var name: kotlin.String!
            private final var privateKey: [ERROR : Unresolved java classifier: PrivateKey]!
            invisible_fake final override /*1*/ /*fake_override*/ var publicKey: [ERROR : Unresolved java classifier: PublicKey]!
            public/*package*/ final override /*1*/ /*fake_override*/ var scope: [ERROR : Unresolved java classifier: IdentityScope]!
            public open override /*1*/ /*fake_override*/ fun addCertificate(/*0*/ p0: [ERROR : Unresolved java classifier: Certificate]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun certificates(): kotlin.Array<(out) [ERROR : Unresolved java classifier: Certificate]!>!
            public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun fullName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getInfo(): kotlin.String!
            public final override /*1*/ /*fake_override*/ fun getName(): kotlin.String!
            public open fun getPrivateKey(): [ERROR : Unresolved java classifier: PrivateKey]!
            public open override /*1*/ /*fake_override*/ fun getPublicKey(): [ERROR : Unresolved java classifier: PublicKey]!
            public final override /*1*/ /*fake_override*/ fun getScope(): [ERROR : Unresolved java classifier: IdentityScope]!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun identityEquals(/*0*/ p0: java.security.Identity!): kotlin.Boolean
            invisible_fake open override /*1*/ /*fake_override*/ fun keyEquals(/*0*/ p0: [ERROR : Unresolved java classifier: Key]!, /*1*/ p1: [ERROR : Unresolved java classifier: Key]!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun printCertificates(): kotlin.String!
            public/*package*/ open override /*1*/ fun printKeys(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun removeCertificate(/*0*/ p0: [ERROR : Unresolved java classifier: Certificate]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setInfo(/*0*/ p0: kotlin.String!): kotlin.Unit
            public final fun setKeyPair(/*0*/ p0: [ERROR : Unresolved java classifier: KeyPair]!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setPublicKey(/*0*/ p0: [ERROR : Unresolved java classifier: PublicKey]!): kotlin.Unit
            public open override /*1*/ fun toString(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun toString(/*0*/ p0: kotlin.Boolean): kotlin.String!

            // Static members
            private final val serialVersionUID: kotlin.Long = -1763464102261361480.toLong()
            private open fun check(/*0*/ p0: kotlin.String!): kotlin.Unit
        }
    }

    package java.sql {

        public trait Array {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun free(): kotlin.Unit
            public abstract fun getArray(): kotlin.Any!
            public abstract fun getArray(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract fun getArray(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.Any!
            public abstract fun getArray(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract fun getBaseType(): kotlin.Int
            public abstract fun getBaseTypeName(): kotlin.String!
            public abstract fun getResultSet(): java.sql.ResultSet!
            public abstract fun getResultSet(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): java.sql.ResultSet!
            public abstract fun getResultSet(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): java.sql.ResultSet!
            public abstract fun getResultSet(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): java.sql.ResultSet!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class BatchUpdateException : java.sql.SQLException {
            public constructor BatchUpdateException()
            public constructor BatchUpdateException(/*0*/ p0: kotlin.IntArray!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Throwable!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!, /*2*/ p2: kotlin.Throwable!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.IntArray!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.IntArray!, /*4*/ p4: kotlin.Throwable!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.IntArray!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.IntArray!, /*3*/ p3: kotlin.Throwable!)
            public constructor BatchUpdateException(/*0*/ p0: kotlin.Throwable!)
            invisible_fake final override /*1*/ /*fake_override*/ var SQLState: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var next: java.sql.SQLException!
            private final val updateCounts: kotlin.IntArray!
            invisible_fake final override /*1*/ /*fake_override*/ var vendorCode: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public open override /*1*/ /*fake_override*/ fun getErrorCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun getNextException(): java.sql.SQLException!
            public open override /*1*/ /*fake_override*/ fun getSQLState(): kotlin.String!
            public open fun getUpdateCounts(): kotlin.IntArray!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.Throwable!>!
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setNextException(/*0*/ p0: java.sql.SQLException!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 5977529877145521757.toLong()
        }

        public trait Blob {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun free(): kotlin.Unit
            public abstract fun getBinaryStream(): java.io.InputStream!
            public abstract fun getBinaryStream(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): java.io.InputStream!
            public abstract fun getBytes(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.ByteArray!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun length(): kotlin.Long
            public abstract fun position(/*0*/ p0: java.sql.Blob!, /*1*/ p1: kotlin.Long): kotlin.Long
            public abstract fun position(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Long): kotlin.Long
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.Long): java.io.OutputStream!
            public abstract fun setBytes(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.ByteArray!): kotlin.Int
            public abstract fun setBytes(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.ByteArray!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun truncate(/*0*/ p0: kotlin.Long): kotlin.Unit
        }

        public trait CallableStatement : java.sql.PreparedStatement {
            public abstract override /*1*/ /*fake_override*/ fun addBatch(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun addBatch(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun cancel(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun clearBatch(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun clearParameters(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun clearWarnings(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun close(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun closeOnCompletion(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun executeBatch(): kotlin.IntArray!
            public abstract override /*1*/ /*fake_override*/ fun executeQuery(): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun executeQuery(/*0*/ p0: kotlin.String!): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Int
            public abstract fun getArray(/*0*/ p0: kotlin.Int): java.sql.Array!
            public abstract fun getArray(/*0*/ p0: kotlin.String!): java.sql.Array!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBlob(/*0*/ p0: kotlin.Int): java.sql.Blob!
            public abstract fun getBlob(/*0*/ p0: kotlin.String!): java.sql.Blob!
            public abstract fun getBoolean(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun getBoolean(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract fun getByte(/*0*/ p0: kotlin.Int): kotlin.Byte
            public abstract fun getByte(/*0*/ p0: kotlin.String!): kotlin.Byte
            public abstract fun getBytes(/*0*/ p0: kotlin.Int): kotlin.ByteArray!
            public abstract fun getBytes(/*0*/ p0: kotlin.String!): kotlin.ByteArray!
            public abstract fun getCharacterStream(/*0*/ p0: kotlin.Int): java.io.Reader!
            public abstract fun getCharacterStream(/*0*/ p0: kotlin.String!): java.io.Reader!
            public abstract fun getClob(/*0*/ p0: kotlin.Int): java.sql.Clob!
            public abstract fun getClob(/*0*/ p0: kotlin.String!): java.sql.Clob!
            public abstract override /*1*/ /*fake_override*/ fun getConnection(): java.sql.Connection!
            public abstract fun getDate(/*0*/ p0: kotlin.Int): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.String!): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Date!
            public abstract fun getDouble(/*0*/ p0: kotlin.Int): kotlin.Double
            public abstract fun getDouble(/*0*/ p0: kotlin.String!): kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun getFetchDirection(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getFetchSize(): kotlin.Int
            public abstract fun getFloat(/*0*/ p0: kotlin.Int): kotlin.Float
            public abstract fun getFloat(/*0*/ p0: kotlin.String!): kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun getGeneratedKeys(): java.sql.ResultSet!
            public abstract fun getInt(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getInt(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract fun getLong(/*0*/ p0: kotlin.Int): kotlin.Long
            public abstract fun getLong(/*0*/ p0: kotlin.String!): kotlin.Long
            public abstract override /*1*/ /*fake_override*/ fun getMaxFieldSize(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getMaxRows(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getMetaData(): java.sql.ResultSetMetaData!
            public abstract override /*1*/ /*fake_override*/ fun getMoreResults(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun getMoreResults(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun getNCharacterStream(/*0*/ p0: kotlin.Int): java.io.Reader!
            public abstract fun getNCharacterStream(/*0*/ p0: kotlin.String!): java.io.Reader!
            public abstract fun getNClob(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun getNClob(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun getNString(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getNString(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun getObject(/*0*/ p0: kotlin.Int): kotlin.Any!
            public abstract fun </*0*/ T> getObject(/*0*/ p0: kotlin.Int, /*1*/ p1: java.lang.Class<T!>!): T!
            public abstract fun getObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract fun getObject(/*0*/ p0: kotlin.String!): kotlin.Any!
            public abstract fun </*0*/ T> getObject(/*0*/ p0: kotlin.String!, /*1*/ p1: java.lang.Class<T!>!): T!
            public abstract fun getObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract override /*1*/ /*fake_override*/ fun getParameterMetaData(): java.sql.ParameterMetaData!
            public abstract override /*1*/ /*fake_override*/ fun getQueryTimeout(): kotlin.Int
            public abstract fun getRef(/*0*/ p0: kotlin.Int): java.sql.Ref!
            public abstract fun getRef(/*0*/ p0: kotlin.String!): java.sql.Ref!
            public abstract override /*1*/ /*fake_override*/ fun getResultSet(): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun getResultSetConcurrency(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getResultSetHoldability(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getResultSetType(): kotlin.Int
            public abstract fun getRowId(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: RowId]!
            public abstract fun getRowId(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: RowId]!
            public abstract fun getSQLXML(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun getSQLXML(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun getShort(/*0*/ p0: kotlin.Int): kotlin.Short
            public abstract fun getShort(/*0*/ p0: kotlin.String!): kotlin.Short
            public abstract fun getString(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getString(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun getTime(/*0*/ p0: kotlin.Int): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.String!): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Time!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.Int): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.String!): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Timestamp!
            public abstract fun getURL(/*0*/ p0: kotlin.Int): java.net.URL!
            public abstract fun getURL(/*0*/ p0: kotlin.String!): java.net.URL!
            public abstract override /*1*/ /*fake_override*/ fun getUpdateCount(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getWarnings(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun isCloseOnCompletion(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun isClosed(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun isPoolable(): kotlin.Boolean
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Unit
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun registerOutParameter(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setArray(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Array!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBigDecimal(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract fun setBigDecimal(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Blob!): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Blob!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBoolean(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public abstract fun setBoolean(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setByte(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Byte): kotlin.Unit
            public abstract fun setByte(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setBytes(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.ByteArray!): kotlin.Unit
            public abstract fun setBytes(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Clob!): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Clob!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setCursorName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Date!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Date!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setDate(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Date!): kotlin.Unit
            public abstract fun setDate(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Date!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setDouble(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): kotlin.Unit
            public abstract fun setDouble(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setEscapeProcessing(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setFetchDirection(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setFetchSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setFloat(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): kotlin.Unit
            public abstract fun setFloat(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setInt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun setInt(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setLong(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Unit
            public abstract fun setLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setMaxFieldSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setMaxRows(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setNCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setNCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun setNString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNull(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setNull(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Unit
            public abstract fun setNull(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun setNull(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setPoolable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setQueryTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setRef(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Ref!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setRowId(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract fun setRowId(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setSQLXML(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract fun setSQLXML(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setShort(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Short): kotlin.Unit
            public abstract fun setShort(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun setString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Time!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Time!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setTime(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Time!): kotlin.Unit
            public abstract fun setTime(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Time!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Timestamp!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Timestamp!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setTimestamp(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Timestamp!): kotlin.Unit
            public abstract fun setTimestamp(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Timestamp!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setURL(/*0*/ p0: kotlin.Int, /*1*/ p1: java.net.URL!): kotlin.Unit
            public abstract fun setURL(/*0*/ p0: kotlin.String!, /*1*/ p1: java.net.URL!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setUnicodeStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun wasNull(): kotlin.Boolean
        }

        public trait Clob {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun free(): kotlin.Unit
            public abstract fun getAsciiStream(): java.io.InputStream!
            public abstract fun getCharacterStream(): java.io.Reader!
            public abstract fun getCharacterStream(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): java.io.Reader!
            public abstract fun getSubString(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun length(): kotlin.Long
            public abstract fun position(/*0*/ p0: java.sql.Clob!, /*1*/ p1: kotlin.Long): kotlin.Long
            public abstract fun position(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Long
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.Long): java.io.OutputStream!
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.Long): java.io.Writer!
            public abstract fun setString(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.String!): kotlin.Int
            public abstract fun setString(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun truncate(/*0*/ p0: kotlin.Long): kotlin.Unit
        }

        public trait Connection : java.lang.AutoCloseable {
            public abstract fun abort(/*0*/ p0: [ERROR : Unresolved java classifier: Executor]!): kotlin.Unit
            public abstract fun clearWarnings(): kotlin.Unit
            public abstract override /*1*/ fun close(): kotlin.Unit
            public abstract fun commit(): kotlin.Unit
            public abstract fun createArrayOf(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!): java.sql.Array!
            public abstract fun createBlob(): java.sql.Blob!
            public abstract fun createClob(): java.sql.Clob!
            public abstract fun createNClob(): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun createSQLXML(): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun createStatement(): java.sql.Statement!
            public abstract fun createStatement(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): java.sql.Statement!
            public abstract fun createStatement(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.sql.Statement!
            public abstract fun createStruct(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!): java.sql.Struct!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getAutoCommit(): kotlin.Boolean
            public abstract fun getCatalog(): kotlin.String!
            public abstract fun getClientInfo(): java.util.Properties!
            public abstract fun getClientInfo(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun getHoldability(): kotlin.Int
            public abstract fun getMetaData(): java.sql.DatabaseMetaData!
            public abstract fun getNetworkTimeout(): kotlin.Int
            public abstract fun getSchema(): kotlin.String!
            public abstract fun getTransactionIsolation(): kotlin.Int
            public abstract fun getTypeMap(): kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!
            public abstract fun getWarnings(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun isClosed(): kotlin.Boolean
            public abstract fun isReadOnly(): kotlin.Boolean
            public abstract fun isValid(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun nativeSQL(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun prepareCall(/*0*/ p0: kotlin.String!): java.sql.CallableStatement!
            public abstract fun prepareCall(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.sql.CallableStatement!
            public abstract fun prepareCall(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.sql.CallableStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!): java.sql.PreparedStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): java.sql.PreparedStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): java.sql.PreparedStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): java.sql.PreparedStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): java.sql.PreparedStatement!
            public abstract fun prepareStatement(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): java.sql.PreparedStatement!
            public abstract fun releaseSavepoint(/*0*/ p0: java.sql.Savepoint!): kotlin.Unit
            public abstract fun rollback(): kotlin.Unit
            public abstract fun rollback(/*0*/ p0: java.sql.Savepoint!): kotlin.Unit
            public abstract fun setAutoCommit(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract fun setCatalog(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun setClientInfo(/*0*/ p0: java.util.Properties!): kotlin.Unit
            public abstract fun setClientInfo(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun setHoldability(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setNetworkTimeout(/*0*/ p0: [ERROR : Unresolved java classifier: Executor]!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun setReadOnly(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract fun setSavepoint(): java.sql.Savepoint!
            public abstract fun setSavepoint(/*0*/ p0: kotlin.String!): java.sql.Savepoint!
            public abstract fun setSchema(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun setTransactionIsolation(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setTypeMap(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val TRANSACTION_NONE: kotlin.Int = 0
            public final val TRANSACTION_READ_COMMITTED: kotlin.Int = 2
            public final val TRANSACTION_READ_UNCOMMITTED: kotlin.Int = 1
            public final val TRANSACTION_REPEATABLE_READ: kotlin.Int = 4
            public final val TRANSACTION_SERIALIZABLE: kotlin.Int = 8
        }

        public open class DataTruncation : java.sql.SQLWarning {
            public constructor DataTruncation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int)
            public constructor DataTruncation(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Throwable!)
            invisible_fake final override /*1*/ /*fake_override*/ var SQLState: kotlin.String!
            private final var dataSize: kotlin.Int
            private final var index: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var next: java.sql.SQLException!
            private final var parameter: kotlin.Boolean
            private final var read: kotlin.Boolean
            private final var transferSize: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var vendorCode: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public open fun getDataSize(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getErrorCode(): kotlin.Int
            public open fun getIndex(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun getNextException(): java.sql.SQLException!
            public open override /*1*/ /*fake_override*/ fun getNextWarning(): java.sql.SQLWarning!
            public open fun getParameter(): kotlin.Boolean
            public open fun getRead(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun getSQLState(): kotlin.String!
            public open fun getTransferSize(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.Throwable!>!
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setNextException(/*0*/ p0: java.sql.SQLException!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setNextWarning(/*0*/ p0: java.sql.SQLWarning!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 6464298989504059473.toLong()
        }

        public trait DatabaseMetaData {
            public abstract fun allProceduresAreCallable(): kotlin.Boolean
            public abstract fun allTablesAreSelectable(): kotlin.Boolean
            public abstract fun autoCommitFailureClosesAllResultSets(): kotlin.Boolean
            public abstract fun dataDefinitionCausesTransactionCommit(): kotlin.Boolean
            public abstract fun dataDefinitionIgnoredInTransactions(): kotlin.Boolean
            public abstract fun deletesAreDetected(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun doesMaxRowSizeIncludeBlobs(): kotlin.Boolean
            public abstract fun generatedKeyAlwaysReturned(): kotlin.Boolean
            public abstract fun getAttributes(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getBestRowIdentifier(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Boolean): java.sql.ResultSet!
            public abstract fun getCatalogSeparator(): kotlin.String!
            public abstract fun getCatalogTerm(): kotlin.String!
            public abstract fun getCatalogs(): java.sql.ResultSet!
            public abstract fun getClientInfoProperties(): java.sql.ResultSet!
            public abstract fun getColumnPrivileges(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getColumns(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getConnection(): java.sql.Connection!
            public abstract fun getCrossReference(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: kotlin.String!, /*5*/ p5: kotlin.String!): java.sql.ResultSet!
            public abstract fun getDatabaseMajorVersion(): kotlin.Int
            public abstract fun getDatabaseMinorVersion(): kotlin.Int
            public abstract fun getDatabaseProductName(): kotlin.String!
            public abstract fun getDatabaseProductVersion(): kotlin.String!
            public abstract fun getDefaultTransactionIsolation(): kotlin.Int
            public abstract fun getDriverMajorVersion(): kotlin.Int
            public abstract fun getDriverMinorVersion(): kotlin.Int
            public abstract fun getDriverName(): kotlin.String!
            public abstract fun getDriverVersion(): kotlin.String!
            public abstract fun getExportedKeys(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getExtraNameCharacters(): kotlin.String!
            public abstract fun getFunctionColumns(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getFunctions(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getIdentifierQuoteString(): kotlin.String!
            public abstract fun getImportedKeys(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getIndexInfo(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Boolean, /*4*/ p4: kotlin.Boolean): java.sql.ResultSet!
            public abstract fun getJDBCMajorVersion(): kotlin.Int
            public abstract fun getJDBCMinorVersion(): kotlin.Int
            public abstract fun getMaxBinaryLiteralLength(): kotlin.Int
            public abstract fun getMaxCatalogNameLength(): kotlin.Int
            public abstract fun getMaxCharLiteralLength(): kotlin.Int
            public abstract fun getMaxColumnNameLength(): kotlin.Int
            public abstract fun getMaxColumnsInGroupBy(): kotlin.Int
            public abstract fun getMaxColumnsInIndex(): kotlin.Int
            public abstract fun getMaxColumnsInOrderBy(): kotlin.Int
            public abstract fun getMaxColumnsInSelect(): kotlin.Int
            public abstract fun getMaxColumnsInTable(): kotlin.Int
            public abstract fun getMaxConnections(): kotlin.Int
            public abstract fun getMaxCursorNameLength(): kotlin.Int
            public abstract fun getMaxIndexLength(): kotlin.Int
            public abstract fun getMaxProcedureNameLength(): kotlin.Int
            public abstract fun getMaxRowSize(): kotlin.Int
            public abstract fun getMaxSchemaNameLength(): kotlin.Int
            public abstract fun getMaxStatementLength(): kotlin.Int
            public abstract fun getMaxStatements(): kotlin.Int
            public abstract fun getMaxTableNameLength(): kotlin.Int
            public abstract fun getMaxTablesInSelect(): kotlin.Int
            public abstract fun getMaxUserNameLength(): kotlin.Int
            public abstract fun getNumericFunctions(): kotlin.String!
            public abstract fun getPrimaryKeys(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getProcedureColumns(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getProcedureTerm(): kotlin.String!
            public abstract fun getProcedures(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getPseudoColumns(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): java.sql.ResultSet!
            public abstract fun getResultSetHoldability(): kotlin.Int
            public abstract fun getRowIdLifetime(): [ERROR : Unresolved java classifier: RowIdLifetime]!
            public abstract fun getSQLKeywords(): kotlin.String!
            public abstract fun getSQLStateType(): kotlin.Int
            public abstract fun getSchemaTerm(): kotlin.String!
            public abstract fun getSchemas(): java.sql.ResultSet!
            public abstract fun getSchemas(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): java.sql.ResultSet!
            public abstract fun getSearchStringEscape(): kotlin.String!
            public abstract fun getStringFunctions(): kotlin.String!
            public abstract fun getSuperTables(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getSuperTypes(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getSystemFunctions(): kotlin.String!
            public abstract fun getTablePrivileges(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun getTableTypes(): java.sql.ResultSet!
            public abstract fun getTables(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.Array<(out) kotlin.String!>!): java.sql.ResultSet!
            public abstract fun getTimeDateFunctions(): kotlin.String!
            public abstract fun getTypeInfo(): java.sql.ResultSet!
            public abstract fun getUDTs(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.IntArray!): java.sql.ResultSet!
            public abstract fun getURL(): kotlin.String!
            public abstract fun getUserName(): kotlin.String!
            public abstract fun getVersionColumns(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.ResultSet!
            public abstract fun insertsAreDetected(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isCatalogAtStart(): kotlin.Boolean
            public abstract fun isReadOnly(): kotlin.Boolean
            public abstract fun locatorsUpdateCopy(): kotlin.Boolean
            public abstract fun nullPlusNonNullIsNull(): kotlin.Boolean
            public abstract fun nullsAreSortedAtEnd(): kotlin.Boolean
            public abstract fun nullsAreSortedAtStart(): kotlin.Boolean
            public abstract fun nullsAreSortedHigh(): kotlin.Boolean
            public abstract fun nullsAreSortedLow(): kotlin.Boolean
            public abstract fun othersDeletesAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun othersInsertsAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun othersUpdatesAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun ownDeletesAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun ownInsertsAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun ownUpdatesAreVisible(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun storesLowerCaseIdentifiers(): kotlin.Boolean
            public abstract fun storesLowerCaseQuotedIdentifiers(): kotlin.Boolean
            public abstract fun storesMixedCaseIdentifiers(): kotlin.Boolean
            public abstract fun storesMixedCaseQuotedIdentifiers(): kotlin.Boolean
            public abstract fun storesUpperCaseIdentifiers(): kotlin.Boolean
            public abstract fun storesUpperCaseQuotedIdentifiers(): kotlin.Boolean
            public abstract fun supportsANSI92EntryLevelSQL(): kotlin.Boolean
            public abstract fun supportsANSI92FullSQL(): kotlin.Boolean
            public abstract fun supportsANSI92IntermediateSQL(): kotlin.Boolean
            public abstract fun supportsAlterTableWithAddColumn(): kotlin.Boolean
            public abstract fun supportsAlterTableWithDropColumn(): kotlin.Boolean
            public abstract fun supportsBatchUpdates(): kotlin.Boolean
            public abstract fun supportsCatalogsInDataManipulation(): kotlin.Boolean
            public abstract fun supportsCatalogsInIndexDefinitions(): kotlin.Boolean
            public abstract fun supportsCatalogsInPrivilegeDefinitions(): kotlin.Boolean
            public abstract fun supportsCatalogsInProcedureCalls(): kotlin.Boolean
            public abstract fun supportsCatalogsInTableDefinitions(): kotlin.Boolean
            public abstract fun supportsColumnAliasing(): kotlin.Boolean
            public abstract fun supportsConvert(): kotlin.Boolean
            public abstract fun supportsConvert(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public abstract fun supportsCoreSQLGrammar(): kotlin.Boolean
            public abstract fun supportsCorrelatedSubqueries(): kotlin.Boolean
            public abstract fun supportsDataDefinitionAndDataManipulationTransactions(): kotlin.Boolean
            public abstract fun supportsDataManipulationTransactionsOnly(): kotlin.Boolean
            public abstract fun supportsDifferentTableCorrelationNames(): kotlin.Boolean
            public abstract fun supportsExpressionsInOrderBy(): kotlin.Boolean
            public abstract fun supportsExtendedSQLGrammar(): kotlin.Boolean
            public abstract fun supportsFullOuterJoins(): kotlin.Boolean
            public abstract fun supportsGetGeneratedKeys(): kotlin.Boolean
            public abstract fun supportsGroupBy(): kotlin.Boolean
            public abstract fun supportsGroupByBeyondSelect(): kotlin.Boolean
            public abstract fun supportsGroupByUnrelated(): kotlin.Boolean
            public abstract fun supportsIntegrityEnhancementFacility(): kotlin.Boolean
            public abstract fun supportsLikeEscapeClause(): kotlin.Boolean
            public abstract fun supportsLimitedOuterJoins(): kotlin.Boolean
            public abstract fun supportsMinimumSQLGrammar(): kotlin.Boolean
            public abstract fun supportsMixedCaseIdentifiers(): kotlin.Boolean
            public abstract fun supportsMixedCaseQuotedIdentifiers(): kotlin.Boolean
            public abstract fun supportsMultipleOpenResults(): kotlin.Boolean
            public abstract fun supportsMultipleResultSets(): kotlin.Boolean
            public abstract fun supportsMultipleTransactions(): kotlin.Boolean
            public abstract fun supportsNamedParameters(): kotlin.Boolean
            public abstract fun supportsNonNullableColumns(): kotlin.Boolean
            public abstract fun supportsOpenCursorsAcrossCommit(): kotlin.Boolean
            public abstract fun supportsOpenCursorsAcrossRollback(): kotlin.Boolean
            public abstract fun supportsOpenStatementsAcrossCommit(): kotlin.Boolean
            public abstract fun supportsOpenStatementsAcrossRollback(): kotlin.Boolean
            public abstract fun supportsOrderByUnrelated(): kotlin.Boolean
            public abstract fun supportsOuterJoins(): kotlin.Boolean
            public abstract fun supportsPositionedDelete(): kotlin.Boolean
            public abstract fun supportsPositionedUpdate(): kotlin.Boolean
            public abstract fun supportsResultSetConcurrency(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public abstract fun supportsResultSetHoldability(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun supportsResultSetType(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun supportsSavepoints(): kotlin.Boolean
            public abstract fun supportsSchemasInDataManipulation(): kotlin.Boolean
            public abstract fun supportsSchemasInIndexDefinitions(): kotlin.Boolean
            public abstract fun supportsSchemasInPrivilegeDefinitions(): kotlin.Boolean
            public abstract fun supportsSchemasInProcedureCalls(): kotlin.Boolean
            public abstract fun supportsSchemasInTableDefinitions(): kotlin.Boolean
            public abstract fun supportsSelectForUpdate(): kotlin.Boolean
            public abstract fun supportsStatementPooling(): kotlin.Boolean
            public abstract fun supportsStoredFunctionsUsingCallSyntax(): kotlin.Boolean
            public abstract fun supportsStoredProcedures(): kotlin.Boolean
            public abstract fun supportsSubqueriesInComparisons(): kotlin.Boolean
            public abstract fun supportsSubqueriesInExists(): kotlin.Boolean
            public abstract fun supportsSubqueriesInIns(): kotlin.Boolean
            public abstract fun supportsSubqueriesInQuantifieds(): kotlin.Boolean
            public abstract fun supportsTableCorrelationNames(): kotlin.Boolean
            public abstract fun supportsTransactionIsolationLevel(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun supportsTransactions(): kotlin.Boolean
            public abstract fun supportsUnion(): kotlin.Boolean
            public abstract fun supportsUnionAll(): kotlin.Boolean
            public abstract fun updatesAreDetected(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun usesLocalFilePerTable(): kotlin.Boolean
            public abstract fun usesLocalFiles(): kotlin.Boolean

            // Static members
            public final val attributeNoNulls: kotlin.Short = 0.toShort()
            public final val attributeNullable: kotlin.Short = 1.toShort()
            public final val attributeNullableUnknown: kotlin.Short = 2.toShort()
            public final val bestRowNotPseudo: kotlin.Int = 1
            public final val bestRowPseudo: kotlin.Int = 2
            public final val bestRowSession: kotlin.Int = 2
            public final val bestRowTemporary: kotlin.Int = 0
            public final val bestRowTransaction: kotlin.Int = 1
            public final val bestRowUnknown: kotlin.Int = 0
            public final val columnNoNulls: kotlin.Int = 0
            public final val columnNullable: kotlin.Int = 1
            public final val columnNullableUnknown: kotlin.Int = 2
            public final val functionColumnIn: kotlin.Int = 1
            public final val functionColumnInOut: kotlin.Int = 2
            public final val functionColumnOut: kotlin.Int = 3
            public final val functionColumnResult: kotlin.Int = 5
            public final val functionColumnUnknown: kotlin.Int = 0
            public final val functionNoNulls: kotlin.Int = 0
            public final val functionNoTable: kotlin.Int = 1
            public final val functionNullable: kotlin.Int = 1
            public final val functionNullableUnknown: kotlin.Int = 2
            public final val functionResultUnknown: kotlin.Int = 0
            public final val functionReturn: kotlin.Int = 4
            public final val functionReturnsTable: kotlin.Int = 2
            public final val importedKeyCascade: kotlin.Int = 0
            public final val importedKeyInitiallyDeferred: kotlin.Int = 5
            public final val importedKeyInitiallyImmediate: kotlin.Int = 6
            public final val importedKeyNoAction: kotlin.Int = 3
            public final val importedKeyNotDeferrable: kotlin.Int = 7
            public final val importedKeyRestrict: kotlin.Int = 1
            public final val importedKeySetDefault: kotlin.Int = 4
            public final val importedKeySetNull: kotlin.Int = 2
            public final val procedureColumnIn: kotlin.Int = 1
            public final val procedureColumnInOut: kotlin.Int = 2
            public final val procedureColumnOut: kotlin.Int = 4
            public final val procedureColumnResult: kotlin.Int = 3
            public final val procedureColumnReturn: kotlin.Int = 5
            public final val procedureColumnUnknown: kotlin.Int = 0
            public final val procedureNoNulls: kotlin.Int = 0
            public final val procedureNoResult: kotlin.Int = 1
            public final val procedureNullable: kotlin.Int = 1
            public final val procedureNullableUnknown: kotlin.Int = 2
            public final val procedureResultUnknown: kotlin.Int = 0
            public final val procedureReturnsResult: kotlin.Int = 2
            public final val sqlStateSQL: kotlin.Int = 2
            public final val sqlStateSQL99: kotlin.Int = 2
            public final val sqlStateXOpen: kotlin.Int = 1
            public final val tableIndexClustered: kotlin.Short = 1.toShort()
            public final val tableIndexHashed: kotlin.Short = 2.toShort()
            public final val tableIndexOther: kotlin.Short = 3.toShort()
            public final val tableIndexStatistic: kotlin.Short = 0.toShort()
            public final val typeNoNulls: kotlin.Int = 0
            public final val typeNullable: kotlin.Int = 1
            public final val typeNullableUnknown: kotlin.Int = 2
            public final val typePredBasic: kotlin.Int = 2
            public final val typePredChar: kotlin.Int = 1
            public final val typePredNone: kotlin.Int = 0
            public final val typeSearchable: kotlin.Int = 3
            public final val versionColumnNotPseudo: kotlin.Int = 1
            public final val versionColumnPseudo: kotlin.Int = 2
            public final val versionColumnUnknown: kotlin.Int = 0
        }

        public open class Date : java.util.Date {
            public constructor Date(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor Date(/*0*/ p0: kotlin.Long)
            invisible_fake final override /*1*/ /*fake_override*/ var cdate: sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ var fastTime: kotlin.Long
            public open override /*1*/ /*fake_override*/ fun after(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun before(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Date!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ fun getCalendarDate(): sun.util.calendar.BaseCalendar.Date!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getDate(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getDay(): kotlin.Int
            public open override /*1*/ fun getHours(): kotlin.Int
            public open override /*1*/ fun getMinutes(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getMonth(): kotlin.Int
            public open override /*1*/ fun getSeconds(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getTime(): kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ fun getTimeImpl(): kotlin.Long
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getTimezoneOffset(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getYear(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(): sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!): sun.util.calendar.BaseCalendar.Date!
            invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setDate(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setHours(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setMinutes(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setMonth(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setSeconds(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setTime(/*0*/ p0: kotlin.Long): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setYear(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toGMTString(): kotlin.String!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toLocaleString(): kotlin.String!
            public open override /*1*/ fun toString(): kotlin.String!
            invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 1511598038487230103.toLong()
            public open fun valueOf(/*0*/ p0: kotlin.String!): java.sql.Date!
        }

        public trait Driver {
            public abstract fun acceptsURL(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract fun connect(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Properties!): java.sql.Connection!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getMajorVersion(): kotlin.Int
            public abstract fun getMinorVersion(): kotlin.Int
            public abstract fun getParentLogger(): [ERROR : Unresolved java classifier: Logger]!
            public abstract fun getPropertyInfo(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Properties!): kotlin.Array<(out) java.sql.DriverPropertyInfo!>!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun jdbcCompliant(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public/*package*/ open class DriverInfo {
            public/*package*/ constructor DriverInfo(/*0*/ p0: java.sql.Driver!)
            public/*package*/ final val driver: java.sql.Driver!
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun toString(): kotlin.String!
        }

        public open class DriverManager {
            private constructor DriverManager()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public/*package*/ final val SET_LOG_PERMISSION: java.sql.SQLPermission!
            private final var logStream: java.io.PrintStream!
            private final val logSync: kotlin.Any!
            private final var logWriter: [ERROR : Unresolved java classifier: PrintWriter]!
            private final var loginTimeout: kotlin.Int
            private final val registeredDrivers: [ERROR : Unresolved java classifier: CopyOnWriteArrayList<DriverInfo>]!
            public open fun deregisterDriver(/*0*/ p0: java.sql.Driver!): kotlin.Unit
            private open fun getCallerClassLoader(): java.lang.ClassLoader!
            public open fun getConnection(/*0*/ p0: kotlin.String!): java.sql.Connection!
            public open fun getConnection(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Properties!): java.sql.Connection!
            private open fun getConnection(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Properties!, /*2*/ p2: java.lang.ClassLoader!): java.sql.Connection!
            public open fun getConnection(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.sql.Connection!
            public open fun getDriver(/*0*/ p0: kotlin.String!): java.sql.Driver!
            public open fun getDrivers(): java.util.Enumeration<java.sql.Driver!>!
            public open fun getLogStream(): java.io.PrintStream!
            public open fun getLogWriter(): [ERROR : Unresolved java classifier: PrintWriter]!
            public open fun getLoginTimeout(): kotlin.Int
            private open fun isDriverAllowed(/*0*/ p0: java.sql.Driver!, /*1*/ p1: java.lang.ClassLoader!): kotlin.Boolean
            private open fun loadInitialDrivers(): kotlin.Unit
            public open fun println(/*0*/ p0: kotlin.String!): kotlin.Unit
            public open fun registerDriver(/*0*/ p0: java.sql.Driver!): kotlin.Unit
            public open fun setLogStream(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open fun setLogWriter(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open fun setLoginTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
        }

        public open class DriverPropertyInfo {
            public constructor DriverPropertyInfo(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            public final var choices: kotlin.Array<(out) kotlin.String!>!
            public final var description: kotlin.String!
            public final var name: kotlin.String!
            public final var required: kotlin.Boolean
            public final var value: kotlin.String!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait ParameterMetaData {
            public abstract fun getParameterClassName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getParameterCount(): kotlin.Int
            public abstract fun getParameterMode(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getParameterType(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getParameterTypeName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getPrecision(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getScale(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun isNullable(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun isSigned(/*0*/ p0: kotlin.Int): kotlin.Boolean

            // Static members
            public final val parameterModeIn: kotlin.Int = 1
            public final val parameterModeInOut: kotlin.Int = 2
            public final val parameterModeOut: kotlin.Int = 4
            public final val parameterModeUnknown: kotlin.Int = 0
            public final val parameterNoNulls: kotlin.Int = 0
            public final val parameterNullable: kotlin.Int = 1
            public final val parameterNullableUnknown: kotlin.Int = 2
        }

        public trait PreparedStatement : java.sql.Statement {
            public abstract fun addBatch(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun addBatch(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun cancel(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun clearBatch(): kotlin.Unit
            public abstract fun clearParameters(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun clearWarnings(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun close(): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun closeOnCompletion(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun execute(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun executeBatch(): kotlin.IntArray!
            public abstract fun executeQuery(): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun executeQuery(/*0*/ p0: kotlin.String!): java.sql.ResultSet!
            public abstract fun executeUpdate(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getConnection(): java.sql.Connection!
            public abstract override /*1*/ /*fake_override*/ fun getFetchDirection(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getFetchSize(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getGeneratedKeys(): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun getMaxFieldSize(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getMaxRows(): kotlin.Int
            public abstract fun getMetaData(): java.sql.ResultSetMetaData!
            public abstract override /*1*/ /*fake_override*/ fun getMoreResults(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun getMoreResults(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun getParameterMetaData(): java.sql.ParameterMetaData!
            public abstract override /*1*/ /*fake_override*/ fun getQueryTimeout(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getResultSet(): java.sql.ResultSet!
            public abstract override /*1*/ /*fake_override*/ fun getResultSetConcurrency(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getResultSetHoldability(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getResultSetType(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getUpdateCount(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun getWarnings(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun isCloseOnCompletion(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun isClosed(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun isPoolable(): kotlin.Boolean
            public abstract fun setArray(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Array!): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setBigDecimal(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Blob!): kotlin.Unit
            public abstract fun setBoolean(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public abstract fun setByte(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Byte): kotlin.Unit
            public abstract fun setBytes(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.ByteArray!): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Clob!): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setCursorName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun setDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Date!): kotlin.Unit
            public abstract fun setDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Date!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setDouble(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setEscapeProcessing(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setFetchDirection(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setFetchSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setFloat(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): kotlin.Unit
            public abstract fun setInt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun setLong(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setMaxFieldSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setMaxRows(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun setNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun setNString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun setNull(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun setNull(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.String!): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun setObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setPoolable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun setQueryTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setRef(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Ref!): kotlin.Unit
            public abstract fun setRowId(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract fun setSQLXML(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract fun setShort(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Short): kotlin.Unit
            public abstract fun setString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun setTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Time!): kotlin.Unit
            public abstract fun setTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Time!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Timestamp!): kotlin.Unit
            public abstract fun setTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Timestamp!, /*2*/ p2: java.util.Calendar!): kotlin.Unit
            public abstract fun setURL(/*0*/ p0: kotlin.Int, /*1*/ p1: java.net.URL!): kotlin.Unit
            public abstract fun setUnicodeStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Ref {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getBaseTypeName(): kotlin.String!
            public abstract fun getObject(): kotlin.Any!
            public abstract fun getObject(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun setObject(/*0*/ p0: kotlin.Any!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait ResultSet : java.lang.AutoCloseable {
            public abstract fun absolute(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun afterLast(): kotlin.Unit
            public abstract fun beforeFirst(): kotlin.Unit
            public abstract fun cancelRowUpdates(): kotlin.Unit
            public abstract fun clearWarnings(): kotlin.Unit
            public abstract override /*1*/ fun close(): kotlin.Unit
            public abstract fun deleteRow(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun findColumn(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract fun first(): kotlin.Boolean
            public abstract fun getArray(/*0*/ p0: kotlin.Int): java.sql.Array!
            public abstract fun getArray(/*0*/ p0: kotlin.String!): java.sql.Array!
            public abstract fun getAsciiStream(/*0*/ p0: kotlin.Int): java.io.InputStream!
            public abstract fun getAsciiStream(/*0*/ p0: kotlin.String!): java.io.InputStream!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBigDecimal(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun getBinaryStream(/*0*/ p0: kotlin.Int): java.io.InputStream!
            public abstract fun getBinaryStream(/*0*/ p0: kotlin.String!): java.io.InputStream!
            public abstract fun getBlob(/*0*/ p0: kotlin.Int): java.sql.Blob!
            public abstract fun getBlob(/*0*/ p0: kotlin.String!): java.sql.Blob!
            public abstract fun getBoolean(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun getBoolean(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract fun getByte(/*0*/ p0: kotlin.Int): kotlin.Byte
            public abstract fun getByte(/*0*/ p0: kotlin.String!): kotlin.Byte
            public abstract fun getBytes(/*0*/ p0: kotlin.Int): kotlin.ByteArray!
            public abstract fun getBytes(/*0*/ p0: kotlin.String!): kotlin.ByteArray!
            public abstract fun getCharacterStream(/*0*/ p0: kotlin.Int): java.io.Reader!
            public abstract fun getCharacterStream(/*0*/ p0: kotlin.String!): java.io.Reader!
            public abstract fun getClob(/*0*/ p0: kotlin.Int): java.sql.Clob!
            public abstract fun getClob(/*0*/ p0: kotlin.String!): java.sql.Clob!
            public abstract fun getConcurrency(): kotlin.Int
            public abstract fun getCursorName(): kotlin.String!
            public abstract fun getDate(/*0*/ p0: kotlin.Int): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.String!): java.sql.Date!
            public abstract fun getDate(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Date!
            public abstract fun getDouble(/*0*/ p0: kotlin.Int): kotlin.Double
            public abstract fun getDouble(/*0*/ p0: kotlin.String!): kotlin.Double
            public abstract fun getFetchDirection(): kotlin.Int
            public abstract fun getFetchSize(): kotlin.Int
            public abstract fun getFloat(/*0*/ p0: kotlin.Int): kotlin.Float
            public abstract fun getFloat(/*0*/ p0: kotlin.String!): kotlin.Float
            public abstract fun getHoldability(): kotlin.Int
            public abstract fun getInt(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getInt(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract fun getLong(/*0*/ p0: kotlin.Int): kotlin.Long
            public abstract fun getLong(/*0*/ p0: kotlin.String!): kotlin.Long
            public abstract fun getMetaData(): java.sql.ResultSetMetaData!
            public abstract fun getNCharacterStream(/*0*/ p0: kotlin.Int): java.io.Reader!
            public abstract fun getNCharacterStream(/*0*/ p0: kotlin.String!): java.io.Reader!
            public abstract fun getNClob(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun getNClob(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun getNString(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getNString(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun getObject(/*0*/ p0: kotlin.Int): kotlin.Any!
            public abstract fun </*0*/ T> getObject(/*0*/ p0: kotlin.Int, /*1*/ p1: java.lang.Class<T!>!): T!
            public abstract fun getObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract fun getObject(/*0*/ p0: kotlin.String!): kotlin.Any!
            public abstract fun </*0*/ T> getObject(/*0*/ p0: kotlin.String!, /*1*/ p1: java.lang.Class<T!>!): T!
            public abstract fun getObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Any!
            public abstract fun getRef(/*0*/ p0: kotlin.Int): java.sql.Ref!
            public abstract fun getRef(/*0*/ p0: kotlin.String!): java.sql.Ref!
            public abstract fun getRow(): kotlin.Int
            public abstract fun getRowId(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: RowId]!
            public abstract fun getRowId(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: RowId]!
            public abstract fun getSQLXML(/*0*/ p0: kotlin.Int): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun getSQLXML(/*0*/ p0: kotlin.String!): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun getShort(/*0*/ p0: kotlin.Int): kotlin.Short
            public abstract fun getShort(/*0*/ p0: kotlin.String!): kotlin.Short
            public abstract fun getStatement(): java.sql.Statement!
            public abstract fun getString(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getString(/*0*/ p0: kotlin.String!): kotlin.String!
            public abstract fun getTime(/*0*/ p0: kotlin.Int): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.String!): java.sql.Time!
            public abstract fun getTime(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Time!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.Int): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.util.Calendar!): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.String!): java.sql.Timestamp!
            public abstract fun getTimestamp(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Calendar!): java.sql.Timestamp!
            public abstract fun getType(): kotlin.Int
            public abstract fun getURL(/*0*/ p0: kotlin.Int): java.net.URL!
            public abstract fun getURL(/*0*/ p0: kotlin.String!): java.net.URL!
            public abstract fun getUnicodeStream(/*0*/ p0: kotlin.Int): java.io.InputStream!
            public abstract fun getUnicodeStream(/*0*/ p0: kotlin.String!): java.io.InputStream!
            public abstract fun getWarnings(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun insertRow(): kotlin.Unit
            public abstract fun isAfterLast(): kotlin.Boolean
            public abstract fun isBeforeFirst(): kotlin.Boolean
            public abstract fun isClosed(): kotlin.Boolean
            public abstract fun isFirst(): kotlin.Boolean
            public abstract fun isLast(): kotlin.Boolean
            public abstract fun last(): kotlin.Boolean
            public abstract fun moveToCurrentRow(): kotlin.Unit
            public abstract fun moveToInsertRow(): kotlin.Unit
            public abstract fun next(): kotlin.Boolean
            public abstract fun previous(): kotlin.Boolean
            public abstract fun refreshRow(): kotlin.Unit
            public abstract fun relative(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun rowDeleted(): kotlin.Boolean
            public abstract fun rowInserted(): kotlin.Boolean
            public abstract fun rowUpdated(): kotlin.Boolean
            public abstract fun setFetchDirection(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setFetchSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun updateArray(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Array!): kotlin.Unit
            public abstract fun updateArray(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Array!): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateAsciiStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateBigDecimal(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract fun updateBigDecimal(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateBinaryStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Blob!): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.InputStream!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateBlob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Blob!): kotlin.Unit
            public abstract fun updateBoolean(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public abstract fun updateBoolean(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public abstract fun updateByte(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Byte): kotlin.Unit
            public abstract fun updateByte(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Byte): kotlin.Unit
            public abstract fun updateBytes(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.ByteArray!): kotlin.Unit
            public abstract fun updateBytes(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.ByteArray!): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Clob!): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Clob!): kotlin.Unit
            public abstract fun updateDate(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Date!): kotlin.Unit
            public abstract fun updateDate(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Date!): kotlin.Unit
            public abstract fun updateDouble(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Double): kotlin.Unit
            public abstract fun updateDouble(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Double): kotlin.Unit
            public abstract fun updateFloat(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float): kotlin.Unit
            public abstract fun updateFloat(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Float): kotlin.Unit
            public abstract fun updateInt(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun updateInt(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public abstract fun updateLong(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Unit
            public abstract fun updateLong(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Long): kotlin.Unit
            public abstract fun updateNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateNCharacterStream(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateNCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateNCharacterStream(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!): kotlin.Unit
            public abstract fun updateNClob(/*0*/ p0: kotlin.String!, /*1*/ p1: java.io.Reader!, /*2*/ p2: kotlin.Long): kotlin.Unit
            public abstract fun updateNString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun updateNString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun updateNull(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun updateNull(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun updateObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public abstract fun updateObject(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!): kotlin.Unit
            public abstract fun updateObject(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Any!, /*2*/ p2: kotlin.Int): kotlin.Unit
            public abstract fun updateRef(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Ref!): kotlin.Unit
            public abstract fun updateRef(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Ref!): kotlin.Unit
            public abstract fun updateRow(): kotlin.Unit
            public abstract fun updateRowId(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract fun updateRowId(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract fun updateSQLXML(/*0*/ p0: kotlin.Int, /*1*/ p1: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract fun updateSQLXML(/*0*/ p0: kotlin.String!, /*1*/ p1: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract fun updateShort(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Short): kotlin.Unit
            public abstract fun updateShort(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Short): kotlin.Unit
            public abstract fun updateString(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun updateString(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public abstract fun updateTime(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Time!): kotlin.Unit
            public abstract fun updateTime(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Time!): kotlin.Unit
            public abstract fun updateTimestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: java.sql.Timestamp!): kotlin.Unit
            public abstract fun updateTimestamp(/*0*/ p0: kotlin.String!, /*1*/ p1: java.sql.Timestamp!): kotlin.Unit
            public abstract fun wasNull(): kotlin.Boolean

            // Static members
            public final val CLOSE_CURSORS_AT_COMMIT: kotlin.Int = 2
            public final val CONCUR_READ_ONLY: kotlin.Int = 1007
            public final val CONCUR_UPDATABLE: kotlin.Int = 1008
            public final val FETCH_FORWARD: kotlin.Int = 1000
            public final val FETCH_REVERSE: kotlin.Int = 1001
            public final val FETCH_UNKNOWN: kotlin.Int = 1002
            public final val HOLD_CURSORS_OVER_COMMIT: kotlin.Int = 1
            public final val TYPE_FORWARD_ONLY: kotlin.Int = 1003
            public final val TYPE_SCROLL_INSENSITIVE: kotlin.Int = 1004
            public final val TYPE_SCROLL_SENSITIVE: kotlin.Int = 1005
        }

        public trait ResultSetMetaData {
            public abstract fun getCatalogName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getColumnClassName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getColumnCount(): kotlin.Int
            public abstract fun getColumnDisplaySize(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getColumnLabel(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getColumnName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getColumnType(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getColumnTypeName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getPrecision(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getScale(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getSchemaName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun getTableName(/*0*/ p0: kotlin.Int): kotlin.String!
            public abstract fun isAutoIncrement(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isCaseSensitive(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isCurrency(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isDefinitelyWritable(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isNullable(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun isReadOnly(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isSearchable(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isSigned(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun isWritable(/*0*/ p0: kotlin.Int): kotlin.Boolean

            // Static members
            public final val columnNoNulls: kotlin.Int = 0
            public final val columnNullable: kotlin.Int = 1
            public final val columnNullableUnknown: kotlin.Int = 2
        }

        public trait SQLData {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getSQLTypeName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun readSQL(/*0*/ p0: java.sql.SQLInput!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun writeSQL(/*0*/ p0: java.sql.SQLOutput!): kotlin.Unit
        }

        public open class SQLException : java.lang.Exception, kotlin.MutableIterable<kotlin.Throwable!> {
            public constructor SQLException()
            public constructor SQLException(/*0*/ p0: kotlin.String!)
            public constructor SQLException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            public constructor SQLException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int)
            public constructor SQLException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Throwable!)
            public constructor SQLException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Throwable!)
            public constructor SQLException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor SQLException(/*0*/ p0: kotlin.Throwable!)
            private final var SQLState: kotlin.String!
            private final var next: java.sql.SQLException!
            private final var vendorCode: kotlin.Int
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public open fun getErrorCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open fun getNextException(): java.sql.SQLException!
            public open fun getSQLState(): kotlin.String!
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.Throwable!>!
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open fun setNextException(/*0*/ p0: java.sql.SQLException!): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val nextUpdater: java.util.concurrent.atomic.AtomicReferenceFieldUpdater<java.sql.SQLException!, java.sql.SQLException!>!
            private final val serialVersionUID: kotlin.Long = 2135244094396331484.toLong()
        }

        public trait SQLInput {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun readArray(): java.sql.Array!
            public abstract fun readAsciiStream(): java.io.InputStream!
            public abstract fun readBigDecimal(): [ERROR : Unresolved java classifier: BigDecimal]!
            public abstract fun readBinaryStream(): java.io.InputStream!
            public abstract fun readBlob(): java.sql.Blob!
            public abstract fun readBoolean(): kotlin.Boolean
            public abstract fun readByte(): kotlin.Byte
            public abstract fun readBytes(): kotlin.ByteArray!
            public abstract fun readCharacterStream(): java.io.Reader!
            public abstract fun readClob(): java.sql.Clob!
            public abstract fun readDate(): java.sql.Date!
            public abstract fun readDouble(): kotlin.Double
            public abstract fun readFloat(): kotlin.Float
            public abstract fun readInt(): kotlin.Int
            public abstract fun readLong(): kotlin.Long
            public abstract fun readNClob(): [ERROR : Unresolved java classifier: NClob]!
            public abstract fun readNString(): kotlin.String!
            public abstract fun readObject(): kotlin.Any!
            public abstract fun readRef(): java.sql.Ref!
            public abstract fun readRowId(): [ERROR : Unresolved java classifier: RowId]!
            public abstract fun readSQLXML(): [ERROR : Unresolved java classifier: SQLXML]!
            public abstract fun readShort(): kotlin.Short
            public abstract fun readString(): kotlin.String!
            public abstract fun readTime(): java.sql.Time!
            public abstract fun readTimestamp(): java.sql.Timestamp!
            public abstract fun readURL(): java.net.URL!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun wasNull(): kotlin.Boolean
        }

        public trait SQLOutput {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun writeArray(/*0*/ p0: java.sql.Array!): kotlin.Unit
            public abstract fun writeAsciiStream(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            public abstract fun writeBigDecimal(/*0*/ p0: [ERROR : Unresolved java classifier: BigDecimal]!): kotlin.Unit
            public abstract fun writeBinaryStream(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            public abstract fun writeBlob(/*0*/ p0: java.sql.Blob!): kotlin.Unit
            public abstract fun writeBoolean(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract fun writeByte(/*0*/ p0: kotlin.Byte): kotlin.Unit
            public abstract fun writeBytes(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public abstract fun writeCharacterStream(/*0*/ p0: java.io.Reader!): kotlin.Unit
            public abstract fun writeClob(/*0*/ p0: java.sql.Clob!): kotlin.Unit
            public abstract fun writeDate(/*0*/ p0: java.sql.Date!): kotlin.Unit
            public abstract fun writeDouble(/*0*/ p0: kotlin.Double): kotlin.Unit
            public abstract fun writeFloat(/*0*/ p0: kotlin.Float): kotlin.Unit
            public abstract fun writeInt(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun writeLong(/*0*/ p0: kotlin.Long): kotlin.Unit
            public abstract fun writeNClob(/*0*/ p0: [ERROR : Unresolved java classifier: NClob]!): kotlin.Unit
            public abstract fun writeNString(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun writeObject(/*0*/ p0: java.sql.SQLData!): kotlin.Unit
            public abstract fun writeRef(/*0*/ p0: java.sql.Ref!): kotlin.Unit
            public abstract fun writeRowId(/*0*/ p0: [ERROR : Unresolved java classifier: RowId]!): kotlin.Unit
            public abstract fun writeSQLXML(/*0*/ p0: [ERROR : Unresolved java classifier: SQLXML]!): kotlin.Unit
            public abstract fun writeShort(/*0*/ p0: kotlin.Short): kotlin.Unit
            public abstract fun writeString(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun writeStruct(/*0*/ p0: java.sql.Struct!): kotlin.Unit
            public abstract fun writeTime(/*0*/ p0: java.sql.Time!): kotlin.Unit
            public abstract fun writeTimestamp(/*0*/ p0: java.sql.Timestamp!): kotlin.Unit
            public abstract fun writeURL(/*0*/ p0: java.net.URL!): kotlin.Unit
        }

        public final class SQLPermission {
            public constructor SQLPermission(/*0*/ p0: kotlin.String!)
            public constructor SQLPermission(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = -1439323187199563495.toLong()
        }

        public open class SQLWarning : java.sql.SQLException {
            public constructor SQLWarning()
            public constructor SQLWarning(/*0*/ p0: kotlin.String!)
            public constructor SQLWarning(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            public constructor SQLWarning(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int)
            public constructor SQLWarning(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Throwable!)
            public constructor SQLWarning(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Throwable!)
            public constructor SQLWarning(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor SQLWarning(/*0*/ p0: kotlin.Throwable!)
            invisible_fake final override /*1*/ /*fake_override*/ var SQLState: kotlin.String!
            invisible_fake final override /*1*/ /*fake_override*/ var next: java.sql.SQLException!
            invisible_fake final override /*1*/ /*fake_override*/ var vendorCode: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public open override /*1*/ /*fake_override*/ fun getErrorCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun getNextException(): java.sql.SQLException!
            public open fun getNextWarning(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun getSQLState(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.Throwable!>!
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setNextException(/*0*/ p0: java.sql.SQLException!): kotlin.Unit
            public open fun setNextWarning(/*0*/ p0: java.sql.SQLWarning!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 3917336774604784856.toLong()
        }

        public trait Savepoint {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getSavepointId(): kotlin.Int
            public abstract fun getSavepointName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Statement : java.lang.AutoCloseable {
            public abstract fun addBatch(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun cancel(): kotlin.Unit
            public abstract fun clearBatch(): kotlin.Unit
            public abstract fun clearWarnings(): kotlin.Unit
            public abstract override /*1*/ fun close(): kotlin.Unit
            public abstract fun closeOnCompletion(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun execute(/*0*/ p0: kotlin.String!): kotlin.Boolean
            public abstract fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Boolean
            public abstract fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Boolean
            public abstract fun execute(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Boolean
            public abstract fun executeBatch(): kotlin.IntArray!
            public abstract fun executeQuery(/*0*/ p0: kotlin.String!): java.sql.ResultSet!
            public abstract fun executeUpdate(/*0*/ p0: kotlin.String!): kotlin.Int
            public abstract fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Int
            public abstract fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Int): kotlin.Int
            public abstract fun executeUpdate(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.IntArray!): kotlin.Int
            public abstract fun getConnection(): java.sql.Connection!
            public abstract fun getFetchDirection(): kotlin.Int
            public abstract fun getFetchSize(): kotlin.Int
            public abstract fun getGeneratedKeys(): java.sql.ResultSet!
            public abstract fun getMaxFieldSize(): kotlin.Int
            public abstract fun getMaxRows(): kotlin.Int
            public abstract fun getMoreResults(): kotlin.Boolean
            public abstract fun getMoreResults(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public abstract fun getQueryTimeout(): kotlin.Int
            public abstract fun getResultSet(): java.sql.ResultSet!
            public abstract fun getResultSetConcurrency(): kotlin.Int
            public abstract fun getResultSetHoldability(): kotlin.Int
            public abstract fun getResultSetType(): kotlin.Int
            public abstract fun getUpdateCount(): kotlin.Int
            public abstract fun getWarnings(): java.sql.SQLWarning!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun isCloseOnCompletion(): kotlin.Boolean
            public abstract fun isClosed(): kotlin.Boolean
            public abstract fun isPoolable(): kotlin.Boolean
            public abstract fun setCursorName(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun setEscapeProcessing(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract fun setFetchDirection(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setFetchSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setMaxFieldSize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setMaxRows(/*0*/ p0: kotlin.Int): kotlin.Unit
            public abstract fun setPoolable(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public abstract fun setQueryTimeout(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val CLOSE_ALL_RESULTS: kotlin.Int = 3
            public final val CLOSE_CURRENT_RESULT: kotlin.Int = 1
            public final val EXECUTE_FAILED: kotlin.Int = -3
            public final val KEEP_CURRENT_RESULT: kotlin.Int = 2
            public final val NO_GENERATED_KEYS: kotlin.Int = 2
            public final val RETURN_GENERATED_KEYS: kotlin.Int = 1
            public final val SUCCESS_NO_INFO: kotlin.Int = -2
        }

        public trait Struct {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun getAttributes(): kotlin.Array<(out) kotlin.Any!>!
            public abstract fun getAttributes(/*0*/ p0: kotlin.(Mutable)Map<kotlin.String!, java.lang.Class<*>!>!): kotlin.Array<(out) kotlin.Any!>!
            public abstract fun getSQLTypeName(): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class Time : java.util.Date {
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Time(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor Time(/*0*/ p0: kotlin.Long)
            invisible_fake final override /*1*/ /*fake_override*/ var cdate: sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ var fastTime: kotlin.Long
            public open override /*1*/ /*fake_override*/ fun after(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun before(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Date!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ fun getCalendarDate(): sun.util.calendar.BaseCalendar.Date!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun getDate(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun getDay(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getHours(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getMinutes(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun getMonth(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getSeconds(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getTime(): kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ fun getTimeImpl(): kotlin.Long
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getTimezoneOffset(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun getYear(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(): sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!): sun.util.calendar.BaseCalendar.Date!
            invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun setDate(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setHours(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setMinutes(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun setMonth(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setSeconds(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setTime(/*0*/ p0: kotlin.Long): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ fun setYear(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toGMTString(): kotlin.String!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toLocaleString(): kotlin.String!
            public open override /*1*/ fun toString(): kotlin.String!
            invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 8397324403548013681.toLong()
            public open fun valueOf(/*0*/ p0: kotlin.String!): java.sql.Time!
        }

        public open class Timestamp : java.util.Date {
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Timestamp(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.Int)
            public constructor Timestamp(/*0*/ p0: kotlin.Long)
            invisible_fake final override /*1*/ /*fake_override*/ var cdate: sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ var fastTime: kotlin.Long
            private final var nanos: kotlin.Int
            public open fun after(/*0*/ p0: java.sql.Timestamp!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun after(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open fun before(/*0*/ p0: java.sql.Timestamp!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun before(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
            public open fun compareTo(/*0*/ p0: java.sql.Timestamp!): kotlin.Int
            public open override /*1*/ fun compareTo(/*0*/ other: java.util.Date!): kotlin.Int
            public open fun equals(/*0*/ p0: java.sql.Timestamp!): kotlin.Boolean
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ fun getCalendarDate(): sun.util.calendar.BaseCalendar.Date!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getDate(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getDay(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getHours(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getMinutes(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getMonth(): kotlin.Int
            public open fun getNanos(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getSeconds(): kotlin.Int
            public open override /*1*/ fun getTime(): kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ fun getTimeImpl(): kotlin.Long
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getTimezoneOffset(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun getYear(): kotlin.Int
            public open override /*1*/ fun hashCode(): kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(): sun.util.calendar.BaseCalendar.Date!
            invisible_fake final override /*1*/ /*fake_override*/ fun normalize(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!): sun.util.calendar.BaseCalendar.Date!
            invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setDate(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setHours(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setMinutes(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setMonth(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setNanos(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setSeconds(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun setTime(/*0*/ p0: kotlin.Long): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun setYear(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toGMTString(): kotlin.String!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open override /*1*/ /*fake_override*/ fun toLocaleString(): kotlin.String!
            public open override /*1*/ fun toString(): kotlin.String!
            invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            public/*package*/ final val serialVersionUID: kotlin.Long = 2745179027874758501.toLong()
            public open fun valueOf(/*0*/ p0: kotlin.String!): java.sql.Timestamp!
        }

        public open class Types {
            private constructor Types()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final val ARRAY: kotlin.Int = 2003
            public final val BIGINT: kotlin.Int = -5
            public final val BINARY: kotlin.Int = -2
            public final val BIT: kotlin.Int = -7
            public final val BLOB: kotlin.Int = 2004
            public final val BOOLEAN: kotlin.Int = 16
            public final val CHAR: kotlin.Int = 1
            public final val CLOB: kotlin.Int = 2005
            public final val DATALINK: kotlin.Int = 70
            public final val DATE: kotlin.Int = 91
            public final val DECIMAL: kotlin.Int = 3
            public final val DISTINCT: kotlin.Int = 2001
            public final val DOUBLE: kotlin.Int = 8
            public final val FLOAT: kotlin.Int = 6
            public final val INTEGER: kotlin.Int = 4
            public final val JAVA_OBJECT: kotlin.Int = 2000
            public final val LONGNVARCHAR: kotlin.Int = -16
            public final val LONGVARBINARY: kotlin.Int = -4
            public final val LONGVARCHAR: kotlin.Int = -1
            public final val NCHAR: kotlin.Int = -15
            public final val NCLOB: kotlin.Int = 2011
            public final val NULL: kotlin.Int = 0
            public final val NUMERIC: kotlin.Int = 2
            public final val NVARCHAR: kotlin.Int = -9
            public final val OTHER: kotlin.Int = 1111
            public final val REAL: kotlin.Int = 7
            public final val REF: kotlin.Int = 2006
            public final val ROWID: kotlin.Int = -8
            public final val SMALLINT: kotlin.Int = 5
            public final val SQLXML: kotlin.Int = 2009
            public final val STRUCT: kotlin.Int = 2002
            public final val TIME: kotlin.Int = 92
            public final val TIMESTAMP: kotlin.Int = 93
            public final val TINYINT: kotlin.Int = -6
            public final val VARBINARY: kotlin.Int = -3
            public final val VARCHAR: kotlin.Int = 12
        }
    }

    package java.util {
        public /*synthesized*/ fun </*0*/ T> Comparator(/*0*/ function: (T!, T!) -> kotlin.Int): java.util.Comparator<T>

        public abstract class AbstractCollection</*0*/ E> : kotlin.MutableCollection<E!> {
            protected/*protected and package*/ constructor AbstractCollection</*0*/ E>()
            public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public open override /*1*/ fun clear(): kotlin.Unit
            public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract override /*1*/ fun size(): kotlin.Int
            public open fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ fun toString(): kotlin.String!

            // Static members
            private final val MAX_ARRAY_SIZE: kotlin.Int = 2147483639
            private open fun </*0*/ T> finishToArray(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: kotlin.(Mutable)Iterator<*>!): kotlin.Array<(out) T!>!
            private open fun hugeCapacity(/*0*/ p0: kotlin.Int): kotlin.Int
        }

        public abstract class AbstractList</*0*/ E> : java.util.AbstractCollection<E!>, kotlin.MutableList<E!> {
            protected/*protected and package*/ constructor AbstractList</*0*/ E>()
            protected/*protected and package*/ final var modCount: kotlin.Int
            public open override /*2*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
            public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public open override /*2*/ fun clear(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public abstract override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public open override /*2*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public open override /*1*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*1*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
            public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
            private open fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
            private open fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
            public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            protected/*protected and package*/ open fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
            public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
            public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
            public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

            private open inner class Itr : kotlin.MutableIterator<E!> {
                private constructor Itr()
                public/*package*/ final var cursor: kotlin.Int
                public/*package*/ final var expectedModCount: kotlin.Int
                public/*package*/ final var lastRet: kotlin.Int
                public/*package*/ final fun checkForComodification(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): E!
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class ListItr : java.util.AbstractList.Itr, kotlin.MutableListIterator<E!> {
                public/*package*/ constructor ListItr(/*0*/ p2: kotlin.Int)
                public/*package*/ final override /*1*/ /*fake_override*/ var cursor: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastRet: kotlin.Int
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Unit
                public/*package*/ final override /*1*/ /*fake_override*/ fun checkForComodification(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ fun hasPrevious(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun next(): E!
                public open override /*1*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ fun previous(): E!
                public open override /*1*/ fun previousIndex(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ fun set(/*0*/ e: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            }
        }

        public abstract class AbstractMap</*0*/ K, /*1*/ V> : kotlin.MutableMap<K!, V!> {
            protected/*protected and package*/ constructor AbstractMap</*0*/ K, /*1*/ V>()
            public/*package*/ final var keySet: kotlin.(Mutable)Set<K!>!
            public/*package*/ final var values: kotlin.(Mutable)Collection<V!>!
            public open override /*1*/ fun clear(): kotlin.Unit
            protected/*protected and package*/ open fun clone(): kotlin.Any!
            public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
            public abstract override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
            public open override /*1*/ fun hashCode(): kotlin.Int
            public open override /*1*/ fun isEmpty(): kotlin.Boolean
            public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
            public open override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
            public open override /*1*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            public open override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
            public open override /*1*/ fun size(): kotlin.Int
            public open override /*1*/ fun toString(): kotlin.String!
            public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!

            public open class SimpleEntry</*0*/ K, /*1*/ V> : kotlin.MutableMap.MutableEntry<K!, V!>, java.io.Serializable {
                public constructor SimpleEntry</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?))
                public constructor SimpleEntry</*0*/ K, /*1*/ V>(/*0*/ p0: K!, /*1*/ p1: V!)
                private final val key: K!
                private final var value: V!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun getKey(): K!
                public open override /*1*/ fun getValue(): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                public open override /*2*/ fun toString(): kotlin.String!

                // Static members
                private final val serialVersionUID: kotlin.Long = -8499721149061103585.toLong()
            }

            public open class SimpleImmutableEntry</*0*/ K, /*1*/ V> : kotlin.MutableMap.MutableEntry<K!, V!>, java.io.Serializable {
                public constructor SimpleImmutableEntry</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?))
                public constructor SimpleImmutableEntry</*0*/ K, /*1*/ V>(/*0*/ p0: K!, /*1*/ p1: V!)
                private final val key: K!
                private final val value: V!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun getKey(): K!
                public open override /*1*/ fun getValue(): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                public open override /*2*/ fun toString(): kotlin.String!

                // Static members
                private final val serialVersionUID: kotlin.Long = 7138329143949025153.toLong()
            }

            // Static members
            private open fun eq(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
        }

        public abstract class AbstractQueue</*0*/ E> : java.util.AbstractCollection<E!> {
            protected/*protected and package*/ constructor AbstractQueue</*0*/ E>()
            public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public open override /*1*/ fun clear(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open fun element(): E!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public open fun remove(): E!
            public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
        }

        public abstract class AbstractSequentialList</*0*/ E> : java.util.AbstractList<E!> {
            protected/*protected and package*/ constructor AbstractSequentialList</*0*/ E>()
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
            public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
            public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
            public abstract override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
            invisible_fake open override /*1*/ /*fake_override*/ fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
            public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
            public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
            public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public abstract class AbstractSet</*0*/ E> : java.util.AbstractCollection<E!>, kotlin.MutableSet<E!> {
            protected/*protected and package*/ constructor AbstractSet</*0*/ E>()
            public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun hashCode(): kotlin.Int
            public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
            public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class ArrayList</*0*/ E> : java.util.AbstractList<E!>, kotlin.MutableList<E!>, java.util.RandomAccess, kotlin.Cloneable, java.io.Serializable {
            public constructor ArrayList</*0*/ E>()
            public constructor ArrayList</*0*/ E>(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?))
            public constructor ArrayList</*0*/ E>(/*0*/ p0: kotlin.Int)
            private final var elementData: kotlin.Array<(out) kotlin.Any!>!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
            private final var size: kotlin.Int
            public open override /*2*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*2*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
            public open override /*2*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public open override /*2*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            private open fun batchRemove(/*0*/ p0: kotlin.(Mutable)Collection<*>!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
            public open override /*2*/ fun clear(): kotlin.Unit
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*2*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public/*package*/ open fun elementData(/*0*/ p0: kotlin.Int): E!
            public open fun ensureCapacity(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun ensureCapacityInternal(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*5*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            private open fun fastRemove(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun get(/*0*/ index: kotlin.Int): E!
            private open fun grow(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*5*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*2*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*2*/ fun isEmpty(): kotlin.Boolean
            public open override /*2*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public open override /*2*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
            public open override /*2*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
            public open override /*2*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
            private open fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
            private open fun rangeCheck(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*2*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun remove(/*0*/ index: kotlin.Int): E!
            public open override /*2*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            protected/*protected and package*/ open override /*1*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*2*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
            public open override /*2*/ fun size(): kotlin.Int
            public open override /*2*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
            public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*5*/ /*fake_override*/ fun toString(): kotlin.String
            public open fun trimToSize(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private open inner class Itr : kotlin.MutableIterator<E!> {
                private constructor Itr()
                public/*package*/ final var cursor: kotlin.Int
                public/*package*/ final var expectedModCount: kotlin.Int
                public/*package*/ final var lastRet: kotlin.Int
                public/*package*/ final fun checkForComodification(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): E!
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class ListItr : java.util.ArrayList.Itr, kotlin.MutableListIterator<E!> {
                public/*package*/ constructor ListItr(/*0*/ p2: kotlin.Int)
                public/*package*/ final override /*1*/ /*fake_override*/ var cursor: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastRet: kotlin.Int
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Unit
                public/*package*/ final override /*1*/ /*fake_override*/ fun checkForComodification(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ fun hasPrevious(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun next(): E!
                public open override /*1*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ fun previous(): E!
                public open override /*1*/ fun previousIndex(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ fun set(/*0*/ e: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class SubList : java.util.AbstractList<E!>, java.util.RandomAccess {
                public/*package*/ constructor SubList(/*0*/ p0: java.util.AbstractList<E!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int)
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
                private final val offset: kotlin.Int
                private final val parent: java.util.AbstractList<E!>!
                private final val parentOffset: kotlin.Int
                public/*package*/ final var size: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                private open fun checkForComodification(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                private open fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
                private open fun rangeCheck(/*0*/ p0: kotlin.Int): kotlin.Unit
                private open fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val MAX_ARRAY_SIZE: kotlin.Int = 2147483639
            private final val serialVersionUID: kotlin.Long = 8683452581122892189.toLong()
            private open fun hugeCapacity(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ open fun subListRangeCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
        }

        public open class Arrays {
            private constructor Arrays()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            private open class ArrayList</*0*/ E> : java.util.AbstractList<E!>, java.util.RandomAccess, java.io.Serializable {
                public/*package*/ constructor ArrayList</*0*/ E>(/*0*/ p0: kotlin.Array<(out) E!>!)
                private final val a: kotlin.Array<(out) E!>!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -2764017481108945198.toLong()
            }

            public/*package*/ final class LegacyMergeSort {
                public/*package*/ constructor LegacyMergeSort()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val userRequested: kotlin.Boolean
            }

            // Static members
            private final val INSERTIONSORT_THRESHOLD: kotlin.Int = 7
            [ERROR : java.lang.SafeVarargs]() public open fun </*0*/ T> asList(/*0*/ vararg a: T! /*kotlin.Array<(out) T!>!*/): kotlin.(Mutable)List<T!>!
            public final /*synthesized*/ fun </*0*/ T> binarySearch(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ key: T!, /*2*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            public open fun </*0*/ T> binarySearch(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ key: T!, /*2*/ c: java.util.Comparator<in T!>!): kotlin.Int
            public final /*synthesized*/ fun </*0*/ T> binarySearch(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: T!, /*4*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            public open fun </*0*/ T> binarySearch(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: T!, /*4*/ c: java.util.Comparator<in T!>!): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ key: kotlin.Any!): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Any!): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.ByteArray!, /*1*/ key: kotlin.Byte): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.ByteArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Byte): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.CharArray!, /*1*/ key: kotlin.Char): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.CharArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Char): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.DoubleArray!, /*1*/ key: kotlin.Double): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.DoubleArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Double): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.FloatArray!, /*1*/ key: kotlin.Float): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.FloatArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Float): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.IntArray!, /*1*/ key: kotlin.Int): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.IntArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Int): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.LongArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Long): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.LongArray!, /*1*/ key: kotlin.Long): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.ShortArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ key: kotlin.Short): kotlin.Int
            public open fun binarySearch(/*0*/ a: kotlin.ShortArray!, /*1*/ key: kotlin.Short): kotlin.Int
            private final /*synthesized*/ fun </*0*/ T> binarySearch0(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: T!, /*4*/ p4: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            private open fun </*0*/ T> binarySearch0(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: T!, /*4*/ p4: java.util.Comparator<in T!>!): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Any!): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Byte): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Char): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.DoubleArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Double): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.FloatArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Float): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.LongArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Long): kotlin.Int
            private open fun binarySearch0(/*0*/ p0: kotlin.ShortArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Short): kotlin.Int
            public open fun </*0*/ T> copyOf(/*0*/ original: kotlin.Array<(out) T!>!, /*1*/ newLength: kotlin.Int): kotlin.Array<(out) T!>!
            public open fun </*0*/ T, /*1*/ U> copyOf(/*0*/ original: kotlin.Array<(out) U!>!, /*1*/ newLength: kotlin.Int, /*2*/ newType: java.lang.Class<out kotlin.Array<(out) T!>!>!): kotlin.Array<(out) T!>!
            public open fun copyOf(/*0*/ original: kotlin.BooleanArray!, /*1*/ newLength: kotlin.Int): kotlin.BooleanArray!
            public open fun copyOf(/*0*/ original: kotlin.ByteArray!, /*1*/ newLength: kotlin.Int): kotlin.ByteArray!
            public open fun copyOf(/*0*/ original: kotlin.CharArray!, /*1*/ newLength: kotlin.Int): kotlin.CharArray!
            public open fun copyOf(/*0*/ original: kotlin.DoubleArray!, /*1*/ newLength: kotlin.Int): kotlin.DoubleArray!
            public open fun copyOf(/*0*/ original: kotlin.FloatArray!, /*1*/ newLength: kotlin.Int): kotlin.FloatArray!
            public open fun copyOf(/*0*/ original: kotlin.IntArray!, /*1*/ newLength: kotlin.Int): kotlin.IntArray!
            public open fun copyOf(/*0*/ original: kotlin.LongArray!, /*1*/ newLength: kotlin.Int): kotlin.LongArray!
            public open fun copyOf(/*0*/ original: kotlin.ShortArray!, /*1*/ newLength: kotlin.Int): kotlin.ShortArray!
            public open fun </*0*/ T> copyOfRange(/*0*/ original: kotlin.Array<(out) T!>!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.Array<(out) T!>!
            public open fun </*0*/ T, /*1*/ U> copyOfRange(/*0*/ original: kotlin.Array<(out) U!>!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int, /*3*/ newType: java.lang.Class<out kotlin.Array<(out) T!>!>!): kotlin.Array<(out) T!>!
            public open fun copyOfRange(/*0*/ original: kotlin.BooleanArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.BooleanArray!
            public open fun copyOfRange(/*0*/ original: kotlin.ByteArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.ByteArray!
            public open fun copyOfRange(/*0*/ original: kotlin.CharArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.CharArray!
            public open fun copyOfRange(/*0*/ original: kotlin.DoubleArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.DoubleArray!
            public open fun copyOfRange(/*0*/ original: kotlin.FloatArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.FloatArray!
            public open fun copyOfRange(/*0*/ original: kotlin.IntArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.IntArray!
            public open fun copyOfRange(/*0*/ original: kotlin.LongArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.LongArray!
            public open fun copyOfRange(/*0*/ original: kotlin.ShortArray!, /*1*/ from: kotlin.Int, /*2*/ to: kotlin.Int): kotlin.ShortArray!
            public open fun deepEquals(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!): kotlin.Boolean
            public/*package*/ open fun deepEquals0(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open fun deepHashCode(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!): kotlin.Int
            public open fun deepToString(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!): kotlin.String!
            private open fun deepToString(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: java.lang.StringBuilder!, /*2*/ p2: kotlin.(Mutable)Set<kotlin.Array<(out) kotlin.Any!>!>!): kotlin.Unit
            public open fun equals(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ a2: kotlin.Array<(out) kotlin.Any!>!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.BooleanArray!, /*1*/ p1: kotlin.BooleanArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.ByteArray!, /*1*/ p1: kotlin.ByteArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.CharArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.DoubleArray!, /*1*/ p1: kotlin.DoubleArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.FloatArray!, /*1*/ p1: kotlin.FloatArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.IntArray!, /*1*/ p1: kotlin.IntArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.LongArray!, /*1*/ p1: kotlin.LongArray!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.ShortArray!, /*1*/ p1: kotlin.ShortArray!): kotlin.Boolean
            public open fun fill(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ `val`: kotlin.Any!): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Any!): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.BooleanArray!, /*1*/ `val`: kotlin.Boolean): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.BooleanArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Boolean): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.ByteArray!, /*1*/ `val`: kotlin.Byte): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.ByteArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Byte): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.CharArray!, /*1*/ `val`: kotlin.Char): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.CharArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Char): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.DoubleArray!, /*1*/ `val`: kotlin.Double): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.DoubleArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Double): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.FloatArray!, /*1*/ `val`: kotlin.Float): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.FloatArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Float): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.IntArray!, /*1*/ `val`: kotlin.Int): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.IntArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Int): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.LongArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Long): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.LongArray!, /*1*/ `val`: kotlin.Long): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.ShortArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ `val`: kotlin.Short): kotlin.Unit
            public open fun fill(/*0*/ a: kotlin.ShortArray!, /*1*/ `val`: kotlin.Short): kotlin.Unit
            public open fun hashCode(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.BooleanArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.ByteArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.CharArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.DoubleArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.FloatArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.IntArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.LongArray!): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.ShortArray!): kotlin.Int
            private final /*synthesized*/ fun </*0*/ T> legacyMergeSort(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: ((T!, T!) -> kotlin.Int)!): kotlin.Unit
            private open fun </*0*/ T> legacyMergeSort(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: java.util.Comparator<in T!>!): kotlin.Unit
            private final /*synthesized*/ fun </*0*/ T> legacyMergeSort(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: ((T!, T!) -> kotlin.Int)!): kotlin.Unit
            private open fun </*0*/ T> legacyMergeSort(/*0*/ p0: kotlin.Array<(out) T!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: java.util.Comparator<in T!>!): kotlin.Unit
            private open fun legacyMergeSort(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!): kotlin.Unit
            private open fun legacyMergeSort(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            private open fun mergeSort(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            private open fun mergeSort(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Array<(out) kotlin.Any!>!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: java.util.Comparator<*>!): kotlin.Unit
            private open fun rangeCheck(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final /*synthesized*/ fun </*0*/ T> sort(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Unit
            public open fun </*0*/ T> sort(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ c: java.util.Comparator<in T!>!): kotlin.Unit
            public final /*synthesized*/ fun </*0*/ T> sort(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Unit
            public open fun </*0*/ T> sort(/*0*/ a: kotlin.Array<(out) T!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int, /*3*/ c: java.util.Comparator<in T!>!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.ByteArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.ByteArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.CharArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.CharArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.DoubleArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.DoubleArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.FloatArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.FloatArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.IntArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.IntArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.LongArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.LongArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.ShortArray!): kotlin.Unit
            public open fun sort(/*0*/ a: kotlin.ShortArray!, /*1*/ fromIndex: kotlin.Int, /*2*/ toIndex: kotlin.Int): kotlin.Unit
            private open fun swap(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun toString(/*0*/ a: kotlin.Array<(out) kotlin.Any!>!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.BooleanArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.ByteArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.CharArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.DoubleArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.FloatArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.IntArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.LongArray!): kotlin.String!
            public open fun toString(/*0*/ a: kotlin.ShortArray!): kotlin.String!
        }

        public abstract class Calendar : java.io.Serializable, kotlin.Cloneable, kotlin.Comparable<java.util.Calendar!> {
            protected/*protected and package*/ constructor Calendar()
            protected/*protected and package*/ constructor Calendar(/*0*/ p0: java.util.TimeZone!, /*1*/ p1: java.util.Locale!)
            public/*package*/ final var areAllFieldsSet: kotlin.Boolean
            protected/*protected and package*/ final var areFieldsSet: kotlin.Boolean
            protected/*protected and package*/ final var fields: kotlin.IntArray!
            private final var firstDayOfWeek: kotlin.Int
            protected/*protected and package*/ final var isSet: kotlin.BooleanArray!
            protected/*protected and package*/ final var isTimeSet: kotlin.Boolean
            private final var lenient: kotlin.Boolean
            private final var minimalDaysInFirstWeek: kotlin.Int
            private final var nextStamp: kotlin.Int
            private final var serialVersionOnStream: kotlin.Int
            private final var sharedZone: kotlin.Boolean
            private final var stamp: kotlin.IntArray!
            protected/*protected and package*/ final var time: kotlin.Long
            private final var zone: java.util.TimeZone!
            public abstract fun add(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            private final fun adjustStamp(): kotlin.Unit
            public open fun after(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public open fun before(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public/*package*/ open fun checkDisplayNameParams(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: java.util.Locale!, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public final fun clear(): kotlin.Unit
            public final fun clear(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*1*/ fun compareTo(/*0*/ other: java.util.Calendar!): kotlin.Int
            private open fun compareTo(/*0*/ p0: kotlin.Long): kotlin.Int
            protected/*protected and package*/ open fun complete(): kotlin.Unit
            protected/*protected and package*/ abstract fun computeFields(): kotlin.Unit
            protected/*protected and package*/ abstract fun computeTime(): kotlin.Unit
            public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open fun get(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun getActualMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun getActualMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun getDisplayName(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.Locale!): kotlin.String!
            public open fun getDisplayNames(/*0*/ field: kotlin.Int, /*1*/ style: kotlin.Int, /*2*/ locale: java.util.Locale!): kotlin.(Mutable)Map<kotlin.String!, kotlin.Int!>!
            private open fun getDisplayNamesImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.Locale!): kotlin.(Mutable)Map<kotlin.String!, kotlin.Int!>!
            private open fun getFieldStrings(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: DateFormatSymbols]!): kotlin.Array<(out) kotlin.String!>!
            public open fun getFirstDayOfWeek(): kotlin.Int
            public abstract fun getGreatestMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getLeastMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public abstract fun getMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun getMinimalDaysInFirstWeek(): kotlin.Int
            public abstract fun getMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ final fun getSetStateFields(): kotlin.Int
            public final fun getTime(): java.util.Date!
            public open fun getTimeInMillis(): kotlin.Long
            public open fun getTimeZone(): java.util.TimeZone!
            public open fun getWeekYear(): kotlin.Int
            public open fun getWeeksInWeekYear(): kotlin.Int
            public/*package*/ open fun getZone(): java.util.TimeZone!
            public open override /*3*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ final fun internalGet(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ final fun internalSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            private open fun invalidateWeekFields(): kotlin.Unit
            public/*package*/ final fun isExternallySet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ final fun isFullyNormalized(): kotlin.Boolean
            public open fun isLenient(): kotlin.Boolean
            public/*package*/ final fun isPartiallyNormalized(): kotlin.Boolean
            public final fun isSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open fun isWeekDateSupported(): kotlin.Boolean
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public abstract fun roll(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public open fun roll(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ final fun selectFields(): kotlin.Int
            public open fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Unit
            public/*package*/ final fun setFieldsComputed(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ final fun setFieldsNormalized(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setFirstDayOfWeek(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setLenient(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open fun setMinimalDaysInFirstWeek(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final fun setTime(/*0*/ p0: java.util.Date!): kotlin.Unit
            public open fun setTimeInMillis(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun setTimeZone(/*0*/ p0: java.util.TimeZone!): kotlin.Unit
            public/*package*/ final fun setUnnormalized(): kotlin.Unit
            private open fun setWeekCountData(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open fun setWeekDate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public/*package*/ open fun setZoneShared(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*3*/ fun toString(): kotlin.String!
            private open fun updateTime(): kotlin.Unit
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private open class CalendarAccessControlContext {
                private constructor CalendarAccessControlContext()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val INSTANCE: [ERROR : Unresolved java classifier: AccessControlContext]!
            }

            // Static members
            public/*package*/ final val ALL_FIELDS: kotlin.Int = 131071
            public final val ALL_STYLES: kotlin.Int = 0
            public final val AM: kotlin.Int = 0
            public final val AM_PM: kotlin.Int = 9
            public/*package*/ final val AM_PM_MASK: kotlin.Int = 512
            public final val APRIL: kotlin.Int = 3
            public final val AUGUST: kotlin.Int = 7
            private final val COMPUTED: kotlin.Int = 1
            public final val DATE: kotlin.Int = 5
            public/*package*/ final val DATE_MASK: kotlin.Int = 32
            public final val DAY_OF_MONTH: kotlin.Int = 5
            public/*package*/ final val DAY_OF_MONTH_MASK: kotlin.Int = 32
            public final val DAY_OF_WEEK: kotlin.Int = 7
            public final val DAY_OF_WEEK_IN_MONTH: kotlin.Int = 8
            public/*package*/ final val DAY_OF_WEEK_IN_MONTH_MASK: kotlin.Int = 256
            public/*package*/ final val DAY_OF_WEEK_MASK: kotlin.Int = 128
            public final val DAY_OF_YEAR: kotlin.Int = 6
            public/*package*/ final val DAY_OF_YEAR_MASK: kotlin.Int = 64
            public final val DECEMBER: kotlin.Int = 11
            public final val DST_OFFSET: kotlin.Int = 16
            public/*package*/ final val DST_OFFSET_MASK: kotlin.Int = 65536
            public final val ERA: kotlin.Int = 0
            public/*package*/ final val ERA_MASK: kotlin.Int = 1
            public final val FEBRUARY: kotlin.Int = 1
            public final val FIELD_COUNT: kotlin.Int = 17
            private final val FIELD_NAME: kotlin.Array<(out) kotlin.String!>!
            public final val FRIDAY: kotlin.Int = 6
            public final val HOUR: kotlin.Int = 10
            public/*package*/ final val HOUR_MASK: kotlin.Int = 1024
            public final val HOUR_OF_DAY: kotlin.Int = 11
            public/*package*/ final val HOUR_OF_DAY_MASK: kotlin.Int = 2048
            public final val JANUARY: kotlin.Int = 0
            public final val JULY: kotlin.Int = 6
            public final val JUNE: kotlin.Int = 5
            public final val LONG: kotlin.Int = 2
            public final val MARCH: kotlin.Int = 2
            public final val MAY: kotlin.Int = 4
            public final val MILLISECOND: kotlin.Int = 14
            public/*package*/ final val MILLISECOND_MASK: kotlin.Int = 16384
            private final val MINIMUM_USER_STAMP: kotlin.Int = 2
            public final val MINUTE: kotlin.Int = 12
            public/*package*/ final val MINUTE_MASK: kotlin.Int = 4096
            public final val MONDAY: kotlin.Int = 2
            public final val MONTH: kotlin.Int = 2
            public/*package*/ final val MONTH_MASK: kotlin.Int = 4
            public final val NOVEMBER: kotlin.Int = 10
            public final val OCTOBER: kotlin.Int = 9
            public final val PM: kotlin.Int = 1
            public final val SATURDAY: kotlin.Int = 7
            public final val SECOND: kotlin.Int = 13
            public/*package*/ final val SECOND_MASK: kotlin.Int = 8192
            public final val SEPTEMBER: kotlin.Int = 8
            public final val SHORT: kotlin.Int = 1
            public final val SUNDAY: kotlin.Int = 1
            public final val THURSDAY: kotlin.Int = 5
            public final val TUESDAY: kotlin.Int = 3
            public final val UNDECIMBER: kotlin.Int = 12
            private final val UNSET: kotlin.Int = 0
            public final val WEDNESDAY: kotlin.Int = 4
            public final val WEEK_OF_MONTH: kotlin.Int = 4
            public/*package*/ final val WEEK_OF_MONTH_MASK: kotlin.Int = 16
            public final val WEEK_OF_YEAR: kotlin.Int = 3
            public/*package*/ final val WEEK_OF_YEAR_MASK: kotlin.Int = 8
            public final val YEAR: kotlin.Int = 1
            public/*package*/ final val YEAR_MASK: kotlin.Int = 2
            public final val ZONE_OFFSET: kotlin.Int = 15
            public/*package*/ final val ZONE_OFFSET_MASK: kotlin.Int = 32768
            private final val cachedLocaleData: [ERROR : Unresolved java classifier: ConcurrentMap<Locale, int[]>]!
            public/*package*/ final val currentSerialVersion: kotlin.Int = 1
            public/*package*/ final val serialVersionUID: kotlin.Long = -1807547505821590642.toLong()
            private final fun aggregateStamp(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            private final fun appendValue(/*0*/ p0: java.lang.StringBuilder!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Long): kotlin.Unit
            private open fun createCalendar(/*0*/ p0: java.util.TimeZone!, /*1*/ p1: java.util.Locale!): java.util.Calendar!
            public open fun getAvailableLocales(): kotlin.Array<(out) java.util.Locale!>!
            public/*package*/ final fun getFieldName(/*0*/ p0: kotlin.Int): kotlin.String!
            public open fun getInstance(): java.util.Calendar!
            public open fun getInstance(/*0*/ p0: java.util.Locale!): java.util.Calendar!
            public open fun getInstance(/*0*/ p0: java.util.TimeZone!): java.util.Calendar!
            public open fun getInstance(/*0*/ p0: java.util.TimeZone!, /*1*/ p1: java.util.Locale!): java.util.Calendar!
            private final fun getMillisOf(/*0*/ p0: java.util.Calendar!): kotlin.Long
            public/*package*/ final fun isFieldSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
        }

        public trait Collection</*0*/ E> : kotlin.MutableIterable<E!> {
            public abstract fun add(/*0*/ e: E!): kotlin.Boolean
            public abstract fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public abstract fun clear(): kotlin.Unit
            public abstract fun contains(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public abstract fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public abstract fun remove(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public abstract fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract fun size(): kotlin.Int
            public abstract fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public abstract fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class Collections {
            private constructor Collections()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            public/*package*/ open class AsLIFOQueue</*0*/ E> : java.util.AbstractQueue<E!>, java.io.Serializable {
                public/*package*/ constructor AsLIFOQueue</*0*/ E>(/*0*/ p0: [ERROR : Unresolved java classifier: Deque<E>]!)
                private final val q: [ERROR : Unresolved java classifier: Deque<E>]!
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun element(): E!
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open fun offer(/*0*/ p0: E!): kotlin.Boolean
                public open fun peek(): E!
                public open fun poll(): E!
                public open override /*1*/ fun remove(): E!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ fun toString(): kotlin.String!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1802017725587941708.toLong()
            }

            public/*package*/ open class CheckedCollection</*0*/ E> : kotlin.MutableCollection<E!>, java.io.Serializable {
                public/*package*/ constructor CheckedCollection</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Collection<E!>!, /*1*/ p1: java.lang.Class<E!>!)
                public/*package*/ final val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final val type: java.lang.Class<E!>!
                private final var zeroLengthElementArray: kotlin.Array<(out) E!>!
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                private open fun badElementMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public/*package*/ open fun checkedCopyOf(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.(Mutable)Collection<E!>!
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ fun toString(): kotlin.String!
                public/*package*/ open fun typeCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                private open fun zeroLengthElementArray(): kotlin.Array<(out) E!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1578914078182001775.toLong()
            }

            public/*package*/ open class CheckedList</*0*/ E> : java.util.Collections.CheckedCollection<E!>, kotlin.MutableList<E!> {
                public/*package*/ constructor CheckedList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!, /*1*/ p1: java.lang.Class<E!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final val list: kotlin.(Mutable)List<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val type: java.lang.Class<E!>!
                invisible_fake final override /*1*/ /*fake_override*/ var zeroLengthElementArray: kotlin.Array<(out) E!>!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                invisible_fake open override /*1*/ /*fake_override*/ fun badElementMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkedCopyOf(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.(Mutable)Collection<E!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ open override /*1*/ /*fake_override*/ fun typeCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                invisible_fake open override /*1*/ /*fake_override*/ fun zeroLengthElementArray(): kotlin.Array<(out) E!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 65247728283967356.toLong()
            }

            private open class CheckedMap</*0*/ K, /*1*/ V> : kotlin.MutableMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor CheckedMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.(Mutable)Map<K!, V!>!, /*1*/ p1: java.lang.Class<K!>!, /*2*/ p2: java.lang.Class<V!>!)
                private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public/*package*/ final val keyType: java.lang.Class<K!>!
                private final val m: kotlin.(Mutable)Map<K!, V!>!
                public/*package*/ final val valueType: java.lang.Class<V!>!
                private open fun badKeyMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                private open fun badValueMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public open override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*2*/ fun toString(): kotlin.String!
                private open fun typeCheck(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!

                public/*package*/ open class CheckedEntrySet</*0*/ K, /*1*/ V> : kotlin.MutableSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                    public/*package*/ constructor CheckedEntrySet</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!, /*1*/ p1: java.lang.Class<V!>!)
                    private final val s: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                    private final val valueType: java.lang.Class<V!>!
                    public open override /*1*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                    public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>..kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>?)): kotlin.Boolean
                    private open fun batchRemove(/*0*/ p0: kotlin.(Mutable)Collection<*>!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                    public open override /*1*/ fun clear(): kotlin.Unit
                    public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun isEmpty(): kotlin.Boolean
                    public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                    public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ fun size(): kotlin.Int
                    public open fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                    public open fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                    public open override /*1*/ fun toString(): kotlin.String!

                    private open class CheckedEntry</*0*/ K, /*1*/ V, /*2*/ T> : kotlin.MutableMap.MutableEntry<K!, V!> {
                        public/*package*/ constructor CheckedEntry</*0*/ K, /*1*/ V, /*2*/ T>(/*0*/ p0: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!, /*1*/ p1: java.lang.Class<T!>!)
                        private final val e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                        private final val valueType: java.lang.Class<T!>!
                        private open fun badValueMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                        public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                        public open override /*1*/ fun getKey(): K!
                        public open override /*1*/ fun getValue(): V!
                        public open override /*1*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                        public open override /*1*/ fun toString(): kotlin.String!
                    }

                    // Static members
                    public/*package*/ open fun </*0*/ K, /*1*/ V, /*2*/ T> checkedEntry(/*0*/ p0: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!, /*1*/ p1: java.lang.Class<T!>!): java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry<K!, V!, T!>!
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = 5742860141034234728.toLong()
            }

            public/*package*/ open class CheckedRandomAccessList</*0*/ E> : java.util.Collections.CheckedList<E!>, java.util.RandomAccess {
                public/*package*/ constructor CheckedRandomAccessList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!, /*1*/ p1: java.lang.Class<E!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val list: kotlin.(Mutable)List<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val type: java.lang.Class<E!>!
                invisible_fake final override /*1*/ /*fake_override*/ var zeroLengthElementArray: kotlin.Array<(out) E!>!
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                invisible_fake open override /*1*/ /*fake_override*/ fun badElementMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkedCopyOf(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.(Mutable)Collection<E!>!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ open override /*1*/ /*fake_override*/ fun typeCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                invisible_fake open override /*1*/ /*fake_override*/ fun zeroLengthElementArray(): kotlin.Array<(out) E!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1638200125423088369.toLong()
            }

            public/*package*/ open class CheckedSet</*0*/ E> : java.util.Collections.CheckedCollection<E!>, kotlin.MutableSet<E!>, java.io.Serializable {
                public/*package*/ constructor CheckedSet</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Set<E!>!, /*1*/ p1: java.lang.Class<E!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val type: java.lang.Class<E!>!
                invisible_fake final override /*1*/ /*fake_override*/ var zeroLengthElementArray: kotlin.Array<(out) E!>!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                invisible_fake open override /*1*/ /*fake_override*/ fun badElementMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkedCopyOf(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.(Mutable)Collection<E!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ open override /*1*/ /*fake_override*/ fun typeCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                invisible_fake open override /*1*/ /*fake_override*/ fun zeroLengthElementArray(): kotlin.Array<(out) E!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 4694047833775013803.toLong()
            }

            public/*package*/ open class CheckedSortedMap</*0*/ K, /*1*/ V> : java.util.Collections.CheckedMap<K!, V!>, java.util.SortedMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor CheckedSortedMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.SortedMap<K!, V!>!, /*1*/ p1: java.lang.Class<K!>!, /*2*/ p2: java.lang.Class<V!>!)
                invisible_fake final override /*1*/ /*fake_override*/ var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val keyType: java.lang.Class<K!>!
                invisible_fake final override /*1*/ /*fake_override*/ val m: kotlin.(Mutable)Map<K!, V!>!
                private final val sm: java.util.SortedMap<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val valueType: java.lang.Class<V!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun badKeyMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun badValueMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in K!>!
                public open override /*2*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun firstKey(): K!
                public open override /*2*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headMap(/*0*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun lastKey(): K!
                public open override /*2*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V?
                public open override /*2*/ /*fake_override*/ fun putAll(/*0*/ m: kotlin.Map<out K!, V!>): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any?): V?
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subMap(/*0*/ fromKey: K!, /*1*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*1*/ fun tailMap(/*0*/ fromKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
                invisible_fake open override /*1*/ /*fake_override*/ fun typeCheck(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1599671320688067438.toLong()
            }

            public/*package*/ open class CheckedSortedSet</*0*/ E> : java.util.Collections.CheckedSet<E!>, java.util.SortedSet<E!>, java.io.Serializable {
                public/*package*/ constructor CheckedSortedSet</*0*/ E>(/*0*/ p0: java.util.SortedSet<E!>!, /*1*/ p1: java.lang.Class<E!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                private final val ss: java.util.SortedSet<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val type: java.lang.Class<E!>!
                invisible_fake final override /*1*/ /*fake_override*/ var zeroLengthElementArray: kotlin.Array<(out) E!>!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                invisible_fake open override /*1*/ /*fake_override*/ fun badElementMsg(/*0*/ p0: kotlin.Any!): kotlin.String!
                public/*package*/ open override /*1*/ /*fake_override*/ fun checkedCopyOf(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.(Mutable)Collection<E!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in E!>!
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun first(): E!
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headSet(/*0*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun last(): E!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subSet(/*0*/ fromElement: E!, /*1*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ fun tailSet(/*0*/ fromElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ open override /*1*/ /*fake_override*/ fun typeCheck(/*0*/ p0: kotlin.Any!): kotlin.Unit
                invisible_fake open override /*1*/ /*fake_override*/ fun zeroLengthElementArray(): kotlin.Array<(out) E!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1599911165492914959.toLong()
            }

            private open class CopiesList</*0*/ E> : java.util.AbstractList<E!>, java.util.RandomAccess, java.io.Serializable {
                public/*package*/ constructor CopiesList</*0*/ E>(/*0*/ p0: kotlin.Int, /*1*/ p1: E!)
                public/*package*/ final val element: E!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
                public/*package*/ final val n: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 2739099268398711800.toLong()
            }

            private open class EmptyEnumeration</*0*/ E> : java.util.Enumeration<E!> {
                private constructor EmptyEnumeration</*0*/ E>()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun hasMoreElements(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun nextElement(): E!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val EMPTY_ENUMERATION: java.util.Collections.EmptyEnumeration<kotlin.Any!>!
            }

            private open class EmptyIterator</*0*/ E> : kotlin.MutableIterator<E!> {
                private constructor EmptyIterator</*0*/ E>()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): E!
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val EMPTY_ITERATOR: java.util.Collections.EmptyIterator<kotlin.Any!>!
            }

            private open class EmptyList</*0*/ E> : java.util.AbstractList<E!>, java.util.RandomAccess, java.io.Serializable {
                private constructor EmptyList</*0*/ E>()
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
                private open fun readResolve(): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 8842843931221139166.toLong()
            }

            private open class EmptyListIterator</*0*/ E> : java.util.Collections.EmptyIterator<E!>, kotlin.MutableListIterator<E!> {
                private constructor EmptyListIterator</*0*/ E>()
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ fun hasPrevious(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun next(): E!
                public open override /*1*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ fun previous(): E!
                public open override /*1*/ fun previousIndex(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ fun set(/*0*/ e: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val EMPTY_ITERATOR: java.util.Collections.EmptyListIterator<kotlin.Any!>!
            }

            private open class EmptyMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, java.io.Serializable {
                private constructor EmptyMap</*0*/ K, /*1*/ V>()
                public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                private open fun readResolve(): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = 6428348081105594320.toLong()
            }

            private open class EmptySet</*0*/ E> : java.util.AbstractSet<E!>, java.io.Serializable {
                private constructor EmptySet</*0*/ E>()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                private open fun readResolve(): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 1582296315990362920.toLong()
            }

            private open class ReverseComparator : java.util.Comparator<kotlin.Comparable<kotlin.Any!>!>, java.io.Serializable {
                private constructor ReverseComparator()
                public open override /*1*/ fun compare(/*0*/ p0: kotlin.Comparable<kotlin.Any!>!, /*1*/ p1: kotlin.Comparable<kotlin.Any!>!): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                private open fun readResolve(): kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val REVERSE_ORDER: java.util.Collections.ReverseComparator!
                private final val serialVersionUID: kotlin.Long = 7207038068494060240.toLong()
            }

            private open class ReverseComparator2</*0*/ T> : java.util.Comparator<T!>, java.io.Serializable {
                public/*package*/ /*synthesized*/ constructor ReverseComparator2</*0*/ T>(/*0*/ p0: ((T!, T!) -> kotlin.Int)!)
                public/*package*/ constructor ReverseComparator2</*0*/ T>(/*0*/ p0: java.util.Comparator<T!>!)
                public/*package*/ final val cmp: java.util.Comparator<T!>!
                public open override /*1*/ fun compare(/*0*/ p0: T!, /*1*/ p1: T!): kotlin.Int
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 4374092139857.toLong()
            }

            private trait SelfComparable : kotlin.Comparable<java.util.Collections.SelfComparable!> {
                public abstract override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Collections.SelfComparable!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class SetFromMap</*0*/ E> : java.util.AbstractSet<E!>, kotlin.MutableSet<E!>, java.io.Serializable {
                public/*package*/ constructor SetFromMap</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Map<E!, kotlin.Boolean!>!)
                private final val m: kotlin.(Mutable)Map<E!, kotlin.Boolean!>!
                private final var s: kotlin.(Mutable)Set<E!>!
                public open override /*2*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*2*/ fun clear(): kotlin.Unit
                public open override /*2*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*2*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open override /*2*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                public open override /*2*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*2*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ fun size(): kotlin.Int
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ fun toString(): kotlin.String!

                // Static members
                private final val serialVersionUID: kotlin.Long = 2454657854757543876.toLong()
            }

            private open class SingletonList</*0*/ E> : java.util.AbstractList<E!>, java.util.RandomAccess, java.io.Serializable {
                public/*package*/ constructor SingletonList</*0*/ E>(/*0*/ p0: E!)
                private final val element: E!
                protected/*protected and package*/ final override /*1*/ /*fake_override*/ var modCount: kotlin.Int
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun outOfBoundsMsg(/*0*/ p0: kotlin.Int): kotlin.String!
                invisible_fake open override /*1*/ /*fake_override*/ fun rangeCheckForAdd(/*0*/ p0: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun removeRange(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 3093736618740652951.toLong()
            }

            private open class SingletonMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor SingletonMap</*0*/ K, /*1*/ V>(/*0*/ p0: K!, /*1*/ p1: V!)
                private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                private final val k: K!
                private final override /*1*/ var keySet: kotlin.(Mutable)Set<K!>!
                private final val v: V!
                private final override /*1*/ var values: kotlin.(Mutable)Collection<V!>!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = -6979724477215052911.toLong()
            }

            private open class SingletonSet</*0*/ E> : java.util.AbstractSet<E!>, java.io.Serializable {
                public/*package*/ constructor SingletonSet</*0*/ E>(/*0*/ p0: E!)
                private final val element: E!
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = 3193687207550431679.toLong()
            }

            public/*package*/ open class SynchronizedCollection</*0*/ E> : kotlin.MutableCollection<E!>, java.io.Serializable {
                public/*package*/ constructor SynchronizedCollection</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Collection<E!>!)
                public/*package*/ constructor SynchronizedCollection</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Collection<E!>!, /*1*/ p1: kotlin.Any!)
                public/*package*/ final val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final val mutex: kotlin.Any!
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ fun toString(): kotlin.String!
                private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = 3053995032091335093.toLong()
            }

            public/*package*/ open class SynchronizedList</*0*/ E> : java.util.Collections.SynchronizedCollection<E!>, kotlin.MutableList<E!> {
                public/*package*/ constructor SynchronizedList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!)
                public/*package*/ constructor SynchronizedList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!, /*1*/ p1: kotlin.Any!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final val list: kotlin.(Mutable)List<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val mutex: kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                private open fun readResolve(): kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = -7754090372962971524.toLong()
            }

            private open class SynchronizedMap</*0*/ K, /*1*/ V> : kotlin.MutableMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor SynchronizedMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.(Mutable)Map<K!, V!>!)
                public/*package*/ constructor SynchronizedMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.(Mutable)Map<K!, V!>!, /*1*/ p1: kotlin.Any!)
                private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                private final var keySet: kotlin.(Mutable)Set<K!>!
                private final val m: kotlin.(Mutable)Map<K!, V!>!
                public/*package*/ final val mutex: kotlin.Any!
                private final var values: kotlin.(Mutable)Collection<V!>!
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public open override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*2*/ fun toString(): kotlin.String!
                public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!
                private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = 1978198479659022715.toLong()
            }

            public/*package*/ open class SynchronizedRandomAccessList</*0*/ E> : java.util.Collections.SynchronizedList<E!>, java.util.RandomAccess {
                public/*package*/ constructor SynchronizedRandomAccessList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!)
                public/*package*/ constructor SynchronizedRandomAccessList</*0*/ E>(/*0*/ p0: kotlin.(Mutable)List<E!>!, /*1*/ p1: kotlin.Any!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val list: kotlin.(Mutable)List<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val mutex: kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun readResolve(): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit
                private open fun writeReplace(): kotlin.Any!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1530674583602358482.toLong()
            }

            public/*package*/ open class SynchronizedSet</*0*/ E> : java.util.Collections.SynchronizedCollection<E!>, kotlin.MutableSet<E!> {
                public/*package*/ constructor SynchronizedSet</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Set<E!>!)
                public/*package*/ constructor SynchronizedSet</*0*/ E>(/*0*/ p0: kotlin.(Mutable)Set<E!>!, /*1*/ p1: kotlin.Any!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val mutex: kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = 487447009682186044.toLong()
            }

            public/*package*/ open class SynchronizedSortedMap</*0*/ K, /*1*/ V> : java.util.Collections.SynchronizedMap<K!, V!>, java.util.SortedMap<K!, V!> {
                public/*package*/ constructor SynchronizedSortedMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.SortedMap<K!, V!>!)
                public/*package*/ constructor SynchronizedSortedMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.SortedMap<K!, V!>!, /*1*/ p1: kotlin.Any!)
                invisible_fake final override /*1*/ /*fake_override*/ var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                invisible_fake final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                invisible_fake final override /*1*/ /*fake_override*/ val m: kotlin.(Mutable)Map<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val mutex: kotlin.Any!
                private final val sm: java.util.SortedMap<K!, V!>!
                invisible_fake final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in K!>!
                public open override /*2*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun firstKey(): K!
                public open override /*2*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headMap(/*0*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun lastKey(): K!
                public open override /*2*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V?
                public open override /*2*/ /*fake_override*/ fun putAll(/*0*/ m: kotlin.Map<out K!, V!>): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any?): V?
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subMap(/*0*/ fromKey: K!, /*1*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*1*/ fun tailMap(/*0*/ fromKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*2*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = -8798146769416483793.toLong()
            }

            public/*package*/ open class SynchronizedSortedSet</*0*/ E> : java.util.Collections.SynchronizedSet<E!>, java.util.SortedSet<E!> {
                public/*package*/ constructor SynchronizedSortedSet</*0*/ E>(/*0*/ p0: java.util.SortedSet<E!>!)
                public/*package*/ constructor SynchronizedSortedSet</*0*/ E>(/*0*/ p0: java.util.SortedSet<E!>!, /*1*/ p1: kotlin.Any!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: kotlin.(Mutable)Collection<E!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val mutex: kotlin.Any!
                private final val ss: java.util.SortedSet<E!>!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in E!>!
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun first(): E!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headSet(/*0*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun last(): E!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subSet(/*0*/ fromElement: E!, /*1*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ fun tailSet(/*0*/ fromElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

                // Static members
                private final val serialVersionUID: kotlin.Long = 8695801310862127406.toLong()
            }

            public/*package*/ open class UnmodifiableCollection</*0*/ E> : kotlin.MutableCollection<E!>, java.io.Serializable {
                public/*package*/ constructor UnmodifiableCollection</*0*/ E>(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?))
                public/*package*/ final val c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)
                public open override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ fun toString(): kotlin.String!

                // Static members
                private final val serialVersionUID: kotlin.Long = 1820017752578914078.toLong()
            }

            public/*package*/ open class UnmodifiableList</*0*/ E> : java.util.Collections.UnmodifiableCollection<E!>, kotlin.MutableList<E!> {
                public/*package*/ constructor UnmodifiableList</*0*/ E>(/*0*/ p0: (kotlin.MutableList<out E!>..kotlin.List<E!>?))
                public/*package*/ final override /*1*/ /*fake_override*/ val c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)
                public/*package*/ final val list: (kotlin.MutableList<out E!>..kotlin.List<E!>?)
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                private open fun readResolve(): kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -283967356065247728.toLong()
            }

            private open class UnmodifiableMap</*0*/ K, /*1*/ V> : kotlin.MutableMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor UnmodifiableMap</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?))
                private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                private final var keySet: kotlin.(Mutable)Set<K!>!
                private final val m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)
                private final var values: kotlin.(Mutable)Collection<V!>!
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public open override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*2*/ fun toString(): kotlin.String!
                public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!

                public/*package*/ open class UnmodifiableEntrySet</*0*/ K, /*1*/ V> : java.util.Collections.UnmodifiableSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                    public/*package*/ constructor UnmodifiableEntrySet</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableSet<out (kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?)>..kotlin.Set<(kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?)>?))
                    public/*package*/ final override /*1*/ /*fake_override*/ val c: (kotlin.MutableCollection<out kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>..kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>?)
                    public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                    public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                    public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                    public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                    public open override /*1*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                    private open class UnmodifiableEntry</*0*/ K, /*1*/ V> : kotlin.MutableMap.MutableEntry<K!, V!> {
                        public/*package*/ constructor UnmodifiableEntry</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?))
                        private final var e: (kotlin.MutableMap.MutableEntry<out K!, out V!>..kotlin.Map.Entry<K!, V!>?)
                        public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                        public open override /*1*/ fun getKey(): K!
                        public open override /*1*/ fun getValue(): V!
                        public open override /*1*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                        public open override /*1*/ fun toString(): kotlin.String!
                    }

                    // Static members
                    private final val serialVersionUID: kotlin.Long = 7854390611657943733.toLong()
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = -1034234728574286014.toLong()
            }

            public/*package*/ open class UnmodifiableRandomAccessList</*0*/ E> : java.util.Collections.UnmodifiableList<E!>, java.util.RandomAccess {
                public/*package*/ constructor UnmodifiableRandomAccessList</*0*/ E>(/*0*/ p0: (kotlin.MutableList<out E!>..kotlin.List<E!>?))
                public/*package*/ final override /*1*/ /*fake_override*/ val c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)
                public/*package*/ final override /*1*/ /*fake_override*/ val list: (kotlin.MutableList<out E!>..kotlin.List<E!>?)
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any!): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
                public open override /*1*/ /*fake_override*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
                invisible_fake open override /*1*/ /*fake_override*/ fun readResolve(): kotlin.Any!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ index: kotlin.Int): E!
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
                public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                private open fun writeReplace(): kotlin.Any!

                // Static members
                private final val serialVersionUID: kotlin.Long = -2542308836966382001.toLong()
            }

            public/*package*/ open class UnmodifiableSet</*0*/ E> : java.util.Collections.UnmodifiableCollection<E!>, kotlin.MutableSet<E!>, java.io.Serializable {
                public/*package*/ constructor UnmodifiableSet</*0*/ E>(/*0*/ p0: (kotlin.MutableSet<out E!>..kotlin.Set<E!>?))
                public/*package*/ final override /*1*/ /*fake_override*/ val c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*3*/ fun hashCode(): kotlin.Int
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -9215047833775013803.toLong()
            }

            public/*package*/ open class UnmodifiableSortedMap</*0*/ K, /*1*/ V> : java.util.Collections.UnmodifiableMap<K!, V!>, java.util.SortedMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor UnmodifiableSortedMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.SortedMap<K!, out V!>!)
                invisible_fake final override /*1*/ /*fake_override*/ var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                invisible_fake final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                invisible_fake final override /*1*/ /*fake_override*/ val m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)
                private final val sm: java.util.SortedMap<K!, out V!>!
                invisible_fake final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in K!>!
                public open override /*2*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun firstKey(): K!
                public open override /*2*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headMap(/*0*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun lastKey(): K!
                public open override /*2*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V?
                public open override /*2*/ /*fake_override*/ fun putAll(/*0*/ m: kotlin.Map<out K!, V!>): kotlin.Unit
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any?): V?
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subMap(/*0*/ fromKey: K!, /*1*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*1*/ fun tailMap(/*0*/ fromKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*2*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = -8806743815996713206.toLong()
            }

            public/*package*/ open class UnmodifiableSortedSet</*0*/ E> : java.util.Collections.UnmodifiableSet<E!>, java.util.SortedSet<E!>, java.io.Serializable {
                public/*package*/ constructor UnmodifiableSortedSet</*0*/ E>(/*0*/ p0: java.util.SortedSet<E!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ val c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)
                private final val ss: java.util.SortedSet<E!>!
                public open override /*2*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun comparator(): java.util.Comparator<in E!>!
                public open override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun first(): E!
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headSet(/*0*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
                public open override /*1*/ fun last(): E!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subSet(/*0*/ fromElement: E!, /*1*/ toElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ fun tailSet(/*0*/ fromElement: E!): java.util.SortedSet<E!>!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ p0: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val serialVersionUID: kotlin.Long = -4929149591599911165.toLong()
            }

            // Static members
            private final val BINARYSEARCH_THRESHOLD: kotlin.Int = 5000
            private final val COPY_THRESHOLD: kotlin.Int = 10
            public final val EMPTY_LIST: kotlin.(Mutable)List<*>!
            public final val EMPTY_MAP: kotlin.(Mutable)Map<*, *>!
            public final val EMPTY_SET: kotlin.(Mutable)Set<*>!
            private final val FILL_THRESHOLD: kotlin.Int = 25
            private final val INDEXOFSUBLIST_THRESHOLD: kotlin.Int = 35
            private final val REPLACEALL_THRESHOLD: kotlin.Int = 11
            private final val REVERSE_THRESHOLD: kotlin.Int = 18
            private final val ROTATE_THRESHOLD: kotlin.Int = 100
            private final val SHUFFLE_THRESHOLD: kotlin.Int = 5
            private final var r: java.util.Random!
            private final /*synthesized*/ fun SelfComparable(/*0*/ function: (java.util.Collections.SelfComparable!) -> kotlin.Int): java.util.Collections.SelfComparable
            [ERROR : java.lang.SafeVarargs]() public open fun </*0*/ T> addAll(/*0*/ c: kotlin.(Mutable)Collection<in T!>!, /*1*/ vararg elements: T! /*kotlin.Array<(out) T!>!*/): kotlin.Boolean
            public open fun </*0*/ T> asLifoQueue(/*0*/ deque: [ERROR : Unresolved java classifier: Deque<T>]!): [ERROR : Unresolved java classifier: Queue<T>]!
            public final /*synthesized*/ fun </*0*/ T> binarySearch(/*0*/ list: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ key: T!, /*2*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            public open fun </*0*/ T> binarySearch(/*0*/ list: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ key: T!, /*2*/ c: java.util.Comparator<in T!>!): kotlin.Int
            public open fun </*0*/ T> binarySearch(/*0*/ list: (kotlin.MutableList<out kotlin.Comparable<T!>!>..kotlin.List<kotlin.Comparable<T!>!>?), /*1*/ key: T!): kotlin.Int
            public open fun </*0*/ E> checkedCollection(/*0*/ c: kotlin.(Mutable)Collection<E!>!, /*1*/ _type: java.lang.Class<E!>!): kotlin.(Mutable)Collection<E!>!
            public open fun </*0*/ E> checkedList(/*0*/ list: kotlin.(Mutable)List<E!>!, /*1*/ _type: java.lang.Class<E!>!): kotlin.(Mutable)List<E!>!
            public open fun </*0*/ K, /*1*/ V> checkedMap(/*0*/ m: kotlin.(Mutable)Map<K!, V!>!, /*1*/ keyType: java.lang.Class<K!>!, /*2*/ valueType: java.lang.Class<V!>!): kotlin.(Mutable)Map<K!, V!>!
            public open fun </*0*/ E> checkedSet(/*0*/ s: kotlin.(Mutable)Set<E!>!, /*1*/ _type: java.lang.Class<E!>!): kotlin.(Mutable)Set<E!>!
            public open fun </*0*/ K, /*1*/ V> checkedSortedMap(/*0*/ m: java.util.SortedMap<K!, V!>!, /*1*/ keyType: java.lang.Class<K!>!, /*2*/ valueType: java.lang.Class<V!>!): java.util.SortedMap<K!, V!>!
            public open fun </*0*/ E> checkedSortedSet(/*0*/ s: java.util.SortedSet<E!>!, /*1*/ _type: java.lang.Class<E!>!): java.util.SortedSet<E!>!
            public open fun </*0*/ T> copy(/*0*/ dest: kotlin.(Mutable)List<in T!>!, /*1*/ src: (kotlin.MutableList<out T!>..kotlin.List<T!>?)): kotlin.Unit
            public open fun disjoint(/*0*/ c1: kotlin.(Mutable)Collection<*>!, /*1*/ c2: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open fun </*0*/ T> emptyEnumeration(): java.util.Enumeration<T!>!
            public open fun </*0*/ T> emptyIterator(): kotlin.(Mutable)Iterator<T!>!
            public final fun </*0*/ T> emptyList(): kotlin.(Mutable)List<T!>!
            public open fun </*0*/ T> emptyListIterator(): kotlin.(Mutable)ListIterator<T!>!
            public final fun </*0*/ K, /*1*/ V> emptyMap(): kotlin.(Mutable)Map<K!, V!>!
            public final fun </*0*/ T> emptySet(): kotlin.(Mutable)Set<T!>!
            public open fun </*0*/ T> enumeration(/*0*/ c: kotlin.(Mutable)Collection<T!>!): java.util.Enumeration<T!>!
            public/*package*/ open fun eq(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open fun </*0*/ T> fill(/*0*/ list: kotlin.(Mutable)List<in T!>!, /*1*/ obj: T!): kotlin.Unit
            public open fun frequency(/*0*/ c: kotlin.(Mutable)Collection<*>!, /*1*/ o: kotlin.Any!): kotlin.Int
            private open fun </*0*/ T> get(/*0*/ p0: (kotlin.MutableListIterator<out T!>..kotlin.ListIterator<T!>?), /*1*/ p1: kotlin.Int): T!
            public open fun indexOfSubList(/*0*/ source: kotlin.(Mutable)List<*>!, /*1*/ target: kotlin.(Mutable)List<*>!): kotlin.Int
            private final /*synthesized*/ fun </*0*/ T> indexedBinarySearch(/*0*/ p0: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ p1: T!, /*2*/ p2: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            private open fun </*0*/ T> indexedBinarySearch(/*0*/ p0: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ p1: T!, /*2*/ p2: java.util.Comparator<in T!>!): kotlin.Int
            private open fun </*0*/ T> indexedBinarySearch(/*0*/ p0: (kotlin.MutableList<out kotlin.Comparable<T!>!>..kotlin.List<kotlin.Comparable<T!>!>?), /*1*/ p1: T!): kotlin.Int
            private final /*synthesized*/ fun </*0*/ T> iteratorBinarySearch(/*0*/ p0: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ p1: T!, /*2*/ p2: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            private open fun </*0*/ T> iteratorBinarySearch(/*0*/ p0: (kotlin.MutableList<out T!>..kotlin.List<T!>?), /*1*/ p1: T!, /*2*/ p2: java.util.Comparator<in T!>!): kotlin.Int
            private open fun </*0*/ T> iteratorBinarySearch(/*0*/ p0: (kotlin.MutableList<out kotlin.Comparable<T!>!>..kotlin.List<kotlin.Comparable<T!>!>?), /*1*/ p1: T!): kotlin.Int
            public open fun lastIndexOfSubList(/*0*/ source: kotlin.(Mutable)List<*>!, /*1*/ target: kotlin.(Mutable)List<*>!): kotlin.Int
            public open fun </*0*/ T> list(/*0*/ e: java.util.Enumeration<T!>!): java.util.ArrayList<T!>!
            public open fun </*0*/ T : kotlin.Any!> max(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?)): T! where T : kotlin.Comparable<T!>!
            public final /*synthesized*/ fun </*0*/ T> max(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?), /*1*/ comp: ((T!, T!) -> kotlin.Int)!): T!
            public open fun </*0*/ T> max(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?), /*1*/ comp: java.util.Comparator<in T!>!): T!
            public open fun </*0*/ T : kotlin.Any!> min(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?)): T! where T : kotlin.Comparable<T!>!
            public final /*synthesized*/ fun </*0*/ T> min(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?), /*1*/ comp: ((T!, T!) -> kotlin.Int)!): T!
            public open fun </*0*/ T> min(/*0*/ coll: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?), /*1*/ comp: java.util.Comparator<in T!>!): T!
            public open fun </*0*/ T> nCopies(/*0*/ p0: kotlin.Int, /*1*/ p1: T!): kotlin.(Mutable)List<T!>!
            public open fun </*0*/ E> newSetFromMap(/*0*/ map: kotlin.(Mutable)Map<E!, kotlin.Boolean!>!): kotlin.(Mutable)Set<E!>!
            public open fun </*0*/ T> replaceAll(/*0*/ list: kotlin.(Mutable)List<T!>!, /*1*/ oldVal: T!, /*2*/ newVal: T!): kotlin.Boolean
            public open fun reverse(/*0*/ list: kotlin.(Mutable)List<*>!): kotlin.Unit
            public open fun </*0*/ T> reverseOrder(): java.util.Comparator<T!>!
            public final /*synthesized*/ fun </*0*/ T> reverseOrder(/*0*/ cmp: ((T!, T!) -> kotlin.Int)!): java.util.Comparator<T!>!
            public open fun </*0*/ T> reverseOrder(/*0*/ cmp: java.util.Comparator<T!>!): java.util.Comparator<T!>!
            public open fun rotate(/*0*/ list: kotlin.(Mutable)List<*>!, /*1*/ distance: kotlin.Int): kotlin.Unit
            private open fun </*0*/ T> rotate1(/*0*/ p0: kotlin.(Mutable)List<T!>!, /*1*/ p1: kotlin.Int): kotlin.Unit
            private open fun rotate2(/*0*/ p0: kotlin.(Mutable)List<*>!, /*1*/ p1: kotlin.Int): kotlin.Unit
            public open fun shuffle(/*0*/ list: kotlin.(Mutable)List<*>!): kotlin.Unit
            public open fun shuffle(/*0*/ list: kotlin.(Mutable)List<*>!, /*1*/ rnd: java.util.Random!): kotlin.Unit
            public open fun </*0*/ T> singleton(/*0*/ o: T!): kotlin.(Mutable)Set<T!>!
            public/*package*/ open fun </*0*/ E> singletonIterator(/*0*/ p0: E!): kotlin.(Mutable)Iterator<E!>!
            public open fun </*0*/ T> singletonList(/*0*/ o: T!): kotlin.(Mutable)List<T!>!
            public open fun </*0*/ K, /*1*/ V> singletonMap(/*0*/ key: K!, /*1*/ value: V!): kotlin.(Mutable)Map<K!, V!>!
            public open fun </*0*/ T : kotlin.Comparable<T!>!> sort(/*0*/ list: kotlin.(Mutable)List<T!>!): kotlin.Unit
            public final /*synthesized*/ fun </*0*/ T> sort(/*0*/ list: kotlin.(Mutable)List<T!>!, /*1*/ c: ((T!, T!) -> kotlin.Int)!): kotlin.Unit
            public open fun </*0*/ T> sort(/*0*/ list: kotlin.(Mutable)List<T!>!, /*1*/ c: java.util.Comparator<in T!>!): kotlin.Unit
            public open fun swap(/*0*/ list: kotlin.(Mutable)List<*>!, /*1*/ i: kotlin.Int, /*2*/ j: kotlin.Int): kotlin.Unit
            private open fun swap(/*0*/ p0: kotlin.Array<(out) kotlin.Any!>!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public open fun </*0*/ T> synchronizedCollection(/*0*/ c: kotlin.(Mutable)Collection<T!>!): kotlin.(Mutable)Collection<T!>!
            public/*package*/ open fun </*0*/ T> synchronizedCollection(/*0*/ p0: kotlin.(Mutable)Collection<T!>!, /*1*/ p1: kotlin.Any!): kotlin.(Mutable)Collection<T!>!
            public open fun </*0*/ T> synchronizedList(/*0*/ list: kotlin.(Mutable)List<T!>!): kotlin.(Mutable)List<T!>!
            public/*package*/ open fun </*0*/ T> synchronizedList(/*0*/ p0: kotlin.(Mutable)List<T!>!, /*1*/ p1: kotlin.Any!): kotlin.(Mutable)List<T!>!
            public open fun </*0*/ K, /*1*/ V> synchronizedMap(/*0*/ m: kotlin.(Mutable)Map<K!, V!>!): kotlin.(Mutable)Map<K!, V!>!
            public open fun </*0*/ T> synchronizedSet(/*0*/ s: kotlin.(Mutable)Set<T!>!): kotlin.(Mutable)Set<T!>!
            public/*package*/ open fun </*0*/ T> synchronizedSet(/*0*/ p0: kotlin.(Mutable)Set<T!>!, /*1*/ p1: kotlin.Any!): kotlin.(Mutable)Set<T!>!
            public open fun </*0*/ K, /*1*/ V> synchronizedSortedMap(/*0*/ m: java.util.SortedMap<K!, V!>!): java.util.SortedMap<K!, V!>!
            public open fun </*0*/ T> synchronizedSortedSet(/*0*/ s: java.util.SortedSet<T!>!): java.util.SortedSet<T!>!
            public open fun </*0*/ T> unmodifiableCollection(/*0*/ c: (kotlin.MutableCollection<out T!>..kotlin.Collection<T!>?)): kotlin.(Mutable)Collection<T!>!
            public open fun </*0*/ T> unmodifiableList(/*0*/ list: (kotlin.MutableList<out T!>..kotlin.List<T!>?)): kotlin.(Mutable)List<T!>!
            public open fun </*0*/ K, /*1*/ V> unmodifiableMap(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.(Mutable)Map<K!, V!>!
            public open fun </*0*/ T> unmodifiableSet(/*0*/ s: (kotlin.MutableSet<out T!>..kotlin.Set<T!>?)): kotlin.(Mutable)Set<T!>!
            public open fun </*0*/ K, /*1*/ V> unmodifiableSortedMap(/*0*/ m: java.util.SortedMap<K!, out V!>!): java.util.SortedMap<K!, V!>!
            public open fun </*0*/ T> unmodifiableSortedSet(/*0*/ s: java.util.SortedSet<T!>!): java.util.SortedSet<T!>!
            public/*package*/ open fun </*0*/ T> zeroLengthArray(/*0*/ p0: java.lang.Class<T!>!): kotlin.Array<(out) T!>!
        }

        public trait Comparator</*0*/ T> {
            public abstract fun compare(/*0*/ p0: T!, /*1*/ p1: T!): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class ConcurrentModificationException : java.lang.RuntimeException {
            public constructor ConcurrentModificationException()
            public constructor ConcurrentModificationException(/*0*/ p0: kotlin.String!)
            public constructor ConcurrentModificationException(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Throwable!)
            public constructor ConcurrentModificationException(/*0*/ p0: kotlin.Throwable!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = -3666751008965953603.toLong()
        }

        public open class Date : java.io.Serializable, kotlin.Cloneable, kotlin.Comparable<java.util.Date!> {
            public constructor Date()
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Date(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Date(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Date(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int)
            public constructor Date(/*0*/ p0: kotlin.Long)
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public constructor Date(/*0*/ p0: kotlin.String!)
            private final var cdate: sun.util.calendar.BaseCalendar.Date!
            private final var fastTime: kotlin.Long
            public open fun after(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open fun before(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*1*/ fun compareTo(/*0*/ other: java.util.Date!): kotlin.Int
            public open override /*3*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            private final fun getCalendarDate(): sun.util.calendar.BaseCalendar.Date!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getDate(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getDay(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getHours(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getMinutes(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getMonth(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getSeconds(): kotlin.Int
            public open fun getTime(): kotlin.Long
            private final fun getTimeImpl(): kotlin.Long
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getTimezoneOffset(): kotlin.Int
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun getYear(): kotlin.Int
            public open override /*3*/ fun hashCode(): kotlin.Int
            private final fun normalize(): sun.util.calendar.BaseCalendar.Date!
            private final fun normalize(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!): sun.util.calendar.BaseCalendar.Date!
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setDate(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setHours(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setMinutes(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setMonth(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setSeconds(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setTime(/*0*/ p0: kotlin.Long): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun setYear(/*0*/ p0: kotlin.Int): kotlin.Unit
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun toGMTString(): kotlin.String!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun toLocaleString(): kotlin.String!
            public open override /*3*/ fun toString(): kotlin.String!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            private final var defaultCenturyStart: kotlin.Int
            private final val gcal: sun.util.calendar.BaseCalendar!
            private final var jcal: sun.util.calendar.BaseCalendar!
            private final val serialVersionUID: kotlin.Long = 7523967970034938905.toLong()
            private final val ttb: kotlin.IntArray!
            private final val wtb: kotlin.Array<(out) kotlin.String!>!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun UTC(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Long
            private final fun convertToAbbr(/*0*/ p0: java.lang.StringBuilder!, /*1*/ p1: kotlin.String!): java.lang.StringBuilder!
            private final fun getCalendarSystem(/*0*/ p0: kotlin.Int): sun.util.calendar.BaseCalendar!
            private final fun getCalendarSystem(/*0*/ p0: kotlin.Long): sun.util.calendar.BaseCalendar!
            private final fun getCalendarSystem(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!): sun.util.calendar.BaseCalendar!
            private final fun getJulianCalendar(): sun.util.calendar.BaseCalendar!
            public/*package*/ final fun getMillisOf(/*0*/ p0: java.util.Date!): kotlin.Long
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun parse(/*0*/ p0: kotlin.String!): kotlin.Long
        }

        public trait Enumeration</*0*/ E> {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun hasMoreElements(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun nextElement(): E!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait EventListener {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public open class GregorianCalendar : java.util.Calendar {
            public constructor GregorianCalendar()
            public constructor GregorianCalendar(/*0*/ p0: java.util.Locale!)
            public constructor GregorianCalendar(/*0*/ p0: java.util.TimeZone!)
            public constructor GregorianCalendar(/*0*/ p0: java.util.TimeZone!, /*1*/ p1: java.util.Locale!)
            public constructor GregorianCalendar(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int)
            public constructor GregorianCalendar(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int)
            public constructor GregorianCalendar(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int)
            public/*package*/ constructor GregorianCalendar(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int, /*6*/ p6: kotlin.Int)
            public/*package*/ final override /*1*/ /*fake_override*/ var areAllFieldsSet: kotlin.Boolean
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var areFieldsSet: kotlin.Boolean
            private final var cachedFixedDate: kotlin.Long
            private final var calsys: sun.util.calendar.BaseCalendar!
            private final var cdate: sun.util.calendar.BaseCalendar.Date!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var fields: kotlin.IntArray!
            invisible_fake final override /*1*/ /*fake_override*/ var firstDayOfWeek: kotlin.Int
            private final var gdate: sun.util.calendar.BaseCalendar.Date!
            private final var gregorianCutover: kotlin.Long
            private final var gregorianCutoverDate: kotlin.Long
            private final var gregorianCutoverYear: kotlin.Int
            private final var gregorianCutoverYearJulian: kotlin.Int
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var isSet: kotlin.BooleanArray!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var isTimeSet: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var lenient: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var minimalDaysInFirstWeek: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var nextStamp: kotlin.Int
            private final var originalFields: kotlin.IntArray!
            invisible_fake final override /*1*/ /*fake_override*/ var serialVersionOnStream: kotlin.Int
            invisible_fake final override /*1*/ /*fake_override*/ var sharedZone: kotlin.Boolean
            invisible_fake final override /*1*/ /*fake_override*/ var stamp: kotlin.IntArray!
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ var time: kotlin.Long
            invisible_fake final override /*1*/ /*fake_override*/ var zone: java.util.TimeZone!
            private final var zoneOffsets: kotlin.IntArray!
            private final fun actualMonthLength(): kotlin.Int
            public open override /*1*/ fun add(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake final override /*1*/ /*fake_override*/ fun adjustStamp(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun after(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun before(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public/*package*/ open override /*1*/ /*fake_override*/ fun checkDisplayNameParams(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: java.util.Locale!, /*5*/ p5: kotlin.Int): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun clear(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Calendar!): kotlin.Int
            invisible_fake open override /*1*/ /*fake_override*/ fun compareTo(/*0*/ p0: kotlin.Long): kotlin.Int
            protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun complete(): kotlin.Unit
            protected/*protected and package*/ open override /*1*/ fun computeFields(): kotlin.Unit
            private open fun computeFields(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            protected/*protected and package*/ open override /*1*/ fun computeTime(): kotlin.Unit
            public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun get(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ fun getActualMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ fun getActualMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            private final fun getCalendarDate(/*0*/ p0: kotlin.Long): sun.util.calendar.BaseCalendar.Date!
            private final fun getCurrentFixedDate(): kotlin.Long
            private open fun getCutoverCalendarSystem(): sun.util.calendar.BaseCalendar!
            public open override /*1*/ /*fake_override*/ fun getDisplayName(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.Locale!): kotlin.String!
            public open override /*1*/ /*fake_override*/ fun getDisplayNames(/*0*/ field: kotlin.Int, /*1*/ style: kotlin.Int, /*2*/ locale: java.util.Locale!): kotlin.(Mutable)Map<kotlin.String!, kotlin.Int!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun getDisplayNamesImpl(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.Locale!): kotlin.(Mutable)Map<kotlin.String!, kotlin.Int!>!
            invisible_fake open override /*1*/ /*fake_override*/ fun getFieldStrings(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: [ERROR : Unresolved java classifier: DateFormatSymbols]!): kotlin.Array<(out) kotlin.String!>!
            public open override /*1*/ /*fake_override*/ fun getFirstDayOfWeek(): kotlin.Int
            private open fun getFixedDate(/*0*/ p0: sun.util.calendar.BaseCalendar!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Long
            private final fun getFixedDateJan1(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!, /*1*/ p1: kotlin.Long): kotlin.Long
            private final fun getFixedDateMonth1(/*0*/ p0: sun.util.calendar.BaseCalendar.Date!, /*1*/ p1: kotlin.Long): kotlin.Long
            public open override /*1*/ fun getGreatestMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            public final fun getGregorianChange(): java.util.Date!
            private final fun getGregorianCutoverDate(): sun.util.calendar.BaseCalendar.Date!
            private final fun getLastJulianDate(): sun.util.calendar.BaseCalendar.Date!
            public open override /*1*/ fun getLeastMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ fun getMaximum(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun getMinimalDaysInFirstWeek(): kotlin.Int
            public open override /*1*/ fun getMinimum(/*0*/ p0: kotlin.Int): kotlin.Int
            private final fun getNormalizedCalendar(): java.util.GregorianCalendar!
            public/*package*/ final override /*1*/ /*fake_override*/ fun getSetStateFields(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun getTime(): java.util.Date!
            public open override /*1*/ /*fake_override*/ fun getTimeInMillis(): kotlin.Long
            public open override /*1*/ fun getTimeZone(): java.util.TimeZone!
            private final fun getWeekNumber(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
            public open override /*1*/ fun getWeekYear(): kotlin.Int
            public open override /*1*/ fun getWeeksInWeekYear(): kotlin.Int
            private final fun getYearOffsetInMillis(): kotlin.Long
            public/*package*/ open override /*1*/ /*fake_override*/ fun getZone(): java.util.TimeZone!
            public open override /*1*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun internalGet(/*0*/ p0: kotlin.Int): kotlin.Int
            private final fun internalGetEra(): kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ fun internalSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun invalidateWeekFields(): kotlin.Unit
            private final fun isCutoverYear(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isExternallySet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isFullyNormalized(): kotlin.Boolean
            public open fun isLeapYear(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun isLenient(): kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ fun isPartiallyNormalized(): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun isSet(/*0*/ p0: kotlin.Int): kotlin.Boolean
            public final override /*1*/ fun isWeekDateSupported(): kotlin.Boolean
            private final fun monthLength(/*0*/ p0: kotlin.Int): kotlin.Int
            private final fun monthLength(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            private final fun pinDayOfMonth(): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*1*/ fun roll(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ fun roll(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun selectFields(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setFieldsComputed(/*0*/ p0: kotlin.Int): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setFieldsNormalized(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setFirstDayOfWeek(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open fun setGregorianChange(/*0*/ p0: java.util.Date!): kotlin.Unit
            private open fun setGregorianChange(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setLenient(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setMinimalDaysInFirstWeek(/*0*/ p0: kotlin.Int): kotlin.Unit
            public final override /*1*/ /*fake_override*/ fun setTime(/*0*/ p0: java.util.Date!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun setTimeInMillis(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ fun setTimeZone(/*0*/ p0: java.util.TimeZone!): kotlin.Unit
            public/*package*/ final override /*1*/ /*fake_override*/ fun setUnnormalized(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun setWeekCountData(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open override /*1*/ fun setWeekDate(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Unit
            public/*package*/ open override /*1*/ /*fake_override*/ fun setZoneShared(/*0*/ p0: kotlin.Boolean): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            invisible_fake open override /*1*/ /*fake_override*/ fun updateTime(): kotlin.Unit
            invisible_fake open override /*1*/ /*fake_override*/ fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit
            private final fun yearLength(): kotlin.Int
            private final fun yearLength(/*0*/ p0: kotlin.Int): kotlin.Int

            // Static members
            public final val AD: kotlin.Int = 1
            public final val BC: kotlin.Int = 0
            public/*package*/ final val BCE: kotlin.Int = 0
            public/*package*/ final val CE: kotlin.Int = 1
            public/*package*/ final val DEFAULT_GREGORIAN_CUTOVER: kotlin.Long = -12219292800000.toLong()
            private final val EPOCH_OFFSET: kotlin.Int = 719163
            private final val EPOCH_YEAR: kotlin.Int = 1970
            public/*package*/ final val LEAP_MONTH_LENGTH: kotlin.IntArray!
            public/*package*/ final val LEAST_MAX_VALUES: kotlin.IntArray!
            public/*package*/ final val MAX_VALUES: kotlin.IntArray!
            public/*package*/ final val MIN_VALUES: kotlin.IntArray!
            public/*package*/ final val MONTH_LENGTH: kotlin.IntArray!
            private final val ONE_DAY: kotlin.Long = 86400000.toLong()
            private final val ONE_HOUR: kotlin.Int = 3600000
            private final val ONE_MINUTE: kotlin.Int = 60000
            private final val ONE_SECOND: kotlin.Int = 1000
            private final val ONE_WEEK: kotlin.Long = 604800000.toLong()
            private final val gcal: [ERROR : Unresolved java classifier: Gregorian]!
            private final var jcal: [ERROR : Unresolved java classifier: JulianCalendar]!
            private final var jeras: kotlin.Array<(out) [ERROR : Unresolved java classifier: Era]!>!
            public/*package*/ final val serialVersionUID: kotlin.Long = -8125100834729963327.toLong()
            private final fun getJulianCalendarSystem(): sun.util.calendar.BaseCalendar!
            private final fun getRolledValue(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Int
        }

        public open class HashMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, kotlin.MutableMap<K!, V!>, kotlin.Cloneable, java.io.Serializable {
            public constructor HashMap</*0*/ K, /*1*/ V>()
            public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?))
            public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.Int)
            public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float)
            private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public/*package*/ final val hashSeed: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
            public/*package*/ final val loadFactor: kotlin.Float
            public/*package*/ final var modCount: kotlin.Int
            public/*package*/ final var size: kotlin.Int
            public/*package*/ final var table: kotlin.Array<(out) java.util.HashMap.Entry<K!, V!>!>!
            public/*package*/ final var threshold: kotlin.Int
            public/*package*/ final var useAltHashing: kotlin.Boolean
            public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
            public/*package*/ open fun addEntry(/*0*/ p0: kotlin.Int, /*1*/ p1: K!, /*2*/ p2: V!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public/*package*/ open fun capacity(): kotlin.Int
            public open override /*2*/ fun clear(): kotlin.Unit
            public open override /*2*/ fun clone(): kotlin.Any!
            public open override /*2*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
            private open fun containsNullValue(): kotlin.Boolean
            public open override /*2*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
            public/*package*/ open fun createEntry(/*0*/ p0: kotlin.Int, /*1*/ p1: K!, /*2*/ p2: V!, /*3*/ p3: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            private open fun entrySet0(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*4*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*2*/ fun get(/*0*/ key: kotlin.Any!): V!
            public/*package*/ final fun getEntry(/*0*/ p0: kotlin.Any!): java.util.HashMap.Entry<K!, V!>!
            private open fun getForNullKey(): V!
            public/*package*/ final fun hash(/*0*/ p0: kotlin.Any!): kotlin.Int
            public open override /*4*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public/*package*/ open fun init(): kotlin.Unit
            public open override /*2*/ fun isEmpty(): kotlin.Boolean
            public open override /*2*/ fun keySet(): kotlin.(Mutable)Set<K!>!
            public/*package*/ open fun loadFactor(): kotlin.Float
            public/*package*/ open fun newEntryIterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public/*package*/ open fun newKeyIterator(): kotlin.(Mutable)Iterator<K!>!
            public/*package*/ open fun newValueIterator(): kotlin.(Mutable)Iterator<V!>!
            public open override /*2*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
            public open override /*2*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            private open fun putAllForCreate(/*0*/ p0: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            private open fun putForCreate(/*0*/ p0: K!, /*1*/ p1: V!): kotlin.Unit
            private open fun putForNullKey(/*0*/ p0: V!): V!
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*2*/ fun remove(/*0*/ key: kotlin.Any!): V!
            public/*package*/ final fun removeEntryForKey(/*0*/ p0: kotlin.Any!): java.util.HashMap.Entry<K!, V!>!
            public/*package*/ final fun removeMapping(/*0*/ p0: kotlin.Any!): java.util.HashMap.Entry<K!, V!>!
            public/*package*/ open fun resize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun size(): kotlin.Int
            public open override /*4*/ /*fake_override*/ fun toString(): kotlin.String
            public/*package*/ open fun transfer(/*0*/ p0: kotlin.Array<(out) java.util.HashMap.Entry<*, *>!>!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public open override /*2*/ fun values(): kotlin.(Mutable)Collection<V!>!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            public/*package*/ open class Entry</*0*/ K, /*1*/ V> : kotlin.MutableMap.MutableEntry<K!, V!> {
                public/*package*/ constructor Entry</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.Int, /*1*/ p1: K!, /*2*/ p2: V!, /*3*/ p3: java.util.HashMap.Entry<K!, V!>!)
                public/*package*/ final var hash: kotlin.Int
                public/*package*/ final val key: K!
                public/*package*/ final var next: java.util.HashMap.Entry<K!, V!>!
                public/*package*/ final var value: V!
                public final override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public final override /*1*/ fun getKey(): K!
                public final override /*1*/ fun getValue(): V!
                public final override /*1*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun recordAccess(/*0*/ p0: java.util.HashMap<K!, V!>!): kotlin.Unit
                public/*package*/ open fun recordRemoval(/*0*/ p0: java.util.HashMap<K!, V!>!): kotlin.Unit
                public final override /*1*/ fun setValue(/*0*/ value: V!): V!
                public final override /*1*/ fun toString(): kotlin.String!
            }

            private final inner class EntryIterator : java.util.HashMap.HashIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                private constructor EntryIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var current: java.util.HashMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private final inner class EntrySet : java.util.AbstractSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                private constructor EntrySet()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private abstract inner class HashIterator</*0*/ E> : kotlin.MutableIterator<E!> {
                public/*package*/ constructor HashIterator</*0*/ E>()
                public/*package*/ final var current: java.util.HashMap.Entry<K!, V!>!
                public/*package*/ final var expectedModCount: kotlin.Int
                public/*package*/ final var index: kotlin.Int
                public/*package*/ final var next: java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract override /*1*/ /*fake_override*/ fun next(): E!
                public/*package*/ final fun nextEntry(): java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class Holder {
                private constructor Holder()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val ALTERNATIVE_HASHING_THRESHOLD: kotlin.Int
                public/*package*/ final val HASHSEED_OFFSET: kotlin.Long
                public/*package*/ final val UNSAFE: [ERROR : Unresolved java classifier: Unsafe]!
            }

            private final inner class KeyIterator : java.util.HashMap.HashIterator<K!> {
                private constructor KeyIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var current: java.util.HashMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): K!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private final inner class KeySet : java.util.AbstractSet<K!> {
                private constructor KeySet()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: K!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<K!>): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<K!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private final inner class ValueIterator : java.util.HashMap.HashIterator<V!> {
                private constructor ValueIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var current: java.util.HashMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): V!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.HashMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private final inner class Values : java.util.AbstractCollection<V!> {
                private constructor Values()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: V!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out V!>..kotlin.Collection<V!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<V!>!
                public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            }

            // Static members
            public/*package*/ final val ALTERNATIVE_HASHING_THRESHOLD_DEFAULT: kotlin.Int = 2147483647
            public/*package*/ final val DEFAULT_INITIAL_CAPACITY: kotlin.Int = 16
            public/*package*/ final val DEFAULT_LOAD_FACTOR: kotlin.Float = 0.75.toFloat()
            public/*package*/ final val MAXIMUM_CAPACITY: kotlin.Int = 1073741824
            private final val serialVersionUID: kotlin.Long = 362498820763181265.toLong()
            public/*package*/ open fun indexFor(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
        }

        public open class HashSet</*0*/ E> : java.util.AbstractSet<E!>, kotlin.MutableSet<E!>, kotlin.Cloneable, java.io.Serializable {
            public constructor HashSet</*0*/ E>()
            public constructor HashSet</*0*/ E>(/*0*/ p0: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?))
            public constructor HashSet</*0*/ E>(/*0*/ p0: kotlin.Int)
            public constructor HashSet</*0*/ E>(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float)
            public/*package*/ constructor HashSet</*0*/ E>(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Float, /*2*/ p2: kotlin.Boolean)
            private final var map: java.util.HashMap<E!, kotlin.Any!>!
            public open override /*2*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
            public open override /*2*/ fun clear(): kotlin.Unit
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*2*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*4*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*4*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*2*/ fun isEmpty(): kotlin.Boolean
            public open override /*2*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*2*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*2*/ fun size(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*4*/ /*fake_override*/ fun toString(): kotlin.String
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            private final val PRESENT: kotlin.Any!
            public/*package*/ final val serialVersionUID: kotlin.Long = -5024744406713321676.toLong()
        }

        public open class IdentityHashMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, kotlin.MutableMap<K!, V!>, java.io.Serializable, kotlin.Cloneable {
            public constructor IdentityHashMap</*0*/ K, /*1*/ V>()
            public constructor IdentityHashMap</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?))
            public constructor IdentityHashMap</*0*/ K, /*1*/ V>(/*0*/ p0: kotlin.Int)
            private final var entrySet: kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
            private final var modCount: kotlin.Int
            private final var size: kotlin.Int
            private final var table: kotlin.Array<(out) kotlin.Any!>!
            private final var threshold: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
            private open fun capacity(/*0*/ p0: kotlin.Int): kotlin.Int
            public open override /*2*/ fun clear(): kotlin.Unit
            public open override /*2*/ fun clone(): kotlin.Any!
            private open fun closeDeletion(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
            private open fun containsMapping(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*4*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public open override /*2*/ fun get(/*0*/ key: kotlin.Any!): V!
            public open override /*4*/ fun hashCode(): kotlin.Int
            private open fun init(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun isEmpty(): kotlin.Boolean
            public open override /*2*/ fun keySet(): kotlin.(Mutable)Set<K!>!
            public open override /*2*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
            public open override /*2*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            private open fun putForCreate(/*0*/ p0: K!, /*1*/ p1: V!): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public open override /*2*/ fun remove(/*0*/ key: kotlin.Any!): V!
            private open fun removeMapping(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            private open fun resize(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ fun size(): kotlin.Int
            public open override /*4*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*2*/ fun values(): kotlin.(Mutable)Collection<V!>!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            private open inner class EntryIterator : java.util.IdentityHashMap.IdentityHashMapIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                private constructor EntryIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var indexValid: kotlin.Boolean
                private final var lastReturnedEntry: java.util.IdentityHashMap.EntryIterator.Entry!
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturnedIndex: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var traversalTable: kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                private open inner class Entry : kotlin.MutableMap.MutableEntry<K!, V!> {
                    private constructor Entry(/*0*/ p2: kotlin.Int)
                    private final var index: kotlin.Int
                    private open fun checkIndexForEntryUse(): kotlin.Unit
                    public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ fun getKey(): K!
                    public open override /*1*/ fun getValue(): V!
                    public open override /*1*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                    public open override /*1*/ fun toString(): kotlin.String!
                }
            }

            private open inner class EntrySet : java.util.AbstractSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                private constructor EntrySet()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private abstract inner class IdentityHashMapIterator</*0*/ T> : kotlin.MutableIterator<T!> {
                private constructor IdentityHashMapIterator</*0*/ T>()
                public/*package*/ final var expectedModCount: kotlin.Int
                public/*package*/ final var index: kotlin.Int
                public/*package*/ final var indexValid: kotlin.Boolean
                public/*package*/ final var lastReturnedIndex: kotlin.Int
                public/*package*/ final var traversalTable: kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract override /*1*/ /*fake_override*/ fun next(): T!
                protected/*protected and package*/ open fun nextIndex(): kotlin.Int
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class KeyIterator : java.util.IdentityHashMap.IdentityHashMapIterator<K!> {
                private constructor KeyIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var indexValid: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturnedIndex: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var traversalTable: kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): K!
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class KeySet : java.util.AbstractSet<K!> {
                private constructor KeySet()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: K!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<K!>): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<K!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class ValueIterator : java.util.IdentityHashMap.IdentityHashMapIterator<V!> {
                private constructor ValueIterator()
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var index: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var indexValid: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturnedIndex: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var traversalTable: kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): V!
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class Values : java.util.AbstractCollection<V!> {
                private constructor Values()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: V!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out V!>..kotlin.Collection<V!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<V!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            }

            // Static members
            private final val DEFAULT_CAPACITY: kotlin.Int = 32
            private final val MAXIMUM_CAPACITY: kotlin.Int = 536870912
            private final val MINIMUM_CAPACITY: kotlin.Int = 4
            private final val NULL_KEY: kotlin.Any!
            private final val serialVersionUID: kotlin.Long = 8188218128353913216.toLong()
            private open fun hash(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun maskNull(/*0*/ p0: kotlin.Any!): kotlin.Any!
            private open fun nextKeyIndex(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
            private open fun unmaskNull(/*0*/ p0: kotlin.Any!): kotlin.Any!
        }

        public trait Iterator</*0*/ E> {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun hasNext(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun next(): E!
            public abstract fun remove(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait List</*0*/ E> : kotlin.MutableCollection<E!> {
            public abstract override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public abstract fun add(/*0*/ index: kotlin.Int, /*1*/ element: E!): kotlin.Unit
            public abstract override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public abstract fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public abstract override /*1*/ fun clear(): kotlin.Unit
            public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun get(/*0*/ index: kotlin.Int): E!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun indexOf(/*0*/ p0: kotlin.Any!): kotlin.Int
            public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public abstract fun lastIndexOf(/*0*/ p0: kotlin.Any!): kotlin.Int
            public abstract fun listIterator(): kotlin.(Mutable)ListIterator<E!>!
            public abstract fun listIterator(/*0*/ index: kotlin.Int): kotlin.(Mutable)ListIterator<E!>!
            public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public abstract fun remove(/*0*/ index: kotlin.Int): E!
            public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract fun set(/*0*/ index: kotlin.Int, /*1*/ element: E!): E!
            public abstract override /*1*/ fun size(): kotlin.Int
            public abstract fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.(Mutable)List<E!>!
            public abstract fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public abstract fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait ListIterator</*0*/ E> : kotlin.MutableIterator<E!> {
            public abstract fun add(/*0*/ p0: E!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ fun hasNext(): kotlin.Boolean
            public abstract fun hasPrevious(): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract override /*1*/ fun next(): E!
            public abstract fun nextIndex(): kotlin.Int
            public abstract fun previous(): E!
            public abstract fun previousIndex(): kotlin.Int
            public abstract override /*1*/ fun remove(): kotlin.Unit
            public abstract fun set(/*0*/ p0: E!): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public final class Locale : kotlin.Cloneable, java.io.Serializable {
            private constructor Locale(/*0*/ p0: [ERROR : Unresolved java classifier: BaseLocale]!, /*1*/ p1: [ERROR : Unresolved java classifier: LocaleExtensions]!)
            public constructor Locale(/*0*/ p0: kotlin.String!)
            public constructor Locale(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!)
            public constructor Locale(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!)
            private final var baseLocale: [ERROR : Unresolved java classifier: BaseLocale]!
            private final var hashCodeValue: kotlin.Int
            private final var localeExtensions: [ERROR : Unresolved java classifier: LocaleExtensions]!
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*2*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
            public/*package*/ open fun getBaseLocale(): [ERROR : Unresolved java classifier: BaseLocale]!
            public open fun getCountry(): kotlin.String!
            public final fun getDisplayCountry(): kotlin.String!
            public open fun getDisplayCountry(/*0*/ p0: java.util.Locale!): kotlin.String!
            public final fun getDisplayLanguage(): kotlin.String!
            public open fun getDisplayLanguage(/*0*/ p0: java.util.Locale!): kotlin.String!
            public final fun getDisplayName(): kotlin.String!
            public open fun getDisplayName(/*0*/ p0: java.util.Locale!): kotlin.String!
            public open fun getDisplayScript(): kotlin.String!
            public open fun getDisplayScript(/*0*/ p0: java.util.Locale!): kotlin.String!
            private open fun getDisplayString(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Locale!, /*2*/ p2: kotlin.Int): kotlin.String!
            public final fun getDisplayVariant(): kotlin.String!
            public open fun getDisplayVariant(/*0*/ p0: java.util.Locale!): kotlin.String!
            private open fun getDisplayVariantArray(/*0*/ p0: [ERROR : Unresolved java classifier: OpenListResourceBundle]!, /*1*/ p1: java.util.Locale!): kotlin.Array<(out) kotlin.String!>!
            public open fun getExtension(/*0*/ p0: kotlin.Char): kotlin.String!
            public open fun getExtensionKeys(): kotlin.(Mutable)Set<kotlin.Char!>!
            public open fun getISO3Country(): kotlin.String!
            public open fun getISO3Language(): kotlin.String!
            public open fun getLanguage(): kotlin.String!
            public/*package*/ open fun getLocaleExtensions(): [ERROR : Unresolved java classifier: LocaleExtensions]!
            public open fun getScript(): kotlin.String!
            public open fun getUnicodeLocaleAttributes(): kotlin.(Mutable)Set<kotlin.String!>!
            public open fun getUnicodeLocaleKeys(): kotlin.(Mutable)Set<kotlin.String!>!
            public open fun getUnicodeLocaleType(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getVariant(): kotlin.String!
            public open override /*2*/ fun hashCode(): kotlin.Int
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            private open fun readResolve(): kotlin.Any!
            public open fun toLanguageTag(): kotlin.String!
            public final override /*2*/ fun toString(): kotlin.String!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            public final class Builder {
                public constructor Builder()
                private final val localeBuilder: [ERROR : Unresolved java classifier: InternalLocaleBuilder]!
                public open fun addUnicodeLocaleAttribute(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun build(): java.util.Locale!
                public open fun clear(): java.util.Locale.Builder!
                public open fun clearExtensions(): java.util.Locale.Builder!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open fun removeUnicodeLocaleAttribute(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun setExtension(/*0*/ p0: kotlin.Char, /*1*/ p1: kotlin.String!): java.util.Locale.Builder!
                public open fun setLanguage(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun setLanguageTag(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun setLocale(/*0*/ p0: java.util.Locale!): java.util.Locale.Builder!
                public open fun setRegion(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun setScript(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open fun setUnicodeLocaleKeyword(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): java.util.Locale.Builder!
                public open fun setVariant(/*0*/ p0: kotlin.String!): java.util.Locale.Builder!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class Cache {
                private constructor Cache()
                protected/*protected and package*/ open fun createObject(/*0*/ p0: java.util.Locale.LocaleKey!): java.util.Locale!
            }

            public final enum class Category : kotlin.Enum<java.util.Locale.Category!> {
                public enum entry DISPLAY : java.util.Locale.Category {
                    private constructor DISPLAY()
                    public/*package*/ final override /*1*/ /*fake_override*/ val countryKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val languageKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val scriptKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val variantKey: kotlin.String!
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Locale.Category!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry FORMAT : java.util.Locale.Category {
                    private constructor FORMAT()
                    public/*package*/ final override /*1*/ /*fake_override*/ val countryKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val languageKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val scriptKey: kotlin.String!
                    public/*package*/ final override /*1*/ /*fake_override*/ val variantKey: kotlin.String!
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Locale.Category!): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor Category(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!)
                public/*package*/ final val countryKey: kotlin.String!
                public/*package*/ final val languageKey: kotlin.String!
                public/*package*/ final val scriptKey: kotlin.String!
                public/*package*/ final val variantKey: kotlin.String!
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.Locale.Category!): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.util.Locale.Category
                public final /*synthesized*/ fun values(): kotlin.Array<java.util.Locale.Category>
            }

            private final class LocaleKey {
                private constructor LocaleKey(/*0*/ p0: [ERROR : Unresolved java classifier: BaseLocale]!, /*1*/ p1: [ERROR : Unresolved java classifier: LocaleExtensions]!)
                private final val base: [ERROR : Unresolved java classifier: BaseLocale]!
                private final val exts: [ERROR : Unresolved java classifier: LocaleExtensions]!
                private final val hash: kotlin.Int
                public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open class LocaleNameGetter {
                private constructor LocaleNameGetter()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open fun getObject(/*0*/ p0: [ERROR : Unresolved java classifier: LocaleNameProvider]!, /*1*/ p1: java.util.Locale!, /*2*/ p2: kotlin.String!, /*3*/ vararg p3: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): kotlin.String!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val INSTANCE: java.util.Locale.LocaleNameGetter!
            }

            // Static members
            public final val CANADA: java.util.Locale!
            public final val CANADA_FRENCH: java.util.Locale!
            public final val CHINA: java.util.Locale!
            public final val CHINESE: java.util.Locale!
            private final val DISPLAY_COUNTRY: kotlin.Int = 1
            private final val DISPLAY_LANGUAGE: kotlin.Int = 0
            private final val DISPLAY_SCRIPT: kotlin.Int = 3
            private final val DISPLAY_VARIANT: kotlin.Int = 2
            public final val ENGLISH: java.util.Locale!
            public final val FRANCE: java.util.Locale!
            public final val FRENCH: java.util.Locale!
            public final val GERMAN: java.util.Locale!
            public final val GERMANY: java.util.Locale!
            public final val ITALIAN: java.util.Locale!
            public final val ITALY: java.util.Locale!
            public final val JAPAN: java.util.Locale!
            public final val JAPANESE: java.util.Locale!
            public final val KOREA: java.util.Locale!
            public final val KOREAN: java.util.Locale!
            private final val LOCALECACHE: java.util.Locale.Cache!
            public final val PRC: java.util.Locale!
            public final val PRIVATE_USE_EXTENSION: kotlin.Char = \u0078 ('x')
            public final val ROOT: java.util.Locale!
            public final val SIMPLIFIED_CHINESE: java.util.Locale!
            public final val TAIWAN: java.util.Locale!
            public final val TRADITIONAL_CHINESE: java.util.Locale!
            public final val UK: java.util.Locale!
            public final val UNICODE_LOCALE_EXTENSION: kotlin.Char = \u0075 ('u')
            public final val US: java.util.Locale!
            private final var defaultDisplayLocale: java.util.Locale!
            private final var defaultFormatLocale: java.util.Locale!
            private final var defaultLocale: java.util.Locale!
            private final var isoCountries: kotlin.Array<(out) kotlin.String!>!
            private final var isoLanguages: kotlin.Array<(out) kotlin.String!>!
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            public/*package*/ final val serialVersionUID: kotlin.Long = 9149081749638150636.toLong()
            private open fun composeList(/*0*/ p0: [ERROR : Unresolved java classifier: MessageFormat]!, /*1*/ p1: kotlin.Array<(out) kotlin.String!>!): kotlin.Array<(out) kotlin.String!>!
            private open fun convertOldISOCodes(/*0*/ p0: kotlin.String!): kotlin.String!
            private open fun createConstant(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): java.util.Locale!
            public open fun forLanguageTag(/*0*/ p0: kotlin.String!): java.util.Locale!
            private open fun formatList(/*0*/ p0: kotlin.Array<(out) kotlin.String!>!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.String!
            public open fun getAvailableLocales(): kotlin.Array<(out) java.util.Locale!>!
            private open fun getCompatibilityExtensions(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!): [ERROR : Unresolved java classifier: LocaleExtensions]!
            public open fun getDefault(): java.util.Locale!
            public open fun getDefault(/*0*/ p0: java.util.Locale.Category!): java.util.Locale!
            private final fun getISO2Table(/*0*/ p0: kotlin.String!): kotlin.Array<(out) kotlin.String!>!
            private final fun getISO3Code(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun getISOCountries(): kotlin.Array<(out) kotlin.String!>!
            public open fun getISOLanguages(): kotlin.Array<(out) kotlin.String!>!
            public/*package*/ open fun getInstance(/*0*/ p0: [ERROR : Unresolved java classifier: BaseLocale]!, /*1*/ p1: [ERROR : Unresolved java classifier: LocaleExtensions]!): java.util.Locale!
            public/*package*/ open fun getInstance(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): java.util.Locale!
            public/*package*/ open fun getInstance(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!, /*3*/ p3: kotlin.String!, /*4*/ p4: [ERROR : Unresolved java classifier: LocaleExtensions]!): java.util.Locale!
            private open fun initDefault(): kotlin.Unit
            private open fun initDefault(/*0*/ p0: java.util.Locale.Category!): kotlin.Unit
            public open fun setDefault(/*0*/ p0: java.util.Locale!): kotlin.Unit
            public open fun setDefault(/*0*/ p0: java.util.Locale.Category!, /*1*/ p1: java.util.Locale!): kotlin.Unit
        }

        public trait Map</*0*/ K, /*1*/ V> {
            public abstract fun clear(): kotlin.Unit
            public abstract fun containsKey(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public abstract fun containsValue(/*0*/ p0: kotlin.Any!): kotlin.Boolean
            public abstract fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun get(/*0*/ p0: kotlin.Any!): V!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun isEmpty(): kotlin.Boolean
            public abstract fun keySet(): kotlin.(Mutable)Set<K!>!
            public abstract fun put(/*0*/ key: K!, /*1*/ value: V!): V!
            public abstract fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            public abstract fun remove(/*0*/ p0: kotlin.Any!): V!
            public abstract fun size(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun values(): kotlin.(Mutable)Collection<V!>!

            public trait Entry</*0*/ K, /*1*/ V> {
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public abstract fun getKey(): K!
                public abstract fun getValue(): V!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract fun setValue(/*0*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }
        }

        public open class NoSuchElementException : java.lang.RuntimeException {
            public constructor NoSuchElementException()
            public constructor NoSuchElementException(/*0*/ p0: kotlin.String!)
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public final override /*1*/ /*fake_override*/ fun getCause(): kotlin.Throwable?
            public final override /*1*/ /*fake_override*/ fun getMessage(): kotlin.String?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public final override /*1*/ /*fake_override*/ fun printStackTrace(): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            private final val serialVersionUID: kotlin.Long = 6769829250639411880.toLong()
        }

        public final class Objects {
            private constructor Objects()
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

            // Static members
            public final /*synthesized*/ fun </*0*/ T> compare(/*0*/ p0: T!, /*1*/ p1: T!, /*2*/ p2: ((T!, T!) -> kotlin.Int)!): kotlin.Int
            public open fun </*0*/ T> compare(/*0*/ p0: T!, /*1*/ p1: T!, /*2*/ p2: java.util.Comparator<in T!>!): kotlin.Int
            public open fun deepEquals(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open fun equals(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
            public open fun hash(/*0*/ vararg p0: kotlin.Any! /*kotlin.Array<(out) kotlin.Any!>!*/): kotlin.Int
            public open fun hashCode(/*0*/ p0: kotlin.Any!): kotlin.Int
            public open fun </*0*/ T> requireNonNull(/*0*/ p0: T!): T!
            public open fun </*0*/ T> requireNonNull(/*0*/ p0: T!, /*1*/ p1: kotlin.String!): T!
            public open fun toString(/*0*/ p0: kotlin.Any!): kotlin.String!
            public open fun toString(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.String!): kotlin.String!
        }

        public open class Properties {
            public constructor Properties()
            public constructor Properties(/*0*/ p0: java.util.Properties!)
            protected/*protected and package*/ final var defaults: java.util.Properties!
            private open fun enumerate(/*0*/ p0: [ERROR : Unresolved java classifier: Hashtable]!): kotlin.Unit
            private open fun enumerateStringProperties(/*0*/ p0: [ERROR : Unresolved java classifier: Hashtable<String, String>]!): kotlin.Unit
            public open fun getProperty(/*0*/ p0: kotlin.String!): kotlin.String!
            public open fun getProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun list(/*0*/ p0: [ERROR : Unresolved java classifier: PrintWriter]!): kotlin.Unit
            public open fun list(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
            public open fun load(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            public open fun load(/*0*/ p0: java.io.Reader!): kotlin.Unit
            private open fun load0(/*0*/ p0: java.util.Properties.LineReader!): kotlin.Unit
            private open fun loadConvert(/*0*/ p0: kotlin.CharArray!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.CharArray!): kotlin.String!
            public open fun loadFromXML(/*0*/ p0: java.io.InputStream!): kotlin.Unit
            public open fun propertyNames(): java.util.Enumeration<*>!
            kotlin.deprecated(value = "Deprecated in Java": kotlin.String) public open fun save(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            private open fun saveConvert(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: kotlin.Boolean): kotlin.String!
            public open fun setProperty(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.Any!
            public open fun store(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open fun store(/*0*/ p0: java.io.Writer!, /*1*/ p1: kotlin.String!): kotlin.Unit
            private open fun store0(/*0*/ p0: java.io.BufferedWriter!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.Boolean): kotlin.Unit
            public open fun storeToXML(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!): kotlin.Unit
            public open fun storeToXML(/*0*/ p0: java.io.OutputStream!, /*1*/ p1: kotlin.String!, /*2*/ p2: kotlin.String!): kotlin.Unit
            public open fun stringPropertyNames(): kotlin.(Mutable)Set<kotlin.String!>!

            public/*package*/ open inner class LineReader {
                public constructor LineReader(/*0*/ p2: java.io.InputStream!)
                public constructor LineReader(/*0*/ p2: java.io.Reader!)
                public/*package*/ final var inByteBuf: kotlin.ByteArray!
                public/*package*/ final var inCharBuf: kotlin.CharArray!
                public/*package*/ final var inLimit: kotlin.Int
                public/*package*/ final var inOff: kotlin.Int
                public/*package*/ final var inStream: java.io.InputStream!
                public/*package*/ final var lineBuf: kotlin.CharArray!
                public/*package*/ final var reader: java.io.Reader!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public/*package*/ open fun readLine(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            // Static members
            private final val hexDigit: kotlin.CharArray!
            private final val serialVersionUID: kotlin.Long = 4112578634029874840.toLong()
            private open fun toHex(/*0*/ p0: kotlin.Int): kotlin.Char
            private open fun writeComments(/*0*/ p0: java.io.BufferedWriter!, /*1*/ p1: kotlin.String!): kotlin.Unit
        }

        public open class Random : java.io.Serializable {
            public constructor Random()
            public constructor Random(/*0*/ p0: kotlin.Long)
            private final var haveNextNextGaussian: kotlin.Boolean
            private final var nextNextGaussian: kotlin.Double
            private final val seed: java.util.concurrent.atomic.AtomicLong!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            protected/*protected and package*/ open fun next(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun nextBoolean(): kotlin.Boolean
            public open fun nextBytes(/*0*/ p0: kotlin.ByteArray!): kotlin.Unit
            public open fun nextDouble(): kotlin.Double
            public open fun nextFloat(): kotlin.Float
            public open fun nextGaussian(): kotlin.Double
            public open fun nextInt(): kotlin.Int
            public open fun nextInt(/*0*/ p0: kotlin.Int): kotlin.Int
            public open fun nextLong(): kotlin.Long
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            private open fun resetSeed(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open fun setSeed(/*0*/ p0: kotlin.Long): kotlin.Unit
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            // Static members
            private final val addend: kotlin.Long = 11.toLong()
            private final val mask: kotlin.Long = 281474976710655.toLong()
            private final val multiplier: kotlin.Long = 25214903917.toLong()
            private final val seedOffset: kotlin.Long
            private final val seedUniquifier: java.util.concurrent.atomic.AtomicLong!
            private final val serialPersistentFields: kotlin.Array<(out) [ERROR : Unresolved java classifier: ObjectStreamField]!>!
            public/*package*/ final val serialVersionUID: kotlin.Long = 3905348978240129619.toLong()
            private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
            private open fun initialScramble(/*0*/ p0: kotlin.Long): kotlin.Long
            private open fun seedUniquifier(): kotlin.Long
        }

        public trait RandomAccess {
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait Set</*0*/ E> : kotlin.MutableCollection<E!> {
            public abstract override /*1*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public abstract override /*1*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out E!>..kotlin.Collection<E!>?)): kotlin.Boolean
            public abstract override /*1*/ fun clear(): kotlin.Unit
            public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
            public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
            public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
            public abstract override /*1*/ fun size(): kotlin.Int
            public abstract fun toArray(): kotlin.Array<(out) kotlin.Any!>!
            public abstract fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public trait SortedMap</*0*/ K, /*1*/ V> : kotlin.MutableMap<K!, V!> {
            public abstract override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
            public abstract fun comparator(): java.util.Comparator<in K!>!
            public abstract override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun firstKey(): K!
            public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun headMap(/*0*/ toKey: K!): java.util.SortedMap<K!, V!>!
            public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
            public abstract fun lastKey(): K!
            public abstract override /*1*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V?
            public abstract override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: kotlin.Map<out K!, V!>): kotlin.Unit
            public abstract override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any?): V?
            public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
            public abstract fun subMap(/*0*/ fromKey: K!, /*1*/ toKey: K!): java.util.SortedMap<K!, V!>!
            public abstract fun tailMap(/*0*/ fromKey: K!): java.util.SortedMap<K!, V!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!
        }

        public trait SortedSet</*0*/ E> : kotlin.MutableSet<E!> {
            public abstract override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
            public abstract fun comparator(): java.util.Comparator<in E!>!
            public abstract override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public abstract fun first(): E!
            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun headSet(/*0*/ toElement: E!): java.util.SortedSet<E!>!
            public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E!>
            public abstract fun last(): E!
            public abstract override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
            public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
            public abstract fun subSet(/*0*/ fromElement: E!, /*1*/ toElement: E!): java.util.SortedSet<E!>!
            public abstract fun tailSet(/*0*/ fromElement: E!): java.util.SortedSet<E!>!
            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
        }

        public abstract class TimeZone : java.io.Serializable, kotlin.Cloneable {
            public constructor TimeZone()
            private final var ID: kotlin.String!
            public open override /*1*/ fun clone(): kotlin.Any!
            public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun getDSTSavings(): kotlin.Int
            public final fun getDisplayName(): kotlin.String!
            public final fun getDisplayName(/*0*/ p0: java.util.Locale!): kotlin.String!
            public final fun getDisplayName(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Int): kotlin.String!
            public open fun getDisplayName(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Int, /*2*/ p2: java.util.Locale!): kotlin.String!
            public open fun getID(): kotlin.String!
            public abstract fun getOffset(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.Int, /*5*/ p5: kotlin.Int): kotlin.Int
            public open fun getOffset(/*0*/ p0: kotlin.Long): kotlin.Int
            public/*package*/ open fun getOffsets(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.IntArray!): kotlin.Int
            public abstract fun getRawOffset(): kotlin.Int
            public open fun hasSameRules(/*0*/ p0: java.util.TimeZone!): kotlin.Boolean
            public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public abstract fun inDaylightTime(/*0*/ p0: java.util.Date!): kotlin.Boolean
            public open fun observesDaylightTime(): kotlin.Boolean
            public open fun setID(/*0*/ p0: kotlin.String!): kotlin.Unit
            public abstract fun setRawOffset(/*0*/ p0: kotlin.Int): kotlin.Unit
            public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
            public abstract fun useDaylightTime(): kotlin.Boolean

            private open class DisplayNames {
                private constructor DisplayNames()
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                private final val CACHE: kotlin.(Mutable)Map<kotlin.String!, [ERROR : Unresolved java classifier: SoftReference<Map<Locale, String[]>>]!>!
            }

            // Static members
            public/*package*/ final val GMT_ID: kotlin.String = "GMT"
            private final val GMT_ID_LENGTH: kotlin.Int = 3
            public final val LONG: kotlin.Int = 1
            public/*package*/ final val NO_TIMEZONE: java.util.TimeZone!
            private final val ONE_DAY: kotlin.Int = 86400000
            private final val ONE_HOUR: kotlin.Int = 3600000
            private final val ONE_MINUTE: kotlin.Int = 60000
            public final val SHORT: kotlin.Int = 0
            private final var defaultTimeZone: java.util.TimeZone!
            private final var javaAWTAccess: [ERROR : Unresolved java classifier: JavaAWTAccess]!
            private final var mainAppContextDefault: java.util.TimeZone!
            public/*package*/ final val serialVersionUID: kotlin.Long = 3581463369166924961.toLong()
            public open fun getAvailableIDs(): kotlin.Array<(out) kotlin.String!>!
            public open fun getAvailableIDs(/*0*/ p0: kotlin.Int): kotlin.Array<(out) kotlin.String!>!
            public open fun getDefault(): java.util.TimeZone!
            private open fun getDefaultInAppContext(): java.util.TimeZone!
            public/*package*/ open fun getDefaultRef(): java.util.TimeZone!
            private final fun getDisplayNames(/*0*/ p0: kotlin.String!, /*1*/ p1: java.util.Locale!): kotlin.Array<(out) kotlin.String!>!
            private open fun getSystemGMTOffsetID(): kotlin.String!
            private open fun getSystemTimeZoneID(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.String!): kotlin.String!
            public open fun getTimeZone(/*0*/ p0: kotlin.String!): java.util.TimeZone!
            private open fun getTimeZone(/*0*/ p0: kotlin.String!, /*1*/ p1: kotlin.Boolean): java.util.TimeZone!
            private open fun hasPermission(): kotlin.Boolean
            private final fun parseCustomTimeZone(/*0*/ p0: kotlin.String!): java.util.TimeZone!
            public open fun setDefault(/*0*/ p0: java.util.TimeZone!): kotlin.Unit
            private open fun setDefaultInAppContext(/*0*/ p0: java.util.TimeZone!): kotlin.Unit
            private open fun setDefaultZone(): java.util.TimeZone!
        }

        public open class TreeMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, kotlin.Cloneable, java.io.Serializable {
            public constructor TreeMap</*0*/ K, /*1*/ V>()
            public /*synthesized*/ constructor TreeMap</*0*/ K, /*1*/ V>(/*0*/ p0: ((K!, K!) -> kotlin.Int)!)
            public constructor TreeMap</*0*/ K, /*1*/ V>(/*0*/ p0: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?))
            public constructor TreeMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.Comparator<in K!>!)
            public constructor TreeMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.SortedMap<K!, out V!>!)
            private final val comparator: java.util.Comparator<in K!>!
            private final var descendingMap: [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
            private final var entrySet: java.util.TreeMap.EntrySet!
            public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
            private final var modCount: kotlin.Int
            private final var navigableKeySet: java.util.TreeMap.KeySet<K!>!
            private final var root: java.util.TreeMap.Entry<K!, V!>!
            private final var size: kotlin.Int
            public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
            public/*package*/ open fun addAllForTreeSet(/*0*/ p0: java.util.SortedSet<out K!>!, /*1*/ p1: V!): kotlin.Unit
            private open fun buildFromSorted(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.(Mutable)Iterator<*>!, /*2*/ p2: java.io.ObjectInputStream!, /*3*/ p3: V!): kotlin.Unit
            private final fun buildFromSorted(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int, /*4*/ p4: kotlin.(Mutable)Iterator<*>!, /*5*/ p5: java.io.ObjectInputStream!, /*6*/ p6: V!): java.util.TreeMap.Entry<K!, V!>!
            public open fun ceilingEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun ceilingKey(/*0*/ p0: K!): K!
            public open override /*1*/ fun clear(): kotlin.Unit
            public open override /*2*/ fun clone(): kotlin.Any!
            public open fun comparator(): java.util.Comparator<in K!>!
            public/*package*/ final fun compare(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Int
            public open override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
            public open override /*1*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
            private open fun deleteEntry(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Unit
            public/*package*/ open fun descendingKeyIterator(): kotlin.(Mutable)Iterator<K!>!
            public open fun descendingKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
            public open fun descendingMap(): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
            public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
            public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
            public open fun firstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun firstKey(): K!
            private open fun fixAfterDeletion(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Unit
            private open fun fixAfterInsertion(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Unit
            public open fun floorEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun floorKey(/*0*/ p0: K!): K!
            public open override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
            public/*package*/ final fun getCeilingEntry(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getEntry(/*0*/ p0: kotlin.Any!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getEntryUsingComparator(/*0*/ p0: kotlin.Any!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getFirstEntry(): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getFloorEntry(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getHigherEntry(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getLastEntry(): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun getLowerEntry(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
            public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
            public open fun headMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
            public open fun headMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
            public open fun higherEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun higherKey(/*0*/ p0: K!): K!
            public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
            public/*package*/ open fun keyIterator(): kotlin.(Mutable)Iterator<K!>!
            public open override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
            public open fun lastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun lastKey(): K!
            public open fun lowerEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun lowerKey(/*0*/ p0: K!): K!
            public open fun navigableKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
            public open fun pollFirstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open fun pollLastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public open override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
            public open override /*1*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
            private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
            public/*package*/ open fun readTreeSet(/*0*/ p0: kotlin.Int, /*1*/ p1: java.io.ObjectInputStream!, /*2*/ p2: V!): kotlin.Unit
            public open override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
            private open fun rotateLeft(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Unit
            private open fun rotateRight(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Unit
            public open override /*1*/ fun size(): kotlin.Int
            public open fun subMap(/*0*/ p0: K!, /*1*/ p1: K!): java.util.SortedMap<K!, V!>!
            public open fun subMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
            public open fun tailMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
            public open fun tailMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
            public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
            public open override /*1*/ fun values(): kotlin.(Mutable)Collection<V!>!
            private open fun writeObject(/*0*/ p0: java.io.ObjectOutputStream!): kotlin.Unit

            public/*package*/ final class AscendingSubMap</*0*/ K, /*1*/ V> : java.util.TreeMap.NavigableSubMap<K!, V!> {
                public/*package*/ constructor AscendingSubMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.TreeMap<K!, V!>!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean, /*4*/ p4: kotlin.Boolean, /*5*/ p5: K!, /*6*/ p6: kotlin.Boolean)
                public/*package*/ final override /*1*/ /*fake_override*/ var descendingMapView: [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public/*package*/ final override /*1*/ /*fake_override*/ var entrySetView: java.util.TreeMap.NavigableSubMap.EntrySetView!
                public/*package*/ final override /*1*/ /*fake_override*/ val fromStart: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ val hi: K!
                public/*package*/ final override /*1*/ /*fake_override*/ val hiInclusive: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val lo: K!
                public/*package*/ final override /*1*/ /*fake_override*/ val loInclusive: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ val m: java.util.TreeMap<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var navigableKeySetView: java.util.TreeMap.KeySet<K!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val toEnd: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHighFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLowFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun ceilingEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun ceilingKey(/*0*/ p0: K!): K!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public open fun comparator(): java.util.Comparator<in K!>!
                public final override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public/*package*/ open override /*1*/ fun descendingKeyIterator(): kotlin.(Mutable)Iterator<K!>!
                public open override /*1*/ /*fake_override*/ fun descendingKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public open fun descendingMap(): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun firstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun firstKey(): K!
                public final override /*1*/ /*fake_override*/ fun floorEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun floorKey(/*0*/ p0: K!): K!
                public final override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun headMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public open fun headMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public final override /*1*/ /*fake_override*/ fun higherEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun higherKey(/*0*/ p0: K!): K!
                public/*package*/ final override /*1*/ /*fake_override*/ fun inClosedRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun inRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun inRange(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public/*package*/ open override /*1*/ fun keyIterator(): kotlin.(Mutable)Iterator<K!>!
                public final override /*1*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public final override /*1*/ /*fake_override*/ fun lastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun lastKey(): K!
                public final override /*1*/ /*fake_override*/ fun lowerEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun lowerKey(/*0*/ p0: K!): K!
                public final override /*1*/ /*fake_override*/ fun navigableKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public final override /*1*/ /*fake_override*/ fun pollFirstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun pollLastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public final override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                public/*package*/ open override /*1*/ fun subCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun subMap(/*0*/ p0: K!, /*1*/ p1: K!): java.util.SortedMap<K!, V!>!
                public open fun subMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public final override /*1*/ /*fake_override*/ fun tailMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public open fun tailMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ final override /*1*/ /*fake_override*/ fun tooHigh(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun tooLow(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                public/*package*/ final inner class AscendingEntrySetView : java.util.TreeMap.NavigableSubMap.EntrySetView {
                    public/*package*/ constructor AscendingEntrySetView()
                    invisible_fake final override /*1*/ /*fake_override*/ var size: kotlin.Int
                    invisible_fake final override /*1*/ /*fake_override*/ var sizeModCount: kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                    public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                    public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = 912986545866124060.toLong()
            }

            public/*package*/ final inner class DescendingKeyIterator : java.util.TreeMap.PrivateEntryIterator<K!> {
                public/*package*/ constructor DescendingKeyIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): K!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ final class DescendingSubMap</*0*/ K, /*1*/ V> : java.util.TreeMap.NavigableSubMap<K!, V!> {
                public/*package*/ constructor DescendingSubMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.TreeMap<K!, V!>!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean, /*4*/ p4: kotlin.Boolean, /*5*/ p5: K!, /*6*/ p6: kotlin.Boolean)
                public/*package*/ final override /*1*/ /*fake_override*/ var descendingMapView: [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public/*package*/ final override /*1*/ /*fake_override*/ var entrySetView: java.util.TreeMap.NavigableSubMap.EntrySetView!
                public/*package*/ final override /*1*/ /*fake_override*/ val fromStart: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ val hi: K!
                public/*package*/ final override /*1*/ /*fake_override*/ val hiInclusive: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val lo: K!
                public/*package*/ final override /*1*/ /*fake_override*/ val loInclusive: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ val m: java.util.TreeMap<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var navigableKeySetView: java.util.TreeMap.KeySet<K!>!
                private final val reverseComparator: java.util.Comparator<in K!>!
                public/*package*/ final override /*1*/ /*fake_override*/ val toEnd: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHighFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLowFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun absLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun ceilingEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun ceilingKey(/*0*/ p0: K!): K!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public open fun comparator(): java.util.Comparator<in K!>!
                public final override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public/*package*/ open override /*1*/ fun descendingKeyIterator(): kotlin.(Mutable)Iterator<K!>!
                public open override /*1*/ /*fake_override*/ fun descendingKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public open fun descendingMap(): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public open override /*1*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun firstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun firstKey(): K!
                public final override /*1*/ /*fake_override*/ fun floorEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun floorKey(/*0*/ p0: K!): K!
                public final override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun headMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public open fun headMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public final override /*1*/ /*fake_override*/ fun higherEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun higherKey(/*0*/ p0: K!): K!
                public/*package*/ final override /*1*/ /*fake_override*/ fun inClosedRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun inRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun inRange(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public/*package*/ open override /*1*/ fun keyIterator(): kotlin.(Mutable)Iterator<K!>!
                public final override /*1*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public final override /*1*/ /*fake_override*/ fun lastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun lastKey(): K!
                public final override /*1*/ /*fake_override*/ fun lowerEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun lowerKey(/*0*/ p0: K!): K!
                public final override /*1*/ /*fake_override*/ fun navigableKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public final override /*1*/ /*fake_override*/ fun pollFirstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun pollLastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public final override /*1*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                public/*package*/ open override /*1*/ fun subCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ open override /*1*/ fun subLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final override /*1*/ /*fake_override*/ fun subMap(/*0*/ p0: K!, /*1*/ p1: K!): java.util.SortedMap<K!, V!>!
                public open fun subMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public final override /*1*/ /*fake_override*/ fun tailMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public open fun tailMap(/*0*/ p0: K!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ final override /*1*/ /*fake_override*/ fun tooHigh(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ fun tooLow(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                public/*package*/ final inner class DescendingEntrySetView : java.util.TreeMap.NavigableSubMap.EntrySetView {
                    public/*package*/ constructor DescendingEntrySetView()
                    invisible_fake final override /*1*/ /*fake_override*/ var size: kotlin.Int
                    invisible_fake final override /*1*/ /*fake_override*/ var sizeModCount: kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                    public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                    public open override /*1*/ /*fake_override*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun size(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                    public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                // Static members
                private final val serialVersionUID: kotlin.Long = 912986545866120460.toLong()
            }

            public/*package*/ final class Entry</*0*/ K, /*1*/ V> : kotlin.MutableMap.MutableEntry<K!, V!> {
                public/*package*/ constructor Entry</*0*/ K, /*1*/ V>(/*0*/ p0: K!, /*1*/ p1: V!, /*2*/ p2: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final var color: kotlin.Boolean
                public/*package*/ final var key: K!
                public/*package*/ final var left: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final var parent: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final var right: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final var value: V!
                public open override /*1*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ fun getKey(): K!
                public open override /*1*/ fun getValue(): V!
                public open override /*1*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun setValue(/*0*/ value: V!): V!
                public open override /*1*/ fun toString(): kotlin.String!
            }

            public/*package*/ final inner class EntryIterator : java.util.TreeMap.PrivateEntryIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                public/*package*/ constructor EntryIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ open inner class EntrySet : java.util.AbstractSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                public/*package*/ constructor EntrySet()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ final inner class KeyIterator : java.util.TreeMap.PrivateEntryIterator<K!> {
                public/*package*/ constructor KeyIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): K!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ final class KeySet</*0*/ E> : java.util.AbstractSet<E!> {
                public/*package*/ constructor KeySet</*0*/ E>(/*0*/ p0: [ERROR : Unresolved java classifier: NavigableMap<E, Object>]!)
                private final val m: [ERROR : Unresolved java classifier: NavigableMap<E, Object>]!
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: E!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<E!>): kotlin.Boolean
                public open fun ceiling(/*0*/ p0: E!): E!
                public open override /*1*/ fun clear(): kotlin.Unit
                public open fun comparator(): java.util.Comparator<in E!>!
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open fun descendingIterator(): kotlin.(Mutable)Iterator<E!>!
                public open fun descendingSet(): [ERROR : Unresolved java classifier: NavigableSet<E>]!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                public open fun first(): E!
                public open fun floor(/*0*/ p0: E!): E!
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open fun headSet(/*0*/ p0: E!): java.util.SortedSet<E!>!
                public open fun headSet(/*0*/ p0: E!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableSet<E>]!
                public open fun higher(/*0*/ p0: E!): E!
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<E!>!
                public open fun last(): E!
                public open fun lower(/*0*/ p0: E!): E!
                public open fun pollFirst(): E!
                public open fun pollLast(): E!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open fun subSet(/*0*/ p0: E!, /*1*/ p1: E!): java.util.SortedSet<E!>!
                public open fun subSet(/*0*/ p0: E!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: E!, /*3*/ p3: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableSet<E>]!
                public open fun tailSet(/*0*/ p0: E!): java.util.SortedSet<E!>!
                public open fun tailSet(/*0*/ p0: E!, /*1*/ p1: kotlin.Boolean): [ERROR : Unresolved java classifier: NavigableSet<E>]!
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ abstract class NavigableSubMap</*0*/ K, /*1*/ V> : java.util.AbstractMap<K!, V!>, java.io.Serializable {
                public/*package*/ constructor NavigableSubMap</*0*/ K, /*1*/ V>(/*0*/ p0: java.util.TreeMap<K!, V!>!, /*1*/ p1: kotlin.Boolean, /*2*/ p2: K!, /*3*/ p3: kotlin.Boolean, /*4*/ p4: kotlin.Boolean, /*5*/ p5: K!, /*6*/ p6: kotlin.Boolean)
                public/*package*/ final var descendingMapView: [ERROR : Unresolved java classifier: NavigableMap<K, V>]!
                public/*package*/ final var entrySetView: java.util.TreeMap.NavigableSubMap.EntrySetView!
                public/*package*/ final val fromStart: kotlin.Boolean
                public/*package*/ final val hi: K!
                public/*package*/ final val hiInclusive: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                public/*package*/ final val lo: K!
                public/*package*/ final val loInclusive: kotlin.Boolean
                public/*package*/ final val m: java.util.TreeMap<K!, V!>!
                public/*package*/ final var navigableKeySetView: java.util.TreeMap.KeySet<K!>!
                public/*package*/ final val toEnd: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public/*package*/ final fun absCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absHighFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absLowFence(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun absLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final fun ceilingEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun ceilingKey(/*0*/ p0: K!): K!
                public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public final override /*1*/ fun containsKey(/*0*/ key: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any!): kotlin.Boolean
                public/*package*/ abstract fun descendingKeyIterator(): kotlin.(Mutable)Iterator<K!>!
                public open fun descendingKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public abstract override /*1*/ /*fake_override*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final fun firstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun firstKey(): K!
                public final fun floorEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun floorKey(/*0*/ p0: K!): K!
                public final override /*1*/ fun get(/*0*/ key: kotlin.Any!): V!
                public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final fun headMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public final fun higherEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun higherKey(/*0*/ p0: K!): K!
                public/*package*/ final fun inClosedRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final fun inRange(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final fun inRange(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                public open override /*1*/ fun isEmpty(): kotlin.Boolean
                public/*package*/ abstract fun keyIterator(): kotlin.(Mutable)Iterator<K!>!
                public final override /*1*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public final fun lastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun lastKey(): K!
                public final fun lowerEntry(/*0*/ p0: K!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun lowerKey(/*0*/ p0: K!): K!
                public final fun navigableKeySet(): [ERROR : Unresolved java classifier: NavigableSet<K>]!
                public final fun pollFirstEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final fun pollLastEntry(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                public final override /*1*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V!
                public open override /*1*/ /*fake_override*/ fun putAll(/*0*/ m: (kotlin.MutableMap<out K!, out V!>..kotlin.Map<out K!, V!>?)): kotlin.Unit
                public final override /*1*/ fun remove(/*0*/ key: kotlin.Any!): V!
                public open override /*1*/ fun size(): kotlin.Int
                public/*package*/ abstract fun subCeiling(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ abstract fun subFloor(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ abstract fun subHigher(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ abstract fun subHighest(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ abstract fun subLower(/*0*/ p0: K!): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ abstract fun subLowest(): java.util.TreeMap.Entry<K!, V!>!
                public final fun subMap(/*0*/ p0: K!, /*1*/ p1: K!): java.util.SortedMap<K!, V!>!
                public final fun tailMap(/*0*/ p0: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                public/*package*/ final fun tooHigh(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public/*package*/ final fun tooLow(/*0*/ p0: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                public/*package*/ final inner class DescendingSubMapEntryIterator : java.util.TreeMap.NavigableSubMap.SubMapIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                    public/*package*/ constructor DescendingSubMapEntryIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: java.util.TreeMap.Entry<K!, V!>!)
                    public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                    public/*package*/ final override /*1*/ /*fake_override*/ val fenceKey: kotlin.Any!
                    public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun next(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ fun remove(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeAscending(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeDescending(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public/*package*/ final inner class DescendingSubMapKeyIterator : java.util.TreeMap.NavigableSubMap.SubMapIterator<K!> {
                    public/*package*/ constructor DescendingSubMapKeyIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: java.util.TreeMap.Entry<K!, V!>!)
                    public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                    public/*package*/ final override /*1*/ /*fake_override*/ val fenceKey: kotlin.Any!
                    public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun next(): K!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ fun remove(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeAscending(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeDescending(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public/*package*/ abstract inner class EntrySetView : java.util.AbstractSet<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                    public/*package*/ constructor EntrySetView()
                    private final var size: kotlin.Int
                    private final var sizeModCount: kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: kotlin.Collection<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun clear(): kotlin.Unit
                    public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun isEmpty(): kotlin.Boolean
                    public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>
                    public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
                    public open override /*1*/ fun size(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                    public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public/*package*/ final inner class SubMapEntryIterator : java.util.TreeMap.NavigableSubMap.SubMapIterator<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!> {
                    public/*package*/ constructor SubMapEntryIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: java.util.TreeMap.Entry<K!, V!>!)
                    public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                    public/*package*/ final override /*1*/ /*fake_override*/ val fenceKey: kotlin.Any!
                    public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun next(): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ fun remove(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeAscending(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeDescending(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public/*package*/ abstract inner class SubMapIterator</*0*/ T> : kotlin.MutableIterator<T!> {
                    public/*package*/ constructor SubMapIterator</*0*/ T>(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: java.util.TreeMap.Entry<K!, V!>!)
                    public/*package*/ final var expectedModCount: kotlin.Int
                    public/*package*/ final val fenceKey: kotlin.Any!
                    public/*package*/ final var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final var next: java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ fun hasNext(): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public abstract override /*1*/ /*fake_override*/ fun next(): T!
                    public/*package*/ final fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public abstract override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                    public/*package*/ final fun removeAscending(): kotlin.Unit
                    public/*package*/ final fun removeDescending(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public/*package*/ final inner class SubMapKeyIterator : java.util.TreeMap.NavigableSubMap.SubMapIterator<K!> {
                    public/*package*/ constructor SubMapKeyIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: java.util.TreeMap.Entry<K!, V!>!)
                    public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                    public/*package*/ final override /*1*/ /*fake_override*/ val fenceKey: kotlin.Any!
                    public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ fun next(): K!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                    public open override /*1*/ fun remove(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeAscending(): kotlin.Unit
                    public/*package*/ final override /*1*/ /*fake_override*/ fun removeDescending(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }
            }

            public/*package*/ abstract inner class PrivateEntryIterator</*0*/ T> : kotlin.MutableIterator<T!> {
                public/*package*/ constructor PrivateEntryIterator</*0*/ T>(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final var expectedModCount: kotlin.Int
                public/*package*/ final var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final var next: java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public abstract override /*1*/ /*fake_override*/ fun next(): T!
                public/*package*/ final fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            private open inner class SubMap : java.util.AbstractMap<K!, V!>, java.util.SortedMap<K!, V!>, java.io.Serializable {
                private constructor SubMap()
                private final var fromKey: K!
                private final var fromStart: kotlin.Boolean
                public/*package*/ final override /*1*/ /*fake_override*/ var keySet: kotlin.(Mutable)Set<K!>!
                private final var toEnd: kotlin.Boolean
                private final var toKey: K!
                public/*package*/ final override /*1*/ /*fake_override*/ var values: kotlin.(Mutable)Collection<V!>!
                public open override /*2*/ /*fake_override*/ fun clear(): kotlin.Unit
                protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun clone(): kotlin.Any!
                public open override /*1*/ fun comparator(): java.util.Comparator<in K!>!
                public open override /*2*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
                public open override /*2*/ fun entrySet(): kotlin.(Mutable)Set<kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!>!
                public open override /*3*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ fun firstKey(): K!
                public open override /*2*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
                public open override /*3*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun headMap(/*0*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*2*/ /*fake_override*/ fun keySet(): kotlin.(Mutable)Set<K!>!
                public open override /*1*/ fun lastKey(): K!
                public open override /*2*/ /*fake_override*/ fun put(/*0*/ key: K!, /*1*/ value: V!): V?
                public open override /*2*/ /*fake_override*/ fun putAll(/*0*/ m: kotlin.Map<out K!, V!>): kotlin.Unit
                private open fun readResolve(): kotlin.Any!
                public open override /*2*/ /*fake_override*/ fun remove(/*0*/ key: kotlin.Any?): V?
                public open override /*2*/ /*fake_override*/ fun size(): kotlin.Int
                public open override /*1*/ fun subMap(/*0*/ fromKey: K!, /*1*/ toKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*1*/ fun tailMap(/*0*/ fromKey: K!): java.util.SortedMap<K!, V!>!
                public open override /*3*/ /*fake_override*/ fun toString(): kotlin.String
                public open override /*2*/ /*fake_override*/ fun values(): kotlin.(Mutable)Collection<V!>!

                // Static members
                private final val serialVersionUID: kotlin.Long = -6520786458950516097.toLong()
            }

            public/*package*/ final inner class ValueIterator : java.util.TreeMap.PrivateEntryIterator<V!> {
                public/*package*/ constructor ValueIterator(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!)
                public/*package*/ final override /*1*/ /*fake_override*/ var expectedModCount: kotlin.Int
                public/*package*/ final override /*1*/ /*fake_override*/ var lastReturned: java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ var next: java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public final override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ fun next(): V!
                public/*package*/ final override /*1*/ /*fake_override*/ fun nextEntry(): java.util.TreeMap.Entry<K!, V!>!
                public/*package*/ final override /*1*/ /*fake_override*/ fun prevEntry(): java.util.TreeMap.Entry<K!, V!>!
                public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public/*package*/ open inner class Values : java.util.AbstractCollection<V!> {
                public/*package*/ constructor Values()
                public open override /*1*/ /*fake_override*/ fun add(/*0*/ e: V!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun addAll(/*0*/ c: (kotlin.MutableCollection<out V!>..kotlin.Collection<V!>?)): kotlin.Boolean
                public open override /*1*/ fun clear(): kotlin.Unit
                public open override /*1*/ fun contains(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
                public open override /*1*/ fun iterator(): kotlin.(Mutable)Iterator<V!>!
                public open override /*1*/ fun remove(/*0*/ o: kotlin.Any!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun removeAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun retainAll(/*0*/ c: kotlin.(Mutable)Collection<*>!): kotlin.Boolean
                public open override /*1*/ fun size(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toArray(): kotlin.Array<(out) kotlin.Any!>!
                public open override /*1*/ /*fake_override*/ fun </*0*/ T> toArray(/*0*/ a: kotlin.Array<(out) T!>!): kotlin.Array<(out) T!>!
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
            }

            // Static members
            private final val BLACK: kotlin.Boolean = true
            private final val RED: kotlin.Boolean = false
            private final val UNBOUNDED: kotlin.Any!
            private final val serialVersionUID: kotlin.Long = 919286545866124006.toLong()
            private open fun </*0*/ K, /*1*/ V> colorOf(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.Boolean
            private open fun computeRedLevel(/*0*/ p0: kotlin.Int): kotlin.Int
            public/*package*/ open fun </*0*/ K, /*1*/ V> exportEntry(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): kotlin.(Mutable)Map.(Mutable)Entry<K!, V!>!
            public/*package*/ open fun </*0*/ K> key(/*0*/ p0: java.util.TreeMap.Entry<K!, *>!): K!
            public/*package*/ open fun </*0*/ K, /*1*/ V> keyOrNull(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): K!
            private open fun </*0*/ K, /*1*/ V> leftOf(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): java.util.TreeMap.Entry<K!, V!>!
            private open fun </*0*/ K, /*1*/ V> parentOf(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ open fun </*0*/ K, /*1*/ V> predecessor(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): java.util.TreeMap.Entry<K!, V!>!
            private open fun </*0*/ K, /*1*/ V> rightOf(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): java.util.TreeMap.Entry<K!, V!>!
            private open fun </*0*/ K, /*1*/ V> setColor(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
            public/*package*/ open fun </*0*/ K, /*1*/ V> successor(/*0*/ p0: java.util.TreeMap.Entry<K!, V!>!): java.util.TreeMap.Entry<K!, V!>!
            public/*package*/ final fun valEquals(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Any!): kotlin.Boolean
        }

        package java.util.concurrent {
            public /*synthesized*/ fun </*0*/ V> Callable(/*0*/ function: () -> V!): java.util.concurrent.Callable<V>

            public trait Callable</*0*/ V> {
                public abstract fun call(): V!
                public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
            }

            public abstract enum class TimeUnit : kotlin.Enum<java.util.concurrent.TimeUnit!> {
                public enum entry NANOSECONDS : java.util.concurrent.TimeUnit {
                    private constructor NANOSECONDS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MICROSECONDS : java.util.concurrent.TimeUnit {
                    private constructor MICROSECONDS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MILLISECONDS : java.util.concurrent.TimeUnit {
                    private constructor MILLISECONDS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry SECONDS : java.util.concurrent.TimeUnit {
                    private constructor SECONDS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry MINUTES : java.util.concurrent.TimeUnit {
                    private constructor MINUTES()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry HOURS : java.util.concurrent.TimeUnit {
                    private constructor HOURS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public enum entry DAYS : java.util.concurrent.TimeUnit {
                    private constructor DAYS()
                    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                    public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public/*package*/ abstract override /*1*/ /*fake_override*/ fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                private constructor TimeUnit()
                public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: java.util.concurrent.TimeUnit!): kotlin.Int
                public open fun convert(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Long
                public final override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                public/*package*/ abstract fun excessNanos(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
                public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
                public open fun sleep(/*0*/ p0: kotlin.Long): kotlin.Unit
                public open fun timedJoin(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public open fun timedWait(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                public open fun toDays(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toHours(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toMicros(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toMillis(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toMinutes(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                public open fun toSeconds(/*0*/ p0: kotlin.Long): kotlin.Long
                public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                // Static members
                public/*package*/ final val C0: kotlin.Long = 1.toLong()
                public/*package*/ final val C1: kotlin.Long = 1000.toLong()
                public/*package*/ final val C2: kotlin.Long = 1000000.toLong()
                public/*package*/ final val C3: kotlin.Long = 1000000000.toLong()
                public/*package*/ final val C4: kotlin.Long = 60000000000.toLong()
                public/*package*/ final val C5: kotlin.Long = 3600000000000.toLong()
                public/*package*/ final val C6: kotlin.Long = 86400000000000.toLong()
                public/*package*/ final val MAX: kotlin.Long = 9223372036854775807.toLong()
                public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): java.util.concurrent.TimeUnit
                public final /*synthesized*/ fun values(): kotlin.Array<java.util.concurrent.TimeUnit>
                public/*package*/ open fun x(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Long
            }

            package java.util.concurrent.atomic {

                public open class AtomicBoolean : java.io.Serializable {
                    public constructor AtomicBoolean()
                    public constructor AtomicBoolean(/*0*/ p0: kotlin.Boolean)
                    private final var value: kotlin.Int
                    public final fun compareAndSet(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final fun get(): kotlin.Boolean
                    public final fun getAndSet(/*0*/ p0: kotlin.Boolean): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun lazySet(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                    public final fun set(/*0*/ p0: kotlin.Boolean): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public open fun weakCompareAndSet(/*0*/ p0: kotlin.Boolean, /*1*/ p1: kotlin.Boolean): kotlin.Boolean

                    // Static members
                    private final val serialVersionUID: kotlin.Long = 4654671469794556979.toLong()
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val valueOffset: kotlin.Long
                }

                public open class AtomicInteger : kotlin.Number, java.io.Serializable {
                    public constructor AtomicInteger()
                    public constructor AtomicInteger(/*0*/ p0: kotlin.Int)
                    private final var value: kotlin.Int
                    public final fun addAndGet(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun compareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                    public final fun decrementAndGet(): kotlin.Int
                    public open fun doubleValue(): kotlin.Double
                    public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun floatValue(): kotlin.Float
                    public final fun get(): kotlin.Int
                    public final fun getAndAdd(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun getAndDecrement(): kotlin.Int
                    public final fun getAndIncrement(): kotlin.Int
                    public final fun getAndSet(/*0*/ p0: kotlin.Int): kotlin.Int
                    public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun incrementAndGet(): kotlin.Int
                    public open fun intValue(): kotlin.Int
                    public final fun lazySet(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public open fun longValue(): kotlin.Long
                    public final fun set(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public open override /*2*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean

                    // Static members
                    private final val serialVersionUID: kotlin.Long = 6214790243416807050.toLong()
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val valueOffset: kotlin.Long
                }

                public open class AtomicIntegerArray : java.io.Serializable {
                    public constructor AtomicIntegerArray(/*0*/ p0: kotlin.Int)
                    public constructor AtomicIntegerArray(/*0*/ p0: kotlin.IntArray!)
                    private final val array: kotlin.IntArray!
                    public final fun addAndGet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                    private open fun checkedByteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun compareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
                    private open fun compareAndSetRaw(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
                    public final fun decrementAndGet(/*0*/ p0: kotlin.Int): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final fun get(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun getAndAdd(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                    public final fun getAndDecrement(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun getAndIncrement(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun getAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Int
                    private open fun getRaw(/*0*/ p0: kotlin.Long): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun incrementAndGet(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun lazySet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                    public final fun length(): kotlin.Int
                    public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean

                    // Static members
                    private final val base: kotlin.Int
                    private final val serialVersionUID: kotlin.Long = 2862133569453604235.toLong()
                    private final val shift: kotlin.Int
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private open fun byteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                }

                public abstract class AtomicIntegerFieldUpdater</*0*/ T> {
                    protected/*protected and package*/ constructor AtomicIntegerFieldUpdater</*0*/ T>()
                    public open fun addAndGet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                    public abstract fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
                    public open fun decrementAndGet(/*0*/ p0: T!): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public abstract fun get(/*0*/ p0: T!): kotlin.Int
                    public open fun getAndAdd(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                    public open fun getAndDecrement(/*0*/ p0: T!): kotlin.Int
                    public open fun getAndIncrement(/*0*/ p0: T!): kotlin.Int
                    public open fun getAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun incrementAndGet(/*0*/ p0: T!): kotlin.Int
                    public abstract fun lazySet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Unit
                    public abstract fun set(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public abstract fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean

                    private open class AtomicIntegerFieldUpdaterImpl</*0*/ T> : java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T!> {
                        public/*package*/ constructor AtomicIntegerFieldUpdaterImpl</*0*/ T>(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: kotlin.String!)
                        private final val cclass: java.lang.Class<*>!
                        private final val offset: kotlin.Long
                        private final val tclass: java.lang.Class<T!>!
                        public open override /*1*/ /*fake_override*/ fun addAndGet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                        public open override /*1*/ fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun decrementAndGet(/*0*/ p0: T!): kotlin.Int
                        private open fun ensureProtectedAccess(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        private open fun fullCheck(/*0*/ p0: T!): kotlin.Unit
                        public final override /*1*/ fun get(/*0*/ p0: T!): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun getAndAdd(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun getAndDecrement(/*0*/ p0: T!): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun getAndIncrement(/*0*/ p0: T!): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun getAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun incrementAndGet(/*0*/ p0: T!): kotlin.Int
                        public open override /*1*/ fun lazySet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        public open override /*1*/ fun set(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        public open override /*1*/ fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean

                        // Static members
                        private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    }

                    // Static members
                    public open fun </*0*/ U> newUpdater(/*0*/ p0: java.lang.Class<U!>!, /*1*/ p1: kotlin.String!): java.util.concurrent.atomic.AtomicIntegerFieldUpdater<U!>!
                }

                public open class AtomicLong : kotlin.Number, java.io.Serializable {
                    public constructor AtomicLong()
                    public constructor AtomicLong(/*0*/ p0: kotlin.Long)
                    private final var value: kotlin.Long
                    public final fun addAndGet(/*0*/ p0: kotlin.Long): kotlin.Long
                    public final fun compareAndSet(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Boolean
                    public final fun decrementAndGet(): kotlin.Long
                    public open fun doubleValue(): kotlin.Double
                    public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun floatValue(): kotlin.Float
                    public final fun get(): kotlin.Long
                    public final fun getAndAdd(/*0*/ p0: kotlin.Long): kotlin.Long
                    public final fun getAndDecrement(): kotlin.Long
                    public final fun getAndIncrement(): kotlin.Long
                    public final fun getAndSet(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun incrementAndGet(): kotlin.Long
                    public open fun intValue(): kotlin.Int
                    public final fun lazySet(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open fun longValue(): kotlin.Long
                    public final fun set(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open override /*2*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long): kotlin.Boolean

                    // Static members
                    public/*package*/ final val VM_SUPPORTS_LONG_CAS: kotlin.Boolean
                    private final val serialVersionUID: kotlin.Long = 1927816293512124184.toLong()
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val valueOffset: kotlin.Long
                    private open fun VMSupportsCS8(): kotlin.Boolean
                }

                public open class AtomicLongArray : java.io.Serializable {
                    public constructor AtomicLongArray(/*0*/ p0: kotlin.Int)
                    public constructor AtomicLongArray(/*0*/ p0: kotlin.LongArray!)
                    private final val array: kotlin.LongArray!
                    public open fun addAndGet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Long
                    private open fun checkedByteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun compareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
                    private open fun compareAndSetRaw(/*0*/ p0: kotlin.Long, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
                    public final fun decrementAndGet(/*0*/ p0: kotlin.Int): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final fun get(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun getAndAdd(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Long
                    public final fun getAndDecrement(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun getAndIncrement(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun getAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Long
                    private open fun getRaw(/*0*/ p0: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun incrementAndGet(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun lazySet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public final fun length(): kotlin.Int
                    public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean

                    // Static members
                    private final val base: kotlin.Int
                    private final val serialVersionUID: kotlin.Long = -2308431214976778248.toLong()
                    private final val shift: kotlin.Int
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private open fun byteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                }

                public abstract class AtomicLongFieldUpdater</*0*/ T> {
                    protected/*protected and package*/ constructor AtomicLongFieldUpdater</*0*/ T>()
                    public open fun addAndGet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                    public abstract fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
                    public open fun decrementAndGet(/*0*/ p0: T!): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public abstract fun get(/*0*/ p0: T!): kotlin.Long
                    public open fun getAndAdd(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                    public open fun getAndDecrement(/*0*/ p0: T!): kotlin.Long
                    public open fun getAndIncrement(/*0*/ p0: T!): kotlin.Long
                    public open fun getAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun incrementAndGet(/*0*/ p0: T!): kotlin.Long
                    public abstract fun lazySet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public abstract fun set(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public abstract fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean

                    private open class CASUpdater</*0*/ T> : java.util.concurrent.atomic.AtomicLongFieldUpdater<T!> {
                        public/*package*/ constructor CASUpdater</*0*/ T>(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: kotlin.String!)
                        private final val cclass: java.lang.Class<*>!
                        private final val offset: kotlin.Long
                        private final val tclass: java.lang.Class<T!>!
                        public open override /*1*/ /*fake_override*/ fun addAndGet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun decrementAndGet(/*0*/ p0: T!): kotlin.Long
                        private open fun ensureProtectedAccess(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        private open fun fullCheck(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ fun get(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndAdd(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndDecrement(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndIncrement(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun incrementAndGet(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ fun lazySet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                        public open override /*1*/ fun set(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        public open override /*1*/ fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean

                        // Static members
                        private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    }

                    private open class LockedUpdater</*0*/ T> : java.util.concurrent.atomic.AtomicLongFieldUpdater<T!> {
                        public/*package*/ constructor LockedUpdater</*0*/ T>(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: kotlin.String!)
                        private final val cclass: java.lang.Class<*>!
                        private final val offset: kotlin.Long
                        private final val tclass: java.lang.Class<T!>!
                        public open override /*1*/ /*fake_override*/ fun addAndGet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun decrementAndGet(/*0*/ p0: T!): kotlin.Long
                        private open fun ensureProtectedAccess(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        private open fun fullCheck(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ fun get(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndAdd(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndDecrement(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndIncrement(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun getAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Long
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun incrementAndGet(/*0*/ p0: T!): kotlin.Long
                        public open override /*1*/ fun lazySet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                        public open override /*1*/ fun set(/*0*/ p0: T!, /*1*/ p1: kotlin.Long): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        public open override /*1*/ fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: kotlin.Long, /*2*/ p2: kotlin.Long): kotlin.Boolean

                        // Static members
                        private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    }

                    // Static members
                    public open fun </*0*/ U> newUpdater(/*0*/ p0: java.lang.Class<U!>!, /*1*/ p1: kotlin.String!): java.util.concurrent.atomic.AtomicLongFieldUpdater<U!>!
                }

                public open class AtomicMarkableReference</*0*/ V> {
                    public constructor AtomicMarkableReference</*0*/ V>(/*0*/ p0: V!, /*1*/ p1: kotlin.Boolean)
                    private final var pair: java.util.concurrent.atomic.AtomicMarkableReference.Pair<V!>!
                    public open fun attemptMark(/*0*/ p0: V!, /*1*/ p1: kotlin.Boolean): kotlin.Boolean
                    private open fun casPair(/*0*/ p0: java.util.concurrent.atomic.AtomicMarkableReference.Pair<V!>!, /*1*/ p1: java.util.concurrent.atomic.AtomicMarkableReference.Pair<V!>!): kotlin.Boolean
                    public open fun compareAndSet(/*0*/ p0: V!, /*1*/ p1: V!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun get(/*0*/ p0: kotlin.BooleanArray!): V!
                    public open fun getReference(): V!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun isMarked(): kotlin.Boolean
                    public open fun set(/*0*/ p0: V!, /*1*/ p1: kotlin.Boolean): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public open fun weakCompareAndSet(/*0*/ p0: V!, /*1*/ p1: V!, /*2*/ p2: kotlin.Boolean, /*3*/ p3: kotlin.Boolean): kotlin.Boolean

                    private open class Pair</*0*/ T> {
                        private constructor Pair</*0*/ T>(/*0*/ p0: T!, /*1*/ p1: kotlin.Boolean)
                        public/*package*/ final val mark: kotlin.Boolean
                        public/*package*/ final val reference: T!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                        // Static members
                        public/*package*/ open fun </*0*/ T> of(/*0*/ p0: T!, /*1*/ p1: kotlin.Boolean): java.util.concurrent.atomic.AtomicMarkableReference.Pair<T!>!
                    }

                    // Static members
                    private final val UNSAFE: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val pairOffset: kotlin.Long
                    public/*package*/ open fun objectFieldOffset(/*0*/ p0: [ERROR : Unresolved java classifier: Unsafe]!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.lang.Class<*>!): kotlin.Long
                }

                public open class AtomicReference</*0*/ V> : java.io.Serializable {
                    public constructor AtomicReference</*0*/ V>()
                    public constructor AtomicReference</*0*/ V>(/*0*/ p0: V!)
                    private final var value: V!
                    public final fun compareAndSet(/*0*/ p0: V!, /*1*/ p1: V!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final fun get(): V!
                    public final fun getAndSet(/*0*/ p0: V!): V!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun lazySet(/*0*/ p0: V!): kotlin.Unit
                    public final fun set(/*0*/ p0: V!): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: V!, /*1*/ p1: V!): kotlin.Boolean

                    // Static members
                    private final val serialVersionUID: kotlin.Long = -1848883965231344442.toLong()
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val valueOffset: kotlin.Long
                }

                public open class AtomicReferenceArray</*0*/ E> : java.io.Serializable {
                    public constructor AtomicReferenceArray</*0*/ E>(/*0*/ p0: kotlin.Array<(out) E!>!)
                    public constructor AtomicReferenceArray</*0*/ E>(/*0*/ p0: kotlin.Int)
                    private final val array: kotlin.Array<(out) kotlin.Any!>!
                    private open fun checkedByteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                    public final fun compareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: E!, /*2*/ p2: E!): kotlin.Boolean
                    private open fun compareAndSetRaw(/*0*/ p0: kotlin.Long, /*1*/ p1: E!, /*2*/ p2: E!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public final fun get(/*0*/ p0: kotlin.Int): E!
                    public final fun getAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: E!): E!
                    private open fun getRaw(/*0*/ p0: kotlin.Long): E!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun lazySet(/*0*/ p0: kotlin.Int, /*1*/ p1: E!): kotlin.Unit
                    public final fun length(): kotlin.Int
                    private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                    public final fun set(/*0*/ p0: kotlin.Int, /*1*/ p1: E!): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public final fun weakCompareAndSet(/*0*/ p0: kotlin.Int, /*1*/ p1: E!, /*2*/ p2: E!): kotlin.Boolean

                    // Static members
                    private final val arrayFieldOffset: kotlin.Long
                    private final val base: kotlin.Int
                    private final val serialVersionUID: kotlin.Long = -6209656149925076980.toLong()
                    private final val shift: kotlin.Int
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private open fun byteOffset(/*0*/ p0: kotlin.Int): kotlin.Long
                }

                public abstract class AtomicReferenceFieldUpdater</*0*/ T, /*1*/ V> {
                    protected/*protected and package*/ constructor AtomicReferenceFieldUpdater</*0*/ T, /*1*/ V>()
                    public abstract fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: V!, /*2*/ p2: V!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public abstract fun get(/*0*/ p0: T!): V!
                    public open fun getAndSet(/*0*/ p0: T!, /*1*/ p1: V!): V!
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public abstract fun lazySet(/*0*/ p0: T!, /*1*/ p1: V!): kotlin.Unit
                    public abstract fun set(/*0*/ p0: T!, /*1*/ p1: V!): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public abstract fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: V!, /*2*/ p2: V!): kotlin.Boolean

                    private final class AtomicReferenceFieldUpdaterImpl</*0*/ T, /*1*/ V> : java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T!, V!> {
                        public/*package*/ constructor AtomicReferenceFieldUpdaterImpl</*0*/ T, /*1*/ V>(/*0*/ p0: java.lang.Class<T!>!, /*1*/ p1: java.lang.Class<V!>!, /*2*/ p2: kotlin.String!)
                        private final val cclass: java.lang.Class<*>!
                        private final val offset: kotlin.Long
                        private final val tclass: java.lang.Class<T!>!
                        private final val vclass: java.lang.Class<V!>!
                        public open override /*1*/ fun compareAndSet(/*0*/ p0: T!, /*1*/ p1: V!, /*2*/ p2: V!): kotlin.Boolean
                        private open fun ensureProtectedAccess(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open override /*1*/ fun get(/*0*/ p0: T!): V!
                        public open override /*1*/ /*fake_override*/ fun getAndSet(/*0*/ p0: T!, /*1*/ p1: V!): V!
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ fun lazySet(/*0*/ p0: T!, /*1*/ p1: V!): kotlin.Unit
                        public open override /*1*/ fun set(/*0*/ p0: T!, /*1*/ p1: V!): kotlin.Unit
                        public/*package*/ open fun targetCheck(/*0*/ p0: T!): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        public/*package*/ open fun updateCheck(/*0*/ p0: T!, /*1*/ p1: V!): kotlin.Unit
                        public open override /*1*/ fun weakCompareAndSet(/*0*/ p0: T!, /*1*/ p1: V!, /*2*/ p2: V!): kotlin.Boolean

                        // Static members
                        private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    }

                    // Static members
                    public open fun </*0*/ U, /*1*/ W> newUpdater(/*0*/ p0: java.lang.Class<U!>!, /*1*/ p1: java.lang.Class<W!>!, /*2*/ p2: kotlin.String!): java.util.concurrent.atomic.AtomicReferenceFieldUpdater<U!, W!>!
                }

                public open class AtomicStampedReference</*0*/ V> {
                    public constructor AtomicStampedReference</*0*/ V>(/*0*/ p0: V!, /*1*/ p1: kotlin.Int)
                    private final var pair: java.util.concurrent.atomic.AtomicStampedReference.Pair<V!>!
                    public open fun attemptStamp(/*0*/ p0: V!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                    private open fun casPair(/*0*/ p0: java.util.concurrent.atomic.AtomicStampedReference.Pair<V!>!, /*1*/ p1: java.util.concurrent.atomic.AtomicStampedReference.Pair<V!>!): kotlin.Boolean
                    public open fun compareAndSet(/*0*/ p0: V!, /*1*/ p1: V!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun get(/*0*/ p0: kotlin.IntArray!): V!
                    public open fun getReference(): V!
                    public open fun getStamp(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open fun set(/*0*/ p0: V!, /*1*/ p1: kotlin.Int): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public open fun weakCompareAndSet(/*0*/ p0: V!, /*1*/ p1: V!, /*2*/ p2: kotlin.Int, /*3*/ p3: kotlin.Int): kotlin.Boolean

                    private open class Pair</*0*/ T> {
                        private constructor Pair</*0*/ T>(/*0*/ p0: T!, /*1*/ p1: kotlin.Int)
                        public/*package*/ final val reference: T!
                        public/*package*/ final val stamp: kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                        // Static members
                        public/*package*/ open fun </*0*/ T> of(/*0*/ p0: T!, /*1*/ p1: kotlin.Int): java.util.concurrent.atomic.AtomicStampedReference.Pair<T!>!
                    }

                    // Static members
                    private final val UNSAFE: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val pairOffset: kotlin.Long
                    public/*package*/ open fun objectFieldOffset(/*0*/ p0: [ERROR : Unresolved java classifier: Unsafe]!, /*1*/ p1: kotlin.String!, /*2*/ p2: java.lang.Class<*>!): kotlin.Long
                }
            }

            package java.util.concurrent.locks {

                public abstract class AbstractQueuedSynchronizer : java.io.Serializable {
                    protected/*protected and package*/ constructor AbstractQueuedSynchronizer()
                    private final var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                    private final var state: kotlin.Int
                    private final var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                    public final fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public final fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public/*package*/ final fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                    public final fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public final fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                    private open fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                    public/*package*/ final fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                    private open fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                    private final fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    protected/*protected and package*/ final fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                    private final fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    private open fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                    private open fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                    private open fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                    private open fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                    private open fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                    private open fun doReleaseShared(): kotlin.Unit
                    private open fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    private open fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    private open fun fullGetFirstQueuedThread(): java.lang.Thread!
                    public/*package*/ final fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                    public final fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public final fun getFirstQueuedThread(): java.lang.Thread!
                    public final fun getQueueLength(): kotlin.Int
                    public final fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public final fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    protected/*protected and package*/ final fun getState(): kotlin.Int
                    public final fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                    public final fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public final fun hasContended(): kotlin.Boolean
                    public final fun hasQueuedPredecessors(): kotlin.Boolean
                    public final fun hasQueuedThreads(): kotlin.Boolean
                    public final fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    protected/*protected and package*/ open fun isHeldExclusively(): kotlin.Boolean
                    public/*package*/ final fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    public final fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                    public final fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                    private final fun parkAndCheckInterrupt(): kotlin.Boolean
                    public final fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                    public final fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                    private open fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                    private open fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                    protected/*protected and package*/ final fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                    public open override /*1*/ fun toString(): kotlin.String!
                    public/*package*/ final fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    public/*package*/ final fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    protected/*protected and package*/ open fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                    public final fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                    protected/*protected and package*/ open fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                    public final fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                    protected/*protected and package*/ open fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                    protected/*protected and package*/ open fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                    private open fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit

                    public open inner class ConditionObject : java.util.concurrent.locks.Condition, java.io.Serializable {
                        public constructor ConditionObject()
                        private final var firstWaiter: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        private final var lastWaiter: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        private open fun addConditionWaiter(): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ fun await(): kotlin.Unit
                        public final override /*1*/ fun await(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Boolean
                        public final override /*1*/ fun awaitNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                        public final override /*1*/ fun awaitUninterruptibly(): kotlin.Unit
                        public final override /*1*/ fun awaitUntil(/*0*/ deadline: java.util.Date!): kotlin.Boolean
                        private open fun checkInterruptWhileWaiting(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        private open fun doSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        private open fun doSignalAll(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        protected/*protected and package*/ final fun getWaitQueueLength(): kotlin.Int
                        protected/*protected and package*/ final fun getWaitingThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final fun hasWaiters(): kotlin.Boolean
                        public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public/*package*/ final fun isOwnedBy(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer!): kotlin.Boolean
                        private open fun reportInterruptAfterWait(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ fun signal(): kotlin.Unit
                        public final override /*1*/ fun signalAll(): kotlin.Unit
                        public open override /*2*/ /*fake_override*/ fun toString(): kotlin.String
                        private open fun unlinkCancelledWaiters(): kotlin.Unit

                        // Static members
                        private final val REINTERRUPT: kotlin.Int = 1
                        private final val THROW_IE: kotlin.Int = -1
                        private final val serialVersionUID: kotlin.Long = 1173984872572414699.toLong()
                    }

                    public/*package*/ final class Node {
                        public/*package*/ constructor Node()
                        public/*package*/ constructor Node(/*0*/ p0: java.lang.Thread!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!)
                        public/*package*/ constructor Node(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Int)
                        public/*package*/ final var next: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final var nextWaiter: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final var prev: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final var thread: java.lang.Thread!
                        public/*package*/ final var waitStatus: kotlin.Int
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public/*package*/ final fun isShared(): kotlin.Boolean
                        public/*package*/ final fun predecessor(): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                        // Static members
                        public/*package*/ final val CANCELLED: kotlin.Int = 1
                        public/*package*/ final val CONDITION: kotlin.Int = -2
                        public/*package*/ final val EXCLUSIVE: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final val PROPAGATE: kotlin.Int = -3
                        public/*package*/ final val SHARED: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final val SIGNAL: kotlin.Int = -1
                    }

                    // Static members
                    private final val headOffset: kotlin.Long
                    private final val nextOffset: kotlin.Long
                    private final val serialVersionUID: kotlin.Long = 7373984972572414691.toLong()
                    public/*package*/ final val spinForTimeoutThreshold: kotlin.Long = 1000.toLong()
                    private final val stateOffset: kotlin.Long
                    private final val tailOffset: kotlin.Long
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    private final val waitStatusOffset: kotlin.Long
                    private final fun compareAndSetNext(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*2*/ p2: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                    private final fun compareAndSetWaitStatus(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int, /*2*/ p2: kotlin.Int): kotlin.Boolean
                    private open fun selfInterrupt(): kotlin.Unit
                    private open fun shouldParkAfterFailedAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                }

                public trait Condition {
                    public abstract fun await(): kotlin.Unit
                    public abstract fun await(/*0*/ p0: kotlin.Long, /*1*/ p1: java.util.concurrent.TimeUnit!): kotlin.Boolean
                    public abstract fun awaitNanos(/*0*/ p0: kotlin.Long): kotlin.Long
                    public abstract fun awaitUninterruptibly(): kotlin.Unit
                    public abstract fun awaitUntil(/*0*/ deadline: java.util.Date!): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public abstract fun signal(): kotlin.Unit
                    public abstract fun signalAll(): kotlin.Unit
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                }

                public trait Lock {
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public abstract fun lock(): kotlin.Unit
                    public abstract fun lockInterruptibly(): kotlin.Unit
                    public abstract fun newCondition(): java.util.concurrent.locks.Condition!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public abstract fun tryLock(): kotlin.Boolean
                    public abstract fun tryLock(/*0*/ time: kotlin.Long, /*1*/ unit: java.util.concurrent.TimeUnit!): kotlin.Boolean
                    public abstract fun unlock(): kotlin.Unit
                }

                public open class LockSupport {
                    private constructor LockSupport()
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String

                    // Static members
                    private final val parkBlockerOffset: kotlin.Long
                    private final val unsafe: [ERROR : Unresolved java classifier: Unsafe]!
                    public open fun getBlocker(/*0*/ p0: java.lang.Thread!): kotlin.Any!
                    public open fun park(): kotlin.Unit
                    public open fun park(/*0*/ p0: kotlin.Any!): kotlin.Unit
                    public open fun parkNanos(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open fun parkNanos(/*0*/ p0: kotlin.Long): kotlin.Unit
                    public open fun parkUntil(/*0*/ p0: kotlin.Any!, /*1*/ p1: kotlin.Long): kotlin.Unit
                    public open fun parkUntil(/*0*/ p0: kotlin.Long): kotlin.Unit
                    private open fun setBlocker(/*0*/ p0: java.lang.Thread!, /*1*/ p1: kotlin.Any!): kotlin.Unit
                    public open fun unpark(/*0*/ p0: java.lang.Thread!): kotlin.Unit
                }

                public trait ReadWriteLock {
                    public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public abstract fun readLock(): java.util.concurrent.locks.Lock!
                    public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                    public abstract fun writeLock(): java.util.concurrent.locks.Lock!
                }

                public open class ReentrantLock : java.util.concurrent.locks.Lock, java.io.Serializable {
                    public constructor ReentrantLock()
                    public constructor ReentrantLock(/*0*/ p0: kotlin.Boolean)
                    private final val sync: java.util.concurrent.locks.ReentrantLock.Sync!
                    public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    public open fun getHoldCount(): kotlin.Int
                    protected/*protected and package*/ open fun getOwner(): java.lang.Thread!
                    public final fun getQueueLength(): kotlin.Int
                    protected/*protected and package*/ open fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public open fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.Int
                    protected/*protected and package*/ open fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public final fun hasQueuedThread(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                    public final fun hasQueuedThreads(): kotlin.Boolean
                    public open fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.Boolean
                    public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun isFair(): kotlin.Boolean
                    public open fun isHeldByCurrentThread(): kotlin.Boolean
                    public open fun isLocked(): kotlin.Boolean
                    public open override /*1*/ fun lock(): kotlin.Unit
                    public open override /*1*/ fun lockInterruptibly(): kotlin.Unit
                    public open override /*1*/ fun newCondition(): java.util.concurrent.locks.Condition!
                    public open override /*2*/ fun toString(): kotlin.String!
                    public open override /*1*/ fun tryLock(): kotlin.Boolean
                    public open override /*1*/ fun tryLock(/*0*/ time: kotlin.Long, /*1*/ unit: java.util.concurrent.TimeUnit!): kotlin.Boolean
                    public open override /*1*/ fun unlock(): kotlin.Unit

                    public/*package*/ final class FairSync : java.util.concurrent.locks.ReentrantLock.Sync {
                        public/*package*/ constructor FairSync()
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getHoldCount(): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isLocked(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ final override /*1*/ fun lock(): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun nonfairTryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -3000897897090466540.toLong()
                    }

                    public/*package*/ final class NonfairSync : java.util.concurrent.locks.ReentrantLock.Sync {
                        public/*package*/ constructor NonfairSync()
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getHoldCount(): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isLocked(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ final override /*1*/ fun lock(): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun nonfairTryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit

                        // Static members
                        private final val serialVersionUID: kotlin.Long = 7316153563782823691.toLong()
                    }

                    public/*package*/ abstract class Sync : java.util.concurrent.locks.AbstractQueuedSynchronizer {
                        public/*package*/ constructor Sync()
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final fun getHoldCount(): kotlin.Int
                        public/*package*/ final fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final fun isLocked(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ abstract fun lock(): kotlin.Unit
                        public/*package*/ final fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public/*package*/ final fun nonfairTryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ open override /*1*/ /*fake_override*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -5179523762034025860.toLong()
                    }

                    // Static members
                    private final val serialVersionUID: kotlin.Long = 7373984872572414699.toLong()
                }

                public open class ReentrantReadWriteLock : java.util.concurrent.locks.ReadWriteLock, java.io.Serializable {
                    public constructor ReentrantReadWriteLock()
                    public constructor ReentrantReadWriteLock(/*0*/ p0: kotlin.Boolean)
                    private final val readerLock: java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock!
                    public/*package*/ final val sync: java.util.concurrent.locks.ReentrantReadWriteLock.Sync!
                    private final val writerLock: java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock!
                    public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                    protected/*protected and package*/ open fun getOwner(): java.lang.Thread!
                    public final fun getQueueLength(): kotlin.Int
                    protected/*protected and package*/ open fun getQueuedReaderThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    protected/*protected and package*/ open fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    protected/*protected and package*/ open fun getQueuedWriterThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public open fun getReadHoldCount(): kotlin.Int
                    public open fun getReadLockCount(): kotlin.Int
                    public open fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.Int
                    protected/*protected and package*/ open fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                    public open fun getWriteHoldCount(): kotlin.Int
                    public final fun hasQueuedThread(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                    public final fun hasQueuedThreads(): kotlin.Boolean
                    public open fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.Condition!): kotlin.Boolean
                    public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                    public final fun isFair(): kotlin.Boolean
                    public open fun isWriteLocked(): kotlin.Boolean
                    public open fun isWriteLockedByCurrentThread(): kotlin.Boolean
                    public open override /*1*/ fun readLock(): java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock!
                    public open override /*2*/ fun toString(): kotlin.String!
                    public open override /*1*/ fun writeLock(): java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock!

                    public/*package*/ final class FairSync : java.util.concurrent.locks.ReentrantReadWriteLock.Sync {
                        public/*package*/ constructor FairSync()
                        invisible_fake final override /*1*/ /*fake_override*/ var cachedHoldCounter: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                        invisible_fake final override /*1*/ /*fake_override*/ var firstReader: java.lang.Thread!
                        invisible_fake final override /*1*/ /*fake_override*/ var firstReaderHoldCount: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        invisible_fake final override /*1*/ /*fake_override*/ var readHolds: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullTryAcquireShared(/*0*/ p0: java.lang.Thread!): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getReadHoldCount(): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getReadLockCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getWriteHoldCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isWriteLocked(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public/*package*/ final override /*1*/ fun readerShouldBlock(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun tryReadLock(): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun tryWriteLock(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun unmatchedUnlockException(): [ERROR : Unresolved java classifier: IllegalMonitorStateException]!
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        public/*package*/ final override /*1*/ fun writerShouldBlock(): kotlin.Boolean

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -2274990926593161451.toLong()
                    }

                    public/*package*/ final class NonfairSync : java.util.concurrent.locks.ReentrantReadWriteLock.Sync {
                        public/*package*/ constructor NonfairSync()
                        invisible_fake final override /*1*/ /*fake_override*/ var cachedHoldCounter: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                        invisible_fake final override /*1*/ /*fake_override*/ var firstReader: java.lang.Thread!
                        invisible_fake final override /*1*/ /*fake_override*/ var firstReaderHoldCount: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        invisible_fake final override /*1*/ /*fake_override*/ var readHolds: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullTryAcquireShared(/*0*/ p0: java.lang.Thread!): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getReadHoldCount(): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getReadLockCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun getWriteHoldCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isWriteLocked(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public/*package*/ final override /*1*/ fun readerShouldBlock(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun tryReadLock(): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun tryWriteLock(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun unmatchedUnlockException(): [ERROR : Unresolved java classifier: IllegalMonitorStateException]!
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        public/*package*/ final override /*1*/ fun writerShouldBlock(): kotlin.Boolean

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -8159625535654395037.toLong()
                    }

                    public open class ReadLock : java.util.concurrent.locks.Lock, java.io.Serializable {
                        protected/*protected and package*/ constructor ReadLock(/*0*/ p0: java.util.concurrent.locks.ReentrantReadWriteLock!)
                        private final val sync: java.util.concurrent.locks.ReentrantReadWriteLock.Sync!
                        public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open override /*1*/ fun lock(): kotlin.Unit
                        public open override /*1*/ fun lockInterruptibly(): kotlin.Unit
                        public open override /*1*/ fun newCondition(): java.util.concurrent.locks.Condition!
                        public open override /*2*/ fun toString(): kotlin.String!
                        public open override /*1*/ fun tryLock(): kotlin.Boolean
                        public open override /*1*/ fun tryLock(/*0*/ time: kotlin.Long, /*1*/ unit: java.util.concurrent.TimeUnit!): kotlin.Boolean
                        public open override /*1*/ fun unlock(): kotlin.Unit

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -5992448646407690164.toLong()
                    }

                    public/*package*/ abstract class Sync : java.util.concurrent.locks.AbstractQueuedSynchronizer {
                        public/*package*/ constructor Sync()
                        private final var cachedHoldCounter: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                        private final var firstReader: java.lang.Thread!
                        private final var firstReaderHoldCount: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var head: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        private final var readHolds: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter!
                        invisible_fake final override /*1*/ /*fake_override*/ var state: kotlin.Int
                        invisible_fake final override /*1*/ /*fake_override*/ var tail: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public final override /*1*/ /*fake_override*/ fun acquire(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public/*package*/ final override /*1*/ /*fake_override*/ fun acquireQueued(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun acquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public final override /*1*/ /*fake_override*/ fun acquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun addWaiter(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun apparentlyFirstQueuedIsExclusive(): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun cancelAcquire(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun compareAndSetState(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Int): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun compareAndSetTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedInterruptibly(/*0*/ p0: kotlin.Int): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun doAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun doReleaseShared(): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun enq(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!
                        public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun findNodeFromTail(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun fullGetFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final fun fullTryAcquireShared(/*0*/ p0: java.lang.Thread!): kotlin.Int
                        public/*package*/ final override /*1*/ /*fake_override*/ fun fullyRelease(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Int
                        public/*package*/ final fun getCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getExclusiveQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public final override /*1*/ /*fake_override*/ fun getFirstQueuedThread(): java.lang.Thread!
                        public/*package*/ final fun getOwner(): java.lang.Thread!
                        public final override /*1*/ /*fake_override*/ fun getQueueLength(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final fun getReadHoldCount(): kotlin.Int
                        public/*package*/ final fun getReadLockCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getSharedQueuedThreads(): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun getState(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitQueueLength(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun getWaitingThreads(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.(Mutable)Collection<java.lang.Thread!>!
                        public/*package*/ final fun getWriteHoldCount(): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun hasContended(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedPredecessors(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasQueuedThreads(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun hasWaiters(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        protected/*protected and package*/ final override /*1*/ fun isHeldExclusively(): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun isOnSyncQueue(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun isQueued(/*0*/ p0: java.lang.Thread!): kotlin.Boolean
                        public/*package*/ final fun isWriteLocked(): kotlin.Boolean
                        public/*package*/ final fun newCondition(): java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!
                        public final override /*1*/ /*fake_override*/ fun owns(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject!): kotlin.Boolean
                        invisible_fake final override /*1*/ /*fake_override*/ fun parkAndCheckInterrupt(): kotlin.Boolean
                        private open fun readObject(/*0*/ p0: java.io.ObjectInputStream!): kotlin.Unit
                        public/*package*/ abstract fun readerShouldBlock(): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun release(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun releaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHead(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        invisible_fake open override /*1*/ /*fake_override*/ fun setHeadAndPropagate(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!, /*1*/ p1: kotlin.Int): kotlin.Unit
                        protected/*protected and package*/ final override /*1*/ /*fake_override*/ fun setState(/*0*/ p0: kotlin.Int): kotlin.Unit
                        public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String!
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferAfterCancelledWait(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        public/*package*/ final override /*1*/ /*fake_override*/ fun transferForSignal(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryAcquire(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public final override /*1*/ /*fake_override*/ fun tryAcquireNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryAcquireShared(/*0*/ p0: kotlin.Int): kotlin.Int
                        public final override /*1*/ /*fake_override*/ fun tryAcquireSharedNanos(/*0*/ p0: kotlin.Int, /*1*/ p1: kotlin.Long): kotlin.Boolean
                        public/*package*/ final fun tryReadLock(): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryRelease(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        protected/*protected and package*/ final override /*1*/ fun tryReleaseShared(/*0*/ p0: kotlin.Int): kotlin.Boolean
                        public/*package*/ final fun tryWriteLock(): kotlin.Boolean
                        private open fun unmatchedUnlockException(): [ERROR : Unresolved java classifier: IllegalMonitorStateException]!
                        invisible_fake open override /*1*/ /*fake_override*/ fun unparkSuccessor(/*0*/ p0: java.util.concurrent.locks.AbstractQueuedSynchronizer.Node!): kotlin.Unit
                        public/*package*/ abstract fun writerShouldBlock(): kotlin.Boolean

                        public/*package*/ final class HoldCounter {
                            public/*package*/ constructor HoldCounter()
                            public/*package*/ final var count: kotlin.Int
                            public/*package*/ final val tid: kotlin.Long
                            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        }

                        public/*package*/ final class ThreadLocalHoldCounter : java.lang.ThreadLocal<java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!> {
                            public/*package*/ constructor ThreadLocalHoldCounter()
                            invisible_fake final override /*1*/ /*fake_override*/ val threadLocalHashCode: kotlin.Int
                            invisible_fake open override /*1*/ /*fake_override*/ fun childValue(/*0*/ p0: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!): java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                            invisible_fake open override /*1*/ /*fake_override*/ fun createMap(/*0*/ p0: java.lang.Thread!, /*1*/ p1: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!): kotlin.Unit
                            public open override /*1*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                            public open override /*1*/ /*fake_override*/ fun get(): java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                            invisible_fake open override /*1*/ /*fake_override*/ fun getMap(/*0*/ p0: java.lang.Thread!): java.lang.ThreadLocal.ThreadLocalMap!
                            public open override /*1*/ /*fake_override*/ fun hashCode(): kotlin.Int
                            public open override /*1*/ fun initialValue(): java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                            public open override /*1*/ /*fake_override*/ fun remove(): kotlin.Unit
                            public open override /*1*/ /*fake_override*/ fun set(/*0*/ p0: java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!): kotlin.Unit
                            invisible_fake open override /*1*/ /*fake_override*/ fun setInitialValue(): java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter!
                            public open override /*1*/ /*fake_override*/ fun toString(): kotlin.String
                        }

                        // Static members
                        public/*package*/ final val EXCLUSIVE_MASK: kotlin.Int = 65535
                        public/*package*/ final val MAX_COUNT: kotlin.Int = 65535
                        public/*package*/ final val SHARED_SHIFT: kotlin.Int = 16
                        public/*package*/ final val SHARED_UNIT: kotlin.Int = 65536
                        private final val serialVersionUID: kotlin.Long = 6317671515068378041.toLong()
                        public/*package*/ open fun exclusiveCount(/*0*/ p0: kotlin.Int): kotlin.Int
                        public/*package*/ open fun sharedCount(/*0*/ p0: kotlin.Int): kotlin.Int
                    }

                    public open class WriteLock : java.util.concurrent.locks.Lock, java.io.Serializable {
                        protected/*protected and package*/ constructor WriteLock(/*0*/ p0: java.util.concurrent.locks.ReentrantReadWriteLock!)
                        private final val sync: java.util.concurrent.locks.ReentrantReadWriteLock.Sync!
                        public open override /*2*/ /*fake_override*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
                        public open fun getHoldCount(): kotlin.Int
                        public open override /*2*/ /*fake_override*/ fun hashCode(): kotlin.Int
                        public open fun isHeldByCurrentThread(): kotlin.Boolean
                        public open override /*1*/ fun lock(): kotlin.Unit
                        public open override /*1*/ fun lockInterruptibly(): kotlin.Unit
                        public open override /*1*/ fun newCondition(): java.util.concurrent.locks.Condition!
                        public open override /*2*/ fun toString(): kotlin.String!
                        public open override /*1*/ fun tryLock(): kotlin.Boolean
                        public open override /*1*/ fun tryLock(/*0*/ time: kotlin.Long, /*1*/ unit: java.util.concurrent.TimeUnit!): kotlin.Boolean
                        public open override /*1*/ fun unlock(): kotlin.Unit

                        // Static members
                        private final val serialVersionUID: kotlin.Long = -4992448646407690164.toLong()
                    }

                    // Static members
                    private final val serialVersionUID: kotlin.Long = -6992448646407690164.toLong()
                }
            }
        }
    }
}
