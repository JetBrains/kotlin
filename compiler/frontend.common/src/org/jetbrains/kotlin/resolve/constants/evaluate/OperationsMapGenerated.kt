/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */
@file:Suppress("DEPRECATION", "DEPRECATION_ERROR", "REDUNDANT_CALL_OF_CONVERSION_METHOD")

package org.jetbrains.kotlin.resolve.constants.evaluate

import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType.*
import java.math.BigInteger

/** This file is generated by `./gradlew generateOperationsMap`. DO NOT MODIFY MANUALLY */

fun evalUnaryOp(name: String, type: CompileTimeType, value: Any): Any? {
    when (type) {
        BOOLEAN -> when (name) {
            "not" -> return (value as Boolean).not()
            "toString" -> return (value as Boolean).toString()
        }
        BYTE -> when (name) {
            "toByte" -> return (value as Byte).toByte()
            "toChar" -> return (value as Byte).toChar()
            "toDouble" -> return (value as Byte).toDouble()
            "toFloat" -> return (value as Byte).toFloat()
            "toInt" -> return (value as Byte).toInt()
            "toLong" -> return (value as Byte).toLong()
            "toShort" -> return (value as Byte).toShort()
            "toString" -> return (value as Byte).toString()
            "unaryMinus" -> return (value as Byte).unaryMinus()
            "unaryPlus" -> return (value as Byte).unaryPlus()
            "toULong" -> return (value as Byte).toULong()
            "toUInt" -> return (value as Byte).toUInt()
            "toUShort" -> return (value as Byte).toUShort()
            "toUByte" -> return (value as Byte).toUByte()
        }
        CHAR -> when (name) {
            "toByte" -> return (value as Char).toByte()
            "toChar" -> return (value as Char).toChar()
            "toDouble" -> return (value as Char).toDouble()
            "toFloat" -> return (value as Char).toFloat()
            "toInt" -> return (value as Char).toInt()
            "toLong" -> return (value as Char).toLong()
            "toShort" -> return (value as Char).toShort()
            "toString" -> return (value as Char).toString()
            "code" -> return (value as Char).code
        }
        DOUBLE -> when (name) {
            "toByte" -> return (value as Double).toByte()
            "toChar" -> return (value as Double).toChar()
            "toDouble" -> return (value as Double).toDouble()
            "toFloat" -> return (value as Double).toFloat()
            "toInt" -> return (value as Double).toInt()
            "toLong" -> return (value as Double).toLong()
            "toShort" -> return (value as Double).toShort()
            "toString" -> return (value as Double).toString()
            "unaryMinus" -> return (value as Double).unaryMinus()
            "unaryPlus" -> return (value as Double).unaryPlus()
            "toULong" -> return (value as Double).toULong()
            "toUInt" -> return (value as Double).toUInt()
        }
        FLOAT -> when (name) {
            "toByte" -> return (value as Float).toByte()
            "toChar" -> return (value as Float).toChar()
            "toDouble" -> return (value as Float).toDouble()
            "toFloat" -> return (value as Float).toFloat()
            "toInt" -> return (value as Float).toInt()
            "toLong" -> return (value as Float).toLong()
            "toShort" -> return (value as Float).toShort()
            "toString" -> return (value as Float).toString()
            "unaryMinus" -> return (value as Float).unaryMinus()
            "unaryPlus" -> return (value as Float).unaryPlus()
            "toULong" -> return (value as Float).toULong()
            "toUInt" -> return (value as Float).toUInt()
        }
        INT -> when (name) {
            "inv" -> return (value as Int).inv()
            "toByte" -> return (value as Int).toByte()
            "toChar" -> return (value as Int).toChar()
            "toDouble" -> return (value as Int).toDouble()
            "toFloat" -> return (value as Int).toFloat()
            "toInt" -> return (value as Int).toInt()
            "toLong" -> return (value as Int).toLong()
            "toShort" -> return (value as Int).toShort()
            "toString" -> return (value as Int).toString()
            "unaryMinus" -> return (value as Int).unaryMinus()
            "unaryPlus" -> return (value as Int).unaryPlus()
            "toULong" -> return (value as Int).toULong()
            "toUInt" -> return (value as Int).toUInt()
            "toUShort" -> return (value as Int).toUShort()
            "toUByte" -> return (value as Int).toUByte()
        }
        LONG -> when (name) {
            "inv" -> return (value as Long).inv()
            "toByte" -> return (value as Long).toByte()
            "toChar" -> return (value as Long).toChar()
            "toDouble" -> return (value as Long).toDouble()
            "toFloat" -> return (value as Long).toFloat()
            "toInt" -> return (value as Long).toInt()
            "toLong" -> return (value as Long).toLong()
            "toShort" -> return (value as Long).toShort()
            "toString" -> return (value as Long).toString()
            "unaryMinus" -> return (value as Long).unaryMinus()
            "unaryPlus" -> return (value as Long).unaryPlus()
            "toULong" -> return (value as Long).toULong()
            "toUInt" -> return (value as Long).toUInt()
            "toUShort" -> return (value as Long).toUShort()
            "toUByte" -> return (value as Long).toUByte()
        }
        SHORT -> when (name) {
            "toByte" -> return (value as Short).toByte()
            "toChar" -> return (value as Short).toChar()
            "toDouble" -> return (value as Short).toDouble()
            "toFloat" -> return (value as Short).toFloat()
            "toInt" -> return (value as Short).toInt()
            "toLong" -> return (value as Short).toLong()
            "toShort" -> return (value as Short).toShort()
            "toString" -> return (value as Short).toString()
            "unaryMinus" -> return (value as Short).unaryMinus()
            "unaryPlus" -> return (value as Short).unaryPlus()
            "toULong" -> return (value as Short).toULong()
            "toUInt" -> return (value as Short).toUInt()
            "toUShort" -> return (value as Short).toUShort()
            "toUByte" -> return (value as Short).toUByte()
        }
        STRING -> when (name) {
            "length" -> return (value as String).length
            "toString" -> return (value as String).toString()
        }
        UINT -> when (name) {
            "inv" -> return (value as UInt).inv()
            "toByte" -> return (value as UInt).toByte()
            "toDouble" -> return (value as UInt).toDouble()
            "toFloat" -> return (value as UInt).toFloat()
            "toInt" -> return (value as UInt).toInt()
            "toLong" -> return (value as UInt).toLong()
            "toShort" -> return (value as UInt).toShort()
            "toString" -> return (value as UInt).toString()
            "toUByte" -> return (value as UInt).toUByte()
            "toUInt" -> return (value as UInt).toUInt()
            "toULong" -> return (value as UInt).toULong()
            "toUShort" -> return (value as UInt).toUShort()
        }
        ULONG -> when (name) {
            "inv" -> return (value as ULong).inv()
            "toByte" -> return (value as ULong).toByte()
            "toDouble" -> return (value as ULong).toDouble()
            "toFloat" -> return (value as ULong).toFloat()
            "toInt" -> return (value as ULong).toInt()
            "toLong" -> return (value as ULong).toLong()
            "toShort" -> return (value as ULong).toShort()
            "toString" -> return (value as ULong).toString()
            "toUByte" -> return (value as ULong).toUByte()
            "toUInt" -> return (value as ULong).toUInt()
            "toULong" -> return (value as ULong).toULong()
            "toUShort" -> return (value as ULong).toUShort()
        }
        UBYTE -> when (name) {
            "inv" -> return (value as UByte).inv()
            "toByte" -> return (value as UByte).toByte()
            "toDouble" -> return (value as UByte).toDouble()
            "toFloat" -> return (value as UByte).toFloat()
            "toInt" -> return (value as UByte).toInt()
            "toLong" -> return (value as UByte).toLong()
            "toShort" -> return (value as UByte).toShort()
            "toString" -> return (value as UByte).toString()
            "toUByte" -> return (value as UByte).toUByte()
            "toUInt" -> return (value as UByte).toUInt()
            "toULong" -> return (value as UByte).toULong()
            "toUShort" -> return (value as UByte).toUShort()
        }
        USHORT -> when (name) {
            "inv" -> return (value as UShort).inv()
            "toByte" -> return (value as UShort).toByte()
            "toDouble" -> return (value as UShort).toDouble()
            "toFloat" -> return (value as UShort).toFloat()
            "toInt" -> return (value as UShort).toInt()
            "toLong" -> return (value as UShort).toLong()
            "toShort" -> return (value as UShort).toShort()
            "toString" -> return (value as UShort).toString()
            "toUByte" -> return (value as UShort).toUByte()
            "toUInt" -> return (value as UShort).toUInt()
            "toULong" -> return (value as UShort).toULong()
            "toUShort" -> return (value as UShort).toUShort()
        }
        else -> {}
    }
    return null
}

fun evalBinaryOp(name: String, leftType: CompileTimeType, left: Any, rightType: CompileTimeType, right: Any): Any? {
    when (leftType) {
        BOOLEAN -> when (rightType) {
            BOOLEAN -> when (name) {
                "and" -> return (left as Boolean).and(right as Boolean)
                "compareTo" -> return (left as Boolean).compareTo(right as Boolean)
                "or" -> return (left as Boolean).or(right as Boolean)
                "xor" -> return (left as Boolean).xor(right as Boolean)
            }
            ANY -> when (name) {
                "equals" -> return (left as Boolean).equals(right)
            }
            else -> {}
        }
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Byte)
                "div" -> return (left as Byte).div(right as Byte)
                "minus" -> return (left as Byte).minus(right as Byte)
                "plus" -> return (left as Byte).plus(right as Byte)
                "rem" -> return (left as Byte).rem(right as Byte)
                "times" -> return (left as Byte).times(right as Byte)
                "mod" -> return (left as Byte).mod(right as Byte)
                "floorDiv" -> return (left as Byte).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Short)
                "div" -> return (left as Byte).div(right as Short)
                "minus" -> return (left as Byte).minus(right as Short)
                "plus" -> return (left as Byte).plus(right as Short)
                "rem" -> return (left as Byte).rem(right as Short)
                "times" -> return (left as Byte).times(right as Short)
                "mod" -> return (left as Byte).mod(right as Short)
                "floorDiv" -> return (left as Byte).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Int)
                "div" -> return (left as Byte).div(right as Int)
                "minus" -> return (left as Byte).minus(right as Int)
                "plus" -> return (left as Byte).plus(right as Int)
                "rem" -> return (left as Byte).rem(right as Int)
                "times" -> return (left as Byte).times(right as Int)
                "mod" -> return (left as Byte).mod(right as Int)
                "floorDiv" -> return (left as Byte).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Long)
                "div" -> return (left as Byte).div(right as Long)
                "minus" -> return (left as Byte).minus(right as Long)
                "plus" -> return (left as Byte).plus(right as Long)
                "rem" -> return (left as Byte).rem(right as Long)
                "times" -> return (left as Byte).times(right as Long)
                "mod" -> return (left as Byte).mod(right as Long)
                "floorDiv" -> return (left as Byte).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Float)
                "div" -> return (left as Byte).div(right as Float)
                "minus" -> return (left as Byte).minus(right as Float)
                "plus" -> return (left as Byte).plus(right as Float)
                "rem" -> return (left as Byte).rem(right as Float)
                "times" -> return (left as Byte).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Double)
                "div" -> return (left as Byte).div(right as Double)
                "minus" -> return (left as Byte).minus(right as Double)
                "plus" -> return (left as Byte).plus(right as Double)
                "rem" -> return (left as Byte).rem(right as Double)
                "times" -> return (left as Byte).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Byte).equals(right)
            }
            else -> {}
        }
        CHAR -> when (rightType) {
            CHAR -> when (name) {
                "compareTo" -> return (left as Char).compareTo(right as Char)
                "minus" -> return (left as Char).minus(right as Char)
            }
            ANY -> when (name) {
                "equals" -> return (left as Char).equals(right)
            }
            INT -> when (name) {
                "minus" -> return (left as Char).minus(right as Int)
                "plus" -> return (left as Char).plus(right as Int)
            }
            else -> {}
        }
        DOUBLE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Byte)
                "div" -> return (left as Double).div(right as Byte)
                "minus" -> return (left as Double).minus(right as Byte)
                "plus" -> return (left as Double).plus(right as Byte)
                "rem" -> return (left as Double).rem(right as Byte)
                "times" -> return (left as Double).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Short)
                "div" -> return (left as Double).div(right as Short)
                "minus" -> return (left as Double).minus(right as Short)
                "plus" -> return (left as Double).plus(right as Short)
                "rem" -> return (left as Double).rem(right as Short)
                "times" -> return (left as Double).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Int)
                "div" -> return (left as Double).div(right as Int)
                "minus" -> return (left as Double).minus(right as Int)
                "plus" -> return (left as Double).plus(right as Int)
                "rem" -> return (left as Double).rem(right as Int)
                "times" -> return (left as Double).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Long)
                "div" -> return (left as Double).div(right as Long)
                "minus" -> return (left as Double).minus(right as Long)
                "plus" -> return (left as Double).plus(right as Long)
                "rem" -> return (left as Double).rem(right as Long)
                "times" -> return (left as Double).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Float)
                "div" -> return (left as Double).div(right as Float)
                "minus" -> return (left as Double).minus(right as Float)
                "plus" -> return (left as Double).plus(right as Float)
                "rem" -> return (left as Double).rem(right as Float)
                "times" -> return (left as Double).times(right as Float)
                "mod" -> return (left as Double).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Double)
                "div" -> return (left as Double).div(right as Double)
                "minus" -> return (left as Double).minus(right as Double)
                "plus" -> return (left as Double).plus(right as Double)
                "rem" -> return (left as Double).rem(right as Double)
                "times" -> return (left as Double).times(right as Double)
                "mod" -> return (left as Double).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Double).equals(right)
            }
            else -> {}
        }
        FLOAT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Byte)
                "div" -> return (left as Float).div(right as Byte)
                "minus" -> return (left as Float).minus(right as Byte)
                "plus" -> return (left as Float).plus(right as Byte)
                "rem" -> return (left as Float).rem(right as Byte)
                "times" -> return (left as Float).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Short)
                "div" -> return (left as Float).div(right as Short)
                "minus" -> return (left as Float).minus(right as Short)
                "plus" -> return (left as Float).plus(right as Short)
                "rem" -> return (left as Float).rem(right as Short)
                "times" -> return (left as Float).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Int)
                "div" -> return (left as Float).div(right as Int)
                "minus" -> return (left as Float).minus(right as Int)
                "plus" -> return (left as Float).plus(right as Int)
                "rem" -> return (left as Float).rem(right as Int)
                "times" -> return (left as Float).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Long)
                "div" -> return (left as Float).div(right as Long)
                "minus" -> return (left as Float).minus(right as Long)
                "plus" -> return (left as Float).plus(right as Long)
                "rem" -> return (left as Float).rem(right as Long)
                "times" -> return (left as Float).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Float)
                "div" -> return (left as Float).div(right as Float)
                "minus" -> return (left as Float).minus(right as Float)
                "plus" -> return (left as Float).plus(right as Float)
                "rem" -> return (left as Float).rem(right as Float)
                "times" -> return (left as Float).times(right as Float)
                "mod" -> return (left as Float).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Double)
                "div" -> return (left as Float).div(right as Double)
                "minus" -> return (left as Float).minus(right as Double)
                "plus" -> return (left as Float).plus(right as Double)
                "rem" -> return (left as Float).rem(right as Double)
                "times" -> return (left as Float).times(right as Double)
                "mod" -> return (left as Float).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Float).equals(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return (left as Int).and(right as Int)
                "compareTo" -> return (left as Int).compareTo(right as Int)
                "div" -> return (left as Int).div(right as Int)
                "minus" -> return (left as Int).minus(right as Int)
                "or" -> return (left as Int).or(right as Int)
                "plus" -> return (left as Int).plus(right as Int)
                "rem" -> return (left as Int).rem(right as Int)
                "shl" -> return (left as Int).shl(right as Int)
                "shr" -> return (left as Int).shr(right as Int)
                "times" -> return (left as Int).times(right as Int)
                "ushr" -> return (left as Int).ushr(right as Int)
                "xor" -> return (left as Int).xor(right as Int)
                "mod" -> return (left as Int).mod(right as Int)
                "floorDiv" -> return (left as Int).floorDiv(right as Int)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Byte)
                "div" -> return (left as Int).div(right as Byte)
                "minus" -> return (left as Int).minus(right as Byte)
                "plus" -> return (left as Int).plus(right as Byte)
                "rem" -> return (left as Int).rem(right as Byte)
                "times" -> return (left as Int).times(right as Byte)
                "mod" -> return (left as Int).mod(right as Byte)
                "floorDiv" -> return (left as Int).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Short)
                "div" -> return (left as Int).div(right as Short)
                "minus" -> return (left as Int).minus(right as Short)
                "plus" -> return (left as Int).plus(right as Short)
                "rem" -> return (left as Int).rem(right as Short)
                "times" -> return (left as Int).times(right as Short)
                "mod" -> return (left as Int).mod(right as Short)
                "floorDiv" -> return (left as Int).floorDiv(right as Short)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Long)
                "div" -> return (left as Int).div(right as Long)
                "minus" -> return (left as Int).minus(right as Long)
                "plus" -> return (left as Int).plus(right as Long)
                "rem" -> return (left as Int).rem(right as Long)
                "times" -> return (left as Int).times(right as Long)
                "mod" -> return (left as Int).mod(right as Long)
                "floorDiv" -> return (left as Int).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Float)
                "div" -> return (left as Int).div(right as Float)
                "minus" -> return (left as Int).minus(right as Float)
                "plus" -> return (left as Int).plus(right as Float)
                "rem" -> return (left as Int).rem(right as Float)
                "times" -> return (left as Int).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Double)
                "div" -> return (left as Int).div(right as Double)
                "minus" -> return (left as Int).minus(right as Double)
                "plus" -> return (left as Int).plus(right as Double)
                "rem" -> return (left as Int).rem(right as Double)
                "times" -> return (left as Int).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Int).equals(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return (left as Long).and(right as Long)
                "compareTo" -> return (left as Long).compareTo(right as Long)
                "div" -> return (left as Long).div(right as Long)
                "minus" -> return (left as Long).minus(right as Long)
                "or" -> return (left as Long).or(right as Long)
                "plus" -> return (left as Long).plus(right as Long)
                "rem" -> return (left as Long).rem(right as Long)
                "times" -> return (left as Long).times(right as Long)
                "xor" -> return (left as Long).xor(right as Long)
                "mod" -> return (left as Long).mod(right as Long)
                "floorDiv" -> return (left as Long).floorDiv(right as Long)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Byte)
                "div" -> return (left as Long).div(right as Byte)
                "minus" -> return (left as Long).minus(right as Byte)
                "plus" -> return (left as Long).plus(right as Byte)
                "rem" -> return (left as Long).rem(right as Byte)
                "times" -> return (left as Long).times(right as Byte)
                "mod" -> return (left as Long).mod(right as Byte)
                "floorDiv" -> return (left as Long).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Short)
                "div" -> return (left as Long).div(right as Short)
                "minus" -> return (left as Long).minus(right as Short)
                "plus" -> return (left as Long).plus(right as Short)
                "rem" -> return (left as Long).rem(right as Short)
                "times" -> return (left as Long).times(right as Short)
                "mod" -> return (left as Long).mod(right as Short)
                "floorDiv" -> return (left as Long).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Int)
                "div" -> return (left as Long).div(right as Int)
                "minus" -> return (left as Long).minus(right as Int)
                "plus" -> return (left as Long).plus(right as Int)
                "rem" -> return (left as Long).rem(right as Int)
                "shl" -> return (left as Long).shl(right as Int)
                "shr" -> return (left as Long).shr(right as Int)
                "times" -> return (left as Long).times(right as Int)
                "ushr" -> return (left as Long).ushr(right as Int)
                "mod" -> return (left as Long).mod(right as Int)
                "floorDiv" -> return (left as Long).floorDiv(right as Int)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Float)
                "div" -> return (left as Long).div(right as Float)
                "minus" -> return (left as Long).minus(right as Float)
                "plus" -> return (left as Long).plus(right as Float)
                "rem" -> return (left as Long).rem(right as Float)
                "times" -> return (left as Long).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Double)
                "div" -> return (left as Long).div(right as Double)
                "minus" -> return (left as Long).minus(right as Double)
                "plus" -> return (left as Long).plus(right as Double)
                "rem" -> return (left as Long).rem(right as Double)
                "times" -> return (left as Long).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Long).equals(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Byte)
                "div" -> return (left as Short).div(right as Byte)
                "minus" -> return (left as Short).minus(right as Byte)
                "plus" -> return (left as Short).plus(right as Byte)
                "rem" -> return (left as Short).rem(right as Byte)
                "times" -> return (left as Short).times(right as Byte)
                "mod" -> return (left as Short).mod(right as Byte)
                "floorDiv" -> return (left as Short).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Short)
                "div" -> return (left as Short).div(right as Short)
                "minus" -> return (left as Short).minus(right as Short)
                "plus" -> return (left as Short).plus(right as Short)
                "rem" -> return (left as Short).rem(right as Short)
                "times" -> return (left as Short).times(right as Short)
                "mod" -> return (left as Short).mod(right as Short)
                "floorDiv" -> return (left as Short).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Int)
                "div" -> return (left as Short).div(right as Int)
                "minus" -> return (left as Short).minus(right as Int)
                "plus" -> return (left as Short).plus(right as Int)
                "rem" -> return (left as Short).rem(right as Int)
                "times" -> return (left as Short).times(right as Int)
                "mod" -> return (left as Short).mod(right as Int)
                "floorDiv" -> return (left as Short).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Long)
                "div" -> return (left as Short).div(right as Long)
                "minus" -> return (left as Short).minus(right as Long)
                "plus" -> return (left as Short).plus(right as Long)
                "rem" -> return (left as Short).rem(right as Long)
                "times" -> return (left as Short).times(right as Long)
                "mod" -> return (left as Short).mod(right as Long)
                "floorDiv" -> return (left as Short).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Float)
                "div" -> return (left as Short).div(right as Float)
                "minus" -> return (left as Short).minus(right as Float)
                "plus" -> return (left as Short).plus(right as Float)
                "rem" -> return (left as Short).rem(right as Float)
                "times" -> return (left as Short).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Double)
                "div" -> return (left as Short).div(right as Double)
                "minus" -> return (left as Short).minus(right as Double)
                "plus" -> return (left as Short).plus(right as Double)
                "rem" -> return (left as Short).rem(right as Double)
                "times" -> return (left as Short).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Short).equals(right)
            }
            else -> {}
        }
        STRING -> when (rightType) {
            STRING -> when (name) {
                "compareTo" -> return (left as String).compareTo(right as String)
            }
            ANY -> when (name) {
                "equals" -> return (left as String).equals(right)
                "plus" -> return (left as String).plus(right)
            }
            INT -> when (name) {
                "get" -> return (left as String).get(right as Int)
            }
            else -> {}
        }
        UINT -> when (rightType) {
            UINT -> when (name) {
                "and" -> return (left as UInt).and(right as UInt)
                "compareTo" -> return (left as UInt).compareTo(right as UInt)
                "div" -> return (left as UInt).div(right as UInt)
                "floorDiv" -> return (left as UInt).floorDiv(right as UInt)
                "minus" -> return (left as UInt).minus(right as UInt)
                "mod" -> return (left as UInt).mod(right as UInt)
                "or" -> return (left as UInt).or(right as UInt)
                "plus" -> return (left as UInt).plus(right as UInt)
                "rem" -> return (left as UInt).rem(right as UInt)
                "times" -> return (left as UInt).times(right as UInt)
                "xor" -> return (left as UInt).xor(right as UInt)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UByte)
                "div" -> return (left as UInt).div(right as UByte)
                "floorDiv" -> return (left as UInt).floorDiv(right as UByte)
                "minus" -> return (left as UInt).minus(right as UByte)
                "mod" -> return (left as UInt).mod(right as UByte)
                "plus" -> return (left as UInt).plus(right as UByte)
                "rem" -> return (left as UInt).rem(right as UByte)
                "times" -> return (left as UInt).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UShort)
                "div" -> return (left as UInt).div(right as UShort)
                "floorDiv" -> return (left as UInt).floorDiv(right as UShort)
                "minus" -> return (left as UInt).minus(right as UShort)
                "mod" -> return (left as UInt).mod(right as UShort)
                "plus" -> return (left as UInt).plus(right as UShort)
                "rem" -> return (left as UInt).rem(right as UShort)
                "times" -> return (left as UInt).times(right as UShort)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as ULong)
                "div" -> return (left as UInt).div(right as ULong)
                "floorDiv" -> return (left as UInt).floorDiv(right as ULong)
                "minus" -> return (left as UInt).minus(right as ULong)
                "mod" -> return (left as UInt).mod(right as ULong)
                "plus" -> return (left as UInt).plus(right as ULong)
                "rem" -> return (left as UInt).rem(right as ULong)
                "times" -> return (left as UInt).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UInt).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as UInt).shl(right as Int)
                "shr" -> return (left as UInt).shr(right as Int)
            }
            else -> {}
        }
        ULONG -> when (rightType) {
            ULONG -> when (name) {
                "and" -> return (left as ULong).and(right as ULong)
                "compareTo" -> return (left as ULong).compareTo(right as ULong)
                "div" -> return (left as ULong).div(right as ULong)
                "floorDiv" -> return (left as ULong).floorDiv(right as ULong)
                "minus" -> return (left as ULong).minus(right as ULong)
                "mod" -> return (left as ULong).mod(right as ULong)
                "or" -> return (left as ULong).or(right as ULong)
                "plus" -> return (left as ULong).plus(right as ULong)
                "rem" -> return (left as ULong).rem(right as ULong)
                "times" -> return (left as ULong).times(right as ULong)
                "xor" -> return (left as ULong).xor(right as ULong)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UByte)
                "div" -> return (left as ULong).div(right as UByte)
                "floorDiv" -> return (left as ULong).floorDiv(right as UByte)
                "minus" -> return (left as ULong).minus(right as UByte)
                "mod" -> return (left as ULong).mod(right as UByte)
                "plus" -> return (left as ULong).plus(right as UByte)
                "rem" -> return (left as ULong).rem(right as UByte)
                "times" -> return (left as ULong).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UShort)
                "div" -> return (left as ULong).div(right as UShort)
                "floorDiv" -> return (left as ULong).floorDiv(right as UShort)
                "minus" -> return (left as ULong).minus(right as UShort)
                "mod" -> return (left as ULong).mod(right as UShort)
                "plus" -> return (left as ULong).plus(right as UShort)
                "rem" -> return (left as ULong).rem(right as UShort)
                "times" -> return (left as ULong).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UInt)
                "div" -> return (left as ULong).div(right as UInt)
                "floorDiv" -> return (left as ULong).floorDiv(right as UInt)
                "minus" -> return (left as ULong).minus(right as UInt)
                "mod" -> return (left as ULong).mod(right as UInt)
                "plus" -> return (left as ULong).plus(right as UInt)
                "rem" -> return (left as ULong).rem(right as UInt)
                "times" -> return (left as ULong).times(right as UInt)
            }
            ANY -> when (name) {
                "equals" -> return (left as ULong).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as ULong).shl(right as Int)
                "shr" -> return (left as ULong).shr(right as Int)
            }
            else -> {}
        }
        UBYTE -> when (rightType) {
            UBYTE -> when (name) {
                "and" -> return (left as UByte).and(right as UByte)
                "compareTo" -> return (left as UByte).compareTo(right as UByte)
                "div" -> return (left as UByte).div(right as UByte)
                "floorDiv" -> return (left as UByte).floorDiv(right as UByte)
                "minus" -> return (left as UByte).minus(right as UByte)
                "mod" -> return (left as UByte).mod(right as UByte)
                "or" -> return (left as UByte).or(right as UByte)
                "plus" -> return (left as UByte).plus(right as UByte)
                "rem" -> return (left as UByte).rem(right as UByte)
                "times" -> return (left as UByte).times(right as UByte)
                "xor" -> return (left as UByte).xor(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UShort)
                "div" -> return (left as UByte).div(right as UShort)
                "floorDiv" -> return (left as UByte).floorDiv(right as UShort)
                "minus" -> return (left as UByte).minus(right as UShort)
                "mod" -> return (left as UByte).mod(right as UShort)
                "plus" -> return (left as UByte).plus(right as UShort)
                "rem" -> return (left as UByte).rem(right as UShort)
                "times" -> return (left as UByte).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UInt)
                "div" -> return (left as UByte).div(right as UInt)
                "floorDiv" -> return (left as UByte).floorDiv(right as UInt)
                "minus" -> return (left as UByte).minus(right as UInt)
                "mod" -> return (left as UByte).mod(right as UInt)
                "plus" -> return (left as UByte).plus(right as UInt)
                "rem" -> return (left as UByte).rem(right as UInt)
                "times" -> return (left as UByte).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as ULong)
                "div" -> return (left as UByte).div(right as ULong)
                "floorDiv" -> return (left as UByte).floorDiv(right as ULong)
                "minus" -> return (left as UByte).minus(right as ULong)
                "mod" -> return (left as UByte).mod(right as ULong)
                "plus" -> return (left as UByte).plus(right as ULong)
                "rem" -> return (left as UByte).rem(right as ULong)
                "times" -> return (left as UByte).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UByte).equals(right)
            }
            else -> {}
        }
        USHORT -> when (rightType) {
            USHORT -> when (name) {
                "and" -> return (left as UShort).and(right as UShort)
                "compareTo" -> return (left as UShort).compareTo(right as UShort)
                "div" -> return (left as UShort).div(right as UShort)
                "floorDiv" -> return (left as UShort).floorDiv(right as UShort)
                "minus" -> return (left as UShort).minus(right as UShort)
                "mod" -> return (left as UShort).mod(right as UShort)
                "or" -> return (left as UShort).or(right as UShort)
                "plus" -> return (left as UShort).plus(right as UShort)
                "rem" -> return (left as UShort).rem(right as UShort)
                "times" -> return (left as UShort).times(right as UShort)
                "xor" -> return (left as UShort).xor(right as UShort)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UByte)
                "div" -> return (left as UShort).div(right as UByte)
                "floorDiv" -> return (left as UShort).floorDiv(right as UByte)
                "minus" -> return (left as UShort).minus(right as UByte)
                "mod" -> return (left as UShort).mod(right as UByte)
                "plus" -> return (left as UShort).plus(right as UByte)
                "rem" -> return (left as UShort).rem(right as UByte)
                "times" -> return (left as UShort).times(right as UByte)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UInt)
                "div" -> return (left as UShort).div(right as UInt)
                "floorDiv" -> return (left as UShort).floorDiv(right as UInt)
                "minus" -> return (left as UShort).minus(right as UInt)
                "mod" -> return (left as UShort).mod(right as UInt)
                "plus" -> return (left as UShort).plus(right as UInt)
                "rem" -> return (left as UShort).rem(right as UInt)
                "times" -> return (left as UShort).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as ULong)
                "div" -> return (left as UShort).div(right as ULong)
                "floorDiv" -> return (left as UShort).floorDiv(right as ULong)
                "minus" -> return (left as UShort).minus(right as ULong)
                "mod" -> return (left as UShort).mod(right as ULong)
                "plus" -> return (left as UShort).plus(right as ULong)
                "rem" -> return (left as UShort).rem(right as ULong)
                "times" -> return (left as UShort).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UShort).equals(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}

fun checkBinaryOp(
    name: String, leftType: CompileTimeType, left: BigInteger, rightType: CompileTimeType, right: BigInteger
): BigInteger? {
    when (leftType) {
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}
private val knownOps = setOf(
    "kotlin/Boolean.not(BOOLEAN)",
    "kotlin/Boolean.toString(BOOLEAN)",
    "kotlin/Byte.toByte(BYTE)",
    "kotlin/Byte.toChar(BYTE)",
    "kotlin/Byte.toDouble(BYTE)",
    "kotlin/Byte.toFloat(BYTE)",
    "kotlin/Byte.toInt(BYTE)",
    "kotlin/Byte.toLong(BYTE)",
    "kotlin/Byte.toShort(BYTE)",
    "kotlin/Byte.toString(BYTE)",
    "kotlin/Byte.unaryMinus(BYTE)",
    "kotlin/Byte.unaryPlus(BYTE)",
    "kotlin/Char.toByte(CHAR)",
    "kotlin/Char.toChar(CHAR)",
    "kotlin/Char.toDouble(CHAR)",
    "kotlin/Char.toFloat(CHAR)",
    "kotlin/Char.toInt(CHAR)",
    "kotlin/Char.toLong(CHAR)",
    "kotlin/Char.toShort(CHAR)",
    "kotlin/Char.toString(CHAR)",
    "kotlin/Double.toByte(DOUBLE)",
    "kotlin/Double.toChar(DOUBLE)",
    "kotlin/Double.toDouble(DOUBLE)",
    "kotlin/Double.toFloat(DOUBLE)",
    "kotlin/Double.toInt(DOUBLE)",
    "kotlin/Double.toLong(DOUBLE)",
    "kotlin/Double.toShort(DOUBLE)",
    "kotlin/Double.toString(DOUBLE)",
    "kotlin/Double.unaryMinus(DOUBLE)",
    "kotlin/Double.unaryPlus(DOUBLE)",
    "kotlin/Float.toByte(FLOAT)",
    "kotlin/Float.toChar(FLOAT)",
    "kotlin/Float.toDouble(FLOAT)",
    "kotlin/Float.toFloat(FLOAT)",
    "kotlin/Float.toInt(FLOAT)",
    "kotlin/Float.toLong(FLOAT)",
    "kotlin/Float.toShort(FLOAT)",
    "kotlin/Float.toString(FLOAT)",
    "kotlin/Float.unaryMinus(FLOAT)",
    "kotlin/Float.unaryPlus(FLOAT)",
    "kotlin/Int.inv(INT)",
    "kotlin/Int.toByte(INT)",
    "kotlin/Int.toChar(INT)",
    "kotlin/Int.toDouble(INT)",
    "kotlin/Int.toFloat(INT)",
    "kotlin/Int.toInt(INT)",
    "kotlin/Int.toLong(INT)",
    "kotlin/Int.toShort(INT)",
    "kotlin/Int.toString(INT)",
    "kotlin/Int.unaryMinus(INT)",
    "kotlin/Int.unaryPlus(INT)",
    "kotlin/Long.inv(LONG)",
    "kotlin/Long.toByte(LONG)",
    "kotlin/Long.toChar(LONG)",
    "kotlin/Long.toDouble(LONG)",
    "kotlin/Long.toFloat(LONG)",
    "kotlin/Long.toInt(LONG)",
    "kotlin/Long.toLong(LONG)",
    "kotlin/Long.toShort(LONG)",
    "kotlin/Long.toString(LONG)",
    "kotlin/Long.unaryMinus(LONG)",
    "kotlin/Long.unaryPlus(LONG)",
    "kotlin/Short.toByte(SHORT)",
    "kotlin/Short.toChar(SHORT)",
    "kotlin/Short.toDouble(SHORT)",
    "kotlin/Short.toFloat(SHORT)",
    "kotlin/Short.toInt(SHORT)",
    "kotlin/Short.toLong(SHORT)",
    "kotlin/Short.toShort(SHORT)",
    "kotlin/Short.toString(SHORT)",
    "kotlin/Short.unaryMinus(SHORT)",
    "kotlin/Short.unaryPlus(SHORT)",
    "kotlin/String.length(STRING)",
    "kotlin/String.toString(STRING)",
    "kotlin/Char.code(CHAR)",
    "kotlin/UInt.inv(UINT)",
    "kotlin/UInt.toByte(UINT)",
    "kotlin/UInt.toDouble(UINT)",
    "kotlin/UInt.toFloat(UINT)",
    "kotlin/UInt.toInt(UINT)",
    "kotlin/UInt.toLong(UINT)",
    "kotlin/UInt.toShort(UINT)",
    "kotlin/UInt.toString(UINT)",
    "kotlin/UInt.toUByte(UINT)",
    "kotlin/UInt.toUInt(UINT)",
    "kotlin/UInt.toULong(UINT)",
    "kotlin/UInt.toUShort(UINT)",
    "kotlin/ULong.inv(ULONG)",
    "kotlin/ULong.toByte(ULONG)",
    "kotlin/ULong.toDouble(ULONG)",
    "kotlin/ULong.toFloat(ULONG)",
    "kotlin/ULong.toInt(ULONG)",
    "kotlin/ULong.toLong(ULONG)",
    "kotlin/ULong.toShort(ULONG)",
    "kotlin/ULong.toString(ULONG)",
    "kotlin/ULong.toUByte(ULONG)",
    "kotlin/ULong.toUInt(ULONG)",
    "kotlin/ULong.toULong(ULONG)",
    "kotlin/ULong.toUShort(ULONG)",
    "kotlin/UByte.inv(UBYTE)",
    "kotlin/UByte.toByte(UBYTE)",
    "kotlin/UByte.toDouble(UBYTE)",
    "kotlin/UByte.toFloat(UBYTE)",
    "kotlin/UByte.toInt(UBYTE)",
    "kotlin/UByte.toLong(UBYTE)",
    "kotlin/UByte.toShort(UBYTE)",
    "kotlin/UByte.toString(UBYTE)",
    "kotlin/UByte.toUByte(UBYTE)",
    "kotlin/UByte.toUInt(UBYTE)",
    "kotlin/UByte.toULong(UBYTE)",
    "kotlin/UByte.toUShort(UBYTE)",
    "kotlin/UShort.inv(USHORT)",
    "kotlin/UShort.toByte(USHORT)",
    "kotlin/UShort.toDouble(USHORT)",
    "kotlin/UShort.toFloat(USHORT)",
    "kotlin/UShort.toInt(USHORT)",
    "kotlin/UShort.toLong(USHORT)",
    "kotlin/UShort.toShort(USHORT)",
    "kotlin/UShort.toString(USHORT)",
    "kotlin/UShort.toUByte(USHORT)",
    "kotlin/UShort.toUInt(USHORT)",
    "kotlin/UShort.toULong(USHORT)",
    "kotlin/UShort.toUShort(USHORT)",
    "kotlin/ULong.toULong(LONG)",
    "kotlin/UInt.toUInt(LONG)",
    "kotlin/UShort.toUShort(LONG)",
    "kotlin/UByte.toUByte(LONG)",
    "kotlin/ULong.toULong(INT)",
    "kotlin/UInt.toUInt(INT)",
    "kotlin/UShort.toUShort(INT)",
    "kotlin/UByte.toUByte(INT)",
    "kotlin/ULong.toULong(SHORT)",
    "kotlin/UInt.toUInt(SHORT)",
    "kotlin/UShort.toUShort(SHORT)",
    "kotlin/UByte.toUByte(SHORT)",
    "kotlin/ULong.toULong(BYTE)",
    "kotlin/UInt.toUInt(BYTE)",
    "kotlin/UShort.toUShort(BYTE)",
    "kotlin/UByte.toUByte(BYTE)",
    "kotlin/ULong.toULong(DOUBLE)",
    "kotlin/UInt.toUInt(DOUBLE)",
    "kotlin/ULong.toULong(FLOAT)",
    "kotlin/UInt.toUInt(FLOAT)",
    "kotlin/Boolean.and(BOOLEAN, BOOLEAN)",
    "kotlin/Boolean.compareTo(BOOLEAN, BOOLEAN)",
    "kotlin/Boolean.equals(BOOLEAN, ANY)",
    "kotlin/Boolean.or(BOOLEAN, BOOLEAN)",
    "kotlin/Boolean.xor(BOOLEAN, BOOLEAN)",
    "kotlin/Byte.compareTo(BYTE, BYTE)",
    "kotlin/Byte.compareTo(BYTE, SHORT)",
    "kotlin/Byte.compareTo(BYTE, INT)",
    "kotlin/Byte.compareTo(BYTE, LONG)",
    "kotlin/Byte.compareTo(BYTE, FLOAT)",
    "kotlin/Byte.compareTo(BYTE, DOUBLE)",
    "kotlin/Byte.div(BYTE, BYTE)",
    "kotlin/Byte.div(BYTE, SHORT)",
    "kotlin/Byte.div(BYTE, INT)",
    "kotlin/Byte.div(BYTE, LONG)",
    "kotlin/Byte.div(BYTE, FLOAT)",
    "kotlin/Byte.div(BYTE, DOUBLE)",
    "kotlin/Byte.equals(BYTE, ANY)",
    "kotlin/Byte.minus(BYTE, BYTE)",
    "kotlin/Byte.minus(BYTE, SHORT)",
    "kotlin/Byte.minus(BYTE, INT)",
    "kotlin/Byte.minus(BYTE, LONG)",
    "kotlin/Byte.minus(BYTE, FLOAT)",
    "kotlin/Byte.minus(BYTE, DOUBLE)",
    "kotlin/Byte.plus(BYTE, BYTE)",
    "kotlin/Byte.plus(BYTE, SHORT)",
    "kotlin/Byte.plus(BYTE, INT)",
    "kotlin/Byte.plus(BYTE, LONG)",
    "kotlin/Byte.plus(BYTE, FLOAT)",
    "kotlin/Byte.plus(BYTE, DOUBLE)",
    "kotlin/Byte.rem(BYTE, BYTE)",
    "kotlin/Byte.rem(BYTE, SHORT)",
    "kotlin/Byte.rem(BYTE, INT)",
    "kotlin/Byte.rem(BYTE, LONG)",
    "kotlin/Byte.rem(BYTE, FLOAT)",
    "kotlin/Byte.rem(BYTE, DOUBLE)",
    "kotlin/Byte.times(BYTE, BYTE)",
    "kotlin/Byte.times(BYTE, SHORT)",
    "kotlin/Byte.times(BYTE, INT)",
    "kotlin/Byte.times(BYTE, LONG)",
    "kotlin/Byte.times(BYTE, FLOAT)",
    "kotlin/Byte.times(BYTE, DOUBLE)",
    "kotlin/Char.compareTo(CHAR, CHAR)",
    "kotlin/Char.equals(CHAR, ANY)",
    "kotlin/Char.minus(CHAR, CHAR)",
    "kotlin/Char.minus(CHAR, INT)",
    "kotlin/Char.plus(CHAR, INT)",
    "kotlin/Double.compareTo(DOUBLE, BYTE)",
    "kotlin/Double.compareTo(DOUBLE, SHORT)",
    "kotlin/Double.compareTo(DOUBLE, INT)",
    "kotlin/Double.compareTo(DOUBLE, LONG)",
    "kotlin/Double.compareTo(DOUBLE, FLOAT)",
    "kotlin/Double.compareTo(DOUBLE, DOUBLE)",
    "kotlin/Double.div(DOUBLE, BYTE)",
    "kotlin/Double.div(DOUBLE, SHORT)",
    "kotlin/Double.div(DOUBLE, INT)",
    "kotlin/Double.div(DOUBLE, LONG)",
    "kotlin/Double.div(DOUBLE, FLOAT)",
    "kotlin/Double.div(DOUBLE, DOUBLE)",
    "kotlin/Double.equals(DOUBLE, ANY)",
    "kotlin/Double.minus(DOUBLE, BYTE)",
    "kotlin/Double.minus(DOUBLE, SHORT)",
    "kotlin/Double.minus(DOUBLE, INT)",
    "kotlin/Double.minus(DOUBLE, LONG)",
    "kotlin/Double.minus(DOUBLE, FLOAT)",
    "kotlin/Double.minus(DOUBLE, DOUBLE)",
    "kotlin/Double.plus(DOUBLE, BYTE)",
    "kotlin/Double.plus(DOUBLE, SHORT)",
    "kotlin/Double.plus(DOUBLE, INT)",
    "kotlin/Double.plus(DOUBLE, LONG)",
    "kotlin/Double.plus(DOUBLE, FLOAT)",
    "kotlin/Double.plus(DOUBLE, DOUBLE)",
    "kotlin/Double.rem(DOUBLE, BYTE)",
    "kotlin/Double.rem(DOUBLE, SHORT)",
    "kotlin/Double.rem(DOUBLE, INT)",
    "kotlin/Double.rem(DOUBLE, LONG)",
    "kotlin/Double.rem(DOUBLE, FLOAT)",
    "kotlin/Double.rem(DOUBLE, DOUBLE)",
    "kotlin/Double.times(DOUBLE, BYTE)",
    "kotlin/Double.times(DOUBLE, SHORT)",
    "kotlin/Double.times(DOUBLE, INT)",
    "kotlin/Double.times(DOUBLE, LONG)",
    "kotlin/Double.times(DOUBLE, FLOAT)",
    "kotlin/Double.times(DOUBLE, DOUBLE)",
    "kotlin/Float.compareTo(FLOAT, BYTE)",
    "kotlin/Float.compareTo(FLOAT, SHORT)",
    "kotlin/Float.compareTo(FLOAT, INT)",
    "kotlin/Float.compareTo(FLOAT, LONG)",
    "kotlin/Float.compareTo(FLOAT, FLOAT)",
    "kotlin/Float.compareTo(FLOAT, DOUBLE)",
    "kotlin/Float.div(FLOAT, BYTE)",
    "kotlin/Float.div(FLOAT, SHORT)",
    "kotlin/Float.div(FLOAT, INT)",
    "kotlin/Float.div(FLOAT, LONG)",
    "kotlin/Float.div(FLOAT, FLOAT)",
    "kotlin/Float.div(FLOAT, DOUBLE)",
    "kotlin/Float.equals(FLOAT, ANY)",
    "kotlin/Float.minus(FLOAT, BYTE)",
    "kotlin/Float.minus(FLOAT, SHORT)",
    "kotlin/Float.minus(FLOAT, INT)",
    "kotlin/Float.minus(FLOAT, LONG)",
    "kotlin/Float.minus(FLOAT, FLOAT)",
    "kotlin/Float.minus(FLOAT, DOUBLE)",
    "kotlin/Float.plus(FLOAT, BYTE)",
    "kotlin/Float.plus(FLOAT, SHORT)",
    "kotlin/Float.plus(FLOAT, INT)",
    "kotlin/Float.plus(FLOAT, LONG)",
    "kotlin/Float.plus(FLOAT, FLOAT)",
    "kotlin/Float.plus(FLOAT, DOUBLE)",
    "kotlin/Float.rem(FLOAT, BYTE)",
    "kotlin/Float.rem(FLOAT, SHORT)",
    "kotlin/Float.rem(FLOAT, INT)",
    "kotlin/Float.rem(FLOAT, LONG)",
    "kotlin/Float.rem(FLOAT, FLOAT)",
    "kotlin/Float.rem(FLOAT, DOUBLE)",
    "kotlin/Float.times(FLOAT, BYTE)",
    "kotlin/Float.times(FLOAT, SHORT)",
    "kotlin/Float.times(FLOAT, INT)",
    "kotlin/Float.times(FLOAT, LONG)",
    "kotlin/Float.times(FLOAT, FLOAT)",
    "kotlin/Float.times(FLOAT, DOUBLE)",
    "kotlin/Int.and(INT, INT)",
    "kotlin/Int.compareTo(INT, BYTE)",
    "kotlin/Int.compareTo(INT, SHORT)",
    "kotlin/Int.compareTo(INT, INT)",
    "kotlin/Int.compareTo(INT, LONG)",
    "kotlin/Int.compareTo(INT, FLOAT)",
    "kotlin/Int.compareTo(INT, DOUBLE)",
    "kotlin/Int.div(INT, BYTE)",
    "kotlin/Int.div(INT, SHORT)",
    "kotlin/Int.div(INT, INT)",
    "kotlin/Int.div(INT, LONG)",
    "kotlin/Int.div(INT, FLOAT)",
    "kotlin/Int.div(INT, DOUBLE)",
    "kotlin/Int.equals(INT, ANY)",
    "kotlin/Int.minus(INT, BYTE)",
    "kotlin/Int.minus(INT, SHORT)",
    "kotlin/Int.minus(INT, INT)",
    "kotlin/Int.minus(INT, LONG)",
    "kotlin/Int.minus(INT, FLOAT)",
    "kotlin/Int.minus(INT, DOUBLE)",
    "kotlin/Int.or(INT, INT)",
    "kotlin/Int.plus(INT, BYTE)",
    "kotlin/Int.plus(INT, SHORT)",
    "kotlin/Int.plus(INT, INT)",
    "kotlin/Int.plus(INT, LONG)",
    "kotlin/Int.plus(INT, FLOAT)",
    "kotlin/Int.plus(INT, DOUBLE)",
    "kotlin/Int.rem(INT, BYTE)",
    "kotlin/Int.rem(INT, SHORT)",
    "kotlin/Int.rem(INT, INT)",
    "kotlin/Int.rem(INT, LONG)",
    "kotlin/Int.rem(INT, FLOAT)",
    "kotlin/Int.rem(INT, DOUBLE)",
    "kotlin/Int.shl(INT, INT)",
    "kotlin/Int.shr(INT, INT)",
    "kotlin/Int.times(INT, BYTE)",
    "kotlin/Int.times(INT, SHORT)",
    "kotlin/Int.times(INT, INT)",
    "kotlin/Int.times(INT, LONG)",
    "kotlin/Int.times(INT, FLOAT)",
    "kotlin/Int.times(INT, DOUBLE)",
    "kotlin/Int.ushr(INT, INT)",
    "kotlin/Int.xor(INT, INT)",
    "kotlin/Long.and(LONG, LONG)",
    "kotlin/Long.compareTo(LONG, BYTE)",
    "kotlin/Long.compareTo(LONG, SHORT)",
    "kotlin/Long.compareTo(LONG, INT)",
    "kotlin/Long.compareTo(LONG, LONG)",
    "kotlin/Long.compareTo(LONG, FLOAT)",
    "kotlin/Long.compareTo(LONG, DOUBLE)",
    "kotlin/Long.div(LONG, BYTE)",
    "kotlin/Long.div(LONG, SHORT)",
    "kotlin/Long.div(LONG, INT)",
    "kotlin/Long.div(LONG, LONG)",
    "kotlin/Long.div(LONG, FLOAT)",
    "kotlin/Long.div(LONG, DOUBLE)",
    "kotlin/Long.equals(LONG, ANY)",
    "kotlin/Long.minus(LONG, BYTE)",
    "kotlin/Long.minus(LONG, SHORT)",
    "kotlin/Long.minus(LONG, INT)",
    "kotlin/Long.minus(LONG, LONG)",
    "kotlin/Long.minus(LONG, FLOAT)",
    "kotlin/Long.minus(LONG, DOUBLE)",
    "kotlin/Long.or(LONG, LONG)",
    "kotlin/Long.plus(LONG, BYTE)",
    "kotlin/Long.plus(LONG, SHORT)",
    "kotlin/Long.plus(LONG, INT)",
    "kotlin/Long.plus(LONG, LONG)",
    "kotlin/Long.plus(LONG, FLOAT)",
    "kotlin/Long.plus(LONG, DOUBLE)",
    "kotlin/Long.rem(LONG, BYTE)",
    "kotlin/Long.rem(LONG, SHORT)",
    "kotlin/Long.rem(LONG, INT)",
    "kotlin/Long.rem(LONG, LONG)",
    "kotlin/Long.rem(LONG, FLOAT)",
    "kotlin/Long.rem(LONG, DOUBLE)",
    "kotlin/Long.shl(LONG, INT)",
    "kotlin/Long.shr(LONG, INT)",
    "kotlin/Long.times(LONG, BYTE)",
    "kotlin/Long.times(LONG, SHORT)",
    "kotlin/Long.times(LONG, INT)",
    "kotlin/Long.times(LONG, LONG)",
    "kotlin/Long.times(LONG, FLOAT)",
    "kotlin/Long.times(LONG, DOUBLE)",
    "kotlin/Long.ushr(LONG, INT)",
    "kotlin/Long.xor(LONG, LONG)",
    "kotlin/Short.compareTo(SHORT, BYTE)",
    "kotlin/Short.compareTo(SHORT, SHORT)",
    "kotlin/Short.compareTo(SHORT, INT)",
    "kotlin/Short.compareTo(SHORT, LONG)",
    "kotlin/Short.compareTo(SHORT, FLOAT)",
    "kotlin/Short.compareTo(SHORT, DOUBLE)",
    "kotlin/Short.div(SHORT, BYTE)",
    "kotlin/Short.div(SHORT, SHORT)",
    "kotlin/Short.div(SHORT, INT)",
    "kotlin/Short.div(SHORT, LONG)",
    "kotlin/Short.div(SHORT, FLOAT)",
    "kotlin/Short.div(SHORT, DOUBLE)",
    "kotlin/Short.equals(SHORT, ANY)",
    "kotlin/Short.minus(SHORT, BYTE)",
    "kotlin/Short.minus(SHORT, SHORT)",
    "kotlin/Short.minus(SHORT, INT)",
    "kotlin/Short.minus(SHORT, LONG)",
    "kotlin/Short.minus(SHORT, FLOAT)",
    "kotlin/Short.minus(SHORT, DOUBLE)",
    "kotlin/Short.plus(SHORT, BYTE)",
    "kotlin/Short.plus(SHORT, SHORT)",
    "kotlin/Short.plus(SHORT, INT)",
    "kotlin/Short.plus(SHORT, LONG)",
    "kotlin/Short.plus(SHORT, FLOAT)",
    "kotlin/Short.plus(SHORT, DOUBLE)",
    "kotlin/Short.rem(SHORT, BYTE)",
    "kotlin/Short.rem(SHORT, SHORT)",
    "kotlin/Short.rem(SHORT, INT)",
    "kotlin/Short.rem(SHORT, LONG)",
    "kotlin/Short.rem(SHORT, FLOAT)",
    "kotlin/Short.rem(SHORT, DOUBLE)",
    "kotlin/Short.times(SHORT, BYTE)",
    "kotlin/Short.times(SHORT, SHORT)",
    "kotlin/Short.times(SHORT, INT)",
    "kotlin/Short.times(SHORT, LONG)",
    "kotlin/Short.times(SHORT, FLOAT)",
    "kotlin/Short.times(SHORT, DOUBLE)",
    "kotlin/String.compareTo(STRING, STRING)",
    "kotlin/String.equals(STRING, ANY)",
    "kotlin/String.get(STRING, INT)",
    "kotlin/String.plus(STRING, ANY)",
    "kotlin/mod(BYTE, BYTE)",
    "kotlin/floorDiv(BYTE, BYTE)",
    "kotlin/mod(BYTE, INT)",
    "kotlin/floorDiv(BYTE, INT)",
    "kotlin/mod(BYTE, LONG)",
    "kotlin/floorDiv(BYTE, LONG)",
    "kotlin/mod(BYTE, SHORT)",
    "kotlin/floorDiv(BYTE, SHORT)",
    "kotlin/mod(INT, BYTE)",
    "kotlin/floorDiv(INT, BYTE)",
    "kotlin/mod(INT, INT)",
    "kotlin/floorDiv(INT, INT)",
    "kotlin/mod(INT, LONG)",
    "kotlin/floorDiv(INT, LONG)",
    "kotlin/mod(INT, SHORT)",
    "kotlin/floorDiv(INT, SHORT)",
    "kotlin/mod(LONG, BYTE)",
    "kotlin/floorDiv(LONG, BYTE)",
    "kotlin/mod(LONG, INT)",
    "kotlin/floorDiv(LONG, INT)",
    "kotlin/mod(LONG, LONG)",
    "kotlin/floorDiv(LONG, LONG)",
    "kotlin/mod(LONG, SHORT)",
    "kotlin/floorDiv(LONG, SHORT)",
    "kotlin/mod(SHORT, BYTE)",
    "kotlin/floorDiv(SHORT, BYTE)",
    "kotlin/mod(SHORT, INT)",
    "kotlin/floorDiv(SHORT, INT)",
    "kotlin/mod(SHORT, LONG)",
    "kotlin/floorDiv(SHORT, LONG)",
    "kotlin/mod(SHORT, SHORT)",
    "kotlin/floorDiv(SHORT, SHORT)",
    "kotlin/mod(DOUBLE, DOUBLE)",
    "kotlin/mod(DOUBLE, FLOAT)",
    "kotlin/mod(FLOAT, DOUBLE)",
    "kotlin/mod(FLOAT, FLOAT)",
    "kotlin/UInt.and(UINT, UINT)",
    "kotlin/UInt.compareTo(UINT, UBYTE)",
    "kotlin/UInt.compareTo(UINT, USHORT)",
    "kotlin/UInt.compareTo(UINT, UINT)",
    "kotlin/UInt.compareTo(UINT, ULONG)",
    "kotlin/UInt.div(UINT, UBYTE)",
    "kotlin/UInt.div(UINT, USHORT)",
    "kotlin/UInt.div(UINT, UINT)",
    "kotlin/UInt.div(UINT, ULONG)",
    "kotlin/UInt.equals(UINT, ANY)",
    "kotlin/UInt.floorDiv(UINT, UBYTE)",
    "kotlin/UInt.floorDiv(UINT, USHORT)",
    "kotlin/UInt.floorDiv(UINT, UINT)",
    "kotlin/UInt.floorDiv(UINT, ULONG)",
    "kotlin/UInt.minus(UINT, UBYTE)",
    "kotlin/UInt.minus(UINT, USHORT)",
    "kotlin/UInt.minus(UINT, UINT)",
    "kotlin/UInt.minus(UINT, ULONG)",
    "kotlin/UInt.mod(UINT, UBYTE)",
    "kotlin/UInt.mod(UINT, USHORT)",
    "kotlin/UInt.mod(UINT, UINT)",
    "kotlin/UInt.mod(UINT, ULONG)",
    "kotlin/UInt.or(UINT, UINT)",
    "kotlin/UInt.plus(UINT, UBYTE)",
    "kotlin/UInt.plus(UINT, USHORT)",
    "kotlin/UInt.plus(UINT, UINT)",
    "kotlin/UInt.plus(UINT, ULONG)",
    "kotlin/UInt.rem(UINT, UBYTE)",
    "kotlin/UInt.rem(UINT, USHORT)",
    "kotlin/UInt.rem(UINT, UINT)",
    "kotlin/UInt.rem(UINT, ULONG)",
    "kotlin/UInt.shl(UINT, INT)",
    "kotlin/UInt.shr(UINT, INT)",
    "kotlin/UInt.times(UINT, UBYTE)",
    "kotlin/UInt.times(UINT, USHORT)",
    "kotlin/UInt.times(UINT, UINT)",
    "kotlin/UInt.times(UINT, ULONG)",
    "kotlin/UInt.xor(UINT, UINT)",
    "kotlin/ULong.and(ULONG, ULONG)",
    "kotlin/ULong.compareTo(ULONG, UBYTE)",
    "kotlin/ULong.compareTo(ULONG, USHORT)",
    "kotlin/ULong.compareTo(ULONG, UINT)",
    "kotlin/ULong.compareTo(ULONG, ULONG)",
    "kotlin/ULong.div(ULONG, UBYTE)",
    "kotlin/ULong.div(ULONG, USHORT)",
    "kotlin/ULong.div(ULONG, UINT)",
    "kotlin/ULong.div(ULONG, ULONG)",
    "kotlin/ULong.equals(ULONG, ANY)",
    "kotlin/ULong.floorDiv(ULONG, UBYTE)",
    "kotlin/ULong.floorDiv(ULONG, USHORT)",
    "kotlin/ULong.floorDiv(ULONG, UINT)",
    "kotlin/ULong.floorDiv(ULONG, ULONG)",
    "kotlin/ULong.minus(ULONG, UBYTE)",
    "kotlin/ULong.minus(ULONG, USHORT)",
    "kotlin/ULong.minus(ULONG, UINT)",
    "kotlin/ULong.minus(ULONG, ULONG)",
    "kotlin/ULong.mod(ULONG, UBYTE)",
    "kotlin/ULong.mod(ULONG, USHORT)",
    "kotlin/ULong.mod(ULONG, UINT)",
    "kotlin/ULong.mod(ULONG, ULONG)",
    "kotlin/ULong.or(ULONG, ULONG)",
    "kotlin/ULong.plus(ULONG, UBYTE)",
    "kotlin/ULong.plus(ULONG, USHORT)",
    "kotlin/ULong.plus(ULONG, UINT)",
    "kotlin/ULong.plus(ULONG, ULONG)",
    "kotlin/ULong.rem(ULONG, UBYTE)",
    "kotlin/ULong.rem(ULONG, USHORT)",
    "kotlin/ULong.rem(ULONG, UINT)",
    "kotlin/ULong.rem(ULONG, ULONG)",
    "kotlin/ULong.shl(ULONG, INT)",
    "kotlin/ULong.shr(ULONG, INT)",
    "kotlin/ULong.times(ULONG, UBYTE)",
    "kotlin/ULong.times(ULONG, USHORT)",
    "kotlin/ULong.times(ULONG, UINT)",
    "kotlin/ULong.times(ULONG, ULONG)",
    "kotlin/ULong.xor(ULONG, ULONG)",
    "kotlin/UByte.and(UBYTE, UBYTE)",
    "kotlin/UByte.compareTo(UBYTE, UBYTE)",
    "kotlin/UByte.compareTo(UBYTE, USHORT)",
    "kotlin/UByte.compareTo(UBYTE, UINT)",
    "kotlin/UByte.compareTo(UBYTE, ULONG)",
    "kotlin/UByte.div(UBYTE, UBYTE)",
    "kotlin/UByte.div(UBYTE, USHORT)",
    "kotlin/UByte.div(UBYTE, UINT)",
    "kotlin/UByte.div(UBYTE, ULONG)",
    "kotlin/UByte.equals(UBYTE, ANY)",
    "kotlin/UByte.floorDiv(UBYTE, UBYTE)",
    "kotlin/UByte.floorDiv(UBYTE, USHORT)",
    "kotlin/UByte.floorDiv(UBYTE, UINT)",
    "kotlin/UByte.floorDiv(UBYTE, ULONG)",
    "kotlin/UByte.minus(UBYTE, UBYTE)",
    "kotlin/UByte.minus(UBYTE, USHORT)",
    "kotlin/UByte.minus(UBYTE, UINT)",
    "kotlin/UByte.minus(UBYTE, ULONG)",
    "kotlin/UByte.mod(UBYTE, UBYTE)",
    "kotlin/UByte.mod(UBYTE, USHORT)",
    "kotlin/UByte.mod(UBYTE, UINT)",
    "kotlin/UByte.mod(UBYTE, ULONG)",
    "kotlin/UByte.or(UBYTE, UBYTE)",
    "kotlin/UByte.plus(UBYTE, UBYTE)",
    "kotlin/UByte.plus(UBYTE, USHORT)",
    "kotlin/UByte.plus(UBYTE, UINT)",
    "kotlin/UByte.plus(UBYTE, ULONG)",
    "kotlin/UByte.rem(UBYTE, UBYTE)",
    "kotlin/UByte.rem(UBYTE, USHORT)",
    "kotlin/UByte.rem(UBYTE, UINT)",
    "kotlin/UByte.rem(UBYTE, ULONG)",
    "kotlin/UByte.times(UBYTE, UBYTE)",
    "kotlin/UByte.times(UBYTE, USHORT)",
    "kotlin/UByte.times(UBYTE, UINT)",
    "kotlin/UByte.times(UBYTE, ULONG)",
    "kotlin/UByte.xor(UBYTE, UBYTE)",
    "kotlin/UShort.and(USHORT, USHORT)",
    "kotlin/UShort.compareTo(USHORT, UBYTE)",
    "kotlin/UShort.compareTo(USHORT, USHORT)",
    "kotlin/UShort.compareTo(USHORT, UINT)",
    "kotlin/UShort.compareTo(USHORT, ULONG)",
    "kotlin/UShort.div(USHORT, UBYTE)",
    "kotlin/UShort.div(USHORT, USHORT)",
    "kotlin/UShort.div(USHORT, UINT)",
    "kotlin/UShort.div(USHORT, ULONG)",
    "kotlin/UShort.equals(USHORT, ANY)",
    "kotlin/UShort.floorDiv(USHORT, UBYTE)",
    "kotlin/UShort.floorDiv(USHORT, USHORT)",
    "kotlin/UShort.floorDiv(USHORT, UINT)",
    "kotlin/UShort.floorDiv(USHORT, ULONG)",
    "kotlin/UShort.minus(USHORT, UBYTE)",
    "kotlin/UShort.minus(USHORT, USHORT)",
    "kotlin/UShort.minus(USHORT, UINT)",
    "kotlin/UShort.minus(USHORT, ULONG)",
    "kotlin/UShort.mod(USHORT, UBYTE)",
    "kotlin/UShort.mod(USHORT, USHORT)",
    "kotlin/UShort.mod(USHORT, UINT)",
    "kotlin/UShort.mod(USHORT, ULONG)",
    "kotlin/UShort.or(USHORT, USHORT)",
    "kotlin/UShort.plus(USHORT, UBYTE)",
    "kotlin/UShort.plus(USHORT, USHORT)",
    "kotlin/UShort.plus(USHORT, UINT)",
    "kotlin/UShort.plus(USHORT, ULONG)",
    "kotlin/UShort.rem(USHORT, UBYTE)",
    "kotlin/UShort.rem(USHORT, USHORT)",
    "kotlin/UShort.rem(USHORT, UINT)",
    "kotlin/UShort.rem(USHORT, ULONG)",
    "kotlin/UShort.times(USHORT, UBYTE)",
    "kotlin/UShort.times(USHORT, USHORT)",
    "kotlin/UShort.times(USHORT, UINT)",
    "kotlin/UShort.times(USHORT, ULONG)",
    "kotlin/UShort.xor(USHORT, USHORT)",
)
fun canEvalOp(callableId: CallableId, typeA: CompileTimeType, typeB: CompileTimeType?): Boolean {
    val types = if (typeB != null) "$typeA, $typeB" else typeA.toString()
    return knownOps.contains("${callableId}($types)")
}
