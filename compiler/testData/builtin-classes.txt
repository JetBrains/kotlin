package-fragment kotlin

public fun </*0*/ reified T> arrayOfNulls(/*0*/ size: kotlin.Int): kotlin.Array<T?>
public fun kotlin.Any?.identityEquals(/*0*/ other: kotlin.Any?): kotlin.Boolean
public fun kotlin.String?.plus(/*0*/ other: kotlin.Any?): kotlin.String
public fun kotlin.Any?.toString(): kotlin.String

public trait Annotation {
}

public open class Any {
    /*primary*/ public constructor Any()
}

public final class Array</*0*/ reified T> : kotlin.Cloneable {
    /*primary*/ private constructor Array</*0*/ reified T>()
    public open override /*1*/ fun clone(): kotlin.Array<T>
    public final fun get(/*0*/ index: kotlin.Int): T
    public final fun iterator(): kotlin.Iterator<T>
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: T): kotlin.Unit
    public final fun size(): kotlin.Int
}

public final class Boolean : kotlin.Comparable<kotlin.Boolean> {
    /*primary*/ private constructor Boolean()
    public final fun and(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Boolean): kotlin.Int
    public final fun not(): kotlin.Boolean
    public final fun or(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public final fun xor(/*0*/ other: kotlin.Boolean): kotlin.Boolean
}

public final class BooleanArray : kotlin.Cloneable {
    /*primary*/ public constructor BooleanArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.BooleanArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Boolean
    public final fun iterator(): kotlin.BooleanIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Boolean): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class BooleanIterator : kotlin.Iterator<kotlin.Boolean> {
    /*primary*/ public constructor BooleanIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Boolean
    public abstract fun nextBoolean(): kotlin.Boolean
}

public final class Byte : kotlin.Number, kotlin.Comparable<kotlin.Byte> {
    /*primary*/ private constructor Byte()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Byte
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Byte
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ByteRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.CharRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ShortRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public final class ByteArray : kotlin.Cloneable {
    /*primary*/ public constructor ByteArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.ByteArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Byte
    public final fun iterator(): kotlin.ByteIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Byte): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class ByteIterator : kotlin.Iterator<kotlin.Byte> {
    /*primary*/ public constructor ByteIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Byte
    public abstract fun nextByte(): kotlin.Byte
}

public final class ByteProgression : kotlin.Progression<kotlin.Byte> {
    /*primary*/ public constructor ByteProgression(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Byte
        public open override /*1*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Byte
        public open override /*1*/ fun <get-start>(): kotlin.Byte
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ByteIterator
}

internal final class ByteProgressionIterator : kotlin.ByteIterator {
    /*primary*/ public constructor ByteProgressionIterator(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Byte
        private final fun <get-finalElement>(): kotlin.Byte
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Byte
    public open override /*1*/ fun nextByte(): kotlin.Byte
}

public final class ByteRange : kotlin.Range<kotlin.Byte>, kotlin.Progression<kotlin.Byte> {
    /*primary*/ public constructor ByteRange(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte)
    public open override /*2*/ val end: kotlin.Byte
        public open override /*2*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Byte
        public open override /*2*/ fun <get-start>(): kotlin.Byte
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Byte): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ByteIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.ByteRange
            public final fun <get-EMPTY>(): kotlin.ByteRange
    }
}

public final class Char : kotlin.Comparable<kotlin.Char> {
    /*primary*/ private constructor Char()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Char
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Char
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.CharRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun toByte(): kotlin.Byte
    public final fun toChar(): kotlin.Char
    public final fun toDouble(): kotlin.Double
    public final fun toFloat(): kotlin.Float
    public final fun toInt(): kotlin.Int
    public final fun toLong(): kotlin.Long
    public final fun toShort(): kotlin.Short
}

public final class CharArray : kotlin.Cloneable {
    /*primary*/ public constructor CharArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.CharArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final fun iterator(): kotlin.CharIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Char): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class CharIterator : kotlin.Iterator<kotlin.Char> {
    /*primary*/ public constructor CharIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Char
    public abstract fun nextChar(): kotlin.Char
}

public final class CharProgression : kotlin.Progression<kotlin.Char> {
    /*primary*/ public constructor CharProgression(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Char
        public open override /*1*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Char
        public open override /*1*/ fun <get-start>(): kotlin.Char
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.CharIterator
}

internal final class CharProgressionIterator : kotlin.CharIterator {
    /*primary*/ public constructor CharProgressionIterator(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Char
        private final fun <get-finalElement>(): kotlin.Char
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Char
    public open override /*1*/ fun nextChar(): kotlin.Char
}

public final class CharRange : kotlin.Range<kotlin.Char>, kotlin.Progression<kotlin.Char> {
    /*primary*/ public constructor CharRange(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char)
    public open override /*2*/ val end: kotlin.Char
        public open override /*2*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Char
        public open override /*2*/ fun <get-start>(): kotlin.Char
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Char): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.CharIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.CharRange
            public final fun <get-EMPTY>(): kotlin.CharRange
    }
}

public trait CharSequence {
    public abstract fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
    public abstract fun length(): kotlin.Int
    public abstract fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence
}

public trait Cloneable {
    protected open fun clone(): kotlin.Any
}

public trait Collection</*0*/ out E> : kotlin.Iterable<E> {
    public abstract fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract fun size(): kotlin.Int
}

public trait Comparable</*0*/ in T> {
    public abstract fun compareTo(/*0*/ other: T): kotlin.Int
}

public final class Double : kotlin.Number, kotlin.Comparable<kotlin.Double> {
    /*primary*/ private constructor Double()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun inc(): kotlin.Double
    public final fun minus(): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun plus(): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Double
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.DoubleRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Double
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public class object Default : kotlin.FloatingPointConstants<kotlin.Double> {
        /*primary*/ private constructor Default()
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Double
    }
}

public final class DoubleArray : kotlin.Cloneable {
    /*primary*/ public constructor DoubleArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.DoubleArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Double
    public final fun iterator(): kotlin.DoubleIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Double): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class DoubleIterator : kotlin.Iterator<kotlin.Double> {
    /*primary*/ public constructor DoubleIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Double
    public abstract fun nextDouble(): kotlin.Double
}

public final class DoubleProgression : kotlin.Progression<kotlin.Double> {
    /*primary*/ public constructor DoubleProgression(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double, /*2*/ increment: kotlin.Double)
    public open override /*1*/ val end: kotlin.Double
        public open override /*1*/ fun <get-end>(): kotlin.Double
    public open override /*1*/ val increment: kotlin.Double
        public open override /*1*/ fun <get-increment>(): kotlin.Double
    public open override /*1*/ val start: kotlin.Double
        public open override /*1*/ fun <get-start>(): kotlin.Double
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.DoubleIterator
}

internal final class DoubleProgressionIterator : kotlin.DoubleIterator {
    /*primary*/ public constructor DoubleProgressionIterator(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double, /*2*/ increment: kotlin.Double)
    internal final val end: kotlin.Double
        internal final fun <get-end>(): kotlin.Double
    internal final val increment: kotlin.Double
        internal final fun <get-increment>(): kotlin.Double
    private final var next: kotlin.Double
        private final fun <get-next>(): kotlin.Double
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Double): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Double
    public open override /*1*/ fun nextDouble(): kotlin.Double
}

public final class DoubleRange : kotlin.Range<kotlin.Double>, kotlin.Progression<kotlin.Double> {
    /*primary*/ public constructor DoubleRange(/*0*/ start: kotlin.Double, /*1*/ end: kotlin.Double)
    public open override /*2*/ val end: kotlin.Double
        public open override /*2*/ fun <get-end>(): kotlin.Double
    public open override /*1*/ val increment: kotlin.Double
        public open override /*1*/ fun <get-increment>(): kotlin.Double
    public open override /*2*/ val start: kotlin.Double
        public open override /*2*/ fun <get-start>(): kotlin.Double
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Double): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.DoubleIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.DoubleRange
            public final fun <get-EMPTY>(): kotlin.DoubleRange
    }
}

public abstract class Enum</*0*/ E : kotlin.Enum<E>> : kotlin.Comparable<E> {
    /*primary*/ public constructor Enum</*0*/ E : kotlin.Enum<E>>(/*0*/ name: kotlin.String, /*1*/ ordinal: kotlin.Int)
    public final override /*1*/ fun compareTo(/*0*/ other: E): kotlin.Int
    public final fun name(): kotlin.String
    public final fun ordinal(): kotlin.Int

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public trait ExtensionFunction0</*0*/ in T, /*1*/ out R> {
    public abstract fun T.invoke(): R
}

public trait ExtensionFunction1</*0*/ in T, /*1*/ in P1, /*2*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1): R
}

public trait ExtensionFunction10</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10): R
}

public trait ExtensionFunction11</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11): R
}

public trait ExtensionFunction12</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12): R
}

public trait ExtensionFunction13</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13): R
}

public trait ExtensionFunction14</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14): R
}

public trait ExtensionFunction15</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15): R
}

public trait ExtensionFunction16</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16): R
}

public trait ExtensionFunction17</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17): R
}

public trait ExtensionFunction18</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ in P18, /*19*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18): R
}

public trait ExtensionFunction19</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ in P18, /*19*/ in P19, /*20*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19): R
}

public trait ExtensionFunction2</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2): R
}

public trait ExtensionFunction20</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ in P18, /*19*/ in P19, /*20*/ in P20, /*21*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20): R
}

public trait ExtensionFunction21</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ in P18, /*19*/ in P19, /*20*/ in P20, /*21*/ in P21, /*22*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20, /*20*/ p21: P21): R
}

public trait ExtensionFunction22</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ in P10, /*11*/ in P11, /*12*/ in P12, /*13*/ in P13, /*14*/ in P14, /*15*/ in P15, /*16*/ in P16, /*17*/ in P17, /*18*/ in P18, /*19*/ in P19, /*20*/ in P20, /*21*/ in P21, /*22*/ in P22, /*23*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20, /*20*/ p21: P21, /*21*/ p22: P22): R
}

public trait ExtensionFunction3</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3): R
}

public trait ExtensionFunction4</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4): R
}

public trait ExtensionFunction5</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5): R
}

public trait ExtensionFunction6</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6): R
}

public trait ExtensionFunction7</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7): R
}

public trait ExtensionFunction8</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8): R
}

public trait ExtensionFunction9</*0*/ in T, /*1*/ in P1, /*2*/ in P2, /*3*/ in P3, /*4*/ in P4, /*5*/ in P5, /*6*/ in P6, /*7*/ in P7, /*8*/ in P8, /*9*/ in P9, /*10*/ out R> {
    public abstract fun T.invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9): R
}

public final class Float : kotlin.Number, kotlin.Comparable<kotlin.Float> {
    /*primary*/ private constructor Float()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun inc(): kotlin.Float
    public final fun minus(): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Char): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun plus(): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Float
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.FloatRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Float
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public class object Default : kotlin.FloatingPointConstants<kotlin.Float> {
        /*primary*/ private constructor Default()
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Float
    }
}

public final class FloatArray : kotlin.Cloneable {
    /*primary*/ public constructor FloatArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.FloatArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Float
    public final fun iterator(): kotlin.FloatIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Float): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class FloatIterator : kotlin.Iterator<kotlin.Float> {
    /*primary*/ public constructor FloatIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Float
    public abstract fun nextFloat(): kotlin.Float
}

public final class FloatProgression : kotlin.Progression<kotlin.Float> {
    /*primary*/ public constructor FloatProgression(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float, /*2*/ increment: kotlin.Float)
    public open override /*1*/ val end: kotlin.Float
        public open override /*1*/ fun <get-end>(): kotlin.Float
    public open override /*1*/ val increment: kotlin.Float
        public open override /*1*/ fun <get-increment>(): kotlin.Float
    public open override /*1*/ val start: kotlin.Float
        public open override /*1*/ fun <get-start>(): kotlin.Float
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.FloatIterator
}

internal final class FloatProgressionIterator : kotlin.FloatIterator {
    /*primary*/ public constructor FloatProgressionIterator(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float, /*2*/ increment: kotlin.Float)
    internal final val end: kotlin.Float
        internal final fun <get-end>(): kotlin.Float
    internal final val increment: kotlin.Float
        internal final fun <get-increment>(): kotlin.Float
    private final var next: kotlin.Float
        private final fun <get-next>(): kotlin.Float
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Float): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Float
    public open override /*1*/ fun nextFloat(): kotlin.Float
}

public final class FloatRange : kotlin.Range<kotlin.Float>, kotlin.Progression<kotlin.Float> {
    /*primary*/ public constructor FloatRange(/*0*/ start: kotlin.Float, /*1*/ end: kotlin.Float)
    public open override /*2*/ val end: kotlin.Float
        public open override /*2*/ fun <get-end>(): kotlin.Float
    public open override /*1*/ val increment: kotlin.Float
        public open override /*1*/ fun <get-increment>(): kotlin.Float
    public open override /*2*/ val start: kotlin.Float
        public open override /*2*/ fun <get-start>(): kotlin.Float
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Float): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.FloatIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.FloatRange
            public final fun <get-EMPTY>(): kotlin.FloatRange
    }
}

public trait FloatingPointConstants</*0*/ T> {
    public abstract val NEGATIVE_INFINITY: T
        public abstract fun <get-NEGATIVE_INFINITY>(): T
    public abstract val NaN: T
        public abstract fun <get-NaN>(): T
    public abstract val POSITIVE_INFINITY: T
        public abstract fun <get-POSITIVE_INFINITY>(): T
}

public trait Function0</*0*/ out R> {
    public abstract fun invoke(): R
}

public trait Function1</*0*/ in P1, /*1*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1): R
}

public trait Function10</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10): R
}

public trait Function11</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11): R
}

public trait Function12</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12): R
}

public trait Function13</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13): R
}

public trait Function14</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14): R
}

public trait Function15</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15): R
}

public trait Function16</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16): R
}

public trait Function17</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17): R
}

public trait Function18</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ in P18, /*18*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18): R
}

public trait Function19</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ in P18, /*18*/ in P19, /*19*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19): R
}

public trait Function2</*0*/ in P1, /*1*/ in P2, /*2*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2): R
}

public trait Function20</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ in P18, /*18*/ in P19, /*19*/ in P20, /*20*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20): R
}

public trait Function21</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ in P18, /*18*/ in P19, /*19*/ in P20, /*20*/ in P21, /*21*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20, /*20*/ p21: P21): R
}

public trait Function22</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ in P10, /*10*/ in P11, /*11*/ in P12, /*12*/ in P13, /*13*/ in P14, /*14*/ in P15, /*15*/ in P16, /*16*/ in P17, /*17*/ in P18, /*18*/ in P19, /*19*/ in P20, /*20*/ in P21, /*21*/ in P22, /*22*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9, /*9*/ p10: P10, /*10*/ p11: P11, /*11*/ p12: P12, /*12*/ p13: P13, /*13*/ p14: P14, /*14*/ p15: P15, /*15*/ p16: P16, /*16*/ p17: P17, /*17*/ p18: P18, /*18*/ p19: P19, /*19*/ p20: P20, /*20*/ p21: P21, /*21*/ p22: P22): R
}

public trait Function3</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3): R
}

public trait Function4</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4): R
}

public trait Function5</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5): R
}

public trait Function6</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6): R
}

public trait Function7</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7): R
}

public trait Function8</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8): R
}

public trait Function9</*0*/ in P1, /*1*/ in P2, /*2*/ in P3, /*3*/ in P4, /*4*/ in P5, /*5*/ in P6, /*6*/ in P7, /*7*/ in P8, /*8*/ in P9, /*9*/ out R> {
    public abstract fun invoke(/*0*/ p1: P1, /*1*/ p2: P2, /*2*/ p3: P3, /*3*/ p4: P4, /*4*/ p5: P5, /*5*/ p6: P6, /*6*/ p7: P7, /*7*/ p8: P8, /*8*/ p9: P9): R
}

public final enum class InlineOption : kotlin.Enum<kotlin.InlineOption> {
    public enum entry LOCAL_CONTINUE_AND_BREAK : kotlin.InlineOption {
        /*primary*/ private constructor LOCAL_CONTINUE_AND_BREAK()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry ONLY_LOCAL_RETURN : kotlin.InlineOption {
        /*primary*/ private constructor ONLY_LOCAL_RETURN()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor InlineOption()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineOption): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.InlineOption
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.InlineOption>
}

public final enum class InlineStrategy : kotlin.Enum<kotlin.InlineStrategy> {
    public enum entry AS_FUNCTION : kotlin.InlineStrategy {
        /*primary*/ private constructor AS_FUNCTION()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    public enum entry IN_PLACE : kotlin.InlineStrategy {
        /*primary*/ private constructor IN_PLACE()
        public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
        public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
        public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int
    }

    /*primary*/ private constructor InlineStrategy()
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.InlineStrategy): kotlin.Int
    public final override /*1*/ /*fake_override*/ fun name(): kotlin.String
    public final override /*1*/ /*fake_override*/ fun ordinal(): kotlin.Int

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.InlineStrategy
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.InlineStrategy>
}

public final class Int : kotlin.Number, kotlin.Comparable<kotlin.Int> {
    /*primary*/ private constructor Int()
    public final fun and(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Int
    public final fun inv(): kotlin.Int
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun or(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.IntRange
    public final fun shl(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun shr(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final fun ushr(/*0*/ bits: kotlin.Int): kotlin.Int
    public final fun xor(/*0*/ other: kotlin.Int): kotlin.Int

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public final class IntArray : kotlin.Cloneable {
    /*primary*/ public constructor IntArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.IntArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Int
    public final fun iterator(): kotlin.IntIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Int): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class IntIterator : kotlin.Iterator<kotlin.Int> {
    /*primary*/ public constructor IntIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Int
    public abstract fun nextInt(): kotlin.Int
}

public final class IntProgression : kotlin.Progression<kotlin.Int> {
    /*primary*/ public constructor IntProgression(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Int
        public open override /*1*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Int
        public open override /*1*/ fun <get-start>(): kotlin.Int
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.IntIterator
}

internal final class IntProgressionIterator : kotlin.IntIterator {
    /*primary*/ public constructor IntProgressionIterator(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Int
    public open override /*1*/ fun nextInt(): kotlin.Int
}

public final class IntRange : kotlin.Range<kotlin.Int>, kotlin.Progression<kotlin.Int> {
    /*primary*/ public constructor IntRange(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int)
    public open override /*2*/ val end: kotlin.Int
        public open override /*2*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Int
        public open override /*2*/ fun <get-start>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Int): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.IntIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.IntRange
            public final fun <get-EMPTY>(): kotlin.IntRange
    }
}

public trait Iterable</*0*/ out T> {
    public abstract fun iterator(): kotlin.Iterator<T>
}

public trait Iterator</*0*/ out T> {
    public abstract fun hasNext(): kotlin.Boolean
    public abstract fun next(): T
}

public trait List</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun get(/*0*/ index: kotlin.Int): E
    public abstract fun indexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract fun lastIndexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract fun listIterator(): kotlin.ListIterator<E>
    public abstract fun listIterator(/*0*/ index: kotlin.Int): kotlin.ListIterator<E>
    public abstract override /*1*/ fun size(): kotlin.Int
    public abstract fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.List<E>
}

public trait ListIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ fun hasNext(): kotlin.Boolean
    public abstract fun hasPrevious(): kotlin.Boolean
    public abstract override /*1*/ fun next(): T
    public abstract fun nextIndex(): kotlin.Int
    public abstract fun previous(): T
    public abstract fun previousIndex(): kotlin.Int
}

public final class Long : kotlin.Number, kotlin.Comparable<kotlin.Long> {
    /*primary*/ private constructor Long()
    public final fun and(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun inc(): kotlin.Long
    public final fun inv(): kotlin.Long
    public final fun minus(): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Char): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun or(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Long
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.LongRange
    public final fun shl(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun shr(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Long
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final fun ushr(/*0*/ bits: kotlin.Int): kotlin.Long
    public final fun xor(/*0*/ other: kotlin.Long): kotlin.Long

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public final class LongArray : kotlin.Cloneable {
    /*primary*/ public constructor LongArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.LongArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Long
    public final fun iterator(): kotlin.LongIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Long): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class LongIterator : kotlin.Iterator<kotlin.Long> {
    /*primary*/ public constructor LongIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Long
    public abstract fun nextLong(): kotlin.Long
}

public final class LongProgression : kotlin.Progression<kotlin.Long> {
    /*primary*/ public constructor LongProgression(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long, /*2*/ increment: kotlin.Long)
    public open override /*1*/ val end: kotlin.Long
        public open override /*1*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public open override /*1*/ val start: kotlin.Long
        public open override /*1*/ fun <get-start>(): kotlin.Long
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.LongIterator
}

internal final class LongProgressionIterator : kotlin.LongIterator {
    /*primary*/ public constructor LongProgressionIterator(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long, /*2*/ increment: kotlin.Long)
    private final val finalElement: kotlin.Long
        private final fun <get-finalElement>(): kotlin.Long
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Long
        internal final fun <get-increment>(): kotlin.Long
    private final var next: kotlin.Long
        private final fun <get-next>(): kotlin.Long
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Long): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Long
    public open override /*1*/ fun nextLong(): kotlin.Long
}

public final class LongRange : kotlin.Range<kotlin.Long>, kotlin.Progression<kotlin.Long> {
    /*primary*/ public constructor LongRange(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long)
    public open override /*2*/ val end: kotlin.Long
        public open override /*2*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public open override /*2*/ val start: kotlin.Long
        public open override /*2*/ fun <get-start>(): kotlin.Long
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Long): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.LongIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.LongRange
            public final fun <get-EMPTY>(): kotlin.LongRange
    }
}

public trait Map</*0*/ K, /*1*/ out V> {
    public abstract fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
    public abstract fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
    public abstract fun entrySet(): kotlin.Set<kotlin.Map.Entry<K, V>>
    public abstract fun get(/*0*/ key: kotlin.Any?): V?
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract fun keySet(): kotlin.Set<K>
    public abstract fun size(): kotlin.Int
    public abstract fun values(): kotlin.Collection<V>

    public trait Entry</*0*/ out K, /*1*/ out V> {
        public abstract fun getKey(): K
        public abstract fun getValue(): V
    }
}

public trait MutableCollection</*0*/ E> : kotlin.Collection<E>, kotlin.MutableIterable<E> {
    public abstract fun add(/*0*/ e: E): kotlin.Boolean
    public abstract fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
}

public trait MutableIterable</*0*/ out T> : kotlin.Iterable<T> {
    public abstract override /*1*/ fun iterator(): kotlin.MutableIterator<T>
}

public trait MutableIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun next(): T
    public abstract fun remove(): kotlin.Unit
}

public trait MutableList</*0*/ E> : kotlin.List<E>, kotlin.MutableCollection<E> {
    public abstract override /*1*/ fun add(/*0*/ e: E): kotlin.Boolean
    public abstract fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public abstract override /*1*/ fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun addAll(/*0*/ index: kotlin.Int, /*1*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ /*fake_override*/ fun indexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ o: kotlin.Any?): kotlin.Int
    public abstract override /*1*/ fun listIterator(): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract fun remove(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
    public abstract override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.MutableList<E>
}

public trait MutableListIterator</*0*/ T> : kotlin.ListIterator<T>, kotlin.MutableIterator<T> {
    public abstract fun add(/*0*/ e: T): kotlin.Unit
    public abstract override /*2*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun hasPrevious(): kotlin.Boolean
    public abstract override /*2*/ fun next(): T
    public abstract override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
    public abstract override /*1*/ /*fake_override*/ fun previous(): T
    public abstract override /*1*/ /*fake_override*/ fun previousIndex(): kotlin.Int
    public abstract override /*1*/ fun remove(): kotlin.Unit
    public abstract fun set(/*0*/ e: T): kotlin.Unit
}

public trait MutableMap</*0*/ K, /*1*/ V> : kotlin.Map<K, V> {
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun entrySet(): kotlin.MutableSet<kotlin.MutableMap.MutableEntry<K, V>>
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ key: kotlin.Any?): V?
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun keySet(): kotlin.MutableSet<K>
    public abstract fun put(/*0*/ key: K, /*1*/ value: V): V?
    public abstract fun putAll(/*0*/ m: kotlin.Map<out K, V>): kotlin.Unit
    public abstract fun remove(/*0*/ key: kotlin.Any?): V?
    public abstract override /*1*/ /*fake_override*/ fun size(): kotlin.Int
    public abstract override /*1*/ fun values(): kotlin.MutableCollection<V>

    public trait MutableEntry</*0*/ K, /*1*/ V> : kotlin.Map.Entry<K, V> {
        public abstract override /*1*/ /*fake_override*/ fun getKey(): K
        public abstract override /*1*/ /*fake_override*/ fun getValue(): V
        public abstract fun setValue(/*0*/ value: V): V
    }
}

public trait MutableSet</*0*/ E> : kotlin.Set<E>, kotlin.MutableCollection<E> {
    public abstract override /*1*/ fun add(/*0*/ e: E): kotlin.Boolean
    public abstract override /*1*/ fun addAll(/*0*/ c: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun removeAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun retainAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun size(): kotlin.Int
}

public final class Nothing {
    /*primary*/ private constructor Nothing()
}

public abstract class Number {
    /*primary*/ public constructor Number()
    public abstract fun toByte(): kotlin.Byte
    public abstract fun toChar(): kotlin.Char
    public abstract fun toDouble(): kotlin.Double
    public abstract fun toFloat(): kotlin.Float
    public abstract fun toInt(): kotlin.Int
    public abstract fun toLong(): kotlin.Long
    public abstract fun toShort(): kotlin.Short
}

public trait Progression</*0*/ out N : kotlin.Any> : kotlin.Iterable<N> {
    public abstract val end: N
        public abstract fun <get-end>(): N
    public abstract val increment: kotlin.Number
        public abstract fun <get-increment>(): kotlin.Number
    public abstract val start: N
        public abstract fun <get-start>(): N
    public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.Iterator<N>
}

public trait PropertyMetadata {
    public abstract val name: kotlin.String
        public abstract fun <get-name>(): kotlin.String
}

public final class PropertyMetadataImpl : kotlin.PropertyMetadata {
    /*primary*/ public constructor PropertyMetadataImpl(/*0*/ name: kotlin.String)
    public open override /*1*/ val name: kotlin.String
        public open override /*1*/ fun <get-name>(): kotlin.String
}

public trait Range</*0*/ T : kotlin.Comparable<T>> {
    public abstract val end: T
        public abstract fun <get-end>(): T
    public abstract val start: T
        public abstract fun <get-start>(): T
    public abstract fun contains(/*0*/ item: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}

public trait Set</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ fun contains(/*0*/ o: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ c: kotlin.Collection<kotlin.Any?>): kotlin.Boolean
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract override /*1*/ fun size(): kotlin.Int
}

public final class Short : kotlin.Number, kotlin.Comparable<kotlin.Short> {
    /*primary*/ private constructor Short()
    public final fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun dec(): kotlin.Short
    public final fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun inc(): kotlin.Short
    public final fun minus(): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun plus(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ShortRange
    public final fun rangeTo(/*0*/ other: kotlin.Char): kotlin.ShortRange
    public final fun rangeTo(/*0*/ other: kotlin.Double): kotlin.DoubleRange
    public final fun rangeTo(/*0*/ other: kotlin.Float): kotlin.FloatRange
    public final fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ShortRange
    public final fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Char): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public final class ShortArray : kotlin.Cloneable {
    /*primary*/ public constructor ShortArray(/*0*/ size: kotlin.Int)
    public open override /*1*/ fun clone(): kotlin.ShortArray
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Short
    public final fun iterator(): kotlin.ShortIterator
    public final fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Short): kotlin.Unit
    public final fun size(): kotlin.Int
}

public abstract class ShortIterator : kotlin.Iterator<kotlin.Short> {
    /*primary*/ public constructor ShortIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Short
    public abstract fun nextShort(): kotlin.Short
}

public final class ShortProgression : kotlin.Progression<kotlin.Short> {
    /*primary*/ public constructor ShortProgression(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short, /*2*/ increment: kotlin.Int)
    public open override /*1*/ val end: kotlin.Short
        public open override /*1*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*1*/ val start: kotlin.Short
        public open override /*1*/ fun <get-start>(): kotlin.Short
    public final fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ShortIterator
}

internal final class ShortProgressionIterator : kotlin.ShortIterator {
    /*primary*/ public constructor ShortProgressionIterator(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Short
        private final fun <get-finalElement>(): kotlin.Short
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    internal final val increment: kotlin.Int
        internal final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Short
    public open override /*1*/ fun nextShort(): kotlin.Short
}

public final class ShortRange : kotlin.Range<kotlin.Short>, kotlin.Progression<kotlin.Short> {
    /*primary*/ public constructor ShortRange(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short)
    public open override /*2*/ val end: kotlin.Short
        public open override /*2*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Short
        public open override /*2*/ fun <get-start>(): kotlin.Short
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Short): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ShortIterator

    public class object Default {
        /*primary*/ private constructor Default()
        public final val EMPTY: kotlin.ShortRange
            public final fun <get-EMPTY>(): kotlin.ShortRange
    }
}

public final class String : kotlin.Comparable<kotlin.String>, kotlin.CharSequence {
    /*primary*/ public constructor String()
    public open override /*1*/ fun charAt(/*0*/ index: kotlin.Int): kotlin.Char
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.String): kotlin.Int
    public final fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public open override /*1*/ fun length(): kotlin.Int
    public final fun plus(/*0*/ other: kotlin.Any?): kotlin.String
    public open override /*1*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence

    public class object Default {
        /*primary*/ private constructor Default()
    }
}

public open class Throwable {
    /*primary*/ public constructor Throwable(/*0*/ message: kotlin.String? = ..., /*1*/ cause: kotlin.Throwable? = ...)
    public final fun getCause(): kotlin.Throwable?
    public final fun getMessage(): kotlin.String?
    public final fun printStackTrace(): kotlin.Unit
}

public object Unit {
    /*primary*/ private constructor Unit()
}

public final annotation class data : kotlin.Annotation {
    /*primary*/ public constructor data()
}

public final annotation class deprecated : kotlin.Annotation {
    /*primary*/ public constructor deprecated(/*0*/ value: kotlin.String)
    internal final val value: kotlin.String
        internal final fun <get-value>(): kotlin.String
}

public final annotation class inline : kotlin.Annotation {
    /*primary*/ public constructor inline(/*0*/ strategy: kotlin.InlineStrategy = ...)
    public final val strategy: kotlin.InlineStrategy
        public final fun <get-strategy>(): kotlin.InlineStrategy
}

public final annotation class inlineOptions : kotlin.Annotation {
    /*primary*/ public constructor inlineOptions(/*0*/ vararg value: kotlin.InlineOption /*kotlin.Array<out kotlin.InlineOption>*/)
    internal final val value: kotlin.Array<out kotlin.InlineOption>
        internal final fun <get-value>(): kotlin.Array<out kotlin.InlineOption>
}

public final annotation class noinline : kotlin.Annotation {
    /*primary*/ public constructor noinline()
}

public final annotation class suppress : kotlin.Annotation {
    /*primary*/ public constructor suppress(/*0*/ vararg names: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    internal final val names: kotlin.Array<out kotlin.String>
        internal final fun <get-names>(): kotlin.Array<out kotlin.String>
}

public final annotation class tailRecursive : kotlin.Annotation {
    /*primary*/ public constructor tailRecursive()
}
