fix.insert.delegation.call=Insert ''{0}()'' call
fix.introduce.non.null.assertion=Add non-null asserted (!!) call
fix.remove.non.null.assertion=Remove unnecessary non-null assertion (!!)
fix.add.annotation.target=Add annotation target
fix.add.const.modifier=Add 'const' modifier
fix.add.constructor.parameter=Add constructor parameter ''{0}''
fix.make.data.class=Make ''{0}'' data class
fix.add.default.constructor=Add default constructor to 'expect' class
fix.add.explicit.import=Add explicit import
fix.add.function.body=Add function body
fix.add.is.to.when=Add ''is'' before ''{0}''
fix.add.new.line.after.annotations=Add new line after annotations
fix.make.type.parameter.reified=Make {0} reified and {1} inline
fix.add.return.last.expression=Add 'return' to last expression
fix.add.return.before.expression=Add 'return' before the expression
fix.add.return.before.lambda.expression=Add 'run' before the lambda expression
fix.add.semicolon.lambda.expression=Terminate preceding call with semicolon
fix.add.spread.operator.after.sam=Add a spread operator before an array passing as 'vararg'
fix.add.else.branch.when=Add else branch
fix.replace.with.assign.function.call=Replace with ''{0}'' call
fix.assign.to.property=Assign to property
fix.change.mutability.change.to.val=Change ''{0}'' to val
fix.change.type.argument=Change type argument to {0}
fix.change.to.function.invocation=Change to function invocation
fix.change.to.mutable.type=Change type to {0}

fix.change.to.property.access.family.remove=Remove invocation
fix.change.to.property.access.family.change=Change to property access

fix.change.to.labeled.return.family=Change to return with label
fix.change.to.labeled.return.text=Change to ''{0}''

fix.change.suspend.hierarchy.add=Add 'suspend' modifier to all functions in hierarchy
fix.change.suspend.hierarchy.remove=Remove 'suspend' modifier from all functions in hierarchy
fix.change.progress.looking.inheritors=Looking for class {0} inheritors…
fix.change.progress.analyzing.class.hierarchy=Analyzing class hierarchy…

fix.change.return.type.family=Change type
fix.change.return.type.text.primary.constructor=Change parameter ''{0}'' type of primary constructor of class ''{1}'' to ''{2}''
fix.change.return.type.text.function=Change parameter ''{0}'' type of function ''{1}'' to ''{2}''
fix.change.return.type.lambda=Change lambda expression return type to {0}
fix.change.return.type.remove.explicit.return.type=Remove explicitly specified return type
fix.change.return.type.remove.explicit.return.type.of=Remove explicitly specified return type of {0}
fix.change.return.type.return.type.text=Change return type to ''{0}''
fix.change.return.type.return.type.text.of=Change return type of {0} to ''{1}''
fix.change.return.type.type.text=Change type to ''{0}''
fix.change.return.type.type.text.of=Change type of {0} to ''{1}''
fix.change.return.type.presentation.property=property {0}
fix.change.return.type.presentation.function=function {0}
fix.change.return.type.presentation.enclosing.function=enclosing function
fix.change.return.type.presentation.enclosing=enclosing {0}
fix.change.return.type.presentation.called.function=called function
fix.change.return.type.presentation.accessed=accessed {0}
fix.change.return.type.presentation.called=called {0}
fix.change.return.type.presentation.base=base {0}

fix.cast.expression.family=Cast expression
fix.cast.expression.text=Cast expression ''{0}'' to ''{1}''

fix.change.accessor.family=Change accessor type
fix.change.accessor.getter=Change getter type to {0}
fix.change.accessor.setter.parameter=Change setter parameter type to {0}

fix.create.from.usage.dialog.title=Create from usage

fix.add.remaining.branches=Add remaining branches
fix.add.remaining.branches.with.star.import=Add remaining branches with * import

fix.add.type.annnotation.family=Add type annotation
fix.add.type.annnotation.text=Add type ''{0}'' to parameter ''{1}''

fix.add.tostring.call.family=Add 'toString()' call
fix.add.tostring.call.text=Add 'toString()' call
fix.add.tostring.call.text.safe=Add safe '?.toString()' call

fix.add.star.projection.family=Add star projections
fix.add.star.projection.text=Add ''{0}''

fix.change.to.star.projection.family=Change to star projection
fix.change.to.star.projection.text=Change type arguments to {0}

fix.change.to.use.spread.operator.family=Change to use spread operator
fix.change.to.use.spread.operator.text=Change ''{0}'' to ''{1}''

fix.change.type.family=Change type
fix.change.type.text=Change type from ''{0}'' to ''{1}''

fix.add.suspend.modifier.function=Make {0} suspend
fix.add.suspend.modifier.function.generic=Make containing function suspend
fix.add.suspend.modifier.receiver=Make {0} type suspend
fix.add.suspend.modifier.receiver.generic=Make receiver type suspend

fix.add.property.to.supertype.family=Add property to supertype
fix.add.property.to.supertype.text=Add ''{0}'' to ''{1}''
fix.add.property.to.supertype.text.generic=Add property to supertype…
fix.add.property.to.supertype.progress=Add property to type
fix.add.property.to.supertype.choose.type=Choose Type

fix.add.function.parameters.change.signature.constructor=Change the signature of constructor ''{0}''
fix.add.function.parameters.change.signature.function=Change the signature of function ''{0}''
fix.add.function.parameters.add.parameter.constructor=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to function ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Add {0,choice,1#parameter|2#parameters} to constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Add {0,choice,1#parameter|2#parameters} to function ''{1}''

fix.change.signature.family=Change signature of function/constructor
fix.change.signature.function.family=Change function signature
fix.change.signature.function.text=Change function signature to ''{0}''
fix.change.signature.function.text.generic=Change function signature...
fix.change.signature.function.popup.title=Choose Signature
fix.change.signature.lambda=Change the signature of lambda expression
fix.change.signature.remove.parameter=Remove parameter ''{0}''
fix.change.signature.unavailable=<not available>
fix.change.signature.error=<error>
fix.change.signature.unnamed.parameter=parameter

fix.change.object.to.class=Change 'object' to 'class'

fix.add.function.supertype.family=Add function to supertype
fix.add.function.supertype.text=Add function to supertype...
fix.add.function.supertype.progress=Add Function to Type
fix.add.function.supertype.choose.type=Choose Type
fix.add.function.supertype.add.to=Add ''{0}'' to ''{1}''

fix.add.generic.upperbound.text=Add ''{0}'' as upper bound for {1}
fix.add.generic.upperbound.family=Add generic upper bound

fix.add.modifier.inline.parameter.family=Add ''{0}'' to parameter
fix.add.modifier.inline.parameter.text=Add ''{0}'' to parameter ''{1}''

fix.add.modifier.inline.function.family=Add ''inline'' to function
fix.add.modifier.inline.function.text=Add ''inline'' to function ''{0}''

fix.add.array.of.type.text=Add {0} wrapper
fix.add.array.of.type.family=Add ''arrayOf'' wrapper

fix.add.loop.label.text.generic=Add label to loop
fix.add.loop.label.text=Add ''{0}'' to {1}

fix.add.modifier.family=Add modifier
fix.add.modifier.text=Make {0} ''{1}''
fix.add.modifier.text.generic=Add ''{0}'' modifier

fix.add.argument.name.family=Add name to argument
fix.add.argument.name.text.generic=Add name to argument...
fix.add.argument.name.text=Add name to argument: ''{0}''
fix.add.argument.name.step.choose.parameter.name=Choose parameter name

fix.change.feature.support.family=Enable/Disable {0} support
fix.change.feature.support.enabled=Enable {0} support
fix.change.feature.support.enabled.warning=Enable {0} support (with warning)
fix.change.feature.support.disabled=Disable {0} support

fix.create.expect.actual=Create expect / actual declaration
fix.create.missing.actual.members=Add missing actual members

fix.create.declaration.error=Cannot generate {0}: {1}
fix.create.declaration.error.inaccessible.type=Inaccessible type
fix.create.declaration.error.some.types.inaccessible=Some types are not accessible:

fix.add.annotation.family=Add annotation
fix.add.annotation.text.self=Add ''@{0}'' annotation
fix.add.annotation.text.declaration=Add ''@{0}'' annotation to ''{1}''
fix.add.annotation.text.containing.class=Add ''@{0}'' annotation to containing class ''{1}''

fix.import=Import
fix.import.kind.delegate.accessors=Delegate accessors
fix.import.kind.component.functions=Component functions
fix.import.exclude=Exclude ''{0}'' from auto-import

fix.move.file.to.package.family=Move file to package-matching directory
fix.move.file.to.package.text=Move file to {0}

fix.change.package.family=file's package to match directory
fix.change.package.text=Change file''s package to {0}

action.add.import.chooser.title=Imports

goto.super.chooser.function.title=Choose super function
goto.super.chooser.property.title=Choose super property
goto.super.chooser.class.title=Choose super class or interface

inspection.unused.receiver.parameter=Receiver parameter is never used
fix.unused.receiver.parameter.remove=Remove redundant receiver parameter

inspection.migration.title=Code Migration
inspection.migration.profile.name=Migration

fix.create.from.usage.family=Create from usage
fix.create.from.usage.local.variable=Create local variable ''{0}''

overridden.marker.implementations.multiple=Has implementations
overridden.marker.implementation=Is implemented in <br/>
overridden.marker.overrides.multiple=Is overridden in subclasses
overridden.marker.overrides=Is overridden in <br/>

overridden.marker.implementations.choose.implementation.title=Choose Implementation of {0}
overridden.marker.implementations.choose.implementation.find.usages=Overriding properties of {0}
overridden.marker.overrides.choose.implementation.title=Choose Super Implementation of {0}
overridden.marker.overrides.choose.implementation.find.usages=Super Implementations of {0}

remove.expression = Remove ''{0}''
unwrap.expression = Unwrap ''{0}''
remove.else = Remove else in ''{0}''
unwrap.else = Unwrap else in ''{0}''

override.declaration.x.in.y={0} in {1}
override.declaration.x.implements.y={0} in {1} implements {2} in {3}.
override.declaration.x.overrides.y.in.class.list={0} overrides declarations in the following classes/interfaces: {1} Do you want to {2} the base declarations?

override.declaration.unused.overriding.methods.title=Unused Overriding Members
override.declaration.unused.overriding.methods.description=There are unused members that override methods you delete.
override.declaration.choose.to.delete=Choose the ones you want to be deleted.
override.declaration.member=Member
override.declaration.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?

find.declaration.implementing.methods.checkbox=&Implementing functions
find.declaration.overriding.methods.checkbox=Over&riding functions
find.declaration.implementing.properties.checkbox=&Implementing properties
find.declaration.overriding.properties.checkbox=Over&riding properties
find.declaration.property.readers.checkbox=Readers
find.declaration.property.writers.checkbox=Writers
find.declaration.include.overloaded.methods.checkbox=Include o&verloaded functions and extensions
find.declaration.functions.usages.checkbox=Usages of &functions
find.declaration.properties.usages.checkbox=Usages of &properties
find.declaration.constructor.usages.checkbox=Usages of &constructor
find.declaration.derived.classes.checkbox=&Derived classes
find.declaration.derived.interfaces.checkbox=Derived &interfaces

hierarchy.legend.member.is.defined.in.class=Member is defined in the class
hierarchy.legend.member.defined.in.superclass=Member is not defined in the class but defined in superclass
hierarchy.legend.member.should.be.defined=Member should be defined since the class is not abstract

intention.change.package.text=Change package

intention.extract.declarations.from.file.text=Extract declaration from current file
intention.extract.declarations.from.file.text.details=Extract ''{0}'' {1, choice, 0#|1#and subclasses }from current file

intention.suppress.family=Suppress Warnings
intention.suppress.text=Suppress ''{0}'' for {1} {2}

kotlin.compiler.option.generate.no.warnings=Report compiler &warnings
kotlin.compiler.option.additional.command.line.parameters=&Additional command line parameters:
kotlin.compiler.option.enable.new.inference.in.ide=Enable new type inference algorithm for IDE analysis

kotlin.compiler.jvm.option.panel.title=Kotlin to JVM

kotlin.compiler.js.option.panel.title=Kotlin to JavaScript
kotlin.compiler.js.option.generate.sourcemaps=Generate &source maps
kotlin.compiler.js.option.output.prefix=File to &prepend to generated code:
kotlin.compiler.js.option.output.postfix=File to append to generated c&ode:
kotlin.compiler.js.option.output.copy.files=&Copy library runtime fileskotlin.compiler.js.option.output.copy.dir=O&utput directory for library &runtime files:

# Android Lint
android.klint.inspections.group.name=Android Lint for Kotlin

# Scratch Files
scratch.run.button=Run Scratch File
scratch.run.from.here.button=Run Scratch From Here
scratch.stop.button=Stop scratch execution
scratch.clear.button=Clear results
scratch.module.combobox=Use classpath of module
scratch.is.repl.checkbox=Use REPL
scratch.is.repl.checkbox.description=Runs in the Kotlin REPL. Executes only the new expressions added to the end of the scratch
scratch.is.interactive.checkbox=Interactive mode
scratch.is.interactive.checkbox.description=Runs after you stop typing for {0} seconds
scratch.make.before.run.checkbox=Make module before Run
scratch.make.before.run.checkbox.description=Make module {0} before running scratch. Only compiled code is reachable from this scope
scratch.inlay.output.mode=Inlay output mode\n\nThe output is shown in the code editor right next to the expression. Well suited for a short single-line output.
scratch.side.panel.output.mode.description=Side panel output mode
scratch.side.panel.output.mode=Side panel output mode\n\nThe output is shown in the separate panel. Useful if the output is long or multi-line.
scratch.inlay.output.mode.description=Inlay output mode

# Code insight
dialog.import.on.paste.title3=Select Import to Remove
copy.paste.reference.notification=<html>{0} {0, choice, 1#import was|2#imports were} added<p><span><a href='show'>Review Added Imports...</a></span></html>

# Experimental features
experimental.ml.completion=ML Completion for Kotlin


plugin.verifier.compatibility.issue.title=Compatibility issue
plugin.verifier.compatibility.issue.message=Installed Kotlin plugin version ({0}) is not compatible with {1}.\nSome functionality may be broken.\n\nPlease reinstall the Kotlin plugin.

plugin.updater.notification.group=Kotlin plugin updates
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=A new version {0} of the Kotlin plugin is available. <b><a href="#">Install</a></b>
plugin.updater.downloading=Downloading plugins
plugin.updater.not.installed=Plugin update was not installed. <a href="#">See the log for more information</a>
plugin.updater.not.installed.misc=Plugin update was not installed: {0}. <a href="#">See the log for more information</a>
plugin.updater.error.check.failed=Kotlin plugin update check failed
plugin.updater.error.unexpected.repository.response=Unexpected plugin repository response
plugin.updater.error.cant.find.plugin.version=Couldn't find plugin version in repository response
plugin.updater.error.custom.repository=Checking custom plugin repository {0} failed

quick.doc.text.enum.ordinal=Enum constant ordinal: {0}
quick.doc.text.tailrec='tailrec' marks a function as <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">tail-recursive</a> (allowing the compiler to replace recursion with iteration)
quick.doc.text.lateinit='lateinit' allows initializing a <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">not-null property outside of a constructor</a>
quick.doc.no.documentation=No documentation available
quick.doc.section.deprecated=Deprecated:
quick.doc.section.replace.with=Replace with:
quick.doc.section.java.declaration=Java declaration:

action.decompile.java.name=Decompile to Java
action.decompile.busy.text=Kotlin Classfile

action.j2k.name=Convert Java to Kotlin
action.j2k.task.name=Convert files from Java to Kotlin
action.j2k.correction.investigate=Investigate Errors
action.j2k.correction.proceed=Proceed with Conversion
action.j2k.correction.required=Some code in the rest of your project may require corrections after performing this conversion. Do you want to find such code and correct it too?
action.j2k.correction.errors.single=''{0}'' contains syntax errors, the conversion result may be incorrect
action.j2k.correction.errors.multiple=''{0}'' and {1} other Java files contain syntax errors, the conversion result may be incorrect
action.j2k.error.cant.save.result=Failed to save conversion result: {0}
action.j2k.error.cant.find.document=couldn't find document for ''{0}''
action.j2k.error.read.only=file ''{0}'' is read-only
action.j2k.errornothing.to.convert=Nothing to convert:<br>No writable Java files found

formatter.settings.title=Kotlin Formatter Settings

action.generate.functions.already.defined=Functions {0} are already defined for class {1}. Do you want to delete them and proceed?

action.generate.equals.choose.equals=Choose properties to be included in ''equals()''
action.generate.equals.choose.hashcode=Choose properties to be included in ''hashCode()''

action.generate.secondary.constructor.choose.properties=Choose Properties to Initialize by Constructor
action.generate.secondary.constructor.error.already.exists=Constructor already exists

action.generate.test.support.choose.framework=Choose Framework
action.generate.test.support.generate.test.function=Generate test function
action.generate.test.support.choose.test.name=Choose test name:
action.generate.test.support.edit.template=Edit Template
action.generate.test.support.error.no.template.found=No template found for {0}:{1}
action.generate.test.support.error.cant.convert.java.template=Couldn't convert Java template to Kotlin
action.generate.test.support.error.cant.generate.method=Cannot generate method: {0}

action.generate.tostring.name=Generate toString()
action.generate.tostring.template.single=Single template
action.generate.tostring.template.multiple=Multiple templates with concatenation
action.generate.tostring.choose.implementation=Choose implementation:
action.generate.tostring.generate.super.call=Generate call to super.toString()

action.new.file.text=Kotlin File/Class
action.new.file.description=Creates new Kotlin file or class
action.new.file.dialog.title=New Kotlin File/Class
action.new.file.dialog.file.title=File
action.new.file.dialog.file.description=Kotlin File
action.new.file.dialog.class.title=Class
action.new.file.dialog.class.description=Kotlin Class
action.new.file.dialog.interface.title=Interface
action.new.file.dialog.interface.description=Kotlin Interface
action.new.file.dialog.enum.title=Enum class
action.new.file.dialog.enum.description=Kotlin Enum
action.new.file.dialog.object.title=Object
action.new.file.dialog.object.description=Kotlin Object
action.new.file.error.empty.name=Name can't be empty
action.new.file.error.empty.name.part=Name can't have empty parts

action.new.script.name=Kotlin Script
action.new.script.description=Creates new Kotlin script
action.new.script.dialog.title=New Kotlin Script
action.new.script.template.name=Kotlin Script

action.new.worksheet.name=Kotlin Worksheet
action.new.worksheet.description=Creates new Kotlin Worksheet
action.new.worksheet.dialog.title=New Kotlin Worksheet
action.new.worksheet.template.name=Kotlin Worksheet

breadcrumbs.tooltip.indexing=Indexing…

copy.paste.resolve.references=Resolve pasted references

type.provider.anonymous.object=anonymous object
type.provider.unknown.type=Type is unknown
type.provider.smart.cast.from=(smart cast from {0})
type.provider.no.expression.found=No expression found

optimize.imports.collect.unused.imports=Collect unused imports
optimize.imports.task.removing.redundant.imports=Removing redundant imports

kdoc.section.title.receiver=Receiver
kdoc.section.title.parameters=Params
kdoc.section.title.returns=Returns
kdoc.section.title.throws=Throws
kdoc.section.title.author=Author
kdoc.section.title.since=Since
kdoc.section.title.samples=Samples
kdoc.section.title.see.also=See Also
kdoc.comment.unresolved=Unresolved

livetemplate.description.main=main() function
livetemplate.description.soutp=Prints function parameter names and values to System.out
livetemplate.description.iter=Iterate over elements of iterable (for-in loop)
livetemplate.description.ifn=Inserts ''if null'' expression
livetemplate.description.inn=Inserts ''if not null'' expression
livetemplate.description.void=Function returning nothing
livetemplate.description.fun0=Function with no parameters
livetemplate.description.fun1=Function with one parameter
livetemplate.description.fun2=Function with two parameters
livetemplate.description.interface=Interface
livetemplate.description.singleton=Singleton
livetemplate.description.closure=Closure (function without name)
livetemplate.description.anonymous=Anonymous class
livetemplate.description.exfun=Extension function
livetemplate.description.exval=Extension read-only property
livetemplate.description.exvar=Extension read-write property

hints.progress.calculating.parameter.info=Calculating parameter info
hints.title.property.type.enabled=Show property type hints
hints.title.property.type.disabled=Do not show property type hints
hints.title.locals.type.enabled=Show local variable type hints
hints.title.locals.type.disabled=Do not show local variable type hints
hints.title.function.type.enabled=Show function return type hints
hints.title.function.type.disabled=Do not show function return type hints
hints.title.parameter.type.enabled=Show parameter type hints
hints.title.parameter.type.disabled=Do not show parameter type hints
hints.title.argument.name.enabled=Show argument name hints
hints.title.argument.name.disabled=Do not show argument name hints
hints.title.return.expression.enabled=Show lambda return expression hints
hints.title.return.expression.disabled=Do not show lambda return expression hints
hints.title.implicit.parameters.enabled=Show hints for implicit receivers and parameters of lambdas
hints.title.implicit.parameters.disabled=Do not show hints for implicit receivers and parameters of lambdas
hints.title.suspend.calls.enabled=Show hints for suspending calls
hints.title.suspend.calls.disabled=Do not show hints for suspending calls

presentation.text.paren=({0})
presentation.text.in.container.paren=(in {0})
presentation.text.in.container={0} in {1}
presentation.text.for.receiver.in.container.paren=(for {0} in {1})
presentation.text.object.in.container=object in {0}

project.view.class.initializer=class initializer

copy.text.adding.imports=Adding imports ...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=Clipboard content seems to be Java code. Do you want to convert it to Kotlin?
copy.text.convert.java.to.kotlin=Convert Java to Kotlin
copy.text.copied.kotlin.code=Copied kotlin code
copy.text.resolving.references=Resolving references ...
copy.title.convert.code.from.java=Convert Code From Java

editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=Auto add val keyword to data/inline class constructor parameters
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convert pasted Java code to Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=Don''t show Java to Kotlin conversion dialog on paste
editor.title.kotlin=Kotlin

facet.checkbox.text.use.project.settings=Use project settings
facet.column.name.options=Options
facet.column.name.plugin=Plugin
facet.error.text.at.least.one.target.platform.should.be.selected=At least one target platform should be selected
facet.label.text.selected.target.platforms=Selected target platforms:
facet.label.text.target.platform=Target platform:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=The project is imported from external build system and could not be edited
facet.link.text.edit.project.settings=Edit project settings
facet.name.compiler.plugins=Compiler Plugins
facet.name.general=General
facet.text.following.arguments.are.redundant=Following arguments are redundant: {0}
facet.text.following.arguments.override.facet.settings=Following arguments override facet settings: {0}
facet.text.following.options.are.not.correct=Following options are not correct:
facet.text.multiplatform=Multiplatform

filters.text.inline.function.body=inline function body
filters.text.inline.function.call.site=inline function call site
filters.title.navigate.to=Navigate to

find.usages.class=class
find.usages.companion.object=companion object
find.usages.constructor=constructor
find.usages.facade.class=facade class
find.usages.for.property={0} for property
find.usages.function=function
find.usages.getter=getter
find.usages.import.alias=import alias
find.usages.interface=interface
find.usages.label=label
find.usages.lambda=lambda
find.usages.object=object
find.usages.parameter=parameter
find.usages.property.accessor=property accessor
find.usages.property=property
find.usages.setter=setter
find.usages.type.alias=type alias
find.usages.type.parameter=type parameter
find.usages.variable=variable
find.usages.checkbox.name.expected.classes=Expected classes
find.usages.class.name.anonymous=Anonymous
find.usages.checkbox.name.expected.functions=Expected functions
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>Find usages for data class components and destruction declarations<br/>could be <a href="{0}">disabled once</a> or <a href="{1}">disabled for a project</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Disable search for data class components and destruction declarations. (Project wide setting)
find.usages.checkbox.text.fast.data.class.component.search=Fast data class component search
find.usages.checkbox.name.expected.properties=Expected properties
find.usages.action.text.find.usages.of=find usages of
find.usages.type.named.argument=Named argument
find.usages.type.type.alias=Type alias
find.usages.type.callable.reference = Callable reference
find.usages.type.type.constraint = Type constraint
find.usages.type.value.parameter.type = Parameter type
find.usages.type.nonLocal.property.type = Class/object property type
find.usages.type.function.return.type = Function return types
find.usages.type.superType = Supertype
find.usages.type.is = Target type of 'is' operation
find.usages.type.class.object = Nested class/object
find.usages.type.companion.object = Companion object
find.usages.type.function.call = Function call
find.usages.type.implicit.get = Implicit 'get'
find.usages.type.implicit.set = Implicit 'set'
find.usages.type.implicit.invoke = Implicit 'invoke'
find.usages.type.implicit.iteration = Implicit iteration
find.usages.type.property.delegation = Property delegation
find.usages.type.extension.receiver.type = Extension receiver type
find.usages.type.super.type.qualifier = Super type qualifier
find.usages.type.receiver = Receiver
find.usages.type.delegate = Delegate
find.usages.type.packageDirective = Package directive
find.usages.type.packageMemberAccess = Package member access

formatter.button.text.use.import.with.when.at.least=Use import with ''*'' when at least
formatter.button.text.use.import.with=Use import with ''*''
formatter.button.text.use.single.name.import=Use single name import
formatter.checkbox.text.insert.imports.for.nested.classes=Insert imports for nested classes
formatter.text.names.used=\ names used
formatter.text.use.defaults.from=Use defaults from:
formatter.title.after.colon.before.declaration.type=After colon, before declaration type
formatter.title.after.colon.in.new.type.definition=After colon in new type definition
formatter.title.align.when.branches.in.columns=Align ''when'' branches in columns
formatter.title.around.arrow.in.function.types=Around arrow in function types
formatter.title.around.arrow.in=Around arrow in "when" clause
formatter.title.around.when.branches.with=Around ''when'' branches with {}
formatter.title.before.colon.after.declaration.name=Before colon, after declaration name
formatter.title.before.colon.in.new.type.definition=Before colon in new type definition
formatter.title.before.lambda.arrow=Before lambda arrow
formatter.title.chained.function.calls=Chained function calls
formatter.title.elvis.expressions=Elvis expressions
formatter.title.expression.body.functions=Expression body functions
formatter.title.function.annotations=Function annotations
formatter.title.function.call.arguments=Function call arguments
formatter.title.function.declaration.parameters=Function declaration parameters
formatter.title.function.parentheses=Function parentheses
formatter.title.in.simple.one.line.methods=In simple one line methods
formatter.title.java.statics.and.enum.members=Java Statics and Enum Members
formatter.title.load.save=Load/Save
formatter.title.other=Other
formatter.title.property.annotations=Property annotations
formatter.title.put.left.brace.on.new.line=Put left brace on new line
formatter.title.range.operator=Range operator (..)
formatter.title.top.level.symbols=Top-level Symbols
formatter.title.use.continuation.indent.in.conditions=Use continuation indent in conditions
formatter.title.use.continuation.indent=Use continuation indent
formatter.title.when.parentheses=''when'' parentheses
formatter.title.when.statements=''when'' statements

framework.name.kotlin.sdk=Kotlin SDK

hierarchy.text.anonymous=[anonymous]
hierarchy.text.in=\ in {0}

highlighter.action.text.go.to.actual.declarations=Go to actual declarations
highlighter.action.text.go.to.expected.declaration=Go to expected declaration
highlighter.action.text.go.to.implementations=Go to implementations
highlighter.action.text.go.to.overridden.methods=Go to overridden methods
highlighter.action.text.go.to.overridden.properties=Go to overridden properties
highlighter.action.text.go.to.subclasses=Go to subclasses
highlighter.action.text.go.to.super.method=Go to super method
highlighter.action.text.go.to.super.property=Go to super property
highlighter.descriptor.text.android.extensions.property=Properties and Variables//Android Extensions synthetic properties
highlighter.descriptor.text.annotation=Annotation//Annotation name
highlighter.descriptor.text.annotation.attribute.name=Annotation//Annotation attribute name
highlighter.descriptor.text.arrow=Braces and Operators//Arrow
highlighter.descriptor.text.builtin.annotation=Keywords//Modifier
highlighter.descriptor.text.builtin.keyword.val=Keywords//'val'
highlighter.descriptor.text.builtin.keyword.var=Keywords//'var'
highlighter.descriptor.text.builtin.keyword=Keywords//Keyword
highlighter.descriptor.text.captured.variable=Properties and Variables//Variables and values captured in a closure
highlighter.descriptor.text.closure.braces=Braces and Operators//Lambda expression braces and arrow
highlighter.descriptor.text.colon=Braces and Operators//Colon
highlighter.descriptor.text.constructor.call=Functions//Constructor call
highlighter.descriptor.text.double.colon=Braces and Operators//Double colon
highlighter.descriptor.text.dynamic.fun.call=Functions//Dynamic function call
highlighter.descriptor.text.dynamic.property=Properties and Variables//Dynamic property
highlighter.descriptor.text.enumEntry=Classes and Interfaces//Enum entry
highlighter.descriptor.text.exclexcl=Braces and Operators//Non-null assertion
highlighter.descriptor.text.extension.fun.call=Functions//Extension function call
highlighter.descriptor.text.extension.property=Properties and Variables//Extension property
highlighter.descriptor.text.field=Properties and Variables//Backing field variable
highlighter.descriptor.text.fun.call=Functions//Function call
highlighter.descriptor.text.fun=Functions//Function declaration
highlighter.descriptor.text.instance.property.custom.property.declaration=Properties and Variables//Instance property with custom property declarations
highlighter.descriptor.text.instance.property=Properties and Variables//Instance property
highlighter.descriptor.text.it=Parameters//Lambda expression default parameter
highlighter.descriptor.text.kdoc.comment=Comments//KDoc//KDoc comment
highlighter.descriptor.text.kdoc.tag=Comments//KDoc//KDoc tag
highlighter.descriptor.text.kdoc.value=Comments//KDoc//Link in KDoc tag
highlighter.descriptor.text.label=Label
highlighter.descriptor.text.local.variable=Properties and Variables//Local variable or value
highlighter.descriptor.text.named.argument=Named argument
highlighter.descriptor.text.object=Classes and Interfaces//Object
highlighter.descriptor.text.package.fun.call=Functions//Package-level function call
highlighter.descriptor.text.package.property.custom.property.declaration=Properties and Variables//Package-level property with custom property declarations
highlighter.descriptor.text.package.property=Properties and Variables//Package-level property
highlighter.descriptor.text.quest=Braces and Operators//Type nullability marker
highlighter.descriptor.text.safe.access=Braces and Operators//Safe access dot
highlighter.descriptor.text.smart.cast.receiver=Smart-casts//Smart-cast implicit receiver
highlighter.descriptor.text.smart.cast=Smart-casts//Smart-cast value
highlighter.descriptor.text.smart.constant=Smart-casts//Smart constant
highlighter.descriptor.text.string.escape=String//Escape in string and template braces
highlighter.descriptor.text.suspend.fun.call=Functions//Suspend function call
highlighter.descriptor.text.synthetic.extension.property=Properties and Variables//Synthetic extension property
highlighter.descriptor.text.typeAlias=Classes and Interfaces//Type alias
highlighter.descriptor.text.var=Properties and Variables//Var (mutable variable, parameter or property)
highlighter.descriptor.text.variable.as.function.call=Properties and Variables//Variable as function call
highlighter.descriptor.text.variable.as.function.like.call=Properties and Variables//Variable as function-like call
highlighter.message.suspend.function.call=Suspend function call
highlighter.message.suspending.iteration=Suspending iteration
highlighter.name.dsl.markers=DSL markers
highlighter.name.dsl=Dsl//
highlighter.name.implemented.declaration=Implemented declaration
highlighter.name.implementing.declaration=Implementing declaration
highlighter.name.kotlin.line.markers=Kotlin line markers
highlighter.name.multiplatform.actual.declaration=Multiplatform actual declaration
highlighter.name.multiplatform.expect.declaration=Multiplatform expect declaration
highlighter.name.overridden.declaration=Overridden declaration
highlighter.name.overriding.declaration=Overriding declaration
highlighter.name.style=Style
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=Navigation to overriding classes is not possible during index update
highlighter.prefix.text.has.actuals.in=Has actuals in
highlighter.text.click.for.navigate=Click {0}to navigate
highlighter.text.has.functional.implementations=Has functional implementations
highlighter.text.implements=Implements
highlighter.text.in={0} in ''{1}''
highlighter.text.modules=\ ({0} modules)
highlighter.text.or.press=\ or press {0}
highlighter.text.overrides=Overrides
highlighter.title.actuals.for=Actuals for {0}
highlighter.title.choose.actual.for=Choose actual for {0}
highlighter.title.choose.expected.for=Choose expected for {0}
highlighter.title.expected.for=Expected for {0}
highlighter.title.overriding.declarations.of=Overriding declarations of {0}
highlighter.title.searching.for.overriding.declarations=Searching for overriding declarations
highlighter.title.searching.for.overriding.methods=Searching for overriding methods
highlighter.tool.tip.has.declaration.in.common.module=Has declaration in common module
highlighter.tool.tip.marker.annotation.for.dsl=Marker annotation for DSL
highlighter.tool.tip.text.function=function
highlighter.tool.tip.text.property=property
highlighter.tool.tip.text.recursive.call=Recursive call
highlighter.tool.tip.text.run.test=Run Test

import.optimizer.notification.text.unused.imports.not.found=Unused imports not found
import.optimizer.progress.indicator.text.collect.imports.for=Collect imports for {0}
import.optimizer.text.import={0, choice, 0#import|2#imports}
import.optimizer.text.non.zero=Removed {0} {1}{2, choice, 0#|1#, added {2} {3}}
import.optimizer.text.zero=Rearranged imports

internal.action.text.decompile.kotlin.bytecode=Decompile kotlin bytecode
internal.error.text.cannot.decompile=Cannot decompile {0}
internal.indicator.text.decompiling=Decompiling {0}
internal.title.decompiler.error=Decompiler error

version.title.no.runtime.found=No Runtime Found
version.dialog.message.is.not.found.make.sure.plugin.is.properly.installed={0} is not found. Make sure plugin is properly installed.
version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} is deprecated since 1.2.0 and should be replaced with {1}

update.name.android.studio=Android Studio
update.reason.text.exception.during.verification=exception during verification {0}
update.reason.text.no.verified.versions.for.this.build=No verified versions for this build.
update.reason.text.unable.to.connect.to.compatibility.verification.repository=unable to connect to compatibility verification repository
update.reason.text.unable.to.parse.compatibility.verification.metadata=unable to parse compatibility verification metadata
update.reason.text.version.to.be.verified=Version to be verified.

test.integration.button.text.cancel=Cancel
test.integration.button.text.rewrite=Rewrite
test.integration.message.text.create.test.in.the.same.source.root=Create test in the same source root?
test.integration.message.text.kotlin.class=Kotlin class ''{0}'' already exists. Do you want to update it?
test.integration.title.no.test.roots.found=No Test Roots Found

slicer.text.in=\ in {0}
slicer.text.tracking.enclosing.lambda=\ (Tracking enclosing lambda)
slicer.title.dataflow.from.here=Dataflow from Here
slicer.title.dataflow.to.here=Dataflow to Here
slicer.tool.tip.text.variable.dereferenced=Variable dereferenced

script.action.text.ignore=Ignore
script.action.text.open.settings=Open Settings
script.action.text.show.all=Show all
script.name.kotlin.scripting=Kotlin Scripting
script.progress.text.kotlin.scanning.dependencies.for.script.definitions=Kotlin: scanning dependencies for script definitions...
script.text.multiple.script.definitions.are.applicable.for.this.script=Multiple script definitions are applicable for this script. {0} is used

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Update source roots for non-JVM modules in Kotlin project

reporter.button.text.ignore=Ignore
reporter.button.text.update=Update
reporter.message.text.you.re.running.kotlin.plugin.version=You''re running Kotlin plugin version {0}, while the latest version is {1}
reporter.text.can.t.report.exception.from.patched.plugin=Can''t report exception from patched plugin
reporter.title.update.kotlin.plugin=Update Kotlin Plugin

configuration.action.text.ignore=Ignore
configuration.action.text.update=Update
configuration.description.always=Always
configuration.description.amd=AMD
configuration.description.commonjs=CommonJS
configuration.description.never=Never
configuration.description.plain.put.to.global.scope=Plain (put to global scope)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD (detect AMD or CommonJS if available, fallback to plain)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=When inlining a function from other module with embedded sources
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=Shouldn''t add null urls to custom repositories
configuration.feature.text.new.experimental.project.wizard=New Experimental Project Wizard
configuration.feature.text.new.java.to.kotlin.converter=New Java to Kotlin Converter
configuration.message.enter.fully.qualified.method.name=Enter fully-qualified method name:
configuration.message.text.a.new.version.is.available=A new version {0} is available
configuration.message.text.a.new.version.is.found=A new version {0} is found but it''s not verified by {1}.
configuration.message.text.update.check.failed=Update check failed: {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=You have the latest version of the plugin installed.
configuration.message.verifier.disabled=(verifier disabled)
configuration.migration.text.api.version=API version: {0} -> {1}
configuration.migration.text.detected.migration=Detected migration:
configuration.migration.text.language.version=Language version: {0} -> {1}
configuration.migration.text.migrations.for.kotlin.code.are.available=Migrations for Kotlin code are available
configuration.migration.text.run.migrations=Run migrations
configuration.migration.text.standard.library=Standard library: {0} -> {1}
configuration.migration.title.kotlin.migration=Kotlin Migration
configuration.name.kotlin.compiler=Kotlin Compiler
configuration.name.kotlin=Kotlin
configuration.name.method=Method
configuration.status.text.installation.failed=Installation failed
configuration.status.text.installing=Installing...
configuration.text.add.exclusion=Add exclusion
configuration.text.and=and
configuration.text.other.s=other(s)
configuration.text.patched.original={0} (Patched! Original: {1})
configuration.text.the.compiler.bundled.to.kotlin.plugin=The compiler bundled to Kotlin plugin ({0}) is older than external compiler used for building modules:
configuration.text.this.may.cause.different.set.of.errors.and.warnings.reported.in.ide.p=This may cause different set of errors and warnings reported in IDE.
configuration.title.choose.output.directory=Choose Output Directory
configuration.title.early.access.preview.1.3.x=Early Access Preview 1.3.x
configuration.title.early.access.preview.1.4.x=Early Access Preview 1.4.x
configuration.title.edit.exclusion=Edit exclusion
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=Choose file to append to generated code
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=Choose file to prepend to generated code
configuration.title.outdated.bundled.kotlin.compiler=Outdated Bundled Kotlin Compiler
configuration.title.stable=Stable
configuration.warning.text.following.modules.override.project.settings=Following modules override project settings:
configuration.warning.text.modules.override.project.settings={0} modules override project settings

#Refactoring
0.1.is.never.used={0} ''{1}'' is never used
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} has detected {1} code {1,choice,1#fragment|2#fragments} in {2} that can be replaced with {3}. Would you like to review and replace {1,choice,1#it|2#them}?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed={0} usages are not supported by the Inline refactoring. They won''t be processed.
0.will.become.invisible.after.extraction={0} will become invisible after extraction
0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
action.text.append=Append
action.text.cancel=Cancel
action.text.overwrite=Overwrite
button.text.move.nested.class.0.to.upper.level=Move &nested class {0} to upper level
button.text.move.nested.class.0.to.another.class=&Move nested class {0} to another class
cannot.extract.method=Cannot find statements to extract
cannot.extract.super.call=Cannot extract super-call
cannot.inline.property.with.accessor.s.and.backing.field=Cannot inline property with accessor(s) and backing field
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.no.type=Cannot perform refactoring without a type
cannot.refactor.not.expression.to.extract=Cannot find an expression to extract
cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.package.expression=Cannot introduce package reference
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.synthesized.function=Cannot refactor synthesized function ''{0}''
checkbox.text.declare.with.var=Declare with &var
checkbox.text.delete.empty.source.files=&Delete empty source files
checkbox.text.extension.property=E&xtension property:\u0020
checkbox.text.introduce.default.value=Introduce &default value
checkbox.text.open.moved.files.in.editor=Open moved member in editor
checkbox.text.replace.all.occurrences.0=&Replace all occurrences ({0})
checkbox.text.search.references=Search &references
checkbox.text.specify.type.explicitly=Specify &type explicitly
checkbox.text.update.package.directive=Update package directive (Kotlin files)
column.name.receiver=Receiver:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
description.a.reference.to.extracted.type.parameter=a reference to extracted type parameter
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
error.hint.text.cannot.inline.0.from.a.decompiled.file=Cannot inline ''{0}'' from a decompiled file
error.text.can.t.change.signature.of.method=Can''t change signature of {0} method
error.text.can.t.copy.class.to.the.containing.file=Can''t copy class to the containing file
error.text.can.t.generate.0.1=Can''t generate {0}: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=Can''t introduce lambda parameter for this expression
error.text.can.t.introduce.property.for.this.expression=Can''t introduce property for this expression
error.text.different.name.expected=Different name expected
error.text.expression.has.no.type=Expression has no type
error.text.extraction.from.expect.class.is.not.yet.supported=Extraction from expect class is not yet supported
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Extraction from non-JVM class is not yet supported
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=Inline Function is not supported for functions with multiple return statements.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=Inline Function is not supported for functions with return statements not at the end of the body.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Interface cannot be extracted from an annotation class
error.text.introduce.parameter.is.not.available.for.default.value=Introduce Parameter is not available for default value
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introduce Parameter is not available inside of annotation entries
error.text.invalid.default.receiver.value=Invalid default receiver value
error.text.invalid.name=Invalid name
error.text.invalid.parameter.name=Invalid parameter name
error.text.invalid.parameter.type=Invalid parameter type
error.text.invalid.receiver.type=Invalid receiver type
error.text.invalid.return.type=Invalid return type
error.text.no.type.to.refactor=No type to refactor
error.text.refactoring.is.not.applicable.in.the.current.context=Refactoring is not applicable in the current context
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Superclass cannot be extracted from an annotation class
error.text.type.reference.is.expected=Type reference is expected
error.types.in.generated.function=Cannot generate function with erroneous return type
error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
extract.function=Extract Function
family.name.update.usages.on.declarations.cut.paste=Update usages on declarations cut/paste
file.does.not.exist=File {0} does not exist.\nDo you want to create it?
function.name.is.invalid=Function name is invalid
introduce.parameter=Introduce Parameter
introduce.property=Introduce Property
introduce.type.parameter.to.declaration=Introduce type parameter to declaration
introduce.type.parameter=Introduce Type Parameter
introduce.variable=Introduce Variable
label.text.default.receiver.value=&Default receiver value:\u0020
label.text.destination.directory=&Destination directory:
label.text.file.name=File &name:
label.text.introduce.as=&Introduce as:\u0020
label.text.name=&Name:\u0020
label.text.package.name=Packa&ge name:
label.text.receiver.type=Receiver &type:\u0020
label.text.target.file.name=Target file name:
label.text.to.file=To &file:
label.text.to.package=To p&ackage:
label.text.type=&Type:\u0020
label.text.update.package.directive=&Update package directive
label.text.visibility=&Visibility:\u0020
member.info.abstract.0=abstract {0}
member.info.companion.0=companion {0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Change signature is not applicable to dynamically invoked functions
message.do.not.show.for.local.variables.in.future=Do not show for local variables in future
message.text.return.type.cannot.be.resolved=Return type ''{0}'' cannot be resolved.\nContinue?
message.text.type.alias.0.is.never.used=Type alias ''{0}'' is never used
message.type.for.cannot.be.resolved=Type ''{0}'' for {1} cannot be resolved.\nContinue?
name.extract.interface=Extract Interface
name.inline.type.alias=Inline Type Alias
name.introduce.import.alias=Introduce Import Alias
name.introduce.lambda.parameter=Introduce Lambda Parameter
name.introduce.parameter1=Introduce Parameter
name.introduce.type.alias=Introduce Type Alias
name.kdoc.for.abstracts=KDoc for abstracts
naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename
non.kotlin.usage.0=Non-Kotlin usage: {0}
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
refactoring.move.non.kotlin.file=Target must be a Kotlin file
return.type.is.invalid=Return type is invalid
searching.usages.of.0.parameter=Searching usages of ''{0}''parameter
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
setter.of.0.will.become.invisible.after.extraction = Setter of {0} will become invisible after extraction
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' must be moved with sealed parent class and all its subclasses
text.0.already.contains.1={0} already contains {1}
text.0.already.contains.nested.class.1={0} already contains nested class named {1}
text.0.already.declared.in.1={0} is already declared in {1}
text.0.have.no.inheritors.warning={0} doesn''t have inheritors\nPushing members down will result in them being deleted. Would you like to proceed?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} in {1} will override corresponding member of {2} after refactoring
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} inherits from {1}.\nIt won''t be affected by the refactoring
text.0.is.invalid.destination.package=''{0}'' is invalid destination package name
text.0.is.not.allowed.in.the.target.context=''{0}'' is not allowed in the target context
text.0.is.not.valid.package.name={0} is not a valid package name
text.0.to.inline={0} to inline
text.0.uses.1.which.is.not.accessible.from.2={0} uses {1}, which is not accessible from the {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} uses {1} which will be inaccessible after move
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} uses {1} which won''t be accessible from the subclass.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} uses internal {1} which will be inaccessible after move
text.0.will.be.shadowed.by.1={0} will be shadowed by {1}
text.0.will.clash.with.existing.1.in.2={0} after rename will clash with existing {1} in {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} will no longer be accessible after signature change
text.all.declarations.must.belong.to.the.same.directory.or.class=All declarations must belong to the same directory or class
text.all=All
text.anonymous=[Anonymous]
text.at.least.one.file.must.be.selected=At least one member must be selected
text.callee.text.would.be.shown.here=Callee text would be shown here
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Caller text\nwith highlighted callee call would be shown here
text.cannot.create.target.directory.0=Cannot create target directory {0}
text.cannot.determine.source.directory=Can't determine sources directory
text.cannot.find.package.corresponding.to.0=Could not find package corresponding to {0}
text.cannot.find.target.package.name=Cannot find target package name
text.cannot.inline.0.1.usages=Cannot inline {0}/{1} usages
text.cannot.move.for.current.project=Can't move for current project
text.cannot.move.inner.class.0.into.itself=Cannot move nested class {0} to itself
text.cannot.move.to.original.file=Can't move to the original file
text.change.file.package.to.0=Change file''s package to ''{0}''
text.choose.containing.file=Choose Containing File
text.class.0.already.contains.member.1={0} already contains {1}
text.class.0.already.exists.in.package.1=Class {0} already exists in package {1}
text.class.0.already.exists.in.the.target.scope=Class {0} already exists in the target scope 
text.class.0.is.final={0} is final
text.constructor=constructor
text.convert._it_.to.explicit.lambda.parameter=Convert 'it' to explicit lambda parameter
text.create.destructuring.declaration=Create destructuring declaration
text.create.single.variable=Create single variable
text.declaration=declaration
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Following declarations would clash: to move {0} and destination {1} declared in scope {2}
text.default.value=\ // default value = {0}
text.destination.class.should.be.kotlin.class=Destination class must be a Kotlin class
text.do.you.want.to.rename.0.as.well=Do you want to rename {0}() as well?
text.do.you.want.to.rename.base.property.from.0=Do you want to rename base property from \n{0}
text.do.you.want.to.rename.base.property=Do you want to rename base property
text.duplicating.local.variable=Duplicating local variable ''{0}''
text.duplicating.parameter=Duplicating parameter ''{0}''
text.duplicating.property=Duplicating property ''{0}''
text.explicit.receiver.is.already.present.in.call.element.0=Explicit receiver is already present in call element: {0}
text.extract.superclass=Extract Superclass
text.file.0.already.exists.in.1=File {0} already exists in {1}
text.file.name.cannot.be.empty=File name may not be empty
text.function.already.exists=Function already exists: ''{0}''
text.function.in.ticks.0=function ''{0}''
text.function=function
text.implicit.companion.object.will.be.inaccessible.0=Implicit companion object will be inaccessible: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Incorrect target path. Directory {0} does not belong to current project.
text.indirect.outer.instances.will.not.be.extracted.0=Indirect outer instances won''t be extracted: {0}
text.inline.0.1.2=Inline {0} ''{1}''? {2}
text.inline.0=Inline {0}
text.inline.all.references.and.0.the.1=Inline all references and {0} the kind {1}
text.inline.recursive.function.is.supported.only.on.references=Inline recursive function is supported only on references
text.inline.this.reference.and.keep.the.0=Inline this reference and keep the {0}
text.inlining.0.1=Inlining {0} {1}
text.inner.class.0.cannot.be.moved.to.intefrace={0} is an inner class. It can not be moved to the interface
text.introduce.default.value=Intro&duce default value
text.invalid.target.path.0=Invalid target path {0}
text.invalid.target.specified=Invalid target specified
text.keep=keep
text.lambda.parameter=lambda parameter
text.lambda.parameters=Lambda &parameters:\u0020
text.lambda.return.type=Lambda return &type
text.lazy.property=lazy property
text.local.property=property
text.local.variable=local variable
text.looking.for.usages=Looking for Usages
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} in super class would clash with existing member of {1}
text.member.extension.call.will.not.be.processed.0=Member extension call won''t be processed: {0}
text.move.declaration.no.support.for.companion.objects=Move declaration is not supported for companion objects
text.move.declaration.no.support.for.enums=Move declaration is not supported for enum entries
text.move.declaration.supports.only.top.levels.and.nested.classes=Move declaration is only supported for top-level declarations and nested classes
text.move.declarations=Move declarations
text.move.file.0=Move {0}
text.move.refactoring.not.available.during.indexing=Move refactoring is not available while indexing is in progress
text.moving.multiple.nested.classes.to.top.level.not.supported=Moving multiple nested classes to top-level is not supported
text.name=Name
text.nested.classes.to.upper.level=Nested Classes to Upper Level
text.no.elements.to.move.are.selected=No elements to move are selected
text.no.files.to.move=There is no given files to move
text.no.name.provided.for.type.alias=No name provided for type alias
text.no.package.corresponds.to.directory=No package corresponds to this directory
text.non.kotlin.0.will.not.be.affected.by.refactoring=Non-Kotlin {0} won''t be affected by the refactoring
text.overload=Overload
text.package.directive.dont.match.file.location=Package directive doesn't match file location
text.parameter.0=parameter ''{0}''
text.parameter.name=Parameter &name:\u0020
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Parameter reference can''t be safely replaced with {0} since {1} is ambiguous in this context
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Parameter reference can''t be safely replaced with {0} since target function can''t be referenced in this context
text.parameter.type=Parameter &type:\u0020
text.parameter=Parameter
text.parameters=&Parameters
text.proceed.with.extraction=Proceed with extraction
text.process.duplicates=Process Duplicates
text.processing.file.0=Processing {0}
text.property.in.ticks.0=property ''{0}''
text.property.with.getter=property with getter
text.property.with.initializer=property with initializer
text.property=property
text.pushed.member.will.not.be.available.in.0=Pushed member won''t be available in ''{0}''
text.qualified.call.will.not.be.processed.0=Qualified call won''t be processed: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=Receiver can''t be safely transformed to value argument: {0}
text.receiver=receiver
text.refactoring.can.t.be.performed.on.the.selected.code.element=Refactoring can't be performed on the selected code element
text.refactoring.is.not.applicable.to.this.code.fragment=Refactoring is not applicable to this code fragment
text.references.in.code.to.0.1.and.its.declarations=References in code to {0} {1} and its declarations
text.remove.0.no.longer.used=Remove {0} no longer used
text.remove=remove
text.rename.as.part.of.phrase=rename
text.rename.is.not.applicable.to.secondary.constructors=Rename is not applicable to secondary constructors
text.rename.is.not.applicable.to.synthetic.declarations=Rename is not applicable to synthetic declaration
text.rename.not.applicable.to.backing.field.reference=Rename is not applicable to backing field reference
text.rename.not.applicable.to.dynamically.invoked.methods=Rename is not applicable to dynamically invoked members
text.rename.overloads.title=Rename Overloads
text.rename.overloads.to=Rename overloads to:
text.rename.parameters.in.hierarchy.to=Rename parameter in hierarchy to:
text.rename.parameters.title=Rename Parameters
text.rename.warning=Rename warning
text.sealed.class.0.must.be.moved.with.all.its.subclasses=Sealed class ''{0}'' must be moved with all its subclasses
text.select.target.code.block.file=Select target code block / file
text.select.target.code.block=Select target code block
text.select.target.file=Select target file
text.the.following=The following
text.there.is.already.a.parameter=There is already a parameter ''{0}'' in {1}. It will conflict with the new parameter.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=There is already a variable ''{0}'' in {1}. It will conflict with the new parameter.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Type alias cannot refer to types which aren't accessible in the scope where it's defined
text.type.alias.name.must.be.a.valid.identifier.0=Type alias name must be a valid identifier: {0}
text.type.alias=type alias
text.type.already.exists.in.the.target.scope=Type {0} already exists in the target scope
text.type.parameter.names.must.be.distinct=Type parameter names must be distinct
text.type.parameters=Type &Parameters
text.type=Type
text.unexpected.element.type.0=Unexpected element type: {0}
text.update.usages.to.reflect.declaration.0.move=Update usages to reflect {0, choice, 0#declaration|1#declarations} move
text.updating.usages.progress=Updating usages...
text.variable=variable
title.change.signature=Change Signature
title.inline.function=Inline Function
title.introduce.parameter.to.declaration=Introduce parameter to declaration
title.move.nested.classes.to.upper.level=Move Nested Classes to Upper Level
title.select.target.code.block=Select target code block
unsupported.usage.0=Unsupported usage: {0}

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=Do you want to delete this parameter in expected declaration and all related actual ones?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=Do you want to delete expected declaration together with all related actual ones?
delete.with.usage.search=delete (with usage search)

destination.not.found.for.package.0=Destination not found for package ''{0}''
leave.in.same.source.root=Leave in same source root
test.root.is.selected.while.the.source.root.is.expected=Test root is selected while the source root is expected
source.root.is.selected.while.the.test.root.is.expected=Source root is selected while the test root is expected