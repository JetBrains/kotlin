/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */
@file:Suppress("DEPRECATION", "DEPRECATION_ERROR", "REDUNDANT_CALL_OF_CONVERSION_METHOD")

package org.jetbrains.kotlin.resolve.constants.evaluate

import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType.*
import java.math.BigInteger

/** This file is generated by `./gradlew generateOperationsMap`. DO NOT MODIFY MANUALLY */

fun evalUnaryOp(name: String, type: CompileTimeType, value: Any): Any? {
    when (type) {
        BOOLEAN -> when (name) {
            "not" -> return (value as Boolean).not()
            "toString" -> return (value as Boolean).toString()
        }
        BYTE -> when (name) {
            "toByte" -> return (value as Byte).toByte()
            "toChar" -> return (value as Byte).toChar()
            "toDouble" -> return (value as Byte).toDouble()
            "toFloat" -> return (value as Byte).toFloat()
            "toInt" -> return (value as Byte).toInt()
            "toLong" -> return (value as Byte).toLong()
            "toShort" -> return (value as Byte).toShort()
            "toString" -> return (value as Byte).toString()
            "unaryMinus" -> return (value as Byte).unaryMinus()
            "unaryPlus" -> return (value as Byte).unaryPlus()
            "toULong" -> return (value as Byte).toULong()
            "toUInt" -> return (value as Byte).toUInt()
            "toUShort" -> return (value as Byte).toUShort()
            "toUByte" -> return (value as Byte).toUByte()
        }
        CHAR -> when (name) {
            "toByte" -> return (value as Char).toByte()
            "toChar" -> return (value as Char).toChar()
            "toDouble" -> return (value as Char).toDouble()
            "toFloat" -> return (value as Char).toFloat()
            "toInt" -> return (value as Char).toInt()
            "toLong" -> return (value as Char).toLong()
            "toShort" -> return (value as Char).toShort()
            "toString" -> return (value as Char).toString()
            "code" -> return (value as Char).code
        }
        DOUBLE -> when (name) {
            "toByte" -> return (value as Double).toByte()
            "toChar" -> return (value as Double).toChar()
            "toDouble" -> return (value as Double).toDouble()
            "toFloat" -> return (value as Double).toFloat()
            "toInt" -> return (value as Double).toInt()
            "toLong" -> return (value as Double).toLong()
            "toShort" -> return (value as Double).toShort()
            "toString" -> return (value as Double).toString()
            "unaryMinus" -> return (value as Double).unaryMinus()
            "unaryPlus" -> return (value as Double).unaryPlus()
            "toULong" -> return (value as Double).toULong()
            "toUInt" -> return (value as Double).toUInt()
        }
        FLOAT -> when (name) {
            "toByte" -> return (value as Float).toByte()
            "toChar" -> return (value as Float).toChar()
            "toDouble" -> return (value as Float).toDouble()
            "toFloat" -> return (value as Float).toFloat()
            "toInt" -> return (value as Float).toInt()
            "toLong" -> return (value as Float).toLong()
            "toShort" -> return (value as Float).toShort()
            "toString" -> return (value as Float).toString()
            "unaryMinus" -> return (value as Float).unaryMinus()
            "unaryPlus" -> return (value as Float).unaryPlus()
            "toULong" -> return (value as Float).toULong()
            "toUInt" -> return (value as Float).toUInt()
        }
        INT -> when (name) {
            "inv" -> return (value as Int).inv()
            "toByte" -> return (value as Int).toByte()
            "toChar" -> return (value as Int).toChar()
            "toDouble" -> return (value as Int).toDouble()
            "toFloat" -> return (value as Int).toFloat()
            "toInt" -> return (value as Int).toInt()
            "toLong" -> return (value as Int).toLong()
            "toShort" -> return (value as Int).toShort()
            "toString" -> return (value as Int).toString()
            "unaryMinus" -> return (value as Int).unaryMinus()
            "unaryPlus" -> return (value as Int).unaryPlus()
            "toULong" -> return (value as Int).toULong()
            "toUInt" -> return (value as Int).toUInt()
            "toUShort" -> return (value as Int).toUShort()
            "toUByte" -> return (value as Int).toUByte()
        }
        LONG -> when (name) {
            "inv" -> return (value as Long).inv()
            "toByte" -> return (value as Long).toByte()
            "toChar" -> return (value as Long).toChar()
            "toDouble" -> return (value as Long).toDouble()
            "toFloat" -> return (value as Long).toFloat()
            "toInt" -> return (value as Long).toInt()
            "toLong" -> return (value as Long).toLong()
            "toShort" -> return (value as Long).toShort()
            "toString" -> return (value as Long).toString()
            "unaryMinus" -> return (value as Long).unaryMinus()
            "unaryPlus" -> return (value as Long).unaryPlus()
            "toULong" -> return (value as Long).toULong()
            "toUInt" -> return (value as Long).toUInt()
            "toUShort" -> return (value as Long).toUShort()
            "toUByte" -> return (value as Long).toUByte()
        }
        SHORT -> when (name) {
            "toByte" -> return (value as Short).toByte()
            "toChar" -> return (value as Short).toChar()
            "toDouble" -> return (value as Short).toDouble()
            "toFloat" -> return (value as Short).toFloat()
            "toInt" -> return (value as Short).toInt()
            "toLong" -> return (value as Short).toLong()
            "toShort" -> return (value as Short).toShort()
            "toString" -> return (value as Short).toString()
            "unaryMinus" -> return (value as Short).unaryMinus()
            "unaryPlus" -> return (value as Short).unaryPlus()
            "toULong" -> return (value as Short).toULong()
            "toUInt" -> return (value as Short).toUInt()
            "toUShort" -> return (value as Short).toUShort()
            "toUByte" -> return (value as Short).toUByte()
        }
        STRING -> when (name) {
            "length" -> return (value as String).length
            "toString" -> return (value as String).toString()
        }
        UINT -> when (name) {
            "inv" -> return (value as UInt).inv()
            "toByte" -> return (value as UInt).toByte()
            "toDouble" -> return (value as UInt).toDouble()
            "toFloat" -> return (value as UInt).toFloat()
            "toInt" -> return (value as UInt).toInt()
            "toLong" -> return (value as UInt).toLong()
            "toShort" -> return (value as UInt).toShort()
            "toString" -> return (value as UInt).toString()
            "toUByte" -> return (value as UInt).toUByte()
            "toUInt" -> return (value as UInt).toUInt()
            "toULong" -> return (value as UInt).toULong()
            "toUShort" -> return (value as UInt).toUShort()
        }
        ULONG -> when (name) {
            "inv" -> return (value as ULong).inv()
            "toByte" -> return (value as ULong).toByte()
            "toDouble" -> return (value as ULong).toDouble()
            "toFloat" -> return (value as ULong).toFloat()
            "toInt" -> return (value as ULong).toInt()
            "toLong" -> return (value as ULong).toLong()
            "toShort" -> return (value as ULong).toShort()
            "toString" -> return (value as ULong).toString()
            "toUByte" -> return (value as ULong).toUByte()
            "toUInt" -> return (value as ULong).toUInt()
            "toULong" -> return (value as ULong).toULong()
            "toUShort" -> return (value as ULong).toUShort()
        }
        UBYTE -> when (name) {
            "inv" -> return (value as UByte).inv()
            "toByte" -> return (value as UByte).toByte()
            "toDouble" -> return (value as UByte).toDouble()
            "toFloat" -> return (value as UByte).toFloat()
            "toInt" -> return (value as UByte).toInt()
            "toLong" -> return (value as UByte).toLong()
            "toShort" -> return (value as UByte).toShort()
            "toString" -> return (value as UByte).toString()
            "toUByte" -> return (value as UByte).toUByte()
            "toUInt" -> return (value as UByte).toUInt()
            "toULong" -> return (value as UByte).toULong()
            "toUShort" -> return (value as UByte).toUShort()
        }
        USHORT -> when (name) {
            "inv" -> return (value as UShort).inv()
            "toByte" -> return (value as UShort).toByte()
            "toDouble" -> return (value as UShort).toDouble()
            "toFloat" -> return (value as UShort).toFloat()
            "toInt" -> return (value as UShort).toInt()
            "toLong" -> return (value as UShort).toLong()
            "toShort" -> return (value as UShort).toShort()
            "toString" -> return (value as UShort).toString()
            "toUByte" -> return (value as UShort).toUByte()
            "toUInt" -> return (value as UShort).toUInt()
            "toULong" -> return (value as UShort).toULong()
            "toUShort" -> return (value as UShort).toUShort()
        }
        else -> {}
    }
    return null
}

fun evalBinaryOp(name: String, leftType: CompileTimeType, left: Any, rightType: CompileTimeType, right: Any): Any? {
    when (leftType) {
        BOOLEAN -> when (rightType) {
            BOOLEAN -> when (name) {
                "and" -> return (left as Boolean).and(right as Boolean)
                "compareTo" -> return (left as Boolean).compareTo(right as Boolean)
                "or" -> return (left as Boolean).or(right as Boolean)
                "xor" -> return (left as Boolean).xor(right as Boolean)
            }
            ANY -> when (name) {
                "equals" -> return (left as Boolean).equals(right)
            }
            else -> {}
        }
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Byte)
                "div" -> return (left as Byte).div(right as Byte)
                "minus" -> return (left as Byte).minus(right as Byte)
                "plus" -> return (left as Byte).plus(right as Byte)
                "rem" -> return (left as Byte).rem(right as Byte)
                "times" -> return (left as Byte).times(right as Byte)
                "mod" -> return (left as Byte).mod(right as Byte)
                "floorDiv" -> return (left as Byte).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Short)
                "div" -> return (left as Byte).div(right as Short)
                "minus" -> return (left as Byte).minus(right as Short)
                "plus" -> return (left as Byte).plus(right as Short)
                "rem" -> return (left as Byte).rem(right as Short)
                "times" -> return (left as Byte).times(right as Short)
                "mod" -> return (left as Byte).mod(right as Short)
                "floorDiv" -> return (left as Byte).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Int)
                "div" -> return (left as Byte).div(right as Int)
                "minus" -> return (left as Byte).minus(right as Int)
                "plus" -> return (left as Byte).plus(right as Int)
                "rem" -> return (left as Byte).rem(right as Int)
                "times" -> return (left as Byte).times(right as Int)
                "mod" -> return (left as Byte).mod(right as Int)
                "floorDiv" -> return (left as Byte).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Long)
                "div" -> return (left as Byte).div(right as Long)
                "minus" -> return (left as Byte).minus(right as Long)
                "plus" -> return (left as Byte).plus(right as Long)
                "rem" -> return (left as Byte).rem(right as Long)
                "times" -> return (left as Byte).times(right as Long)
                "mod" -> return (left as Byte).mod(right as Long)
                "floorDiv" -> return (left as Byte).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Float)
                "div" -> return (left as Byte).div(right as Float)
                "minus" -> return (left as Byte).minus(right as Float)
                "plus" -> return (left as Byte).plus(right as Float)
                "rem" -> return (left as Byte).rem(right as Float)
                "times" -> return (left as Byte).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Double)
                "div" -> return (left as Byte).div(right as Double)
                "minus" -> return (left as Byte).minus(right as Double)
                "plus" -> return (left as Byte).plus(right as Double)
                "rem" -> return (left as Byte).rem(right as Double)
                "times" -> return (left as Byte).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Byte).equals(right)
            }
            else -> {}
        }
        CHAR -> when (rightType) {
            CHAR -> when (name) {
                "compareTo" -> return (left as Char).compareTo(right as Char)
                "minus" -> return (left as Char).minus(right as Char)
            }
            ANY -> when (name) {
                "equals" -> return (left as Char).equals(right)
            }
            INT -> when (name) {
                "minus" -> return (left as Char).minus(right as Int)
                "plus" -> return (left as Char).plus(right as Int)
            }
            else -> {}
        }
        DOUBLE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Byte)
                "div" -> return (left as Double).div(right as Byte)
                "minus" -> return (left as Double).minus(right as Byte)
                "plus" -> return (left as Double).plus(right as Byte)
                "rem" -> return (left as Double).rem(right as Byte)
                "times" -> return (left as Double).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Short)
                "div" -> return (left as Double).div(right as Short)
                "minus" -> return (left as Double).minus(right as Short)
                "plus" -> return (left as Double).plus(right as Short)
                "rem" -> return (left as Double).rem(right as Short)
                "times" -> return (left as Double).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Int)
                "div" -> return (left as Double).div(right as Int)
                "minus" -> return (left as Double).minus(right as Int)
                "plus" -> return (left as Double).plus(right as Int)
                "rem" -> return (left as Double).rem(right as Int)
                "times" -> return (left as Double).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Long)
                "div" -> return (left as Double).div(right as Long)
                "minus" -> return (left as Double).minus(right as Long)
                "plus" -> return (left as Double).plus(right as Long)
                "rem" -> return (left as Double).rem(right as Long)
                "times" -> return (left as Double).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Float)
                "div" -> return (left as Double).div(right as Float)
                "minus" -> return (left as Double).minus(right as Float)
                "plus" -> return (left as Double).plus(right as Float)
                "rem" -> return (left as Double).rem(right as Float)
                "times" -> return (left as Double).times(right as Float)
                "mod" -> return (left as Double).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Double)
                "div" -> return (left as Double).div(right as Double)
                "minus" -> return (left as Double).minus(right as Double)
                "plus" -> return (left as Double).plus(right as Double)
                "rem" -> return (left as Double).rem(right as Double)
                "times" -> return (left as Double).times(right as Double)
                "mod" -> return (left as Double).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Double).equals(right)
            }
            else -> {}
        }
        FLOAT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Byte)
                "div" -> return (left as Float).div(right as Byte)
                "minus" -> return (left as Float).minus(right as Byte)
                "plus" -> return (left as Float).plus(right as Byte)
                "rem" -> return (left as Float).rem(right as Byte)
                "times" -> return (left as Float).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Short)
                "div" -> return (left as Float).div(right as Short)
                "minus" -> return (left as Float).minus(right as Short)
                "plus" -> return (left as Float).plus(right as Short)
                "rem" -> return (left as Float).rem(right as Short)
                "times" -> return (left as Float).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Int)
                "div" -> return (left as Float).div(right as Int)
                "minus" -> return (left as Float).minus(right as Int)
                "plus" -> return (left as Float).plus(right as Int)
                "rem" -> return (left as Float).rem(right as Int)
                "times" -> return (left as Float).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Long)
                "div" -> return (left as Float).div(right as Long)
                "minus" -> return (left as Float).minus(right as Long)
                "plus" -> return (left as Float).plus(right as Long)
                "rem" -> return (left as Float).rem(right as Long)
                "times" -> return (left as Float).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Float)
                "div" -> return (left as Float).div(right as Float)
                "minus" -> return (left as Float).minus(right as Float)
                "plus" -> return (left as Float).plus(right as Float)
                "rem" -> return (left as Float).rem(right as Float)
                "times" -> return (left as Float).times(right as Float)
                "mod" -> return (left as Float).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Double)
                "div" -> return (left as Float).div(right as Double)
                "minus" -> return (left as Float).minus(right as Double)
                "plus" -> return (left as Float).plus(right as Double)
                "rem" -> return (left as Float).rem(right as Double)
                "times" -> return (left as Float).times(right as Double)
                "mod" -> return (left as Float).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Float).equals(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return (left as Int).and(right as Int)
                "compareTo" -> return (left as Int).compareTo(right as Int)
                "div" -> return (left as Int).div(right as Int)
                "minus" -> return (left as Int).minus(right as Int)
                "or" -> return (left as Int).or(right as Int)
                "plus" -> return (left as Int).plus(right as Int)
                "rem" -> return (left as Int).rem(right as Int)
                "shl" -> return (left as Int).shl(right as Int)
                "shr" -> return (left as Int).shr(right as Int)
                "times" -> return (left as Int).times(right as Int)
                "ushr" -> return (left as Int).ushr(right as Int)
                "xor" -> return (left as Int).xor(right as Int)
                "mod" -> return (left as Int).mod(right as Int)
                "floorDiv" -> return (left as Int).floorDiv(right as Int)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Byte)
                "div" -> return (left as Int).div(right as Byte)
                "minus" -> return (left as Int).minus(right as Byte)
                "plus" -> return (left as Int).plus(right as Byte)
                "rem" -> return (left as Int).rem(right as Byte)
                "times" -> return (left as Int).times(right as Byte)
                "mod" -> return (left as Int).mod(right as Byte)
                "floorDiv" -> return (left as Int).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Short)
                "div" -> return (left as Int).div(right as Short)
                "minus" -> return (left as Int).minus(right as Short)
                "plus" -> return (left as Int).plus(right as Short)
                "rem" -> return (left as Int).rem(right as Short)
                "times" -> return (left as Int).times(right as Short)
                "mod" -> return (left as Int).mod(right as Short)
                "floorDiv" -> return (left as Int).floorDiv(right as Short)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Long)
                "div" -> return (left as Int).div(right as Long)
                "minus" -> return (left as Int).minus(right as Long)
                "plus" -> return (left as Int).plus(right as Long)
                "rem" -> return (left as Int).rem(right as Long)
                "times" -> return (left as Int).times(right as Long)
                "mod" -> return (left as Int).mod(right as Long)
                "floorDiv" -> return (left as Int).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Float)
                "div" -> return (left as Int).div(right as Float)
                "minus" -> return (left as Int).minus(right as Float)
                "plus" -> return (left as Int).plus(right as Float)
                "rem" -> return (left as Int).rem(right as Float)
                "times" -> return (left as Int).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Double)
                "div" -> return (left as Int).div(right as Double)
                "minus" -> return (left as Int).minus(right as Double)
                "plus" -> return (left as Int).plus(right as Double)
                "rem" -> return (left as Int).rem(right as Double)
                "times" -> return (left as Int).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Int).equals(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return (left as Long).and(right as Long)
                "compareTo" -> return (left as Long).compareTo(right as Long)
                "div" -> return (left as Long).div(right as Long)
                "minus" -> return (left as Long).minus(right as Long)
                "or" -> return (left as Long).or(right as Long)
                "plus" -> return (left as Long).plus(right as Long)
                "rem" -> return (left as Long).rem(right as Long)
                "times" -> return (left as Long).times(right as Long)
                "xor" -> return (left as Long).xor(right as Long)
                "mod" -> return (left as Long).mod(right as Long)
                "floorDiv" -> return (left as Long).floorDiv(right as Long)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Byte)
                "div" -> return (left as Long).div(right as Byte)
                "minus" -> return (left as Long).minus(right as Byte)
                "plus" -> return (left as Long).plus(right as Byte)
                "rem" -> return (left as Long).rem(right as Byte)
                "times" -> return (left as Long).times(right as Byte)
                "mod" -> return (left as Long).mod(right as Byte)
                "floorDiv" -> return (left as Long).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Short)
                "div" -> return (left as Long).div(right as Short)
                "minus" -> return (left as Long).minus(right as Short)
                "plus" -> return (left as Long).plus(right as Short)
                "rem" -> return (left as Long).rem(right as Short)
                "times" -> return (left as Long).times(right as Short)
                "mod" -> return (left as Long).mod(right as Short)
                "floorDiv" -> return (left as Long).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Int)
                "div" -> return (left as Long).div(right as Int)
                "minus" -> return (left as Long).minus(right as Int)
                "plus" -> return (left as Long).plus(right as Int)
                "rem" -> return (left as Long).rem(right as Int)
                "shl" -> return (left as Long).shl(right as Int)
                "shr" -> return (left as Long).shr(right as Int)
                "times" -> return (left as Long).times(right as Int)
                "ushr" -> return (left as Long).ushr(right as Int)
                "mod" -> return (left as Long).mod(right as Int)
                "floorDiv" -> return (left as Long).floorDiv(right as Int)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Float)
                "div" -> return (left as Long).div(right as Float)
                "minus" -> return (left as Long).minus(right as Float)
                "plus" -> return (left as Long).plus(right as Float)
                "rem" -> return (left as Long).rem(right as Float)
                "times" -> return (left as Long).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Double)
                "div" -> return (left as Long).div(right as Double)
                "minus" -> return (left as Long).minus(right as Double)
                "plus" -> return (left as Long).plus(right as Double)
                "rem" -> return (left as Long).rem(right as Double)
                "times" -> return (left as Long).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Long).equals(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Byte)
                "div" -> return (left as Short).div(right as Byte)
                "minus" -> return (left as Short).minus(right as Byte)
                "plus" -> return (left as Short).plus(right as Byte)
                "rem" -> return (left as Short).rem(right as Byte)
                "times" -> return (left as Short).times(right as Byte)
                "mod" -> return (left as Short).mod(right as Byte)
                "floorDiv" -> return (left as Short).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Short)
                "div" -> return (left as Short).div(right as Short)
                "minus" -> return (left as Short).minus(right as Short)
                "plus" -> return (left as Short).plus(right as Short)
                "rem" -> return (left as Short).rem(right as Short)
                "times" -> return (left as Short).times(right as Short)
                "mod" -> return (left as Short).mod(right as Short)
                "floorDiv" -> return (left as Short).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Int)
                "div" -> return (left as Short).div(right as Int)
                "minus" -> return (left as Short).minus(right as Int)
                "plus" -> return (left as Short).plus(right as Int)
                "rem" -> return (left as Short).rem(right as Int)
                "times" -> return (left as Short).times(right as Int)
                "mod" -> return (left as Short).mod(right as Int)
                "floorDiv" -> return (left as Short).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Long)
                "div" -> return (left as Short).div(right as Long)
                "minus" -> return (left as Short).minus(right as Long)
                "plus" -> return (left as Short).plus(right as Long)
                "rem" -> return (left as Short).rem(right as Long)
                "times" -> return (left as Short).times(right as Long)
                "mod" -> return (left as Short).mod(right as Long)
                "floorDiv" -> return (left as Short).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Float)
                "div" -> return (left as Short).div(right as Float)
                "minus" -> return (left as Short).minus(right as Float)
                "plus" -> return (left as Short).plus(right as Float)
                "rem" -> return (left as Short).rem(right as Float)
                "times" -> return (left as Short).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Double)
                "div" -> return (left as Short).div(right as Double)
                "minus" -> return (left as Short).minus(right as Double)
                "plus" -> return (left as Short).plus(right as Double)
                "rem" -> return (left as Short).rem(right as Double)
                "times" -> return (left as Short).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Short).equals(right)
            }
            else -> {}
        }
        STRING -> when (rightType) {
            STRING -> when (name) {
                "compareTo" -> return (left as String).compareTo(right as String)
            }
            ANY -> when (name) {
                "equals" -> return (left as String).equals(right)
                "plus" -> return (left as String).plus(right)
            }
            INT -> when (name) {
                "get" -> return (left as String).get(right as Int)
            }
            else -> {}
        }
        UINT -> when (rightType) {
            UINT -> when (name) {
                "and" -> return (left as UInt).and(right as UInt)
                "compareTo" -> return (left as UInt).compareTo(right as UInt)
                "div" -> return (left as UInt).div(right as UInt)
                "floorDiv" -> return (left as UInt).floorDiv(right as UInt)
                "minus" -> return (left as UInt).minus(right as UInt)
                "mod" -> return (left as UInt).mod(right as UInt)
                "or" -> return (left as UInt).or(right as UInt)
                "plus" -> return (left as UInt).plus(right as UInt)
                "rem" -> return (left as UInt).rem(right as UInt)
                "times" -> return (left as UInt).times(right as UInt)
                "xor" -> return (left as UInt).xor(right as UInt)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UByte)
                "div" -> return (left as UInt).div(right as UByte)
                "floorDiv" -> return (left as UInt).floorDiv(right as UByte)
                "minus" -> return (left as UInt).minus(right as UByte)
                "mod" -> return (left as UInt).mod(right as UByte)
                "plus" -> return (left as UInt).plus(right as UByte)
                "rem" -> return (left as UInt).rem(right as UByte)
                "times" -> return (left as UInt).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UShort)
                "div" -> return (left as UInt).div(right as UShort)
                "floorDiv" -> return (left as UInt).floorDiv(right as UShort)
                "minus" -> return (left as UInt).minus(right as UShort)
                "mod" -> return (left as UInt).mod(right as UShort)
                "plus" -> return (left as UInt).plus(right as UShort)
                "rem" -> return (left as UInt).rem(right as UShort)
                "times" -> return (left as UInt).times(right as UShort)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as ULong)
                "div" -> return (left as UInt).div(right as ULong)
                "floorDiv" -> return (left as UInt).floorDiv(right as ULong)
                "minus" -> return (left as UInt).minus(right as ULong)
                "mod" -> return (left as UInt).mod(right as ULong)
                "plus" -> return (left as UInt).plus(right as ULong)
                "rem" -> return (left as UInt).rem(right as ULong)
                "times" -> return (left as UInt).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UInt).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as UInt).shl(right as Int)
                "shr" -> return (left as UInt).shr(right as Int)
            }
            else -> {}
        }
        ULONG -> when (rightType) {
            ULONG -> when (name) {
                "and" -> return (left as ULong).and(right as ULong)
                "compareTo" -> return (left as ULong).compareTo(right as ULong)
                "div" -> return (left as ULong).div(right as ULong)
                "floorDiv" -> return (left as ULong).floorDiv(right as ULong)
                "minus" -> return (left as ULong).minus(right as ULong)
                "mod" -> return (left as ULong).mod(right as ULong)
                "or" -> return (left as ULong).or(right as ULong)
                "plus" -> return (left as ULong).plus(right as ULong)
                "rem" -> return (left as ULong).rem(right as ULong)
                "times" -> return (left as ULong).times(right as ULong)
                "xor" -> return (left as ULong).xor(right as ULong)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UByte)
                "div" -> return (left as ULong).div(right as UByte)
                "floorDiv" -> return (left as ULong).floorDiv(right as UByte)
                "minus" -> return (left as ULong).minus(right as UByte)
                "mod" -> return (left as ULong).mod(right as UByte)
                "plus" -> return (left as ULong).plus(right as UByte)
                "rem" -> return (left as ULong).rem(right as UByte)
                "times" -> return (left as ULong).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UShort)
                "div" -> return (left as ULong).div(right as UShort)
                "floorDiv" -> return (left as ULong).floorDiv(right as UShort)
                "minus" -> return (left as ULong).minus(right as UShort)
                "mod" -> return (left as ULong).mod(right as UShort)
                "plus" -> return (left as ULong).plus(right as UShort)
                "rem" -> return (left as ULong).rem(right as UShort)
                "times" -> return (left as ULong).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UInt)
                "div" -> return (left as ULong).div(right as UInt)
                "floorDiv" -> return (left as ULong).floorDiv(right as UInt)
                "minus" -> return (left as ULong).minus(right as UInt)
                "mod" -> return (left as ULong).mod(right as UInt)
                "plus" -> return (left as ULong).plus(right as UInt)
                "rem" -> return (left as ULong).rem(right as UInt)
                "times" -> return (left as ULong).times(right as UInt)
            }
            ANY -> when (name) {
                "equals" -> return (left as ULong).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as ULong).shl(right as Int)
                "shr" -> return (left as ULong).shr(right as Int)
            }
            else -> {}
        }
        UBYTE -> when (rightType) {
            UBYTE -> when (name) {
                "and" -> return (left as UByte).and(right as UByte)
                "compareTo" -> return (left as UByte).compareTo(right as UByte)
                "div" -> return (left as UByte).div(right as UByte)
                "floorDiv" -> return (left as UByte).floorDiv(right as UByte)
                "minus" -> return (left as UByte).minus(right as UByte)
                "mod" -> return (left as UByte).mod(right as UByte)
                "or" -> return (left as UByte).or(right as UByte)
                "plus" -> return (left as UByte).plus(right as UByte)
                "rem" -> return (left as UByte).rem(right as UByte)
                "times" -> return (left as UByte).times(right as UByte)
                "xor" -> return (left as UByte).xor(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UShort)
                "div" -> return (left as UByte).div(right as UShort)
                "floorDiv" -> return (left as UByte).floorDiv(right as UShort)
                "minus" -> return (left as UByte).minus(right as UShort)
                "mod" -> return (left as UByte).mod(right as UShort)
                "plus" -> return (left as UByte).plus(right as UShort)
                "rem" -> return (left as UByte).rem(right as UShort)
                "times" -> return (left as UByte).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UInt)
                "div" -> return (left as UByte).div(right as UInt)
                "floorDiv" -> return (left as UByte).floorDiv(right as UInt)
                "minus" -> return (left as UByte).minus(right as UInt)
                "mod" -> return (left as UByte).mod(right as UInt)
                "plus" -> return (left as UByte).plus(right as UInt)
                "rem" -> return (left as UByte).rem(right as UInt)
                "times" -> return (left as UByte).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as ULong)
                "div" -> return (left as UByte).div(right as ULong)
                "floorDiv" -> return (left as UByte).floorDiv(right as ULong)
                "minus" -> return (left as UByte).minus(right as ULong)
                "mod" -> return (left as UByte).mod(right as ULong)
                "plus" -> return (left as UByte).plus(right as ULong)
                "rem" -> return (left as UByte).rem(right as ULong)
                "times" -> return (left as UByte).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UByte).equals(right)
            }
            else -> {}
        }
        USHORT -> when (rightType) {
            USHORT -> when (name) {
                "and" -> return (left as UShort).and(right as UShort)
                "compareTo" -> return (left as UShort).compareTo(right as UShort)
                "div" -> return (left as UShort).div(right as UShort)
                "floorDiv" -> return (left as UShort).floorDiv(right as UShort)
                "minus" -> return (left as UShort).minus(right as UShort)
                "mod" -> return (left as UShort).mod(right as UShort)
                "or" -> return (left as UShort).or(right as UShort)
                "plus" -> return (left as UShort).plus(right as UShort)
                "rem" -> return (left as UShort).rem(right as UShort)
                "times" -> return (left as UShort).times(right as UShort)
                "xor" -> return (left as UShort).xor(right as UShort)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UByte)
                "div" -> return (left as UShort).div(right as UByte)
                "floorDiv" -> return (left as UShort).floorDiv(right as UByte)
                "minus" -> return (left as UShort).minus(right as UByte)
                "mod" -> return (left as UShort).mod(right as UByte)
                "plus" -> return (left as UShort).plus(right as UByte)
                "rem" -> return (left as UShort).rem(right as UByte)
                "times" -> return (left as UShort).times(right as UByte)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UInt)
                "div" -> return (left as UShort).div(right as UInt)
                "floorDiv" -> return (left as UShort).floorDiv(right as UInt)
                "minus" -> return (left as UShort).minus(right as UInt)
                "mod" -> return (left as UShort).mod(right as UInt)
                "plus" -> return (left as UShort).plus(right as UInt)
                "rem" -> return (left as UShort).rem(right as UInt)
                "times" -> return (left as UShort).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as ULong)
                "div" -> return (left as UShort).div(right as ULong)
                "floorDiv" -> return (left as UShort).floorDiv(right as ULong)
                "minus" -> return (left as UShort).minus(right as ULong)
                "mod" -> return (left as UShort).mod(right as ULong)
                "plus" -> return (left as UShort).plus(right as ULong)
                "rem" -> return (left as UShort).rem(right as ULong)
                "times" -> return (left as UShort).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UShort).equals(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}

fun checkBinaryOp(
    name: String, leftType: CompileTimeType, left: BigInteger, rightType: CompileTimeType, right: BigInteger
): BigInteger? {
    when (leftType) {
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}
private val knownOps = mapOf(
    "kotlin/Boolean.not" to listOf(listOf(BOOLEAN)),
    "kotlin/Boolean.toString" to listOf(listOf(BOOLEAN)),
    "kotlin/Byte.toByte" to listOf(listOf(BYTE)),
    "kotlin/Byte.toChar" to listOf(listOf(BYTE)),
    "kotlin/Byte.toDouble" to listOf(listOf(BYTE)),
    "kotlin/Byte.toFloat" to listOf(listOf(BYTE)),
    "kotlin/Byte.toInt" to listOf(listOf(BYTE)),
    "kotlin/Byte.toLong" to listOf(listOf(BYTE)),
    "kotlin/Byte.toShort" to listOf(listOf(BYTE)),
    "kotlin/Byte.toString" to listOf(listOf(BYTE)),
    "kotlin/Byte.unaryMinus" to listOf(listOf(BYTE)),
    "kotlin/Byte.unaryPlus" to listOf(listOf(BYTE)),
    "kotlin/Char.toByte" to listOf(listOf(CHAR)),
    "kotlin/Char.toChar" to listOf(listOf(CHAR)),
    "kotlin/Char.toDouble" to listOf(listOf(CHAR)),
    "kotlin/Char.toFloat" to listOf(listOf(CHAR)),
    "kotlin/Char.toInt" to listOf(listOf(CHAR)),
    "kotlin/Char.toLong" to listOf(listOf(CHAR)),
    "kotlin/Char.toShort" to listOf(listOf(CHAR)),
    "kotlin/Char.toString" to listOf(listOf(CHAR)),
    "kotlin/Double.toByte" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toChar" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toDouble" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toFloat" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toInt" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toLong" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toShort" to listOf(listOf(DOUBLE)),
    "kotlin/Double.toString" to listOf(listOf(DOUBLE)),
    "kotlin/Double.unaryMinus" to listOf(listOf(DOUBLE)),
    "kotlin/Double.unaryPlus" to listOf(listOf(DOUBLE)),
    "kotlin/Float.toByte" to listOf(listOf(FLOAT)),
    "kotlin/Float.toChar" to listOf(listOf(FLOAT)),
    "kotlin/Float.toDouble" to listOf(listOf(FLOAT)),
    "kotlin/Float.toFloat" to listOf(listOf(FLOAT)),
    "kotlin/Float.toInt" to listOf(listOf(FLOAT)),
    "kotlin/Float.toLong" to listOf(listOf(FLOAT)),
    "kotlin/Float.toShort" to listOf(listOf(FLOAT)),
    "kotlin/Float.toString" to listOf(listOf(FLOAT)),
    "kotlin/Float.unaryMinus" to listOf(listOf(FLOAT)),
    "kotlin/Float.unaryPlus" to listOf(listOf(FLOAT)),
    "kotlin/Int.inv" to listOf(listOf(INT)),
    "kotlin/Int.toByte" to listOf(listOf(INT)),
    "kotlin/Int.toChar" to listOf(listOf(INT)),
    "kotlin/Int.toDouble" to listOf(listOf(INT)),
    "kotlin/Int.toFloat" to listOf(listOf(INT)),
    "kotlin/Int.toInt" to listOf(listOf(INT)),
    "kotlin/Int.toLong" to listOf(listOf(INT)),
    "kotlin/Int.toShort" to listOf(listOf(INT)),
    "kotlin/Int.toString" to listOf(listOf(INT)),
    "kotlin/Int.unaryMinus" to listOf(listOf(INT)),
    "kotlin/Int.unaryPlus" to listOf(listOf(INT)),
    "kotlin/Long.inv" to listOf(listOf(LONG)),
    "kotlin/Long.toByte" to listOf(listOf(LONG)),
    "kotlin/Long.toChar" to listOf(listOf(LONG)),
    "kotlin/Long.toDouble" to listOf(listOf(LONG)),
    "kotlin/Long.toFloat" to listOf(listOf(LONG)),
    "kotlin/Long.toInt" to listOf(listOf(LONG)),
    "kotlin/Long.toLong" to listOf(listOf(LONG)),
    "kotlin/Long.toShort" to listOf(listOf(LONG)),
    "kotlin/Long.toString" to listOf(listOf(LONG)),
    "kotlin/Long.unaryMinus" to listOf(listOf(LONG)),
    "kotlin/Long.unaryPlus" to listOf(listOf(LONG)),
    "kotlin/Short.toByte" to listOf(listOf(SHORT)),
    "kotlin/Short.toChar" to listOf(listOf(SHORT)),
    "kotlin/Short.toDouble" to listOf(listOf(SHORT)),
    "kotlin/Short.toFloat" to listOf(listOf(SHORT)),
    "kotlin/Short.toInt" to listOf(listOf(SHORT)),
    "kotlin/Short.toLong" to listOf(listOf(SHORT)),
    "kotlin/Short.toShort" to listOf(listOf(SHORT)),
    "kotlin/Short.toString" to listOf(listOf(SHORT)),
    "kotlin/Short.unaryMinus" to listOf(listOf(SHORT)),
    "kotlin/Short.unaryPlus" to listOf(listOf(SHORT)),
    "kotlin/String.length" to listOf(listOf(STRING)),
    "kotlin/String.toString" to listOf(listOf(STRING)),
    "kotlin/Char.code" to listOf(listOf(CHAR)),
    "kotlin/UInt.inv" to listOf(listOf(UINT)),
    "kotlin/UInt.toByte" to listOf(listOf(UINT)),
    "kotlin/UInt.toDouble" to listOf(listOf(UINT)),
    "kotlin/UInt.toFloat" to listOf(listOf(UINT)),
    "kotlin/UInt.toInt" to listOf(listOf(UINT)),
    "kotlin/UInt.toLong" to listOf(listOf(UINT)),
    "kotlin/UInt.toShort" to listOf(listOf(UINT)),
    "kotlin/UInt.toString" to listOf(listOf(UINT)),
    "kotlin/UInt.toUByte" to listOf(listOf(UINT)),
    "kotlin/UInt.toUInt" to listOf(listOf(UINT),listOf(LONG),listOf(INT),listOf(SHORT),listOf(BYTE),listOf(DOUBLE),listOf(FLOAT)),
    "kotlin/UInt.toULong" to listOf(listOf(UINT)),
    "kotlin/UInt.toUShort" to listOf(listOf(UINT)),
    "kotlin/ULong.inv" to listOf(listOf(ULONG)),
    "kotlin/ULong.toByte" to listOf(listOf(ULONG)),
    "kotlin/ULong.toDouble" to listOf(listOf(ULONG)),
    "kotlin/ULong.toFloat" to listOf(listOf(ULONG)),
    "kotlin/ULong.toInt" to listOf(listOf(ULONG)),
    "kotlin/ULong.toLong" to listOf(listOf(ULONG)),
    "kotlin/ULong.toShort" to listOf(listOf(ULONG)),
    "kotlin/ULong.toString" to listOf(listOf(ULONG)),
    "kotlin/ULong.toUByte" to listOf(listOf(ULONG)),
    "kotlin/ULong.toUInt" to listOf(listOf(ULONG)),
    "kotlin/ULong.toULong" to listOf(listOf(ULONG),listOf(LONG),listOf(INT),listOf(SHORT),listOf(BYTE),listOf(DOUBLE),listOf(FLOAT)),
    "kotlin/ULong.toUShort" to listOf(listOf(ULONG)),
    "kotlin/UByte.inv" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toByte" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toDouble" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toFloat" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toInt" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toLong" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toShort" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toString" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toUByte" to listOf(listOf(UBYTE),listOf(LONG),listOf(INT),listOf(SHORT),listOf(BYTE)),
    "kotlin/UByte.toUInt" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toULong" to listOf(listOf(UBYTE)),
    "kotlin/UByte.toUShort" to listOf(listOf(UBYTE)),
    "kotlin/UShort.inv" to listOf(listOf(USHORT)),
    "kotlin/UShort.toByte" to listOf(listOf(USHORT)),
    "kotlin/UShort.toDouble" to listOf(listOf(USHORT)),
    "kotlin/UShort.toFloat" to listOf(listOf(USHORT)),
    "kotlin/UShort.toInt" to listOf(listOf(USHORT)),
    "kotlin/UShort.toLong" to listOf(listOf(USHORT)),
    "kotlin/UShort.toShort" to listOf(listOf(USHORT)),
    "kotlin/UShort.toString" to listOf(listOf(USHORT)),
    "kotlin/UShort.toUByte" to listOf(listOf(USHORT)),
    "kotlin/UShort.toUInt" to listOf(listOf(USHORT)),
    "kotlin/UShort.toULong" to listOf(listOf(USHORT)),
    "kotlin/UShort.toUShort" to listOf(listOf(USHORT),listOf(LONG),listOf(INT),listOf(SHORT),listOf(BYTE)),
    "kotlin/Boolean.and" to listOf(listOf(BOOLEAN, BOOLEAN)),
    "kotlin/Boolean.compareTo" to listOf(listOf(BOOLEAN, BOOLEAN)),
    "kotlin/Boolean.equals" to listOf(listOf(BOOLEAN, ANY)),
    "kotlin/Boolean.or" to listOf(listOf(BOOLEAN, BOOLEAN)),
    "kotlin/Boolean.xor" to listOf(listOf(BOOLEAN, BOOLEAN)),
    "kotlin/Byte.compareTo" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Byte.div" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Byte.equals" to listOf(listOf(BYTE, ANY)),
    "kotlin/Byte.minus" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Byte.plus" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Byte.rem" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Byte.times" to listOf(listOf(BYTE, BYTE),listOf(BYTE, SHORT),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, FLOAT),listOf(BYTE, DOUBLE)),
    "kotlin/Char.compareTo" to listOf(listOf(CHAR, CHAR)),
    "kotlin/Char.equals" to listOf(listOf(CHAR, ANY)),
    "kotlin/Char.minus" to listOf(listOf(CHAR, CHAR),listOf(CHAR, INT)),
    "kotlin/Char.plus" to listOf(listOf(CHAR, INT)),
    "kotlin/Double.compareTo" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Double.div" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Double.equals" to listOf(listOf(DOUBLE, ANY)),
    "kotlin/Double.minus" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Double.plus" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Double.rem" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Double.times" to listOf(listOf(DOUBLE, BYTE),listOf(DOUBLE, SHORT),listOf(DOUBLE, INT),listOf(DOUBLE, LONG),listOf(DOUBLE, FLOAT),listOf(DOUBLE, DOUBLE)),
    "kotlin/Float.compareTo" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Float.div" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Float.equals" to listOf(listOf(FLOAT, ANY)),
    "kotlin/Float.minus" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Float.plus" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Float.rem" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Float.times" to listOf(listOf(FLOAT, BYTE),listOf(FLOAT, SHORT),listOf(FLOAT, INT),listOf(FLOAT, LONG),listOf(FLOAT, FLOAT),listOf(FLOAT, DOUBLE)),
    "kotlin/Int.and" to listOf(listOf(INT, INT)),
    "kotlin/Int.compareTo" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.div" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.equals" to listOf(listOf(INT, ANY)),
    "kotlin/Int.minus" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.or" to listOf(listOf(INT, INT)),
    "kotlin/Int.plus" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.rem" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.shl" to listOf(listOf(INT, INT)),
    "kotlin/Int.shr" to listOf(listOf(INT, INT)),
    "kotlin/Int.times" to listOf(listOf(INT, BYTE),listOf(INT, SHORT),listOf(INT, INT),listOf(INT, LONG),listOf(INT, FLOAT),listOf(INT, DOUBLE)),
    "kotlin/Int.ushr" to listOf(listOf(INT, INT)),
    "kotlin/Int.xor" to listOf(listOf(INT, INT)),
    "kotlin/Long.and" to listOf(listOf(LONG, LONG)),
    "kotlin/Long.compareTo" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.div" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.equals" to listOf(listOf(LONG, ANY)),
    "kotlin/Long.minus" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.or" to listOf(listOf(LONG, LONG)),
    "kotlin/Long.plus" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.rem" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.shl" to listOf(listOf(LONG, INT)),
    "kotlin/Long.shr" to listOf(listOf(LONG, INT)),
    "kotlin/Long.times" to listOf(listOf(LONG, BYTE),listOf(LONG, SHORT),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, FLOAT),listOf(LONG, DOUBLE)),
    "kotlin/Long.ushr" to listOf(listOf(LONG, INT)),
    "kotlin/Long.xor" to listOf(listOf(LONG, LONG)),
    "kotlin/Short.compareTo" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/Short.div" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/Short.equals" to listOf(listOf(SHORT, ANY)),
    "kotlin/Short.minus" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/Short.plus" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/Short.rem" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/Short.times" to listOf(listOf(SHORT, BYTE),listOf(SHORT, SHORT),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, FLOAT),listOf(SHORT, DOUBLE)),
    "kotlin/String.compareTo" to listOf(listOf(STRING, STRING)),
    "kotlin/String.equals" to listOf(listOf(STRING, ANY)),
    "kotlin/String.get" to listOf(listOf(STRING, INT)),
    "kotlin/String.plus" to listOf(listOf(STRING, ANY)),
    "kotlin/mod" to listOf(listOf(BYTE, BYTE),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, SHORT),listOf(INT, BYTE),listOf(INT, INT),listOf(INT, LONG),listOf(INT, SHORT),listOf(LONG, BYTE),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, SHORT),listOf(SHORT, BYTE),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, SHORT)),
    "kotlin/floorDiv" to listOf(listOf(BYTE, BYTE),listOf(BYTE, INT),listOf(BYTE, LONG),listOf(BYTE, SHORT),listOf(INT, BYTE),listOf(INT, INT),listOf(INT, LONG),listOf(INT, SHORT),listOf(LONG, BYTE),listOf(LONG, INT),listOf(LONG, LONG),listOf(LONG, SHORT),listOf(SHORT, BYTE),listOf(SHORT, INT),listOf(SHORT, LONG),listOf(SHORT, SHORT)),
    "kotlin/Double.mod" to listOf(listOf(DOUBLE, DOUBLE),listOf(DOUBLE, FLOAT)),
    "kotlin/Float.mod" to listOf(listOf(FLOAT, DOUBLE),listOf(FLOAT, FLOAT)),
    "kotlin/UInt.and" to listOf(listOf(UINT, UINT)),
    "kotlin/UInt.compareTo" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.div" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.equals" to listOf(listOf(UINT, ANY)),
    "kotlin/UInt.floorDiv" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.minus" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.mod" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.or" to listOf(listOf(UINT, UINT)),
    "kotlin/UInt.plus" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.rem" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.shl" to listOf(listOf(UINT, INT)),
    "kotlin/UInt.shr" to listOf(listOf(UINT, INT)),
    "kotlin/UInt.times" to listOf(listOf(UINT, UBYTE),listOf(UINT, USHORT),listOf(UINT, UINT),listOf(UINT, ULONG)),
    "kotlin/UInt.xor" to listOf(listOf(UINT, UINT)),
    "kotlin/ULong.and" to listOf(listOf(ULONG, ULONG)),
    "kotlin/ULong.compareTo" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.div" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.equals" to listOf(listOf(ULONG, ANY)),
    "kotlin/ULong.floorDiv" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.minus" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.mod" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.or" to listOf(listOf(ULONG, ULONG)),
    "kotlin/ULong.plus" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.rem" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.shl" to listOf(listOf(ULONG, INT)),
    "kotlin/ULong.shr" to listOf(listOf(ULONG, INT)),
    "kotlin/ULong.times" to listOf(listOf(ULONG, UBYTE),listOf(ULONG, USHORT),listOf(ULONG, UINT),listOf(ULONG, ULONG)),
    "kotlin/ULong.xor" to listOf(listOf(ULONG, ULONG)),
    "kotlin/UByte.and" to listOf(listOf(UBYTE, UBYTE)),
    "kotlin/UByte.compareTo" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.div" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.equals" to listOf(listOf(UBYTE, ANY)),
    "kotlin/UByte.floorDiv" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.minus" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.mod" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.or" to listOf(listOf(UBYTE, UBYTE)),
    "kotlin/UByte.plus" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.rem" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.times" to listOf(listOf(UBYTE, UBYTE),listOf(UBYTE, USHORT),listOf(UBYTE, UINT),listOf(UBYTE, ULONG)),
    "kotlin/UByte.xor" to listOf(listOf(UBYTE, UBYTE)),
    "kotlin/UShort.and" to listOf(listOf(USHORT, USHORT)),
    "kotlin/UShort.compareTo" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.div" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.equals" to listOf(listOf(USHORT, ANY)),
    "kotlin/UShort.floorDiv" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.minus" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.mod" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.or" to listOf(listOf(USHORT, USHORT)),
    "kotlin/UShort.plus" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.rem" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.times" to listOf(listOf(USHORT, UBYTE),listOf(USHORT, USHORT),listOf(USHORT, UINT),listOf(USHORT, ULONG)),
    "kotlin/UShort.xor" to listOf(listOf(USHORT, USHORT)),
)
fun canEvalOp(callableId: CallableId, typeA: CompileTimeType, typeB: CompileTimeType?): Boolean {
    return knownOps[callableId.toString()]?.any { it.first() == typeA && it.getOrNull(1) == typeB } ?: false
}
