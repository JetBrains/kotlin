FILE: indirectLowerBound.kt
    public final fun <K> select(vararg k: R|kotlin/Array<out K>|): R|K| {
        ^select R|<local>/k|.R|SubstitutionOverride<kotlin/Array.get: R|CapturedType(out K)|>|(Int(0))
    }
    public final fun <I> id(i: R|I|): R|I| {
        ^id R|<local>/i|
    }
    public final fun cond(): R|kotlin/Boolean| {
        ^cond Boolean(true)
    }
    public final fun test(): R|kotlin/Unit| {
        R|/select<Inapplicable(INAPPLICABLE): /select>#|<R|kotlin/collections/Set<kotlin/String>|>(vararg(R|/id|<R|kotlin/collections/Set<kotlin/String>|>(Q|kotlin/collections|.R|kotlin/collections/setOf|<R|kotlin/Int|>(Int(42))), R|kotlin/collections/setOf|<R|kotlin/String|>()))
        R|/select|<R|kotlin/collections/Set<kotlin/String>|>(vararg(R|/id|<R|kotlin/collections/Set<kotlin/String>|>(Q|kotlin/collections|.R|kotlin/collections/setOf|<R|kotlin/String|>()), R|kotlin/collections/setOf|<R|kotlin/String|>()))
        R|/select<CS errors: /select>#|<<ERROR TYPE REF: Cannot infer argument for type parameter K>>(vararg(R|/id|<<ERROR TYPE REF: Cannot infer argument for type parameter I>>(<collectionLiteralCall>(Int(42))), R|kotlin/collections/setOf|<<ERROR TYPE REF: Cannot infer argument for type parameter T>>()))
    }
    public final fun testWithRun(): R|kotlin/Unit| {
        lval exp: R|kotlin/collections/Set<kotlin/String>| = when () {
            R|/cond|() ->  {
                R|kotlin/run|<R|kotlin/collections/Set<kotlin/String>|>(<L> = run@fun <anonymous>(): R|kotlin/collections/Set<kotlin/String>| <inline=Inline, kind=EXACTLY_ONCE>  {
                    ^ Q|kotlin/collections|.R|kotlin/collections/setOf|<R|kotlin/Int|>(Int(42))
                }
                )
            }
            else ->  {
                R|kotlin/collections/setOf|<R|kotlin/String|>()
            }
        }

    }
