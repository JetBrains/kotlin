/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.jetbrains.kotlin.NativeFullCrossDistKt
import org.jetbrains.kotlin.konan.target.*
import org.jetbrains.kotlin.CopySamples
import org.jetbrains.kotlin.PlatformInfo
import org.jetbrains.kotlin.cpp.CompilationDatabasePlugin
import org.jetbrains.kotlin.cpp.GitClangFormatPlugin
import org.jetbrains.kotlin.CompareDistributionSignatures
import org.jetbrains.kotlin.nativeDistribution.NativeDistributionKt
import org.jetbrains.kotlin.xcode.XcodeOverridePlugin
import org.jetbrains.kotlin.UtilsKt
import plugins.KotlinBuildPublishingPluginKt
import java.security.MessageDigest

buildscript {

    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    dependencies {
        classpath libs.shadow.gradlePlugin
    }
}

defaultTasks 'clean', 'dist'

apply plugin: XcodeOverridePlugin

if (PlatformInfo.isMac()) {
    PlatformInfo.checkXcodeVersion(project)
}

apply plugin: "kotlin.native.build-tools-conventions"
apply plugin: "platform-manager"
apply plugin: "java"

allprojects {
    repositories {
        mavenCentral()
        maven {
            url project.bootstrapKotlinRepo
        }
    }
}

def platformManager = project.extensions.platformManager
def targetList = EnabledTargetsKt.enabledTargets(platformManager).collect { it.visibleName } as List
def nativeDistribution = NativeDistributionKt.getNativeDistribution(project)

configurations {
    commonSources
}

apply plugin: CompilationDatabasePlugin

dependencies {
    commonSources project(path: ':kotlin-stdlib', configuration: 'metadataSourcesElements')
    commonSources project(path: ':kotlin-test', configuration: 'metadataSourcesElements')
    compilationDatabase project(":kotlin-native:runtime")

    // declared to be included in verification-metadata.xml
    implicitDependencies("org.jetbrains.kotlin:kotlin-native-prebuilt:$bootstrapKotlinVersion:macos-aarch64@tar.gz")
    implicitDependencies("org.jetbrains.kotlin:kotlin-native-prebuilt:$bootstrapKotlinVersion:macos-x86_64@tar.gz")
    implicitDependencies("org.jetbrains.kotlin:kotlin-native-prebuilt:$bootstrapKotlinVersion:linux-x86_64@tar.gz")
    implicitDependencies("org.jetbrains.kotlin:kotlin-native-prebuilt:$bootstrapKotlinVersion:windows-x86_64@zip")
}

apply plugin: GitClangFormatPlugin
apply plugin: 'maven-publish'
apply plugin: BasePlugin

// TODO: Remove this
tasks.named("build") {
    dependsOn ":kotlin-native:prepare:kotlin-native-distribution:dist"
    dependsOn ":kotlin-native:prepare:kotlin-native-distribution:distPlatformLibs"
}

tasks.register("distNativeSources", Zip) {
    dependsOn(configurations.commonSources)
    duplicatesStrategy = DuplicatesStrategy.FAIL
    destinationDirectory = nativeDistribution.map { it.sources }
    archiveFileName = nativeDistribution.map { it.stdlibSources.asFile.name }

    includeEmptyDirs = false
    include('**/*.kt')

    from {
        configurations.commonSources
                .collect { zipTree(it) }
                .inject { t1, t2 -> t1 + t2 }
    }
    into('nativeWasmMain') {
        from(project(":kotlin-stdlib").file('native-wasm/src/'))
    }
    into('nativeMain') {
        from(project(':kotlin-native:runtime').file('src/main/kotlin'))
        from(project(':kotlin-native:Interop:Runtime').file('src/main/kotlin'))
        from(project(':kotlin-native:Interop:Runtime').file('src/native/kotlin'))
    }
}

tasks.register("distSources") {
    dependsOn(distNativeSources)
}

// TODO: Remove this
tasks.register("distCompiler") {
    dependsOn(":kotlin-native:prepare:kotlin-native-distribution:distCompiler")
}

// TODO: Remove this
tasks.register("crossDistPlatformLibs") {
    dependsOn(":kotlin-native:prepare:kotlin-native-distribution:crossDistPlatformLibs")
}

targetList.each { target ->
    // TODO: Remove this
    tasks.register("${target}PlatformLibs") {
        dependsOn ":kotlin-native:prepare:kotlin-native-distribution:distPlatformLibs${target.capitalize()}"
    }

    // TODO: Remove this
    tasks.register("${target}CrossDist") {
        dependsOn ":kotlin-native:prepare:kotlin-native-distribution:crossDist${target.capitalize()}"
    }
}

// TODO: Remove this
tasks.register("distPlatformLibs") {
    dependsOn(":kotlin-native:prepare:kotlin-native-distribution:distPlatformLibs")
}

// TODO: Make this a custom task
tasks.register("dist") {
    dependsOn ":kotlin-native:prepare:kotlin-native-distribution:dist"
}

// TODO: Remove this
tasks.register("crossDist") {
    dependsOn ":kotlin-native:prepare:kotlin-native-distribution:crossDist"
}

tasks.register("bundle") {
    dependsOn 'bundleRegular', 'bundlePrebuilt'
}

def sbomBundleRegular = SbomKt.configureSbom(project, "BundleRegular", "Kotlin/Native bundle", [].toSet(), null)

def sbomBundleRegularForPublish = tasks.register("sbomBundleRegularForPublish", Copy) {
    dependsOn(sbomBundleRegular)
    destinationDir = file("$buildDir/spdx/regular")
    from(sbomBundleRegular) {
        rename(".*", "kotlin-native-${HostManager.platformName()}-${kotlinVersion}.spdx.json")
    }
}

tasks.register("bundleRegular", (PlatformInfo.isWindows()) ? Zip : Tar) {
    dependsOn(sbomBundleRegularForPublish)
    def simpleOsName = HostManager.platformName()
    archiveBaseName.set("kotlin-native-$simpleOsName")
    archiveVersion.set(kotlinVersion)
    from(nativeDistribution.map { it.root }) {
        include '**'
        exclude 'dependencies'
        exclude 'klib/testLibrary'
        // Don't include platform libraries into the bundle (generate them at the user side instead).
        exclude 'klib/platform'
        // Exclude platform libraries caches too. Keep caches for stdlib.
        exclude 'klib/cache/*/org.jetbrains.kotlin.native.platform.*/**'
        into "${archiveBaseName.get()}-${archiveVersion.get()}"
    }
}

def sbomBundlePrebuilt = SbomKt.configureSbom(project,
        "BundlePrebuilt", "Kotlin/Native bundle (prebuilt platform libs)", [].toSet(), null)

def sbomBundlePrebuiltForPublish = tasks.register("sbomBundlePrebuiltForPublish", Copy) {
    dependsOn(sbomBundlePrebuilt)
    destinationDir = file("$buildDir/spdx/prebuilt")
    from(sbomBundlePrebuilt) {
        rename(".*", "kotlin-native-prebuilt-${HostManager.platformName()}-${kotlinVersion}.spdx.json")
    }
}

def mergeCrossBundleTask = NativeFullCrossDistKt.setupMergeCrossBundleTask(project)

tasks.register("bundlePrebuilt", (PlatformInfo.isWindows()) ? Zip : Tar) {
    dependsOn(sbomBundlePrebuiltForPublish)
    if (mergeCrossBundleTask == null)
        dependsOn(":kotlin-native:prepare:kotlin-native-distribution:crossDistPlatformLibs")
    else
        dependsOn(mergeCrossBundleTask)

    def simpleOsName = HostManager.platformName()
    archiveBaseName.set("kotlin-native-prebuilt-$simpleOsName")
    archiveVersion.set(kotlinVersion)
    from(nativeDistribution.map { it.root }) {
        include '**'
        exclude 'dependencies'
        exclude 'klib/testLibrary'
        into "${archiveBaseName.get()}-${archiveVersion.get()}"
    }
}

void configurePackingLicensesToBundle(AbstractArchiveTask task, boolean containsPlatformLibraries, boolean crossBundleEnabled) {
    task.from(project.projectDir) {
        include 'licenses/**'
        def hasXcodeLibraries = PlatformInfo.isMac() || crossBundleEnabled
        if (!containsPlatformLibraries || !hasXcodeLibraries) {
            exclude '**/xcode_license.pdf'
        }
        if (!containsPlatformLibraries) {
            exclude '**/mingw-w64-headers_LICENSE.txt'
        }
        into "${task.archiveBaseName.get()}-${task.archiveVersion.get()}"
    }

    task.from(project.rootProject.file("license")) {
        into "${task.archiveBaseName.get()}-${task.archiveVersion.get()}/licenses"
    }
}

tasks.named("bundleRegular").configure {
    configurePackingLicensesToBundle(
            it,
            /* containsPlatformLibraries = */ false,
            /* crossBundleEnabled = */ mergeCrossBundleTask != null
    )
}
tasks.named("bundlePrebuilt").configure {
    configurePackingLicensesToBundle(
            it,
            /* containsPlatformLibraries = */ true,
            /* crossBundleEnabled = */ mergeCrossBundleTask != null
    )
}

configure([bundleRegular, bundlePrebuilt]) {
    if (mergeCrossBundleTask == null) {
        dependsOn(":kotlin-native:prepare:kotlin-native-distribution:crossDist")
        dependsOn("distSources")
    } else {
        dependsOn(mergeCrossBundleTask)
    }

    destinationDirectory.set(file('.'))

    if (PlatformInfo.isWindows()) {
        zip64 true
    } else {
        archiveExtension.set('tar.gz')
        compression = Compression.GZIP
    }

    // Calculating SHA-256 checksums for bundle artifacts
    def archiveExtension = PlatformInfo.isWindows() ? 'zip' : 'tar.gz'
    def checksumFile = archiveBaseName.zip(archiveVersion) { name, version -> file("${buildDir}/${name}-${version}.${archiveExtension}.sha256") }
    outputs.file(checksumFile).withPropertyName("checksumFile")

    // If `bundleRegular`/`bundlePrebuilt` tasks are executed with CC enabled, you will get a
    // "Couldn't find method 'calculateChecksum' ... " error. This most likely happens due to bug/issue on Gradle side, somewhere around
    // capturing mechanisms in doLast-lambda and CC's serialization/deserialization mechanism.
    //
    // Issue can be workarounded by converting this file to build.gradle.kts, but it's quite an invasive change, and there's no strict
    // need for it. Indeed, normally you can't use `bundleRegular/`bundlePrebuilt` tasks with CC because they depend transitively on
    // `KonanCompileLibraryTask` / `KonanCacheTask` (transitively via `crossDist`), which are inherently not compatible with CC
    //
    // Q: If `bundle*`-tasks depend on CC-incompatible tasks anyways, why we need this explicit call?
    // A: When we're building a cross-dist on CI, we don't depend on 'crossDist' and other tasks, but just reuse the dist built in this
    // build chain, via `mergeCrossBundleTask`. In such case, there won't be any CC-incompatible tasks in execution plan, and by default,
    // Gradle will try using CC, leading to aforementioned "Couldn't find method"-issue. To avoid that, we additionally mark `bundle*`
    // tasks as notCompatibleWithConfigurationCache.
    notCompatibleWithConfigurationCache("Groovy script evaluation issue workaround")

    doLast {
        File bundleFile = archiveFile.get().asFile
        if (bundleFile.exists()) {
            String checksum = calculateChecksum(bundleFile, "SHA-256")
            checksumFile.get().write(checksum)
        }
    }
}

def calculateChecksum(File file, String algorithm) {
    MessageDigest digest = MessageDigest.getInstance(algorithm)
    FileInputStream fis = new FileInputStream(file)
    byte[] byteArray = new byte[1024]
    int bytesCount
    while ((bytesCount = fis.read(byteArray)) != -1) {
        digest.update(byteArray, 0, bytesCount)
    }
    fis.close()
    byte[] bytes = digest.digest()

    StringBuilder sb = new StringBuilder()
    for (byte aByte : bytes) {
        sb.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1))
    }
    return sb.toString()
}

tasks.register("samples") {
    dependsOn 'samplesZip', 'samplesTar'
}

tasks.register("samplesZip", Zip)
tasks.register("samplesTar", Tar) {
    archiveExtension = 'tar.gz'
    compression = Compression.GZIP
}

configure([samplesZip, samplesTar]) {
    archiveBaseName = "kotlin-native-samples-$kotlinVersion"
    destinationDirectory = projectDir
    into(archiveBaseName)

    from(file('samples')) {
        // Process properties files separately.
        exclude '**/gradle.properties'
    }

    from(project.projectDir) {
        include 'licenses/**'
    }

    from(file('samples')) {
        include '**/gradle.properties'
        filter {
            it.startsWith('org.jetbrains.kotlin.native.home=') || it.startsWith('# Use custom Kotlin/Native home:') ? null : it
        }
        filter(org.apache.tools.ant.filters.FixCrLfFilter, "eol": org.apache.tools.ant.filters.FixCrLfFilter.CrLf.newInstance("lf"))
    }

    // Exclude build artifacts.
    exclude '**/build'
    exclude '**/.gradle'
    exclude '**/.idea'
    exclude '**/*.kt.bc-build/'
}

tasks.register("copy_samples") {
    dependsOn 'copySamples'
}
tasks.register("copySamples", CopySamples) {
    destinationDir file('build/samples-under-test')
}

compilationDatabase {
    allTargets {}
}

// TODO: Replace with a more convenient user-facing task that can build for a specific target.
//       like compilationDatabase with optional argument --target.
tasks.register("compdb", Copy) {
    from compilationDatabase.hostTarget.task
    into layout.projectDirectory

    group = compilationDatabase.TASK_GROUP
    description = "Copy host compilation database to kotlin-native/"
}

targetList.each { targetName ->
    CompareDistributionSignatures.registerForPlatform(project, targetName)
}

CompareDistributionSignatures.registerForStdlib(project)

// FIXME: should be a part of Host/TargetManager
String platformName(KonanTarget target) {
    def result
    switch (target) {
        case KonanTarget.LINUX_X64:
            result ="linux-x86_64"
            break
        case KonanTarget.MACOS_X64:
            result = "macos-x86_64"
            break
        case KonanTarget.MACOS_ARM64:
            result = "macos-aarch64"
            break
        case KonanTarget.MINGW_X64:
            result = "windows-x86_64"
            break
        default:
            throw TargetSupportException("Unknown host target")
    }
    return result
}

Map<KonanTarget, File> createConfigurations(List<File> bundles) {
    def hostTargets = platformManager.enabledByHost.keySet()
    def result = hostTargets.collectEntries { target ->
        [ (target): bundles.find { it.name.contains(platformName(target)) }]
    }
    result.retainAll { it.value != null }
    def missingBundles = hostTargets - result.keySet()
    if (!missingBundles.isEmpty()) {
        println("Some of the archive bundles are missing for targets $missingBundles:")
        println(result)
        throw new IllegalArgumentException("Bundle archives are missing for $missingBundles")
    }
    result.each { target, file ->
        if (!file.name.contains(kotlinVersion)) {
            throw new IllegalArgumentException("Incorrect version specified for the publish: ${file.name}")
        }
    }
    return result
}

def bundlesLocationFiles = UtilsKt.getNativeBundlesLocation(project)
        .listFiles()
        .toList()

KotlinBuildPublishingPluginKt.configureDefaultPublishing(
        /* receiver = */        project,
        /* signingRequired = */ KotlinBuildPublishingPluginKt.getSignLibraryPublication(project)
)

tasks.named("clean", Delete) {
    dependsOn subprojects.collect { it.tasks.matching { it.name == "clean" } }
    it.delete(nativeDistribution.map { it.root })
    it.delete(layout.buildDirectory)
    it.delete(bundle.outputs.files)
    it.delete("${projectDir}/compile_commands.json")
    it.delete(rootProject.file("test.output").absolutePath) // Clean up after legacy test infrastructure
}

publishing {
    publications {
        def publishBundlesFromLocation = UtilsKt.getNativeBundlesLocation(project) != project.projectDir
        register("Bundle", MavenPublication) { mvn ->
            mvn.groupId = project.group.toString()
            mvn.artifactId = project.name
            mvn.version = kotlinVersion

            if (publishBundlesFromLocation) {
                def bundleArchives = bundlesLocationFiles
                        .findAll {
                            it.name.startsWith("kotlin-native")
                                    && !it.name.contains("prebuilt")
                                    && (it.name.endsWith("zip") || it.name.endsWith("tar.gz"))
                        }
                def bundleConfigs = createConfigurations(bundleArchives)
                bundleConfigs.forEach { target, file ->
                    def archiveExtension = (target.family == Family.MINGW) ? 'zip' : 'tar.gz'
                    mvn.artifact(file) {
                        classifier = platformName(target)
                        extension = archiveExtension
                    }
                    mvn.artifact("${UtilsKt.getNativeBundlesLocation(project)}/kotlin-native-${platformName(target)}-${kotlinVersion}.spdx.json") {
                        classifier = platformName(target)
                        extension = "spdx.json"
                    }
                }
            } else {
                mvn.artifact(bundleRegular) {
                    classifier = HostManager.platformName()
                    extension = (PlatformInfo.isWindows()) ? 'zip' : 'tar.gz'
                }
                mvn.artifact(sbomBundleRegular) {
                    classifier = HostManager.platformName()
                    extension = "spdx.json"
                }
            }

            KotlinBuildPublishingPluginKt.configureKotlinPomAttributes(
                    /* receiver = */  mvn,
                    /* project = */   project,
                    /* explicitDescription = */ "Kotlin/Native bundle",
                    /* packaging = */ "pom",
                    /* explicitName = */ null
            )
        }
        register("BundlePrebuilt", MavenPublication) { mvn ->
            mvn.groupId = project.group.toString()
            mvn.artifactId = project.name + "-prebuilt"
            mvn.version = kotlinVersion

            if (publishBundlesFromLocation) {
                def prebuiltBundleArchives = bundlesLocationFiles
                        .findAll {
                            it.name.startsWith("kotlin-native-prebuilt")
                                    && (it.name.endsWith("zip") || it.name.endsWith("tar.gz"))
                        }
                def bundlePrebuiltConfigs = createConfigurations(prebuiltBundleArchives)
                bundlePrebuiltConfigs.forEach { target, file ->
                    def archiveExtension = (target.family == Family.MINGW) ? 'zip' : 'tar.gz'
                    mvn.artifact(file) {
                        classifier = platformName(target)
                        extension = archiveExtension
                    }
                    mvn.artifact("${UtilsKt.getNativeBundlesLocation(project)}/kotlin-native-prebuilt-${platformName(target)}-${kotlinVersion}.spdx.json") {
                        classifier = platformName(target)
                        extension = "spdx.json"
                    }
                }
            } else {
                mvn.artifact(bundlePrebuilt) {
                    classifier = HostManager.platformName()
                    extension = (PlatformInfo.isWindows()) ? 'zip' : 'tar.gz'
                }
                mvn.artifact(sbomBundlePrebuilt) {
                    classifier = HostManager.platformName()
                    extension = "spdx.json"
                }
            }
            KotlinBuildPublishingPluginKt.configureKotlinPomAttributes(
                    /* receiver = */  mvn,
                    /* project = */   project,
                    /* explicitDescription = */ "Kotlin/Native bundle (prebuilt platform libs)",
                    /* packaging = */ "pom",
                    /* explicitName = */ null
            )
        }
    }
}
