package-fragment kotlin

public inline fun </*0*/ reified @kotlin.internal.PureReifiable T> arrayOf(/*0*/ vararg elements: T /*kotlin.Array<out T>*/): kotlin.Array<T>
public fun </*0*/ reified @kotlin.internal.PureReifiable T> arrayOfNulls(/*0*/ size: kotlin.Int): kotlin.Array<T?>
public fun booleanArrayOf(/*0*/ vararg elements: kotlin.Boolean /*kotlin.BooleanArray*/): kotlin.BooleanArray
public fun byteArrayOf(/*0*/ vararg elements: kotlin.Byte /*kotlin.ByteArray*/): kotlin.ByteArray
public fun charArrayOf(/*0*/ vararg elements: kotlin.Char /*kotlin.CharArray*/): kotlin.CharArray
public fun doubleArrayOf(/*0*/ vararg elements: kotlin.Double /*kotlin.DoubleArray*/): kotlin.DoubleArray
public inline fun </*0*/ reified @kotlin.internal.PureReifiable T> emptyArray(): kotlin.Array<T>
@kotlin.SinceKotlin(version = "1.1") public inline fun </*0*/ reified T : kotlin.Enum<T>> enumValueOf(/*0*/ name: kotlin.String): T
@kotlin.SinceKotlin(version = "1.1") public inline fun </*0*/ reified T : kotlin.Enum<T>> enumValues(): kotlin.Array<T>
public fun floatArrayOf(/*0*/ vararg elements: kotlin.Float /*kotlin.FloatArray*/): kotlin.FloatArray
public fun intArrayOf(/*0*/ vararg elements: kotlin.Int /*kotlin.IntArray*/): kotlin.IntArray
public fun longArrayOf(/*0*/ vararg elements: kotlin.Long /*kotlin.LongArray*/): kotlin.LongArray
public fun shortArrayOf(/*0*/ vararg elements: kotlin.Short /*kotlin.ShortArray*/): kotlin.ShortArray
public operator fun kotlin.String?.plus(/*0*/ other: kotlin.Any?): kotlin.String
public fun kotlin.Any?.toString(): kotlin.String

public interface Annotation {
}

public open class Any {
    /*primary*/ public constructor Any()
}

public final class Array</*0*/ T> : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    public constructor Array</*0*/ T>(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> T)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.Array<T>
    public final operator fun get(/*0*/ index: kotlin.Int): T
    public final operator fun iterator(): kotlin.collections.Iterator<T>
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: T): kotlin.Unit
}

public final class Boolean : kotlin.Comparable<kotlin.Boolean>, java.io.Serializable {
    /*primary*/ private constructor Boolean()
    public final infix fun and(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Boolean): kotlin.Int
    public final operator fun not(): kotlin.Boolean
    public final infix fun or(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public final infix fun xor(/*0*/ other: kotlin.Boolean): kotlin.Boolean

    @kotlin.SinceKotlin(version = "1.3") public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

public final class BooleanArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor BooleanArray(/*0*/ size: kotlin.Int)
    public constructor BooleanArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Boolean)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.BooleanArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Boolean
    public final operator fun iterator(): kotlin.collections.BooleanIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Boolean): kotlin.Unit
}

public final class Byte : kotlin.Number, kotlin.Comparable<kotlin.Byte>, java.io.Serializable {
    /*primary*/ private constructor Byte()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Byte
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Byte
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ranges.IntRange
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    @kotlin.Deprecated(message = "Direct conversion to Char is deprecated. Use toInt().toChar() or Char constructor instead.", replaceWith = kotlin.ReplaceWith(expression = "this.toInt().toChar()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Byte
            public final fun <get-MAX_VALUE>(): kotlin.Byte
        public const final val MIN_VALUE: kotlin.Byte
            public final fun <get-MIN_VALUE>(): kotlin.Byte
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class ByteArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor ByteArray(/*0*/ size: kotlin.Int)
    public constructor ByteArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Byte)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.ByteArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Byte
    public final operator fun iterator(): kotlin.collections.ByteIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Byte): kotlin.Unit
}

public final class Char : kotlin.Comparable<kotlin.Char>, java.io.Serializable {
    /*primary*/ private constructor Char()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final operator fun dec(): kotlin.Char
    public final operator fun inc(): kotlin.Char
    public final operator fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Char
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Char
    public final operator fun rangeTo(/*0*/ other: kotlin.Char): kotlin.ranges.CharRange
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code.toByte()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toByte(): kotlin.Byte
    public final fun toChar(): kotlin.Char
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code.toDouble()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toDouble(): kotlin.Double
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code.toFloat()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toFloat(): kotlin.Float
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toInt(): kotlin.Int
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code.toLong()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toLong(): kotlin.Long
    @kotlin.Deprecated(message = "Conversion of Char to Number is deprecated. Use Char.code property instead.", replaceWith = kotlin.ReplaceWith(expression = "this.code.toShort()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public final fun toShort(): kotlin.Short

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_HIGH_SURROGATE: kotlin.Char
            public final fun <get-MAX_HIGH_SURROGATE>(): kotlin.Char
        public const final val MAX_LOW_SURROGATE: kotlin.Char
            public final fun <get-MAX_LOW_SURROGATE>(): kotlin.Char
        public const final val MAX_SURROGATE: kotlin.Char
            public final fun <get-MAX_SURROGATE>(): kotlin.Char
        @kotlin.SinceKotlin(version = "1.3") public const final val MAX_VALUE: kotlin.Char
            public final fun <get-MAX_VALUE>(): kotlin.Char
        public const final val MIN_HIGH_SURROGATE: kotlin.Char
            public final fun <get-MIN_HIGH_SURROGATE>(): kotlin.Char
        public const final val MIN_LOW_SURROGATE: kotlin.Char
            public final fun <get-MIN_LOW_SURROGATE>(): kotlin.Char
        public const final val MIN_SURROGATE: kotlin.Char
            public final fun <get-MIN_SURROGATE>(): kotlin.Char
        @kotlin.SinceKotlin(version = "1.3") public const final val MIN_VALUE: kotlin.Char
            public final fun <get-MIN_VALUE>(): kotlin.Char
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class CharArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor CharArray(/*0*/ size: kotlin.Int)
    public constructor CharArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Char)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.CharArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final operator fun iterator(): kotlin.collections.CharIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Char): kotlin.Unit
}

public interface CharSequence {
    public abstract val length: kotlin.Int
        public abstract fun <get-length>(): kotlin.Int
    public abstract operator fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public abstract fun subSequence(/*0*/ startIndex: kotlin.Int, /*1*/ endIndex: kotlin.Int): kotlin.CharSequence
}

public interface Cloneable {
    protected open fun clone(): kotlin.Any
}

public interface Comparable</*0*/ in T> {
    public abstract operator fun compareTo(/*0*/ other: T): kotlin.Int
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.MustBeDocumented public final annotation class ContextFunctionTypeParams : kotlin.Annotation {
    /*primary*/ public constructor ContextFunctionTypeParams(/*0*/ count: kotlin.Int)
    public final val count: kotlin.Int
        public final fun <get-count>(): kotlin.Int
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.TYPEALIAS}) @kotlin.annotation.MustBeDocumented public final annotation class Deprecated : kotlin.Annotation {
    /*primary*/ public constructor Deprecated(/*0*/ message: kotlin.String, /*1*/ replaceWith: kotlin.ReplaceWith = ..., /*2*/ level: kotlin.DeprecationLevel = ...)
    public final val level: kotlin.DeprecationLevel
        public final fun <get-level>(): kotlin.DeprecationLevel
    public final val message: kotlin.String
        public final fun <get-message>(): kotlin.String
    public final val replaceWith: kotlin.ReplaceWith
        public final fun <get-replaceWith>(): kotlin.ReplaceWith
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.TYPEALIAS}) @kotlin.annotation.MustBeDocumented @kotlin.SinceKotlin(version = "1.4") public final annotation class DeprecatedSinceKotlin : kotlin.Annotation {
    /*primary*/ public constructor DeprecatedSinceKotlin(/*0*/ warningSince: kotlin.String = ..., /*1*/ errorSince: kotlin.String = ..., /*2*/ hiddenSince: kotlin.String = ...)
    public final val errorSince: kotlin.String
        public final fun <get-errorSince>(): kotlin.String
    public final val hiddenSince: kotlin.String
        public final fun <get-hiddenSince>(): kotlin.String
    public final val warningSince: kotlin.String
        public final fun <get-warningSince>(): kotlin.String
}

public final enum class DeprecationLevel : kotlin.Enum<kotlin.DeprecationLevel> {
    enum entry WARNING

    enum entry ERROR

    enum entry HIDDEN

    /*primary*/ private constructor DeprecationLevel()
    public final override /*1*/ /*fake_override*/ val name: kotlin.String
        public final override /*1*/ /*fake_override*/ fun <get-name>(): kotlin.String
    public final override /*1*/ /*fake_override*/ val ordinal: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-ordinal>(): kotlin.Int
    protected final override /*1*/ /*fake_override*/ fun clone(): kotlin.Any
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.DeprecationLevel): kotlin.Int
    protected/*protected and package*/ final override /*1*/ /*fake_override*/ /*isHiddenForResolutionEverywhereBesideSupercalls*/ fun finalize(): kotlin.Unit
    public final override /*1*/ /*fake_override*/ /*isHiddenForResolutionEverywhereBesideSupercalls*/ fun getDeclaringClass(): java.lang.Class<kotlin.DeprecationLevel!>!

    // Static members
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.DeprecationLevel
    public final /*synthesized*/ fun values(): kotlin.Array<kotlin.DeprecationLevel>
}

public final class Double : kotlin.Number, kotlin.Comparable<kotlin.Double>, java.io.Serializable {
    /*primary*/ private constructor Double()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun inc(): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Double
    @kotlin.Deprecated(message = "Unclear conversion. To achieve the same result convert to Int explicitly and then to Byte.", replaceWith = kotlin.ReplaceWith(expression = "toInt().toByte()", imports = {})) @kotlin.DeprecatedSinceKotlin(errorSince = "1.5", warningSince = "1.3") public open override /*1*/ fun toByte(): kotlin.Byte
    @kotlin.Deprecated(message = "Direct conversion to Char is deprecated. Use toInt().toChar() or Char constructor instead.", replaceWith = kotlin.ReplaceWith(expression = "this.toInt().toChar()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    @kotlin.Deprecated(message = "Unclear conversion. To achieve the same result convert to Int explicitly and then to Short.", replaceWith = kotlin.ReplaceWith(expression = "toInt().toShort()", imports = {})) @kotlin.DeprecatedSinceKotlin(errorSince = "1.5", warningSince = "1.3") public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Double
    public final operator fun unaryPlus(): kotlin.Double

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Double
            public final fun <get-MAX_VALUE>(): kotlin.Double
        public const final val MIN_VALUE: kotlin.Double
            public final fun <get-MIN_VALUE>(): kotlin.Double
        public const final val NEGATIVE_INFINITY: kotlin.Double
            public final fun <get-NEGATIVE_INFINITY>(): kotlin.Double
        public const final val NaN: kotlin.Double
            public final fun <get-NaN>(): kotlin.Double
        public const final val POSITIVE_INFINITY: kotlin.Double
            public final fun <get-POSITIVE_INFINITY>(): kotlin.Double
        @kotlin.SinceKotlin(version = "1.4") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.4") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class DoubleArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor DoubleArray(/*0*/ size: kotlin.Int)
    public constructor DoubleArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Double)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.DoubleArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Double
    public final operator fun iterator(): kotlin.collections.DoubleIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Double): kotlin.Unit
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.ANNOTATION_CLASS}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented @kotlin.SinceKotlin(version = "1.1") public final annotation class DslMarker : kotlin.Annotation {
    /*primary*/ public constructor DslMarker()
}

public abstract class Enum</*0*/ E : kotlin.Enum<E>> : kotlin.Comparable<E>, java.io.Serializable {
    /*primary*/ public constructor Enum</*0*/ E : kotlin.Enum<E>>(/*0*/ name: kotlin.String, /*1*/ ordinal: kotlin.Int)
    public final val name: kotlin.String
        public final fun <get-name>(): kotlin.String
    public final val ordinal: kotlin.Int
        public final fun <get-ordinal>(): kotlin.Int
    protected final fun clone(): kotlin.Any
    public final override /*1*/ fun compareTo(/*0*/ other: E): kotlin.Int
    protected/*protected and package*/ final /*isHiddenForResolutionEverywhereBesideSupercalls*/ fun finalize(): kotlin.Unit
    public final /*isHiddenForResolutionEverywhereBesideSupercalls*/ fun getDeclaringClass(): java.lang.Class<E!>!

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.MustBeDocumented public final annotation class ExtensionFunctionType : kotlin.Annotation {
    /*primary*/ public constructor ExtensionFunctionType()
}

public final class Float : kotlin.Number, kotlin.Comparable<kotlin.Float>, java.io.Serializable {
    /*primary*/ private constructor Float()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun inc(): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Float
    @kotlin.Deprecated(message = "Unclear conversion. To achieve the same result convert to Int explicitly and then to Byte.", replaceWith = kotlin.ReplaceWith(expression = "toInt().toByte()", imports = {})) @kotlin.DeprecatedSinceKotlin(errorSince = "1.5", warningSince = "1.3") public open override /*1*/ fun toByte(): kotlin.Byte
    @kotlin.Deprecated(message = "Direct conversion to Char is deprecated. Use toInt().toChar() or Char constructor instead.", replaceWith = kotlin.ReplaceWith(expression = "this.toInt().toChar()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    @kotlin.Deprecated(message = "Unclear conversion. To achieve the same result convert to Int explicitly and then to Short.", replaceWith = kotlin.ReplaceWith(expression = "toInt().toShort()", imports = {})) @kotlin.DeprecatedSinceKotlin(errorSince = "1.5", warningSince = "1.3") public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Float
    public final operator fun unaryPlus(): kotlin.Float

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Float
            public final fun <get-MAX_VALUE>(): kotlin.Float
        public const final val MIN_VALUE: kotlin.Float
            public final fun <get-MIN_VALUE>(): kotlin.Float
        public const final val NEGATIVE_INFINITY: kotlin.Float
            public final fun <get-NEGATIVE_INFINITY>(): kotlin.Float
        public const final val NaN: kotlin.Float
            public final fun <get-NaN>(): kotlin.Float
        public const final val POSITIVE_INFINITY: kotlin.Float
            public final fun <get-POSITIVE_INFINITY>(): kotlin.Float
        @kotlin.SinceKotlin(version = "1.4") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.4") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class FloatArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor FloatArray(/*0*/ size: kotlin.Int)
    public constructor FloatArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Float)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.FloatArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Float
    public final operator fun iterator(): kotlin.collections.FloatIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Float): kotlin.Unit
}

public interface Function</*0*/ out R> {
}

public final class Int : kotlin.Number, kotlin.Comparable<kotlin.Int>, java.io.Serializable {
    /*primary*/ private constructor Int()
    public final infix fun and(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Int
    public final fun inv(): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final infix fun or(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ranges.IntRange
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Int
    public final infix fun shl(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final infix fun shr(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int
    public final infix fun ushr(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final infix fun xor(/*0*/ other: kotlin.Int): kotlin.Int

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Int
            public final fun <get-MAX_VALUE>(): kotlin.Int
        public const final val MIN_VALUE: kotlin.Int
            public final fun <get-MIN_VALUE>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class IntArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor IntArray(/*0*/ size: kotlin.Int)
    public constructor IntArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.IntArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Int
    public final operator fun iterator(): kotlin.collections.IntIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Int): kotlin.Unit
}

public final class Long : kotlin.Number, kotlin.Comparable<kotlin.Long>, java.io.Serializable {
    /*primary*/ private constructor Long()
    public final infix fun and(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Long
    public final operator fun inc(): kotlin.Long
    public final fun inv(): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Long
    public final infix fun or(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Long
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ranges.LongRange
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Long
    public final infix fun shl(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final infix fun shr(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Long
    public open override /*1*/ fun toByte(): kotlin.Byte
    @kotlin.Deprecated(message = "Direct conversion to Char is deprecated. Use toInt().toChar() or Char constructor instead.", replaceWith = kotlin.ReplaceWith(expression = "this.toInt().toChar()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Long
    public final operator fun unaryPlus(): kotlin.Long
    public final infix fun ushr(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final infix fun xor(/*0*/ other: kotlin.Long): kotlin.Long

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Long
            public final fun <get-MAX_VALUE>(): kotlin.Long
        public const final val MIN_VALUE: kotlin.Long
            public final fun <get-MIN_VALUE>(): kotlin.Long
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class LongArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor LongArray(/*0*/ size: kotlin.Int)
    public constructor LongArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Long)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.LongArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Long
    public final operator fun iterator(): kotlin.collections.LongIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Long): kotlin.Unit
}

public final class Nothing {
    /*primary*/ private constructor Nothing()
}

public abstract class Number : kotlin.Any, java.io.Serializable {
    /*primary*/ public constructor Number()
    public abstract fun toByte(): kotlin.Byte
    public abstract fun toChar(): kotlin.Char
    public abstract fun toDouble(): kotlin.Double
    public abstract fun toFloat(): kotlin.Float
    public abstract fun toInt(): kotlin.Int
    public abstract fun toLong(): kotlin.Long
    public abstract fun toShort(): kotlin.Short
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.MustBeDocumented @kotlin.SinceKotlin(version = "1.1") public final annotation class ParameterName : kotlin.Annotation {
    /*primary*/ public constructor ParameterName(/*0*/ name: kotlin.String)
    public final val name: kotlin.String
        public final fun <get-name>(): kotlin.String
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented @kotlin.SinceKotlin(version = "1.1") public final annotation class PublishedApi : kotlin.Annotation {
    /*primary*/ public constructor PublishedApi()
}

@kotlin.annotation.Target(allowedTargets = {}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented public final annotation class ReplaceWith : kotlin.Annotation {
    /*primary*/ public constructor ReplaceWith(/*0*/ expression: kotlin.String, /*1*/ vararg imports: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    public final val expression: kotlin.String
        public final fun <get-expression>(): kotlin.String
    public final val imports: kotlin.Array<out kotlin.String>
        public final fun <get-imports>(): kotlin.Array<out kotlin.String>
}

public final class Short : kotlin.Number, kotlin.Comparable<kotlin.Short>, java.io.Serializable {
    /*primary*/ private constructor Short()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Short
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Short
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.ranges.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.ranges.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.ranges.IntRange
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Byte): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Double): kotlin.Double
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Float): kotlin.Float
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Int): kotlin.Int
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Long): kotlin.Long
    @kotlin.SinceKotlin(version = "1.1") public final operator fun rem(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    @kotlin.Deprecated(message = "Direct conversion to Char is deprecated. Use toInt().toChar() or Char constructor instead.", replaceWith = kotlin.ReplaceWith(expression = "this.toInt().toChar()", imports = {})) @kotlin.DeprecatedSinceKotlin(warningSince = "1.5") public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public const final val MAX_VALUE: kotlin.Short
            public final fun <get-MAX_VALUE>(): kotlin.Short
        public const final val MIN_VALUE: kotlin.Short
            public final fun <get-MIN_VALUE>(): kotlin.Short
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BITS: kotlin.Int
            public final fun <get-SIZE_BITS>(): kotlin.Int
        @kotlin.SinceKotlin(version = "1.3") public const final val SIZE_BYTES: kotlin.Int
            public final fun <get-SIZE_BYTES>(): kotlin.Int
    }
}

public final class ShortArray : kotlin.Any, kotlin.Cloneable, java.io.Serializable {
    /*primary*/ public constructor ShortArray(/*0*/ size: kotlin.Int)
    public constructor ShortArray(/*0*/ size: kotlin.Int, /*1*/ init: (kotlin.Int) -> kotlin.Short)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.ShortArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Short
    public final operator fun iterator(): kotlin.collections.ShortIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Short): kotlin.Unit
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.PROPERTY, AnnotationTarget.FIELD, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.TYPEALIAS}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented public final annotation class SinceKotlin : kotlin.Annotation {
    /*primary*/ public constructor SinceKotlin(/*0*/ version: kotlin.String)
    public final val version: kotlin.String
        public final fun <get-version>(): kotlin.String
}

public final class String : kotlin.Comparable<kotlin.String>, kotlin.CharSequence, java.io.Serializable {
    /*primary*/ public constructor String()
    public open override /*1*/ val length: kotlin.Int
        public open override /*1*/ fun <get-length>(): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.String): kotlin.Int
    public open override /*1*/ fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final operator fun plus(/*0*/ other: kotlin.Any?): kotlin.String
    public open override /*1*/ fun subSequence(/*0*/ startIndex: kotlin.Int, /*1*/ endIndex: kotlin.Int): kotlin.CharSequence

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.TYPE_PARAMETER, AnnotationTarget.PROPERTY, AnnotationTarget.FIELD, AnnotationTarget.LOCAL_VARIABLE, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.TYPE, AnnotationTarget.EXPRESSION, AnnotationTarget.FILE, AnnotationTarget.TYPEALIAS}) @kotlin.annotation.Retention(value = AnnotationRetention.SOURCE) public final annotation class Suppress : kotlin.Annotation {
    /*primary*/ public constructor Suppress(/*0*/ vararg names: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    public final val names: kotlin.Array<out kotlin.String>
        public final fun <get-names>(): kotlin.Array<out kotlin.String>
}

public open class Throwable : kotlin.Any, java.io.Serializable {
    public constructor Throwable()
    public constructor Throwable(/*0*/ message: kotlin.String?)
    /*primary*/ public constructor Throwable(/*0*/ message: kotlin.String?, /*1*/ cause: kotlin.Throwable?)
    public constructor Throwable(/*0*/ cause: kotlin.Throwable?)
    public open val cause: kotlin.Throwable?
        public open fun <get-cause>(): kotlin.Throwable?
    public open val message: kotlin.String?
        public open fun <get-message>(): kotlin.String?
    public open fun fillInStackTrace(): kotlin.Throwable!
    public open fun getLocalizedMessage(): kotlin.String!
    public open fun getStackTrace(): kotlin.Array<(out) java.lang.StackTraceElement!>!
    public open fun initCause(/*0*/ p0: kotlin.Throwable!): kotlin.Throwable!
    public open fun printStackTrace(): kotlin.Unit
    public open fun printStackTrace(/*0*/ p0: java.io.PrintStream!): kotlin.Unit
    public open fun printStackTrace(/*0*/ p0: java.io.PrintWriter!): kotlin.Unit
    public open fun setStackTrace(/*0*/ p0: kotlin.Array<(out) java.lang.StackTraceElement!>!): kotlin.Unit
}

public object Unit {
    /*primary*/ private constructor Unit()
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.Retention(value = AnnotationRetention.SOURCE) @kotlin.annotation.MustBeDocumented public final annotation class UnsafeVariance : kotlin.Annotation {
    /*primary*/ public constructor UnsafeVariance()
}
