FILE: [ResolvedTo(BODY_RESOLVE)] annotationArguments.kt
    @<ERROR TYPE REF: Symbol not found for Arrays>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithArrays : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithArrays] constructor(): R|WithArrays| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Arrays>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithExplicitArrays : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithExplicitArrays] constructor(): R|WithExplicitArrays| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for ClassLiteral>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithClassLiteral : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithClassLiteral] constructor(): R|WithClassLiteral| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for EnumLiteral>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithEnumLiteral : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithEnumLiteral] constructor(): R|WithEnumLiteral| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for VarArg>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class OneVararg : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=OneVararg] constructor(): R|OneVararg| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for VarArg>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class TwoVararg : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=TwoVararg] constructor(): R|TwoVararg| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for VarArg>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class ThreeVararg : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=ThreeVararg] constructor(): R|ThreeVararg| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for VarArg>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class SpreadVararg : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=SpreadVararg] constructor(): R|SpreadVararg| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Outer>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithNested : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithNested] constructor(): R|WithNested| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Outer>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithQualifiedNested : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithQualifiedNested] constructor(): R|WithQualifiedNested| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class Qualified : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=Qualified] constructor(): R|Qualified| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class Sum : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=Sum] constructor(): R|Sum| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class Negative : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=Negative] constructor(): R|Negative| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class Negative2 : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=Negative2] constructor(): R|Negative2| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class Positive : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=Positive] constructor(): R|Positive| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithSimple : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithSimple] constructor(): R|WithSimple| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithNamedSimple : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithNamedSimple] constructor(): R|WithNamedSimple| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types](LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class WithSimpleOperations : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=WithSimpleOperations] constructor(): R|WithSimpleOperations| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for Simple>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithConversionCall : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithConversionCall] constructor(): R|WithConversionCall| {
            super<R|kotlin/Any|>()
        }

    }
    @R|ConversionCallConsumer|[Types](b = Int(12).R|kotlin/Int.toByte|()) public final [ResolvedTo(BODY_RESOLVE)] class WithResolvedConversionCall : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithResolvedConversionCall] constructor(): R|WithResolvedConversionCall| {
            super<R|kotlin/Any|>()
        }

    }
    public final [ResolvedTo(BODY_RESOLVE)] annotation class ConversionCallConsumer : R|kotlin/Annotation| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=ConversionCallConsumer] constructor([ResolvedTo(BODY_RESOLVE)] [CorrespondingProperty=/ConversionCallConsumer.b] b: R|kotlin/Byte|): R|ConversionCallConsumer| {
            super<R|kotlin/Any|>()
        }

        public final [ResolvedTo(BODY_RESOLVE)] [IsFromPrimaryConstructor=true] val b: R|kotlin/Byte| = R|<local>/b|
            public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=ConversionCallConsumer] get(): R|kotlin/Byte|

    }
    @<ERROR TYPE REF: Symbol not found for StringLiteral>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithStringLiteral : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithStringLiteral] constructor(): R|WithStringLiteral| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for StringLiteral>[Types](LAZY_EXPRESSION, LAZY_EXPRESSION, LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class WithStringLiteralConcat : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=WithStringLiteralConcat] constructor(): R|WithStringLiteralConcat| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @<ERROR TYPE REF: Symbol not found for StringLiteral>[Types]() public final [ResolvedTo(BODY_RESOLVE)] class WithStringInterpolationPrefix : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=WithStringInterpolationPrefix] constructor(): R|WithStringInterpolationPrefix| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for InvalidArguments>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class LongStringTemplateEntryWithTwoExpressions : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=LongStringTemplateEntryWithTwoExpressions] constructor(): R|LongStringTemplateEntryWithTwoExpressions| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @R|kotlin/Deprecated|[Types](message = String(Deprecated), replaceWith = R|kotlin/ReplaceWith.ReplaceWith|(String(NewClass), vararg(String(foo.bar.baz.NewClass))), level = Q|kotlin/DeprecationLevel|.R|kotlin/DeprecationLevel.HIDDEN|) public final [ResolvedTo(BODY_RESOLVE)] class Another : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=Another] constructor(): R|Another| {
            super<R|kotlin/Any|>()
        }

    }
    @<ERROR TYPE REF: Symbol not found for Arrays>[Types](LAZY_EXPRESSION) public final [ResolvedTo(CONSTANT_EVALUATION)] class WithIncorrectArguments : R|kotlin/Any| {
        public [ResolvedTo(CONSTANT_EVALUATION)] [ContainingClassKey=WithIncorrectArguments] constructor(): R|WithIncorrectArguments| {
            LAZY_super<R|kotlin/Any|>
        }

    }
    @R|kotlin/Deprecated|[Types](message = String(Deprecated), replaceWith = Q|kotlin|.R|kotlin/ReplaceWith.ReplaceWith|(String(NewClass), vararg(String(foo.bar.baz.NewClass))), level = Q|kotlin/DeprecationLevel|.R|kotlin/DeprecationLevel.HIDDEN|) public final [ResolvedTo(BODY_RESOLVE)] class Qualified : R|kotlin/Any| {
        public [ResolvedTo(BODY_RESOLVE)] [ContainingClassKey=Qualified] constructor(): R|Qualified| {
            super<R|kotlin/Any|>()
        }

    }