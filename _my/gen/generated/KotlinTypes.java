// This is a generated file. Not intended for manual editing.
package generated;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import kt.KotlinParserDefinition;
import generated.psi.impl.*;

public interface KotlinTypes {

  IElementType ADDITIVE_EXPRESSION_PLUS = KotlinParserDefinition.createType("ADDITIVE_EXPRESSION_PLUS");
  IElementType ADDITIVE_OPERATION = KotlinParserDefinition.createType("ADDITIVE_OPERATION");
  IElementType AND_OPERATION = KotlinParserDefinition.createType("AND_OPERATION");
  IElementType ANNOTATED_EXPRESSION = KotlinParserDefinition.createType("ANNOTATED_EXPRESSION");
  IElementType ANNOTATIONS = KotlinParserDefinition.createType("ANNOTATIONS");
  IElementType ANNOTATION_ENTRY = KotlinParserDefinition.createType("ANNOTATION_ENTRY");
  IElementType ANONYMOUS_INITIALIZER = KotlinParserDefinition.createType("ANONYMOUS_INITIALIZER");
  IElementType ARRAY_ACCESS = KotlinParserDefinition.createType("ARRAY_ACCESS");
  IElementType ASSIGNMENT_EXPRESSION = KotlinParserDefinition.createType("ASSIGNMENT_EXPRESSION");
  IElementType ASSIGNMENT_OPERATOR = KotlinParserDefinition.createType("ASSIGNMENT_OPERATOR");
  IElementType ASTERISK = KotlinParserDefinition.createType("ASTERISK");
  IElementType BINARY_CONSTANT = KotlinParserDefinition.createType("BINARY_CONSTANT");
  IElementType BLOCK = KotlinParserDefinition.createType("BLOCK");
  IElementType CALLABLE_REFERENCE = KotlinParserDefinition.createType("CALLABLE_REFERENCE");
  IElementType CALL_SUFFIX = KotlinParserDefinition.createType("CALL_SUFFIX");
  IElementType CATCH_BLOCK = KotlinParserDefinition.createType("CATCH_BLOCK");
  IElementType CHARACTER_CONSTANT = KotlinParserDefinition.createType("CHARACTER_CONSTANT");
  IElementType CLASS_BODY = KotlinParserDefinition.createType("CLASS_BODY");
  IElementType CLASS_DECLARATION = KotlinParserDefinition.createType("CLASS_DECLARATION");
  IElementType CLASS_OBJECT = KotlinParserDefinition.createType("CLASS_OBJECT");
  IElementType COMPARISON_EXPRESSION = KotlinParserDefinition.createType("COMPARISON_EXPRESSION");
  IElementType COMPARISON_OPERATION = KotlinParserDefinition.createType("COMPARISON_OPERATION");
  IElementType CONDITION = KotlinParserDefinition.createType("CONDITION");
  IElementType CONJUNCTION_PLUS = KotlinParserDefinition.createType("CONJUNCTION_PLUS");
  IElementType CONSTRUCTOR_CALLEE = KotlinParserDefinition.createType("CONSTRUCTOR_CALLEE");
  IElementType DELEGATION_SPECIFIER_EXT = KotlinParserDefinition.createType("DELEGATION_SPECIFIER_EXT");
  IElementType DELEGATOR_SUPER_CALL = KotlinParserDefinition.createType("DELEGATOR_SUPER_CALL");
  IElementType DELEGATOR_SUPER_CLASS = KotlinParserDefinition.createType("DELEGATOR_SUPER_CLASS");
  IElementType DISJUNCTION_PLUS = KotlinParserDefinition.createType("DISJUNCTION_PLUS");
  IElementType DOT_IDENTIFIER = KotlinParserDefinition.createType("DOT_IDENTIFIER");
  IElementType DOT_QUALIFIED_EXPRESSION = KotlinParserDefinition.createType("DOT_QUALIFIED_EXPRESSION");
  IElementType DO_WHILE_LOOP = KotlinParserDefinition.createType("DO_WHILE_LOOP");
  IElementType ELSE_EXPRESSION = KotlinParserDefinition.createType("ELSE_EXPRESSION");
  IElementType ELVIS_ACCESS_EXPRESSION = KotlinParserDefinition.createType("ELVIS_ACCESS_EXPRESSION");
  IElementType ELVIS_OPERATION = KotlinParserDefinition.createType("ELVIS_OPERATION");
  IElementType ENUM_CLASS_BODY = KotlinParserDefinition.createType("ENUM_CLASS_BODY");
  IElementType ENUM_ENTRY = KotlinParserDefinition.createType("ENUM_ENTRY");
  IElementType EQUALITY_COMPARISON_EXPRESSION = KotlinParserDefinition.createType("EQUALITY_COMPARISON_EXPRESSION");
  IElementType EQUALITY_OPERATION = KotlinParserDefinition.createType("EQUALITY_OPERATION");
  IElementType EXPLICIT_DELEGATION = KotlinParserDefinition.createType("EXPLICIT_DELEGATION");
  IElementType FINALLY_BLOCK = KotlinParserDefinition.createType("FINALLY_BLOCK");
  IElementType FLOAT_CONSTANT = KotlinParserDefinition.createType("FLOAT_CONSTANT");
  IElementType FOR_LOOP = KotlinParserDefinition.createType("FOR_LOOP");
  IElementType FUNCTION = KotlinParserDefinition.createType("FUNCTION");
  IElementType FUNCTION_LITERAL = KotlinParserDefinition.createType("FUNCTION_LITERAL");
  IElementType FUNCTION_LITERAL_ARGUMENT = KotlinParserDefinition.createType("FUNCTION_LITERAL_ARGUMENT");
  IElementType FUNCTION_LITERAL_EXPRESSION = KotlinParserDefinition.createType("FUNCTION_LITERAL_EXPRESSION");
  IElementType FUNCTION_LITERAL_VALUE_PARAMETER_LIST_1 = KotlinParserDefinition.createType("FUNCTION_LITERAL_VALUE_PARAMETER_LIST_1");
  IElementType FUNCTION_LITERAL_VALUE_PARAMETER_LIST_2 = KotlinParserDefinition.createType("FUNCTION_LITERAL_VALUE_PARAMETER_LIST_2");
  IElementType FUNCTION_PARAMETER = KotlinParserDefinition.createType("FUNCTION_PARAMETER");
  IElementType FUNCTION_TYPE = KotlinParserDefinition.createType("FUNCTION_TYPE");
  IElementType FUNCTION_TYPE_RECEIVER = KotlinParserDefinition.createType("FUNCTION_TYPE_RECEIVER");
  IElementType FUNCTION_TYPE_RECEIVER_REFERENCE = KotlinParserDefinition.createType("FUNCTION_TYPE_RECEIVER_REFERENCE");
  IElementType GETTER = KotlinParserDefinition.createType("GETTER");
  IElementType IF_EXPRESSION = KotlinParserDefinition.createType("IF_EXPRESSION");
  IElementType IMPORT_DIRECTIVE = KotlinParserDefinition.createType("IMPORT_DIRECTIVE");
  IElementType IMPORT_LIST = KotlinParserDefinition.createType("IMPORT_LIST");
  IElementType INDICES = KotlinParserDefinition.createType("INDICES");
  IElementType INITIALIZER_EXT = KotlinParserDefinition.createType("INITIALIZER_EXT");
  IElementType INTEGER_CONSTANT = KotlinParserDefinition.createType("INTEGER_CONSTANT");
  IElementType IN_OPERATION = KotlinParserDefinition.createType("IN_OPERATION");
  IElementType IS_OPERATION = KotlinParserDefinition.createType("IS_OPERATION");
  IElementType JUMP_BREAK = KotlinParserDefinition.createType("JUMP_BREAK");
  IElementType JUMP_CONTINUE = KotlinParserDefinition.createType("JUMP_CONTINUE");
  IElementType JUMP_RETURN = KotlinParserDefinition.createType("JUMP_RETURN");
  IElementType JUMP_THROW = KotlinParserDefinition.createType("JUMP_THROW");
  IElementType LABEL = KotlinParserDefinition.createType("LABEL");
  IElementType LABEL_EXPRESSION = KotlinParserDefinition.createType("LABEL_EXPRESSION");
  IElementType LABEL_LABEL = KotlinParserDefinition.createType("LABEL_LABEL");
  IElementType LEFT_FUNCTION_TYPE = KotlinParserDefinition.createType("LEFT_FUNCTION_TYPE");
  IElementType LONG_ANNOTATION = KotlinParserDefinition.createType("LONG_ANNOTATION");
  IElementType LONG_TEMPLATE = KotlinParserDefinition.createType("LONG_TEMPLATE");
  IElementType LOOP = KotlinParserDefinition.createType("LOOP");
  IElementType MODIFIERS_IDENTIFIER_EXT = KotlinParserDefinition.createType("MODIFIERS_IDENTIFIER_EXT");
  IElementType MODIFIERS_IDENTIFIER_TYPE_EXT = KotlinParserDefinition.createType("MODIFIERS_IDENTIFIER_TYPE_EXT");
  IElementType MODIFIER_LIST = KotlinParserDefinition.createType("MODIFIER_LIST");
  IElementType MULTIPLE_VARIABLE_DECLARATIONS = KotlinParserDefinition.createType("MULTIPLE_VARIABLE_DECLARATIONS");
  IElementType MULTIPLICATIVE_EXPRESSION_PLUS = KotlinParserDefinition.createType("MULTIPLICATIVE_EXPRESSION_PLUS");
  IElementType MULTIPLICATIVE_OPERATION = KotlinParserDefinition.createType("MULTIPLICATIVE_OPERATION");
  IElementType NAMED_INFIX_FIRST = KotlinParserDefinition.createType("NAMED_INFIX_FIRST");
  IElementType NAMED_INFIX_PLUS = KotlinParserDefinition.createType("NAMED_INFIX_PLUS");
  IElementType NULL = KotlinParserDefinition.createType("NULL");
  IElementType NULLABLE_TYPE = KotlinParserDefinition.createType("NULLABLE_TYPE");
  IElementType OBJECT = KotlinParserDefinition.createType("OBJECT");
  IElementType OBJECT_DECLARATION = KotlinParserDefinition.createType("OBJECT_DECLARATION");
  IElementType OBJECT_DECLARATION_NAME = KotlinParserDefinition.createType("OBJECT_DECLARATION_NAME");
  IElementType OBJECT_LITERAL = KotlinParserDefinition.createType("OBJECT_LITERAL");
  IElementType OBJECT_NAME = KotlinParserDefinition.createType("OBJECT_NAME");
  IElementType OBJECT_UNNAMED = KotlinParserDefinition.createType("OBJECT_UNNAMED");
  IElementType OR_OPERATION = KotlinParserDefinition.createType("OR_OPERATION");
  IElementType PACKAGE_DIRECTIVE = KotlinParserDefinition.createType("PACKAGE_DIRECTIVE");
  IElementType PACKAGE_HEADER = KotlinParserDefinition.createType("PACKAGE_HEADER");
  IElementType PARAMETER = KotlinParserDefinition.createType("PARAMETER");
  IElementType PARAMETER_OR_MODIFIER_TYPE = KotlinParserDefinition.createType("PARAMETER_OR_MODIFIER_TYPE");
  IElementType PARENTHESIZED_EXPRESSION = KotlinParserDefinition.createType("PARENTHESIZED_EXPRESSION");
  IElementType PLUS_PLUS_AND_OTHERS_EXPRESSION = KotlinParserDefinition.createType("PLUS_PLUS_AND_OTHERS_EXPRESSION");
  IElementType PLUS_PLUS_AND_OTHERS_OPERATION = KotlinParserDefinition.createType("PLUS_PLUS_AND_OTHERS_OPERATION");
  IElementType PREFIX_OPERATION = KotlinParserDefinition.createType("PREFIX_OPERATION");
  IElementType PREFIX_OPERATION_EXPRESSION = KotlinParserDefinition.createType("PREFIX_OPERATION_EXPRESSION");
  IElementType PRIMARY_CONSTRUCTOR_MODIFIER_LIST = KotlinParserDefinition.createType("PRIMARY_CONSTRUCTOR_MODIFIER_LIST");
  IElementType PROPERTY = KotlinParserDefinition.createType("PROPERTY");
  IElementType PROPERTY_LOCAL = KotlinParserDefinition.createType("PROPERTY_LOCAL");
  IElementType REFERENCE_EXPRESSION = KotlinParserDefinition.createType("REFERENCE_EXPRESSION");
  IElementType SAFE_ACCESS_EXPRESSION = KotlinParserDefinition.createType("SAFE_ACCESS_EXPRESSION");
  IElementType SELF_TYPE = KotlinParserDefinition.createType("SELF_TYPE");
  IElementType SETTER = KotlinParserDefinition.createType("SETTER");
  IElementType SIMPLE_USER_TYPE = KotlinParserDefinition.createType("SIMPLE_USER_TYPE");
  IElementType SIMPLE_USER_TYPE_ADD = KotlinParserDefinition.createType("SIMPLE_USER_TYPE_ADD");
  IElementType SINGLE_VALUE_PARAMETER_LIST = KotlinParserDefinition.createType("SINGLE_VALUE_PARAMETER_LIST");
  IElementType STATEMENTS_BLOCK = KotlinParserDefinition.createType("STATEMENTS_BLOCK");
  IElementType STRING_TEMPLATE = KotlinParserDefinition.createType("STRING_TEMPLATE");
  IElementType STRING_TEMPLATE_ELEMENT = KotlinParserDefinition.createType("STRING_TEMPLATE_ELEMENT");
  IElementType SUPER_EXPRESSION = KotlinParserDefinition.createType("SUPER_EXPRESSION");
  IElementType SUPER_REFERENCE = KotlinParserDefinition.createType("SUPER_REFERENCE");
  IElementType THEN_EXPRESSION = KotlinParserDefinition.createType("THEN_EXPRESSION");
  IElementType THIS_EXPRESSION = KotlinParserDefinition.createType("THIS_EXPRESSION");
  IElementType THIS_REFERENCE = KotlinParserDefinition.createType("THIS_REFERENCE");
  IElementType TRY_BLOCK = KotlinParserDefinition.createType("TRY_BLOCK");
  IElementType TYPE = KotlinParserDefinition.createType("TYPE");
  IElementType TYPEDEF = KotlinParserDefinition.createType("TYPEDEF");
  IElementType TYPE_ARGUMENTS = KotlinParserDefinition.createType("TYPE_ARGUMENTS");
  IElementType TYPE_ARGUMENT_LIST = KotlinParserDefinition.createType("TYPE_ARGUMENT_LIST");
  IElementType TYPE_CONSTRAINT = KotlinParserDefinition.createType("TYPE_CONSTRAINT");
  IElementType TYPE_CONSTRAINT_EXT = KotlinParserDefinition.createType("TYPE_CONSTRAINT_EXT");
  IElementType TYPE_LIST = KotlinParserDefinition.createType("TYPE_LIST");
  IElementType TYPE_OPERATION = KotlinParserDefinition.createType("TYPE_OPERATION");
  IElementType TYPE_PARAMETER = KotlinParserDefinition.createType("TYPE_PARAMETER");
  IElementType TYPE_PARAMETERS = KotlinParserDefinition.createType("TYPE_PARAMETERS");
  IElementType TYPE_PROJECTION = KotlinParserDefinition.createType("TYPE_PROJECTION");
  IElementType TYPE_RHS_PLUS = KotlinParserDefinition.createType("TYPE_RHS_PLUS");
  IElementType USER_TYPE_REFERENCE = KotlinParserDefinition.createType("USER_TYPE_REFERENCE");
  IElementType VALUE_ARGUMENT = KotlinParserDefinition.createType("VALUE_ARGUMENT");
  IElementType VALUE_ARGUMENTS = KotlinParserDefinition.createType("VALUE_ARGUMENTS");
  IElementType VALUE_ARGUMENT_NAME = KotlinParserDefinition.createType("VALUE_ARGUMENT_NAME");
  IElementType VALUE_PARAMETERS = KotlinParserDefinition.createType("VALUE_PARAMETERS");
  IElementType VALUE_PARAMETER_LIST = KotlinParserDefinition.createType("VALUE_PARAMETER_LIST");
  IElementType VARIABLE_DECLARATION_ENTRY_EXT = KotlinParserDefinition.createType("VARIABLE_DECLARATION_ENTRY_EXT");
  IElementType WHEN = KotlinParserDefinition.createType("WHEN");
  IElementType WHEN_CONDITION_EXPRESSION = KotlinParserDefinition.createType("WHEN_CONDITION_EXPRESSION");
  IElementType WHEN_CONDITION_IN_RANGE = KotlinParserDefinition.createType("WHEN_CONDITION_IN_RANGE");
  IElementType WHEN_CONDITION_IS_PATTERN = KotlinParserDefinition.createType("WHEN_CONDITION_IS_PATTERN");
  IElementType WHEN_ENTRY = KotlinParserDefinition.createType("WHEN_ENTRY");
  IElementType WHEN_PROPERTY = KotlinParserDefinition.createType("WHEN_PROPERTY");
  IElementType WHILE_LOOP = KotlinParserDefinition.createType("WHILE_LOOP");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ADDITIVE_EXPRESSION_PLUS) {
        return new KtAdditiveExpressionPlusImpl(node);
      }
      else if (type == ADDITIVE_OPERATION) {
        return new KtAdditiveOperationImpl(node);
      }
      else if (type == AND_OPERATION) {
        return new KtAndOperationImpl(node);
      }
      else if (type == ANNOTATED_EXPRESSION) {
        return new KtAnnotatedExpressionImpl(node);
      }
      else if (type == ANNOTATIONS) {
        return new KtAnnotationsImpl(node);
      }
      else if (type == ANNOTATION_ENTRY) {
        return new KtAnnotationEntryImpl(node);
      }
      else if (type == ANONYMOUS_INITIALIZER) {
        return new KtAnonymousInitializerImpl(node);
      }
      else if (type == ARRAY_ACCESS) {
        return new KtArrayAccessImpl(node);
      }
      else if (type == ASSIGNMENT_EXPRESSION) {
        return new KtAssignmentExpressionImpl(node);
      }
      else if (type == ASSIGNMENT_OPERATOR) {
        return new KtAssignmentOperatorImpl(node);
      }
      else if (type == ASTERISK) {
        return new KtAsteriskImpl(node);
      }
      else if (type == BINARY_CONSTANT) {
        return new KtBinaryConstantImpl(node);
      }
      else if (type == BLOCK) {
        return new KtBlockImpl(node);
      }
      else if (type == CALLABLE_REFERENCE) {
        return new KtCallableReferenceImpl(node);
      }
      else if (type == CALL_SUFFIX) {
        return new KtCallSuffixImpl(node);
      }
      else if (type == CATCH_BLOCK) {
        return new KtCatchBlockImpl(node);
      }
      else if (type == CHARACTER_CONSTANT) {
        return new KtCharacterConstantImpl(node);
      }
      else if (type == CLASS_BODY) {
        return new KtClassBodyImpl(node);
      }
      else if (type == CLASS_DECLARATION) {
        return new KtClassDeclarationImpl(node);
      }
      else if (type == CLASS_OBJECT) {
        return new KtClassObjectImpl(node);
      }
      else if (type == COMPARISON_EXPRESSION) {
        return new KtComparisonExpressionImpl(node);
      }
      else if (type == COMPARISON_OPERATION) {
        return new KtComparisonOperationImpl(node);
      }
      else if (type == CONDITION) {
        return new KtConditionImpl(node);
      }
      else if (type == CONJUNCTION_PLUS) {
        return new KtConjunctionPlusImpl(node);
      }
      else if (type == CONSTRUCTOR_CALLEE) {
        return new KtConstructorCalleeImpl(node);
      }
      else if (type == DELEGATION_SPECIFIER_EXT) {
        return new KtDelegationSpecifierExtImpl(node);
      }
      else if (type == DELEGATOR_SUPER_CALL) {
        return new KtDelegatorSuperCallImpl(node);
      }
      else if (type == DELEGATOR_SUPER_CLASS) {
        return new KtDelegatorSuperClassImpl(node);
      }
      else if (type == DISJUNCTION_PLUS) {
        return new KtDisjunctionPlusImpl(node);
      }
      else if (type == DOT_IDENTIFIER) {
        return new KtDotIdentifierImpl(node);
      }
      else if (type == DOT_QUALIFIED_EXPRESSION) {
        return new KtDotQualifiedExpressionImpl(node);
      }
      else if (type == DO_WHILE_LOOP) {
        return new KtDoWhileLoopImpl(node);
      }
      else if (type == ELSE_EXPRESSION) {
        return new KtElseExpressionImpl(node);
      }
      else if (type == ELVIS_ACCESS_EXPRESSION) {
        return new KtElvisAccessExpressionImpl(node);
      }
      else if (type == ELVIS_OPERATION) {
        return new KtElvisOperationImpl(node);
      }
      else if (type == ENUM_CLASS_BODY) {
        return new KtEnumClassBodyImpl(node);
      }
      else if (type == ENUM_ENTRY) {
        return new KtEnumEntryImpl(node);
      }
      else if (type == EQUALITY_COMPARISON_EXPRESSION) {
        return new KtEqualityComparisonExpressionImpl(node);
      }
      else if (type == EQUALITY_OPERATION) {
        return new KtEqualityOperationImpl(node);
      }
      else if (type == EXPLICIT_DELEGATION) {
        return new KtExplicitDelegationImpl(node);
      }
      else if (type == FINALLY_BLOCK) {
        return new KtFinallyBlockImpl(node);
      }
      else if (type == FLOAT_CONSTANT) {
        return new KtFloatConstantImpl(node);
      }
      else if (type == FOR_LOOP) {
        return new KtForLoopImpl(node);
      }
      else if (type == FUNCTION) {
        return new KtFunctionImpl(node);
      }
      else if (type == FUNCTION_LITERAL) {
        return new KtFunctionLiteralImpl(node);
      }
      else if (type == FUNCTION_LITERAL_ARGUMENT) {
        return new KtFunctionLiteralArgumentImpl(node);
      }
      else if (type == FUNCTION_LITERAL_EXPRESSION) {
        return new KtFunctionLiteralExpressionImpl(node);
      }
      else if (type == FUNCTION_LITERAL_VALUE_PARAMETER_LIST_1) {
        return new KtFunctionLiteralValueParameterList1Impl(node);
      }
      else if (type == FUNCTION_LITERAL_VALUE_PARAMETER_LIST_2) {
        return new KtFunctionLiteralValueParameterList2Impl(node);
      }
      else if (type == FUNCTION_PARAMETER) {
        return new KtFunctionParameterImpl(node);
      }
      else if (type == FUNCTION_TYPE) {
        return new KtFunctionTypeImpl(node);
      }
      else if (type == FUNCTION_TYPE_RECEIVER) {
        return new KtFunctionTypeReceiverImpl(node);
      }
      else if (type == FUNCTION_TYPE_RECEIVER_REFERENCE) {
        return new KtFunctionTypeReceiverReferenceImpl(node);
      }
      else if (type == GETTER) {
        return new KtGetterImpl(node);
      }
      else if (type == IF_EXPRESSION) {
        return new KtIfExpressionImpl(node);
      }
      else if (type == IMPORT_DIRECTIVE) {
        return new KtImportDirectiveImpl(node);
      }
      else if (type == IMPORT_LIST) {
        return new KtImportListImpl(node);
      }
      else if (type == INDICES) {
        return new KtIndicesImpl(node);
      }
      else if (type == INITIALIZER_EXT) {
        return new KtInitializerExtImpl(node);
      }
      else if (type == INTEGER_CONSTANT) {
        return new KtIntegerConstantImpl(node);
      }
      else if (type == IN_OPERATION) {
        return new KtInOperationImpl(node);
      }
      else if (type == IS_OPERATION) {
        return new KtIsOperationImpl(node);
      }
      else if (type == JUMP_BREAK) {
        return new KtJumpBreakImpl(node);
      }
      else if (type == JUMP_CONTINUE) {
        return new KtJumpContinueImpl(node);
      }
      else if (type == JUMP_RETURN) {
        return new KtJumpReturnImpl(node);
      }
      else if (type == JUMP_THROW) {
        return new KtJumpThrowImpl(node);
      }
      else if (type == LABEL) {
        return new KtLabelImpl(node);
      }
      else if (type == LABEL_EXPRESSION) {
        return new KtLabelExpressionImpl(node);
      }
      else if (type == LABEL_LABEL) {
        return new KtLabelLabelImpl(node);
      }
      else if (type == LEFT_FUNCTION_TYPE) {
        return new KtLeftFunctionTypeImpl(node);
      }
      else if (type == LONG_ANNOTATION) {
        return new KtLongAnnotationImpl(node);
      }
      else if (type == LONG_TEMPLATE) {
        return new KtLongTemplateImpl(node);
      }
      else if (type == LOOP) {
        return new KtLoopImpl(node);
      }
      else if (type == MODIFIERS_IDENTIFIER_EXT) {
        return new KtModifiersIDENTIFIERExtImpl(node);
      }
      else if (type == MODIFIERS_IDENTIFIER_TYPE_EXT) {
        return new KtModifiersIDENTIFIERTypeExtImpl(node);
      }
      else if (type == MODIFIER_LIST) {
        return new KtModifierListImpl(node);
      }
      else if (type == MULTIPLE_VARIABLE_DECLARATIONS) {
        return new KtMultipleVariableDeclarationsImpl(node);
      }
      else if (type == MULTIPLICATIVE_EXPRESSION_PLUS) {
        return new KtMultiplicativeExpressionPlusImpl(node);
      }
      else if (type == MULTIPLICATIVE_OPERATION) {
        return new KtMultiplicativeOperationImpl(node);
      }
      else if (type == NAMED_INFIX_FIRST) {
        return new KtNamedInfixFirstImpl(node);
      }
      else if (type == NAMED_INFIX_PLUS) {
        return new KtNamedInfixPlusImpl(node);
      }
      else if (type == NULL) {
        return new KtNullImpl(node);
      }
      else if (type == NULLABLE_TYPE) {
        return new KtNullableTypeImpl(node);
      }
      else if (type == OBJECT) {
        return new KtObjectImpl(node);
      }
      else if (type == OBJECT_DECLARATION) {
        return new KtObjectDeclarationImpl(node);
      }
      else if (type == OBJECT_DECLARATION_NAME) {
        return new KtObjectDeclarationNameImpl(node);
      }
      else if (type == OBJECT_LITERAL) {
        return new KtObjectLiteralImpl(node);
      }
      else if (type == OBJECT_NAME) {
        return new KtObjectNameImpl(node);
      }
      else if (type == OBJECT_UNNAMED) {
        return new KtObjectUnnamedImpl(node);
      }
      else if (type == OR_OPERATION) {
        return new KtOrOperationImpl(node);
      }
      else if (type == PACKAGE_DIRECTIVE) {
        return new KtPackageDirectiveImpl(node);
      }
      else if (type == PACKAGE_HEADER) {
        return new KtPackageHeaderImpl(node);
      }
      else if (type == PARAMETER) {
        return new KtParameterImpl(node);
      }
      else if (type == PARAMETER_OR_MODIFIER_TYPE) {
        return new KtParameterOrModifierTypeImpl(node);
      }
      else if (type == PARENTHESIZED_EXPRESSION) {
        return new KtParenthesizedExpressionImpl(node);
      }
      else if (type == PLUS_PLUS_AND_OTHERS_EXPRESSION) {
        return new KtPlusPlusAndOthersExpressionImpl(node);
      }
      else if (type == PLUS_PLUS_AND_OTHERS_OPERATION) {
        return new KtPlusPlusAndOthersOperationImpl(node);
      }
      else if (type == PREFIX_OPERATION) {
        return new KtPrefixOperationImpl(node);
      }
      else if (type == PREFIX_OPERATION_EXPRESSION) {
        return new KtPrefixOperationExpressionImpl(node);
      }
      else if (type == PRIMARY_CONSTRUCTOR_MODIFIER_LIST) {
        return new KtPrimaryConstructorModifierListImpl(node);
      }
      else if (type == PROPERTY) {
        return new KtPropertyImpl(node);
      }
      else if (type == PROPERTY_LOCAL) {
        return new KtPropertyLocalImpl(node);
      }
      else if (type == REFERENCE_EXPRESSION) {
        return new KtReferenceExpressionImpl(node);
      }
      else if (type == SAFE_ACCESS_EXPRESSION) {
        return new KtSafeAccessExpressionImpl(node);
      }
      else if (type == SELF_TYPE) {
        return new KtSelfTypeImpl(node);
      }
      else if (type == SETTER) {
        return new KtSetterImpl(node);
      }
      else if (type == SIMPLE_USER_TYPE) {
        return new KtSimpleUserTypeImpl(node);
      }
      else if (type == SIMPLE_USER_TYPE_ADD) {
        return new KtSimpleUserTypeAddImpl(node);
      }
      else if (type == SINGLE_VALUE_PARAMETER_LIST) {
        return new KtSingleValueParameterListImpl(node);
      }
      else if (type == STATEMENTS_BLOCK) {
        return new KtStatementsBlockImpl(node);
      }
      else if (type == STRING_TEMPLATE) {
        return new KtStringTemplateImpl(node);
      }
      else if (type == STRING_TEMPLATE_ELEMENT) {
        return new KtStringTemplateElementImpl(node);
      }
      else if (type == SUPER_EXPRESSION) {
        return new KtSuperExpressionImpl(node);
      }
      else if (type == SUPER_REFERENCE) {
        return new KtSuperReferenceImpl(node);
      }
      else if (type == THEN_EXPRESSION) {
        return new KtThenExpressionImpl(node);
      }
      else if (type == THIS_EXPRESSION) {
        return new KtThisExpressionImpl(node);
      }
      else if (type == THIS_REFERENCE) {
        return new KtThisReferenceImpl(node);
      }
      else if (type == TRY_BLOCK) {
        return new KtTryBlockImpl(node);
      }
      else if (type == TYPE) {
        return new KtTypeImpl(node);
      }
      else if (type == TYPEDEF) {
        return new KtTypedefImpl(node);
      }
      else if (type == TYPE_ARGUMENTS) {
        return new KtTypeArgumentsImpl(node);
      }
      else if (type == TYPE_ARGUMENT_LIST) {
        return new KtTypeArgumentListImpl(node);
      }
      else if (type == TYPE_CONSTRAINT) {
        return new KtTypeConstraintImpl(node);
      }
      else if (type == TYPE_CONSTRAINT_EXT) {
        return new KtTypeConstraintExtImpl(node);
      }
      else if (type == TYPE_LIST) {
        return new KtTypeListImpl(node);
      }
      else if (type == TYPE_OPERATION) {
        return new KtTypeOperationImpl(node);
      }
      else if (type == TYPE_PARAMETER) {
        return new KtTypeParameterImpl(node);
      }
      else if (type == TYPE_PARAMETERS) {
        return new KtTypeParametersImpl(node);
      }
      else if (type == TYPE_PROJECTION) {
        return new KtTypeProjectionImpl(node);
      }
      else if (type == TYPE_RHS_PLUS) {
        return new KtTypeRHSPlusImpl(node);
      }
      else if (type == USER_TYPE_REFERENCE) {
        return new KtUserTypeReferenceImpl(node);
      }
      else if (type == VALUE_ARGUMENT) {
        return new KtValueArgumentImpl(node);
      }
      else if (type == VALUE_ARGUMENTS) {
        return new KtValueArgumentsImpl(node);
      }
      else if (type == VALUE_ARGUMENT_NAME) {
        return new KtValueArgumentNameImpl(node);
      }
      else if (type == VALUE_PARAMETERS) {
        return new KtValueParametersImpl(node);
      }
      else if (type == VALUE_PARAMETER_LIST) {
        return new KtValueParameterListImpl(node);
      }
      else if (type == VARIABLE_DECLARATION_ENTRY_EXT) {
        return new KtVariableDeclarationEntryExtImpl(node);
      }
      else if (type == WHEN) {
        return new KtWhenImpl(node);
      }
      else if (type == WHEN_CONDITION_EXPRESSION) {
        return new KtWhenConditionExpressionImpl(node);
      }
      else if (type == WHEN_CONDITION_IN_RANGE) {
        return new KtWhenConditionInRangeImpl(node);
      }
      else if (type == WHEN_CONDITION_IS_PATTERN) {
        return new KtWhenConditionIsPatternImpl(node);
      }
      else if (type == WHEN_ENTRY) {
        return new KtWhenEntryImpl(node);
      }
      else if (type == WHEN_PROPERTY) {
        return new KtWhenPropertyImpl(node);
      }
      else if (type == WHILE_LOOP) {
        return new KtWhileLoopImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
