/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.js

import kotlin.internal.throwIrLinkageError
import kotlin.reflect.KProperty

internal fun throwLinkageErrorInCallableName(function: dynamic, linkageError: String) {
    defineProp(
        function,
        name = "callableName",
        getter = { throwIrLinkageError(linkageError) },
        setter = VOID,
        enumerable = true,
    )
}

@Deprecated("TODO: Remove after boostrap advance", level = DeprecationLevel.HIDDEN)
internal fun getPropertyCallableRef(
    name: String?,
    paramCount: Int,
    superType: dynamic,
    getter: dynamic,
    setter: dynamic,
): KProperty<*> = getPropertyCallableRef2(name, paramCount, getter, setter, superType.`$imask$`, VOID)

internal fun getPropertyCallableRef2(
    name: String?,
    paramCount: Int,
    getter: dynamic,
    setter: dynamic,
    interfaceMask: Array<Int>?,
    linkageError: String?,
): KProperty<*> {
    getter.get = getter
    getter.set = setter
    if (linkageError != null) {
        throwLinkageErrorInCallableName(getter, linkageError)
    } else {
        getter.callableName = name
    }
    getter.`$metadata$` = getKPropMetadata(paramCount, setter)
    getter.constructor = getter
    if (interfaceMask != null) {
        getter.`$imask$` = interfaceMask.toBitMask()
    }
    return getter.unsafeCast<KProperty<*>>()
}

@Deprecated("TODO: Remove after boostrap advance", level = DeprecationLevel.HIDDEN)
internal fun getLocalDelegateReference(name: String, superType: dynamic, mutable: Boolean): KProperty<*> =
    getLocalDelegateReference2(name, mutable, superType.`$imask$`)

@Suppress("unused") // usages are generated by the compiler
internal fun getLocalDelegateReference2(name: String, mutable: Boolean, interfaceMask: Array<Int>?): KProperty<*> {
    // getPropertyCallableRef will mutate the lambda, so it's important that the lambda is not transformed into a global function.
    val lambda = @JsNoLifting { throwUnsupportedOperationException("Not supported for local property reference.") }
    return getPropertyCallableRef2(name, 0, lambda, if (mutable) lambda else null, interfaceMask, VOID)
}

@Suppress("unused") // usages are generated by the compiler
internal fun getInterfaceMaskForPropertyRef(superType: dynamic): Array<Int>? =
    implement(arrayOf(superType)).takeIf { it.size > 0 }?.toTypedArray()

@Suppress("UNUSED_PARAMETER")
private fun getKPropMetadata(paramCount: Int, setter: Any?): dynamic {
    return propertyRefClassMetadataCache[paramCount][if (setter == null) 0 else 1]
}

private fun metadataObject(): Metadata {
    return createMetadata(METADATA_KIND_CLASS, VOID, VOID, VOID, VOID, VOID)
}

private val propertyRefClassMetadataCache: Array<Array<dynamic>> = arrayOf<Array<dynamic>>(
    //                 immutable     ,     mutable
    arrayOf<dynamic>(metadataObject(), metadataObject()), // 0
    arrayOf<dynamic>(metadataObject(), metadataObject()), // 1
    arrayOf<dynamic>(metadataObject(), metadataObject())  // 2
)
