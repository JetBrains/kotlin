/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */
@file:Suppress("DEPRECATION", "DEPRECATION_ERROR", "REDUNDANT_CALL_OF_CONVERSION_METHOD")

package org.jetbrains.kotlin.resolve.constants.evaluate

import org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType.*
import java.math.BigInteger

/** This file is generated by `./gradlew generateOperationsMap`. DO NOT MODIFY MANUALLY */

fun evalUnaryOp(name: String, type: CompileTimeType, value: Any): Any? {
    when (type) {
        BOOLEAN -> when (name) {
            "not" -> return (value as Boolean).not()
            "toString" -> return (value as Boolean).toString()
        }
        BYTE -> when (name) {
            "toByte" -> return (value as Byte).toByte()
            "toChar" -> return (value as Byte).toChar()
            "toDouble" -> return (value as Byte).toDouble()
            "toFloat" -> return (value as Byte).toFloat()
            "toInt" -> return (value as Byte).toInt()
            "toLong" -> return (value as Byte).toLong()
            "toShort" -> return (value as Byte).toShort()
            "toString" -> return (value as Byte).toString()
            "unaryMinus" -> return (value as Byte).unaryMinus()
            "unaryPlus" -> return (value as Byte).unaryPlus()
            "toULong" -> return (value as Byte).toULong()
            "toUInt" -> return (value as Byte).toUInt()
            "toUShort" -> return (value as Byte).toUShort()
            "toUByte" -> return (value as Byte).toUByte()
        }
        CHAR -> when (name) {
            "toByte" -> return (value as Char).toByte()
            "toChar" -> return (value as Char).toChar()
            "toDouble" -> return (value as Char).toDouble()
            "toFloat" -> return (value as Char).toFloat()
            "toInt" -> return (value as Char).toInt()
            "toLong" -> return (value as Char).toLong()
            "toShort" -> return (value as Char).toShort()
            "toString" -> return (value as Char).toString()
            "code" -> return (value as Char).code
        }
        DOUBLE -> when (name) {
            "toByte" -> return (value as Double).toByte()
            "toChar" -> return (value as Double).toChar()
            "toDouble" -> return (value as Double).toDouble()
            "toFloat" -> return (value as Double).toFloat()
            "toInt" -> return (value as Double).toInt()
            "toLong" -> return (value as Double).toLong()
            "toShort" -> return (value as Double).toShort()
            "toString" -> return (value as Double).toString()
            "unaryMinus" -> return (value as Double).unaryMinus()
            "unaryPlus" -> return (value as Double).unaryPlus()
            "toULong" -> return (value as Double).toULong()
            "toUInt" -> return (value as Double).toUInt()
        }
        FLOAT -> when (name) {
            "toByte" -> return (value as Float).toByte()
            "toChar" -> return (value as Float).toChar()
            "toDouble" -> return (value as Float).toDouble()
            "toFloat" -> return (value as Float).toFloat()
            "toInt" -> return (value as Float).toInt()
            "toLong" -> return (value as Float).toLong()
            "toShort" -> return (value as Float).toShort()
            "toString" -> return (value as Float).toString()
            "unaryMinus" -> return (value as Float).unaryMinus()
            "unaryPlus" -> return (value as Float).unaryPlus()
            "toULong" -> return (value as Float).toULong()
            "toUInt" -> return (value as Float).toUInt()
        }
        INT -> when (name) {
            "inv" -> return (value as Int).inv()
            "toByte" -> return (value as Int).toByte()
            "toChar" -> return (value as Int).toChar()
            "toDouble" -> return (value as Int).toDouble()
            "toFloat" -> return (value as Int).toFloat()
            "toInt" -> return (value as Int).toInt()
            "toLong" -> return (value as Int).toLong()
            "toShort" -> return (value as Int).toShort()
            "toString" -> return (value as Int).toString()
            "unaryMinus" -> return (value as Int).unaryMinus()
            "unaryPlus" -> return (value as Int).unaryPlus()
            "toULong" -> return (value as Int).toULong()
            "toUInt" -> return (value as Int).toUInt()
            "toUShort" -> return (value as Int).toUShort()
            "toUByte" -> return (value as Int).toUByte()
        }
        LONG -> when (name) {
            "inv" -> return (value as Long).inv()
            "toByte" -> return (value as Long).toByte()
            "toChar" -> return (value as Long).toChar()
            "toDouble" -> return (value as Long).toDouble()
            "toFloat" -> return (value as Long).toFloat()
            "toInt" -> return (value as Long).toInt()
            "toLong" -> return (value as Long).toLong()
            "toShort" -> return (value as Long).toShort()
            "toString" -> return (value as Long).toString()
            "unaryMinus" -> return (value as Long).unaryMinus()
            "unaryPlus" -> return (value as Long).unaryPlus()
            "toULong" -> return (value as Long).toULong()
            "toUInt" -> return (value as Long).toUInt()
            "toUShort" -> return (value as Long).toUShort()
            "toUByte" -> return (value as Long).toUByte()
        }
        SHORT -> when (name) {
            "toByte" -> return (value as Short).toByte()
            "toChar" -> return (value as Short).toChar()
            "toDouble" -> return (value as Short).toDouble()
            "toFloat" -> return (value as Short).toFloat()
            "toInt" -> return (value as Short).toInt()
            "toLong" -> return (value as Short).toLong()
            "toShort" -> return (value as Short).toShort()
            "toString" -> return (value as Short).toString()
            "unaryMinus" -> return (value as Short).unaryMinus()
            "unaryPlus" -> return (value as Short).unaryPlus()
            "toULong" -> return (value as Short).toULong()
            "toUInt" -> return (value as Short).toUInt()
            "toUShort" -> return (value as Short).toUShort()
            "toUByte" -> return (value as Short).toUByte()
        }
        STRING -> when (name) {
            "length" -> return (value as String).length
            "toString" -> return (value as String).toString()
            "trim" -> return (value as String).trim()
            "trimEnd" -> return (value as String).trimEnd()
            "trimIndent" -> return (value as String).trimIndent()
            "trimMargin" -> return (value as String).trimMargin()
            "trimStart" -> return (value as String).trimStart()
        }
        UINT -> when (name) {
            "inv" -> return (value as UInt).inv()
            "toByte" -> return (value as UInt).toByte()
            "toDouble" -> return (value as UInt).toDouble()
            "toFloat" -> return (value as UInt).toFloat()
            "toInt" -> return (value as UInt).toInt()
            "toLong" -> return (value as UInt).toLong()
            "toShort" -> return (value as UInt).toShort()
            "toString" -> return (value as UInt).toString()
            "toUByte" -> return (value as UInt).toUByte()
            "toUInt" -> return (value as UInt).toUInt()
            "toULong" -> return (value as UInt).toULong()
            "toUShort" -> return (value as UInt).toUShort()
        }
        ULONG -> when (name) {
            "inv" -> return (value as ULong).inv()
            "toByte" -> return (value as ULong).toByte()
            "toDouble" -> return (value as ULong).toDouble()
            "toFloat" -> return (value as ULong).toFloat()
            "toInt" -> return (value as ULong).toInt()
            "toLong" -> return (value as ULong).toLong()
            "toShort" -> return (value as ULong).toShort()
            "toString" -> return (value as ULong).toString()
            "toUByte" -> return (value as ULong).toUByte()
            "toUInt" -> return (value as ULong).toUInt()
            "toULong" -> return (value as ULong).toULong()
            "toUShort" -> return (value as ULong).toUShort()
        }
        UBYTE -> when (name) {
            "inv" -> return (value as UByte).inv()
            "toByte" -> return (value as UByte).toByte()
            "toDouble" -> return (value as UByte).toDouble()
            "toFloat" -> return (value as UByte).toFloat()
            "toInt" -> return (value as UByte).toInt()
            "toLong" -> return (value as UByte).toLong()
            "toShort" -> return (value as UByte).toShort()
            "toString" -> return (value as UByte).toString()
            "toUByte" -> return (value as UByte).toUByte()
            "toUInt" -> return (value as UByte).toUInt()
            "toULong" -> return (value as UByte).toULong()
            "toUShort" -> return (value as UByte).toUShort()
        }
        USHORT -> when (name) {
            "inv" -> return (value as UShort).inv()
            "toByte" -> return (value as UShort).toByte()
            "toDouble" -> return (value as UShort).toDouble()
            "toFloat" -> return (value as UShort).toFloat()
            "toInt" -> return (value as UShort).toInt()
            "toLong" -> return (value as UShort).toLong()
            "toShort" -> return (value as UShort).toShort()
            "toString" -> return (value as UShort).toString()
            "toUByte" -> return (value as UShort).toUByte()
            "toUInt" -> return (value as UShort).toUInt()
            "toULong" -> return (value as UShort).toULong()
            "toUShort" -> return (value as UShort).toUShort()
        }
        else -> {}
    }
    return null
}

fun evalBinaryOp(name: String, leftType: CompileTimeType, left: Any, rightType: CompileTimeType, right: Any): Any? {
    when (leftType) {
        BOOLEAN -> when (rightType) {
            BOOLEAN -> when (name) {
                "and" -> return (left as Boolean).and(right as Boolean)
                "compareTo" -> return (left as Boolean).compareTo(right as Boolean)
                "or" -> return (left as Boolean).or(right as Boolean)
                "xor" -> return (left as Boolean).xor(right as Boolean)
            }
            ANY -> when (name) {
                "equals" -> return (left as Boolean).equals(right)
            }
            else -> {}
        }
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Byte)
                "div" -> return (left as Byte).div(right as Byte)
                "minus" -> return (left as Byte).minus(right as Byte)
                "plus" -> return (left as Byte).plus(right as Byte)
                "rem" -> return (left as Byte).rem(right as Byte)
                "times" -> return (left as Byte).times(right as Byte)
                "mod" -> return (left as Byte).mod(right as Byte)
                "floorDiv" -> return (left as Byte).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Short)
                "div" -> return (left as Byte).div(right as Short)
                "minus" -> return (left as Byte).minus(right as Short)
                "plus" -> return (left as Byte).plus(right as Short)
                "rem" -> return (left as Byte).rem(right as Short)
                "times" -> return (left as Byte).times(right as Short)
                "mod" -> return (left as Byte).mod(right as Short)
                "floorDiv" -> return (left as Byte).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Int)
                "div" -> return (left as Byte).div(right as Int)
                "minus" -> return (left as Byte).minus(right as Int)
                "plus" -> return (left as Byte).plus(right as Int)
                "rem" -> return (left as Byte).rem(right as Int)
                "times" -> return (left as Byte).times(right as Int)
                "mod" -> return (left as Byte).mod(right as Int)
                "floorDiv" -> return (left as Byte).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Long)
                "div" -> return (left as Byte).div(right as Long)
                "minus" -> return (left as Byte).minus(right as Long)
                "plus" -> return (left as Byte).plus(right as Long)
                "rem" -> return (left as Byte).rem(right as Long)
                "times" -> return (left as Byte).times(right as Long)
                "mod" -> return (left as Byte).mod(right as Long)
                "floorDiv" -> return (left as Byte).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Float)
                "div" -> return (left as Byte).div(right as Float)
                "minus" -> return (left as Byte).minus(right as Float)
                "plus" -> return (left as Byte).plus(right as Float)
                "rem" -> return (left as Byte).rem(right as Float)
                "times" -> return (left as Byte).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Byte).compareTo(right as Double)
                "div" -> return (left as Byte).div(right as Double)
                "minus" -> return (left as Byte).minus(right as Double)
                "plus" -> return (left as Byte).plus(right as Double)
                "rem" -> return (left as Byte).rem(right as Double)
                "times" -> return (left as Byte).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Byte).equals(right)
            }
            else -> {}
        }
        CHAR -> when (rightType) {
            CHAR -> when (name) {
                "compareTo" -> return (left as Char).compareTo(right as Char)
                "minus" -> return (left as Char).minus(right as Char)
            }
            ANY -> when (name) {
                "equals" -> return (left as Char).equals(right)
            }
            INT -> when (name) {
                "minus" -> return (left as Char).minus(right as Int)
                "plus" -> return (left as Char).plus(right as Int)
            }
            else -> {}
        }
        DOUBLE -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Byte)
                "div" -> return (left as Double).div(right as Byte)
                "minus" -> return (left as Double).minus(right as Byte)
                "plus" -> return (left as Double).plus(right as Byte)
                "rem" -> return (left as Double).rem(right as Byte)
                "times" -> return (left as Double).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Short)
                "div" -> return (left as Double).div(right as Short)
                "minus" -> return (left as Double).minus(right as Short)
                "plus" -> return (left as Double).plus(right as Short)
                "rem" -> return (left as Double).rem(right as Short)
                "times" -> return (left as Double).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Int)
                "div" -> return (left as Double).div(right as Int)
                "minus" -> return (left as Double).minus(right as Int)
                "plus" -> return (left as Double).plus(right as Int)
                "rem" -> return (left as Double).rem(right as Int)
                "times" -> return (left as Double).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Long)
                "div" -> return (left as Double).div(right as Long)
                "minus" -> return (left as Double).minus(right as Long)
                "plus" -> return (left as Double).plus(right as Long)
                "rem" -> return (left as Double).rem(right as Long)
                "times" -> return (left as Double).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Float)
                "div" -> return (left as Double).div(right as Float)
                "minus" -> return (left as Double).minus(right as Float)
                "plus" -> return (left as Double).plus(right as Float)
                "rem" -> return (left as Double).rem(right as Float)
                "times" -> return (left as Double).times(right as Float)
                "mod" -> return (left as Double).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Double).compareTo(right as Double)
                "div" -> return (left as Double).div(right as Double)
                "minus" -> return (left as Double).minus(right as Double)
                "plus" -> return (left as Double).plus(right as Double)
                "rem" -> return (left as Double).rem(right as Double)
                "times" -> return (left as Double).times(right as Double)
                "mod" -> return (left as Double).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Double).equals(right)
            }
            else -> {}
        }
        FLOAT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Byte)
                "div" -> return (left as Float).div(right as Byte)
                "minus" -> return (left as Float).minus(right as Byte)
                "plus" -> return (left as Float).plus(right as Byte)
                "rem" -> return (left as Float).rem(right as Byte)
                "times" -> return (left as Float).times(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Short)
                "div" -> return (left as Float).div(right as Short)
                "minus" -> return (left as Float).minus(right as Short)
                "plus" -> return (left as Float).plus(right as Short)
                "rem" -> return (left as Float).rem(right as Short)
                "times" -> return (left as Float).times(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Int)
                "div" -> return (left as Float).div(right as Int)
                "minus" -> return (left as Float).minus(right as Int)
                "plus" -> return (left as Float).plus(right as Int)
                "rem" -> return (left as Float).rem(right as Int)
                "times" -> return (left as Float).times(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Long)
                "div" -> return (left as Float).div(right as Long)
                "minus" -> return (left as Float).minus(right as Long)
                "plus" -> return (left as Float).plus(right as Long)
                "rem" -> return (left as Float).rem(right as Long)
                "times" -> return (left as Float).times(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Float)
                "div" -> return (left as Float).div(right as Float)
                "minus" -> return (left as Float).minus(right as Float)
                "plus" -> return (left as Float).plus(right as Float)
                "rem" -> return (left as Float).rem(right as Float)
                "times" -> return (left as Float).times(right as Float)
                "mod" -> return (left as Float).mod(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Float).compareTo(right as Double)
                "div" -> return (left as Float).div(right as Double)
                "minus" -> return (left as Float).minus(right as Double)
                "plus" -> return (left as Float).plus(right as Double)
                "rem" -> return (left as Float).rem(right as Double)
                "times" -> return (left as Float).times(right as Double)
                "mod" -> return (left as Float).mod(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Float).equals(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return (left as Int).and(right as Int)
                "compareTo" -> return (left as Int).compareTo(right as Int)
                "div" -> return (left as Int).div(right as Int)
                "minus" -> return (left as Int).minus(right as Int)
                "or" -> return (left as Int).or(right as Int)
                "plus" -> return (left as Int).plus(right as Int)
                "rem" -> return (left as Int).rem(right as Int)
                "shl" -> return (left as Int).shl(right as Int)
                "shr" -> return (left as Int).shr(right as Int)
                "times" -> return (left as Int).times(right as Int)
                "ushr" -> return (left as Int).ushr(right as Int)
                "xor" -> return (left as Int).xor(right as Int)
                "mod" -> return (left as Int).mod(right as Int)
                "floorDiv" -> return (left as Int).floorDiv(right as Int)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Byte)
                "div" -> return (left as Int).div(right as Byte)
                "minus" -> return (left as Int).minus(right as Byte)
                "plus" -> return (left as Int).plus(right as Byte)
                "rem" -> return (left as Int).rem(right as Byte)
                "times" -> return (left as Int).times(right as Byte)
                "mod" -> return (left as Int).mod(right as Byte)
                "floorDiv" -> return (left as Int).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Short)
                "div" -> return (left as Int).div(right as Short)
                "minus" -> return (left as Int).minus(right as Short)
                "plus" -> return (left as Int).plus(right as Short)
                "rem" -> return (left as Int).rem(right as Short)
                "times" -> return (left as Int).times(right as Short)
                "mod" -> return (left as Int).mod(right as Short)
                "floorDiv" -> return (left as Int).floorDiv(right as Short)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Long)
                "div" -> return (left as Int).div(right as Long)
                "minus" -> return (left as Int).minus(right as Long)
                "plus" -> return (left as Int).plus(right as Long)
                "rem" -> return (left as Int).rem(right as Long)
                "times" -> return (left as Int).times(right as Long)
                "mod" -> return (left as Int).mod(right as Long)
                "floorDiv" -> return (left as Int).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Float)
                "div" -> return (left as Int).div(right as Float)
                "minus" -> return (left as Int).minus(right as Float)
                "plus" -> return (left as Int).plus(right as Float)
                "rem" -> return (left as Int).rem(right as Float)
                "times" -> return (left as Int).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Int).compareTo(right as Double)
                "div" -> return (left as Int).div(right as Double)
                "minus" -> return (left as Int).minus(right as Double)
                "plus" -> return (left as Int).plus(right as Double)
                "rem" -> return (left as Int).rem(right as Double)
                "times" -> return (left as Int).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Int).equals(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return (left as Long).and(right as Long)
                "compareTo" -> return (left as Long).compareTo(right as Long)
                "div" -> return (left as Long).div(right as Long)
                "minus" -> return (left as Long).minus(right as Long)
                "or" -> return (left as Long).or(right as Long)
                "plus" -> return (left as Long).plus(right as Long)
                "rem" -> return (left as Long).rem(right as Long)
                "times" -> return (left as Long).times(right as Long)
                "xor" -> return (left as Long).xor(right as Long)
                "mod" -> return (left as Long).mod(right as Long)
                "floorDiv" -> return (left as Long).floorDiv(right as Long)
            }
            BYTE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Byte)
                "div" -> return (left as Long).div(right as Byte)
                "minus" -> return (left as Long).minus(right as Byte)
                "plus" -> return (left as Long).plus(right as Byte)
                "rem" -> return (left as Long).rem(right as Byte)
                "times" -> return (left as Long).times(right as Byte)
                "mod" -> return (left as Long).mod(right as Byte)
                "floorDiv" -> return (left as Long).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Short)
                "div" -> return (left as Long).div(right as Short)
                "minus" -> return (left as Long).minus(right as Short)
                "plus" -> return (left as Long).plus(right as Short)
                "rem" -> return (left as Long).rem(right as Short)
                "times" -> return (left as Long).times(right as Short)
                "mod" -> return (left as Long).mod(right as Short)
                "floorDiv" -> return (left as Long).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Int)
                "div" -> return (left as Long).div(right as Int)
                "minus" -> return (left as Long).minus(right as Int)
                "plus" -> return (left as Long).plus(right as Int)
                "rem" -> return (left as Long).rem(right as Int)
                "shl" -> return (left as Long).shl(right as Int)
                "shr" -> return (left as Long).shr(right as Int)
                "times" -> return (left as Long).times(right as Int)
                "ushr" -> return (left as Long).ushr(right as Int)
                "mod" -> return (left as Long).mod(right as Int)
                "floorDiv" -> return (left as Long).floorDiv(right as Int)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Float)
                "div" -> return (left as Long).div(right as Float)
                "minus" -> return (left as Long).minus(right as Float)
                "plus" -> return (left as Long).plus(right as Float)
                "rem" -> return (left as Long).rem(right as Float)
                "times" -> return (left as Long).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Long).compareTo(right as Double)
                "div" -> return (left as Long).div(right as Double)
                "minus" -> return (left as Long).minus(right as Double)
                "plus" -> return (left as Long).plus(right as Double)
                "rem" -> return (left as Long).rem(right as Double)
                "times" -> return (left as Long).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Long).equals(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Byte)
                "div" -> return (left as Short).div(right as Byte)
                "minus" -> return (left as Short).minus(right as Byte)
                "plus" -> return (left as Short).plus(right as Byte)
                "rem" -> return (left as Short).rem(right as Byte)
                "times" -> return (left as Short).times(right as Byte)
                "mod" -> return (left as Short).mod(right as Byte)
                "floorDiv" -> return (left as Short).floorDiv(right as Byte)
            }
            SHORT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Short)
                "div" -> return (left as Short).div(right as Short)
                "minus" -> return (left as Short).minus(right as Short)
                "plus" -> return (left as Short).plus(right as Short)
                "rem" -> return (left as Short).rem(right as Short)
                "times" -> return (left as Short).times(right as Short)
                "mod" -> return (left as Short).mod(right as Short)
                "floorDiv" -> return (left as Short).floorDiv(right as Short)
            }
            INT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Int)
                "div" -> return (left as Short).div(right as Int)
                "minus" -> return (left as Short).minus(right as Int)
                "plus" -> return (left as Short).plus(right as Int)
                "rem" -> return (left as Short).rem(right as Int)
                "times" -> return (left as Short).times(right as Int)
                "mod" -> return (left as Short).mod(right as Int)
                "floorDiv" -> return (left as Short).floorDiv(right as Int)
            }
            LONG -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Long)
                "div" -> return (left as Short).div(right as Long)
                "minus" -> return (left as Short).minus(right as Long)
                "plus" -> return (left as Short).plus(right as Long)
                "rem" -> return (left as Short).rem(right as Long)
                "times" -> return (left as Short).times(right as Long)
                "mod" -> return (left as Short).mod(right as Long)
                "floorDiv" -> return (left as Short).floorDiv(right as Long)
            }
            FLOAT -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Float)
                "div" -> return (left as Short).div(right as Float)
                "minus" -> return (left as Short).minus(right as Float)
                "plus" -> return (left as Short).plus(right as Float)
                "rem" -> return (left as Short).rem(right as Float)
                "times" -> return (left as Short).times(right as Float)
            }
            DOUBLE -> when (name) {
                "compareTo" -> return (left as Short).compareTo(right as Double)
                "div" -> return (left as Short).div(right as Double)
                "minus" -> return (left as Short).minus(right as Double)
                "plus" -> return (left as Short).plus(right as Double)
                "rem" -> return (left as Short).rem(right as Double)
                "times" -> return (left as Short).times(right as Double)
            }
            ANY -> when (name) {
                "equals" -> return (left as Short).equals(right)
            }
            else -> {}
        }
        STRING -> when (rightType) {
            STRING -> when (name) {
                "compareTo" -> return (left as String).compareTo(right as String)
                "trimMargin" -> return (left as String).trimMargin(right as String)
            }
            ANY -> when (name) {
                "equals" -> return (left as String).equals(right)
                "plus" -> return (left as String).plus(right)
            }
            INT -> when (name) {
                "get" -> return (left as String).get(right as Int)
            }
            else -> {}
        }
        UINT -> when (rightType) {
            UINT -> when (name) {
                "and" -> return (left as UInt).and(right as UInt)
                "compareTo" -> return (left as UInt).compareTo(right as UInt)
                "div" -> return (left as UInt).div(right as UInt)
                "floorDiv" -> return (left as UInt).floorDiv(right as UInt)
                "minus" -> return (left as UInt).minus(right as UInt)
                "mod" -> return (left as UInt).mod(right as UInt)
                "or" -> return (left as UInt).or(right as UInt)
                "plus" -> return (left as UInt).plus(right as UInt)
                "rem" -> return (left as UInt).rem(right as UInt)
                "times" -> return (left as UInt).times(right as UInt)
                "xor" -> return (left as UInt).xor(right as UInt)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UByte)
                "div" -> return (left as UInt).div(right as UByte)
                "floorDiv" -> return (left as UInt).floorDiv(right as UByte)
                "minus" -> return (left as UInt).minus(right as UByte)
                "mod" -> return (left as UInt).mod(right as UByte)
                "plus" -> return (left as UInt).plus(right as UByte)
                "rem" -> return (left as UInt).rem(right as UByte)
                "times" -> return (left as UInt).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as UShort)
                "div" -> return (left as UInt).div(right as UShort)
                "floorDiv" -> return (left as UInt).floorDiv(right as UShort)
                "minus" -> return (left as UInt).minus(right as UShort)
                "mod" -> return (left as UInt).mod(right as UShort)
                "plus" -> return (left as UInt).plus(right as UShort)
                "rem" -> return (left as UInt).rem(right as UShort)
                "times" -> return (left as UInt).times(right as UShort)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UInt).compareTo(right as ULong)
                "div" -> return (left as UInt).div(right as ULong)
                "floorDiv" -> return (left as UInt).floorDiv(right as ULong)
                "minus" -> return (left as UInt).minus(right as ULong)
                "mod" -> return (left as UInt).mod(right as ULong)
                "plus" -> return (left as UInt).plus(right as ULong)
                "rem" -> return (left as UInt).rem(right as ULong)
                "times" -> return (left as UInt).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UInt).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as UInt).shl(right as Int)
                "shr" -> return (left as UInt).shr(right as Int)
            }
            else -> {}
        }
        ULONG -> when (rightType) {
            ULONG -> when (name) {
                "and" -> return (left as ULong).and(right as ULong)
                "compareTo" -> return (left as ULong).compareTo(right as ULong)
                "div" -> return (left as ULong).div(right as ULong)
                "floorDiv" -> return (left as ULong).floorDiv(right as ULong)
                "minus" -> return (left as ULong).minus(right as ULong)
                "mod" -> return (left as ULong).mod(right as ULong)
                "or" -> return (left as ULong).or(right as ULong)
                "plus" -> return (left as ULong).plus(right as ULong)
                "rem" -> return (left as ULong).rem(right as ULong)
                "times" -> return (left as ULong).times(right as ULong)
                "xor" -> return (left as ULong).xor(right as ULong)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UByte)
                "div" -> return (left as ULong).div(right as UByte)
                "floorDiv" -> return (left as ULong).floorDiv(right as UByte)
                "minus" -> return (left as ULong).minus(right as UByte)
                "mod" -> return (left as ULong).mod(right as UByte)
                "plus" -> return (left as ULong).plus(right as UByte)
                "rem" -> return (left as ULong).rem(right as UByte)
                "times" -> return (left as ULong).times(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UShort)
                "div" -> return (left as ULong).div(right as UShort)
                "floorDiv" -> return (left as ULong).floorDiv(right as UShort)
                "minus" -> return (left as ULong).minus(right as UShort)
                "mod" -> return (left as ULong).mod(right as UShort)
                "plus" -> return (left as ULong).plus(right as UShort)
                "rem" -> return (left as ULong).rem(right as UShort)
                "times" -> return (left as ULong).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as ULong).compareTo(right as UInt)
                "div" -> return (left as ULong).div(right as UInt)
                "floorDiv" -> return (left as ULong).floorDiv(right as UInt)
                "minus" -> return (left as ULong).minus(right as UInt)
                "mod" -> return (left as ULong).mod(right as UInt)
                "plus" -> return (left as ULong).plus(right as UInt)
                "rem" -> return (left as ULong).rem(right as UInt)
                "times" -> return (left as ULong).times(right as UInt)
            }
            ANY -> when (name) {
                "equals" -> return (left as ULong).equals(right)
            }
            INT -> when (name) {
                "shl" -> return (left as ULong).shl(right as Int)
                "shr" -> return (left as ULong).shr(right as Int)
            }
            else -> {}
        }
        UBYTE -> when (rightType) {
            UBYTE -> when (name) {
                "and" -> return (left as UByte).and(right as UByte)
                "compareTo" -> return (left as UByte).compareTo(right as UByte)
                "div" -> return (left as UByte).div(right as UByte)
                "floorDiv" -> return (left as UByte).floorDiv(right as UByte)
                "minus" -> return (left as UByte).minus(right as UByte)
                "mod" -> return (left as UByte).mod(right as UByte)
                "or" -> return (left as UByte).or(right as UByte)
                "plus" -> return (left as UByte).plus(right as UByte)
                "rem" -> return (left as UByte).rem(right as UByte)
                "times" -> return (left as UByte).times(right as UByte)
                "xor" -> return (left as UByte).xor(right as UByte)
            }
            USHORT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UShort)
                "div" -> return (left as UByte).div(right as UShort)
                "floorDiv" -> return (left as UByte).floorDiv(right as UShort)
                "minus" -> return (left as UByte).minus(right as UShort)
                "mod" -> return (left as UByte).mod(right as UShort)
                "plus" -> return (left as UByte).plus(right as UShort)
                "rem" -> return (left as UByte).rem(right as UShort)
                "times" -> return (left as UByte).times(right as UShort)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as UInt)
                "div" -> return (left as UByte).div(right as UInt)
                "floorDiv" -> return (left as UByte).floorDiv(right as UInt)
                "minus" -> return (left as UByte).minus(right as UInt)
                "mod" -> return (left as UByte).mod(right as UInt)
                "plus" -> return (left as UByte).plus(right as UInt)
                "rem" -> return (left as UByte).rem(right as UInt)
                "times" -> return (left as UByte).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UByte).compareTo(right as ULong)
                "div" -> return (left as UByte).div(right as ULong)
                "floorDiv" -> return (left as UByte).floorDiv(right as ULong)
                "minus" -> return (left as UByte).minus(right as ULong)
                "mod" -> return (left as UByte).mod(right as ULong)
                "plus" -> return (left as UByte).plus(right as ULong)
                "rem" -> return (left as UByte).rem(right as ULong)
                "times" -> return (left as UByte).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UByte).equals(right)
            }
            else -> {}
        }
        USHORT -> when (rightType) {
            USHORT -> when (name) {
                "and" -> return (left as UShort).and(right as UShort)
                "compareTo" -> return (left as UShort).compareTo(right as UShort)
                "div" -> return (left as UShort).div(right as UShort)
                "floorDiv" -> return (left as UShort).floorDiv(right as UShort)
                "minus" -> return (left as UShort).minus(right as UShort)
                "mod" -> return (left as UShort).mod(right as UShort)
                "or" -> return (left as UShort).or(right as UShort)
                "plus" -> return (left as UShort).plus(right as UShort)
                "rem" -> return (left as UShort).rem(right as UShort)
                "times" -> return (left as UShort).times(right as UShort)
                "xor" -> return (left as UShort).xor(right as UShort)
            }
            UBYTE -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UByte)
                "div" -> return (left as UShort).div(right as UByte)
                "floorDiv" -> return (left as UShort).floorDiv(right as UByte)
                "minus" -> return (left as UShort).minus(right as UByte)
                "mod" -> return (left as UShort).mod(right as UByte)
                "plus" -> return (left as UShort).plus(right as UByte)
                "rem" -> return (left as UShort).rem(right as UByte)
                "times" -> return (left as UShort).times(right as UByte)
            }
            UINT -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as UInt)
                "div" -> return (left as UShort).div(right as UInt)
                "floorDiv" -> return (left as UShort).floorDiv(right as UInt)
                "minus" -> return (left as UShort).minus(right as UInt)
                "mod" -> return (left as UShort).mod(right as UInt)
                "plus" -> return (left as UShort).plus(right as UInt)
                "rem" -> return (left as UShort).rem(right as UInt)
                "times" -> return (left as UShort).times(right as UInt)
            }
            ULONG -> when (name) {
                "compareTo" -> return (left as UShort).compareTo(right as ULong)
                "div" -> return (left as UShort).div(right as ULong)
                "floorDiv" -> return (left as UShort).floorDiv(right as ULong)
                "minus" -> return (left as UShort).minus(right as ULong)
                "mod" -> return (left as UShort).mod(right as ULong)
                "plus" -> return (left as UShort).plus(right as ULong)
                "rem" -> return (left as UShort).rem(right as ULong)
                "times" -> return (left as UShort).times(right as ULong)
            }
            ANY -> when (name) {
                "equals" -> return (left as UShort).equals(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}

fun checkBinaryOp(
    name: String, leftType: CompileTimeType, left: BigInteger, rightType: CompileTimeType, right: BigInteger
): BigInteger? {
    when (leftType) {
        BYTE -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        INT -> when (rightType) {
            INT -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        LONG -> when (rightType) {
            LONG -> when (name) {
                "and" -> return left.and(right)
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "or" -> return left.or(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
                "xor" -> return left.xor(right)
            }
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        SHORT -> when (rightType) {
            BYTE -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            SHORT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            INT -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            LONG -> when (name) {
                "div" -> return left.divide(right)
                "minus" -> return left.subtract(right)
                "plus" -> return left.add(right)
                "rem" -> return left.rem(right)
                "times" -> return left.multiply(right)
            }
            else -> {}
        }
        else -> {}
    }
    return null
}
