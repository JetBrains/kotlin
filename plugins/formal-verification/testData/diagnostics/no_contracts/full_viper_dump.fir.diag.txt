/full_viper_dump.kt:(54,55): info: Generated Viper text for f:
domain dom$Any  {


}

domain dom$Casting[A, B]  {

  function dom$Casting$cast(a: A, newType: dom$Type): B

  axiom dom$Casting$null_cast {
    (forall newType: dom$Type ::
      { (dom$Casting$cast((dom$Nullable$null(): dom$Nullable[A]), newType): dom$Nullable[B]) }
      dom$Type$is_nullable_type(newType) ==>
      (dom$Casting$cast((dom$Nullable$null(): dom$Nullable[A]), newType): dom$Nullable[B]) ==
      (dom$Nullable$null(): dom$Nullable[B]))
  }

  axiom dom$Casting$type_of_cast {
    (forall a: A, newType: dom$Type ::
      { (dom$TypeOf$typeOf((dom$Casting$cast(a, newType): B)): dom$Type) }
      dom$Type$isSubtype((dom$TypeOf$typeOf((dom$Casting$cast(a, newType): B)): dom$Type),
      newType))
  }

  axiom dom$Casting$type_of_cast_invariant {
    (forall a: A, newType: dom$Type ::
      { (dom$Casting$cast(a, newType): B) }
      (dom$TypeOf$typeOf((dom$Casting$cast(a, newType): B)): dom$Type) ==
      (dom$TypeOf$typeOf(a): dom$Type))
  }
}

domain dom$Nullable[T]  {

  function dom$Nullable$null(): dom$Nullable[T]

  axiom dom$Nullable$some_not_null {
    (forall x: T, newType: dom$Type ::
      { (dom$Casting$cast(x, dom$Type$special$Nullable(newType)): dom$Nullable[T]) }
      !dom$Type$is_nullable_type(newType) ==>
      (dom$Casting$cast(x, dom$Type$special$Nullable(newType)): dom$Nullable[T]) !=
      (dom$Nullable$null(): dom$Nullable[T]))
  }

  axiom dom$Nullable$null_of_every_nullable_type {
    (forall nx: dom$Nullable[T], newType: dom$Type ::
      { dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), newType) }
      dom$Type$is_nullable_type(newType) &&
      nx == (dom$Nullable$null(): dom$Nullable[T]) ==>
      dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), newType))
  }

  axiom dom$Nullable$val_of_nullable_of_val {
    (forall x: T, newType: dom$Type ::
      { (dom$Casting$cast((dom$Casting$cast(x, dom$Type$special$Nullable(newType)): dom$Nullable[T]),
      (dom$TypeOf$typeOf(x): dom$Type)): T) }
      (dom$Casting$cast((dom$Casting$cast(x, dom$Type$special$Nullable(newType)): dom$Nullable[T]),
      (dom$TypeOf$typeOf(x): dom$Type)): T) ==
      x)
  }

  axiom dom$Nullable$nullable_of_val_of_nullable {
    (forall nx: dom$Nullable[T], newType: dom$Type ::
      { (dom$Casting$cast((dom$Casting$cast(nx, newType): T), (dom$TypeOf$typeOf(nx): dom$Type)): dom$Nullable[T]) }
      nx != (dom$Nullable$null(): dom$Nullable[T]) ==>
      (dom$Casting$cast((dom$Casting$cast(nx, newType): T), (dom$TypeOf$typeOf(nx): dom$Type)): dom$Nullable[T]) ==
      nx)
  }

  axiom dom$Nullable$null_val_or_under_type {
    (forall nx: dom$Nullable[T], newType: dom$Type ::
      { dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), dom$Type$special$Nullable(newType)) }
      !dom$Type$is_nullable_type(newType) &&
      dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), dom$Type$special$Nullable(newType)) ==>
      nx == (dom$Nullable$null(): dom$Nullable[T]) ||
      dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), newType))
  }

  axiom dom$Nullable$null_not_any {
    (forall nx: dom$Nullable[T], newType: dom$Type ::
      { dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), newType) }
      !dom$Type$is_nullable_type(newType) &&
      nx == (dom$Nullable$null(): dom$Nullable[T]) ==>
      !dom$Type$isSubtype((dom$TypeOf$typeOf(nx): dom$Type), newType))
  }
}

domain dom$Type  {

  unique function dom$Type$Int(): dom$Type

  unique function dom$Type$Boolean(): dom$Type

  unique function dom$Type$Unit(): dom$Type

  unique function dom$Type$Nothing(): dom$Type

  unique function dom$Type$Any(): dom$Type

  unique function dom$Type$Function(): dom$Type

  unique function dom$Type$global$class_Foo(): dom$Type

  function dom$Type$special$Nullable(t: dom$Type): dom$Type

  function dom$Type$isSubtype(a: dom$Type, b: dom$Type): Bool

  function dom$Type$is_nullable_type(t: dom$Type): Bool

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Int())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Int())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Int(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Boolean())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Boolean())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Boolean(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Unit())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Unit())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Unit(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Nothing())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Nothing())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Nothing(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Any())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Any())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Any(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$Function())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$Function())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$Function(), dom$Type$Any())
  }

  axiom {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$special$Nullable(t) != dom$Type$global$class_Foo())
  }

  axiom {
    !dom$Type$is_nullable_type(dom$Type$global$class_Foo())
  }

  axiom {
    dom$Type$isSubtype(dom$Type$global$class_Foo(), dom$Type$Any())
  }

  axiom dom$Type$nullable_injective {
    (forall t: dom$Type, t2: dom$Type ::t != t2 ==>
      dom$Type$special$Nullable(t) != dom$Type$special$Nullable(t2))
  }

  axiom dom$Type$nullable_is_nullable {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$is_nullable_type(dom$Type$special$Nullable(t)))
  }

  axiom dom$Type$subtype_reflexive {
    (forall t: dom$Type ::dom$Type$isSubtype(t, t))
  }

  axiom dom$Type$subtype_transitive {
    (forall t: dom$Type, t2: dom$Type, t3: dom$Type ::
      { dom$Type$isSubtype(t, t2), dom$Type$isSubtype(t2, t3) }
      dom$Type$isSubtype(t, t2) && dom$Type$isSubtype(t2, t3) ==>
      dom$Type$isSubtype(t, t3))
  }

  axiom dom$Type$subtype_antisymmetric {
    (forall t: dom$Type, t2: dom$Type ::
      { dom$Type$isSubtype(t, t2), dom$Type$isSubtype(t2, t) }
      dom$Type$isSubtype(t, t2) && dom$Type$isSubtype(t2, t) ==> t == t2)
  }

  axiom dom$Type$nullable_supertype {
    (forall t: dom$Type ::
      { dom$Type$special$Nullable(t) }
      dom$Type$isSubtype(t, dom$Type$special$Nullable(t)))
  }

  axiom dom$Type$nullable_covariant {
    (forall t: dom$Type, t2: dom$Type ::
      { dom$Type$isSubtype(dom$Type$special$Nullable(t), dom$Type$special$Nullable(t2)) }
      dom$Type$isSubtype(t, t2) ==>
      dom$Type$isSubtype(dom$Type$special$Nullable(t), dom$Type$special$Nullable(t2)))
  }

  axiom dom$Type$nothing_bottom {
    (forall t: dom$Type ::dom$Type$isSubtype(dom$Type$Nothing(), t))
  }

  axiom dom$Type$nullable_any_top {
    (forall t: dom$Type ::dom$Type$isSubtype(t, dom$Type$special$Nullable(dom$Type$Any())))
  }

  axiom {
    dom$Type$isSubtype(dom$Type$global$class_Foo(), dom$Type$Any())
  }
}

domain dom$TypeOf[T]  {

  function dom$TypeOf$typeOf(x: T): dom$Type

  axiom dom$TypeOf$type_of_int {
    (forall i: Int ::
      { (dom$TypeOf$typeOf(i): dom$Type) }
      (dom$TypeOf$typeOf(i): dom$Type) == dom$Type$Int())
  }

  axiom dom$TypeOf$type_of_bool {
    (forall b: Bool ::
      { (dom$TypeOf$typeOf(b): dom$Type) }
      (dom$TypeOf$typeOf(b): dom$Type) == dom$Type$Boolean())
  }
}

domain dom$Unit  {

  function dom$Unit$element(): dom$Unit

  axiom dom$Unit$type_of_unit {
    (forall u: dom$Unit ::
      { (dom$TypeOf$typeOf(u): dom$Type) }
      (dom$TypeOf$typeOf(u): dom$Type) == dom$Type$Unit())
  }
}

field class_Foo$member_x: Int

field special$function_object_call_counter: Int

function special$duplicable(anonymous$0: Ref): Bool


predicate T_class_global$class_Foo(class$predicate$subject: Ref) {
  acc(class$predicate$subject.class_Foo$member_x, wildcard)
}

method class_Foo$constructor$fun_take$T_Int$return$T_class_global$class_Foo(local$x: Int)
  returns (ret: Ref)
  ensures dom$Type$isSubtype((dom$TypeOf$typeOf(ret): dom$Type), dom$Type$global$class_Foo())
  ensures acc(ret.class_Foo$member_x, wildcard)


method global$fun_f$fun_take$$return$T_Unit() returns (ret: dom$Unit)
{
  var anonymous$0: Ref
  var local0$foo: Ref
  anonymous$0 := class_Foo$constructor$fun_take$T_Int$return$T_class_global$class_Foo(0)
  local0$foo := anonymous$0
  label label$ret$0
}

method special$invoke_function_object(anonymous$0: Ref)
  requires acc(anonymous$0.special$function_object_call_counter, write)
  ensures acc(anonymous$0.special$function_object_call_counter, write)
  ensures old(anonymous$0.special$function_object_call_counter) + 1 ==
    anonymous$0.special$function_object_call_counter

