/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.formver.conversion

import org.jetbrains.kotlin.contracts.description.*
import org.jetbrains.kotlin.fir.contracts.description.ConeContractConstantValues
import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.formver.effects
import org.jetbrains.kotlin.formver.embeddings.FunctionTypeEmbedding
import org.jetbrains.kotlin.formver.embeddings.NullableTypeEmbedding
import org.jetbrains.kotlin.formver.embeddings.SourceRole
import org.jetbrains.kotlin.formver.embeddings.callables.NamedFunctionSignature
import org.jetbrains.kotlin.formver.embeddings.expression.*

data class ContractVisitorContext(
    val returnVariable: VariableEmbedding,
    // Kotlin function where the visited contract is attached to.
    val functionContractOwner: FirFunctionSymbol<*>,
)

/**
 * `KtEffectDeclaration`s are nodes generated by the compiler, and as such have no source
 * information beyond the source of the `FirEffectDeclaration`. As such, we only assign
 * position information at the top level.
 */

class ContractDescriptionConversionVisitor(
    private val ctx: ProgramConversionContext,
    private val signature: NamedFunctionSignature,
) : KtContractDescriptionVisitor<ExpEmbedding, ContractVisitorContext, ConeKotlinType, ConeDiagnostic>() {
    private val parameterIndices = signature.params.indices.toSet() + setOfNotNull(signature.receiver?.let { -1 })

    fun getPreconditions(context: ContractVisitorContext): List<ExpEmbedding> {
        val callsInPlaceIndices = context.functionContractOwner.effects
            .mapNotNull { (it.effect as? KtCallsEffectDeclaration<*, *>)?.valueParameterReference?.parameterIndex }
            .toSet()

        // All parameters of function type that are not callsInPlace should be marked duplicable.
        return (parameterIndices - callsInPlaceIndices)
            .map { embeddedVarByIndex(it) }
            .filter { it.type is FunctionTypeEmbedding }
            .map { DuplicableCall(it) }
    }

    fun getPostconditions(context: ContractVisitorContext): List<ExpEmbedding> {
        return context.functionContractOwner.effects.map {
            it.effect.accept(this, context).withPosition(it.source)
        }
    }

    override fun visitBooleanConstantDescriptor(
        booleanConstantDescriptor: KtBooleanConstantReference<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding = when (booleanConstantDescriptor) {
        ConeContractConstantValues.TRUE -> BooleanLit(true, SourceRole.Condition.Constant(true))
        ConeContractConstantValues.FALSE -> BooleanLit(false, SourceRole.Condition.Constant(false))
        else -> throw IllegalArgumentException("Unexpected boolean constant: $booleanConstantDescriptor")
    }

    override fun visitReturnsEffectDeclaration(
        returnsEffect: KtReturnsEffectDeclaration<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        return when (returnsEffect.value) {
            ConeContractConstantValues.WILDCARD -> BooleanLit(true, SourceRole.ReturnsEffect.Wildcard)
            /* NOTE: in a function that has a non-nullable return type, the compiler will not complain if there is an effect like
             * returnsNotNull(). So it is necessary to take care of these cases in order to avoid comparison between non-nullable
             * values and null. In a function that has a non-nullable return type, returnsNotNull() is mapped to true and returns(null)
             * is mapped to false
             */
            ConeContractConstantValues.NULL -> data.returnVariable.nullCmp(false, SourceRole.ReturnsEffect.Null(negated = false))
            ConeContractConstantValues.NOT_NULL -> data.returnVariable.nullCmp(true, SourceRole.ReturnsEffect.Null(negated = true))
            ConeContractConstantValues.TRUE -> EqCmp(data.returnVariable, BooleanLit(true), SourceRole.ReturnsEffect.Bool(true))
            ConeContractConstantValues.FALSE -> EqCmp(data.returnVariable, BooleanLit(false), SourceRole.ReturnsEffect.Bool(false))
            else -> throw IllegalArgumentException("Unexpected constant: ${returnsEffect.value}")
        }
    }

    override fun visitValueParameterReference(
        valueParameterReference: KtValueParameterReference<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding = valueParameterReference.embeddedVar()

    override fun visitIsNullPredicate(
        isNullPredicate: KtIsNullPredicate<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        /* NOTE: useless comparisons like x != null with x non-nullable will compile with just a warning.
         * So it is necessary to take care of these cases in order to avoid comparison between non-nullable
         * values and null. Let x be a non-nullable variable, then x == null is mapped to false and x != null is mapped to true
         */
        val param = isNullPredicate.arg.embeddedVar()
        val role = SourceRole.Condition.IsNull(isNullPredicate.arg.getTargetParameter(data), isNullPredicate.isNegated)
        return param.nullCmp(isNullPredicate.isNegated, role)
    }

    override fun visitLogicalBinaryOperationContractExpression(
        binaryLogicExpression: KtBinaryLogicExpression<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        val left = binaryLogicExpression.left.accept(this, data)
        val right = binaryLogicExpression.right.accept(this, data)
        val lhsRole = left.sourceRole as SourceRole.Condition
        val rhsRole = right.sourceRole as SourceRole.Condition
        return when (binaryLogicExpression.kind) {
            LogicOperationKind.AND -> And(left, right, SourceRole.Condition.Conjunction(lhsRole, rhsRole))
            LogicOperationKind.OR -> Or(left, right, SourceRole.Condition.Disjunction(lhsRole, rhsRole))
        }
    }

    override fun visitLogicalNot(
        logicalNot: KtLogicalNot<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        val arg = logicalNot.arg.accept(this, data)
        return Not(arg, SourceRole.Condition.Negation(arg.sourceRole as SourceRole.Condition))
    }

    override fun visitConditionalEffectDeclaration(
        conditionalEffect: KtConditionalEffectDeclaration<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        val effect = conditionalEffect.effect.accept(this, data)
        val cond = conditionalEffect.condition.accept(this, data)
        // The effect's source role it is guaranteed to be not null. The same goes for the condition's source role.
        val role = SourceRole.ConditionalEffect(effect.sourceRole as SourceRole.ReturnsEffect, cond.sourceRole as SourceRole.Condition)
        return Implies(effect, cond, role)
    }

    override fun visitCallsEffectDeclaration(
        callsEffect: KtCallsEffectDeclaration<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        val param = callsEffect.valueParameterReference.accept(this, data)
        val callsFieldAccess = FieldAccess(param, SpecialFields.FunctionObjectCallCounterField)
        val targetLambdaByCallsEffect = callsEffect.valueParameterReference.getTargetParameter(data)
        val sourceRole = SourceRole.CallsInPlaceEffect(targetLambdaByCallsEffect, callsEffect.kind)
        return when (callsEffect.kind) {
            // NOTE: case not supported for contracts
            EventOccurrencesRange.ZERO -> EqCmp(
                callsFieldAccess,
                Old(callsFieldAccess),
                sourceRole
            )
            EventOccurrencesRange.AT_MOST_ONCE -> LeCmp(
                callsFieldAccess,
                Add(Old(callsFieldAccess), IntLit(1)),
                sourceRole
            )
            EventOccurrencesRange.EXACTLY_ONCE -> EqCmp(
                callsFieldAccess,
                Add(Old(callsFieldAccess), IntLit(1)),
                sourceRole
            )
            EventOccurrencesRange.AT_LEAST_ONCE -> GtCmp(
                callsFieldAccess,
                Old(callsFieldAccess),
                sourceRole
            )
            // NOTE: case not supported for contracts
            EventOccurrencesRange.MORE_THAN_ONCE -> GtCmp(
                callsFieldAccess,
                Add(Old(callsFieldAccess), IntLit(1)),
                sourceRole
            )
            EventOccurrencesRange.UNKNOWN -> BooleanLit(true, sourceRole)
        }
    }

    override fun visitIsInstancePredicate(
        isInstancePredicate: KtIsInstancePredicate<ConeKotlinType, ConeDiagnostic>,
        data: ContractVisitorContext,
    ): ExpEmbedding {
        val argVar = isInstancePredicate.arg.embeddedVar()
        val argSymbol = isInstancePredicate.arg.getTargetParameter(data)
        val role = SourceRole.Condition.IsType(argSymbol, isInstancePredicate.type, isInstancePredicate.isNegated)
        return if (isInstancePredicate.isNegated) {
            Not(Is(argVar, ctx.embedType(isInstancePredicate.type)), role)
        } else {
            Is(argVar, ctx.embedType(isInstancePredicate.type), role)
        }
    }

    /**
     * According to the input index, invoke `default` if the index is equal to -1, otherwise
     * invoke `mapper` with the given index as input.
     */
    private inline fun <T> resolveByIndex(index: Int, default: () -> T, mapper: (Int) -> T): T {
        // Implementation notes: the `default` value is lazily evaluated, since
        // we could get a possible NPE if the index is different from -1.
        // Thanks to inlining, we do not create any extra objects when invoking the function.
        return when (index) {
            -1 -> default()
            else -> mapper(index)
        }
    }

    private fun KtValueParameterReference<ConeKotlinType, ConeDiagnostic>.embeddedVar(): VariableEmbedding =
        embeddedVarByIndex(parameterIndex)

    private fun KtValueParameterReference<ConeKotlinType, ConeDiagnostic>.getTargetParameter(data: ContractVisitorContext): FirBasedSymbol<*> =
        resolveByIndex(
            parameterIndex,
            { TODO("old code: data.functionContractOwner.receiverParameter!!.calleeSymbol") }) { data.functionContractOwner.valueParameterSymbols[it] }

    private fun embeddedVarByIndex(ix: Int): VariableEmbedding = resolveByIndex(ix, { signature.receiver!! }) { signature.params[it] }

    private fun VariableEmbedding.nullCmp(isNegated: Boolean, sourceRole: SourceRole?): ExpEmbedding =
        when (val type = this.type) {
            is NullableTypeEmbedding ->
                if (isNegated) NeCmp(this, type.nullVal, sourceRole)
                else EqCmp(this, type.nullVal, sourceRole)
            else -> BooleanLit(isNegated, sourceRole)
        }
}
