package-fragment kotlin.ranges

public open class CharProgression : kotlin.collections.Iterable<kotlin.Char> {
    /*primary*/ internal constructor CharProgression(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char, /*2*/ step: kotlin.Int)
    public final val first: kotlin.Char
        public final fun `<get-first>`(): kotlin.Char
    public final val last: kotlin.Char
        public final fun `<get-last>`(): kotlin.Char
    public final val step: kotlin.Int
        public final fun `<get-step>`(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Char!>!): kotlin.Unit
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.CharIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Char>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Char, /*1*/ rangeEnd: kotlin.Char, /*2*/ step: kotlin.Int): kotlin.ranges.CharProgression
    }
}

internal final class CharProgressionIterator : kotlin.collections.CharIterator {
    /*primary*/ public constructor CharProgressionIterator(/*0*/ first: kotlin.Char, /*1*/ last: kotlin.Char, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun `<get-finalElement>`(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun `<get-hasNext>`(): kotlin.Boolean
        private final fun `<set-hasNext>`(/*0*/ `<set-?>`: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun `<get-next>`(): kotlin.Int
        private final fun `<set-next>`(/*0*/ `<set-?>`: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun `<get-step>`(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun forEachRemaining(/*0*/ p0: java.util.function.Consumer<in kotlin.Char>): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Char
    public open override /*1*/ fun nextChar(): kotlin.Char
}

public final class CharRange : kotlin.ranges.CharProgression, kotlin.ranges.ClosedRange<kotlin.Char>, kotlin.ranges.OpenEndRange<kotlin.Char> {
    /*primary*/ public constructor CharRange(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char)
    @kotlin.Deprecated(message = "Can throw an exception when it's impossible to represent the value with Char type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.") @kotlin.SinceKotlin(version = "1.9") @kotlin.WasExperimental(markerClass = {kotlin.ExperimentalStdlibApi::class}) public open override /*1*/ val endExclusive: kotlin.Char
        public open override /*1*/ fun `<get-endExclusive>`(): kotlin.Char
    public open override /*1*/ val endInclusive: kotlin.Char
        public open override /*1*/ fun `<get-endInclusive>`(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val first: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun `<get-first>`(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val last: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun `<get-last>`(): kotlin.Char
    public open override /*2*/ val start: kotlin.Char
        public open override /*2*/ fun `<get-start>`(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun `<get-step>`(): kotlin.Int
    public open override /*2*/ fun contains(/*0*/ value: kotlin.Char): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Char!>!): kotlin.Unit
    public open override /*3*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.CharIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Char>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.CharRange
            public final fun `<get-EMPTY>`(): kotlin.ranges.CharRange
    }
}

public interface ClosedRange</*0*/ T : kotlin.Comparable<T>> {
    public abstract val endInclusive: T
        public abstract fun `<get-endInclusive>`(): T
    public abstract val start: T
        public abstract fun `<get-start>`(): T
    public open operator fun contains(/*0*/ value: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}

public open class IntProgression : kotlin.collections.Iterable<kotlin.Int> {
    /*primary*/ internal constructor IntProgression(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int, /*2*/ step: kotlin.Int)
    public final val first: kotlin.Int
        public final fun `<get-first>`(): kotlin.Int
    public final val last: kotlin.Int
        public final fun `<get-last>`(): kotlin.Int
    public final val step: kotlin.Int
        public final fun `<get-step>`(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Int!>!): kotlin.Unit
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.IntIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Int>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Int, /*1*/ rangeEnd: kotlin.Int, /*2*/ step: kotlin.Int): kotlin.ranges.IntProgression
    }
}

internal final class IntProgressionIterator : kotlin.collections.IntIterator {
    /*primary*/ public constructor IntProgressionIterator(/*0*/ first: kotlin.Int, /*1*/ last: kotlin.Int, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun `<get-finalElement>`(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun `<get-hasNext>`(): kotlin.Boolean
        private final fun `<set-hasNext>`(/*0*/ `<set-?>`: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun `<get-next>`(): kotlin.Int
        private final fun `<set-next>`(/*0*/ `<set-?>`: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun `<get-step>`(): kotlin.Int
    public open override /*1*/ /*fake_override*/ fun forEachRemaining(/*0*/ p0: java.util.function.Consumer<in kotlin.Int>): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Int
    public open override /*1*/ fun nextInt(): kotlin.Int
}

public final class IntRange : kotlin.ranges.IntProgression, kotlin.ranges.ClosedRange<kotlin.Int>, kotlin.ranges.OpenEndRange<kotlin.Int> {
    /*primary*/ public constructor IntRange(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int)
    @kotlin.Deprecated(message = "Can throw an exception when it's impossible to represent the value with Int type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.") @kotlin.SinceKotlin(version = "1.9") @kotlin.WasExperimental(markerClass = {kotlin.ExperimentalStdlibApi::class}) public open override /*1*/ val endExclusive: kotlin.Int
        public open override /*1*/ fun `<get-endExclusive>`(): kotlin.Int
    public open override /*1*/ val endInclusive: kotlin.Int
        public open override /*1*/ fun `<get-endInclusive>`(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val first: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun `<get-first>`(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun `<get-last>`(): kotlin.Int
    public open override /*2*/ val start: kotlin.Int
        public open override /*2*/ fun `<get-start>`(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun `<get-step>`(): kotlin.Int
    public open override /*2*/ fun contains(/*0*/ value: kotlin.Int): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Int!>!): kotlin.Unit
    public open override /*3*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.IntIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Int>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.IntRange
            public final fun `<get-EMPTY>`(): kotlin.ranges.IntRange
    }
}

public open class LongProgression : kotlin.collections.Iterable<kotlin.Long> {
    /*primary*/ internal constructor LongProgression(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long, /*2*/ step: kotlin.Long)
    public final val first: kotlin.Long
        public final fun `<get-first>`(): kotlin.Long
    public final val last: kotlin.Long
        public final fun `<get-last>`(): kotlin.Long
    public final val step: kotlin.Long
        public final fun `<get-step>`(): kotlin.Long
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Long!>!): kotlin.Unit
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.LongIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Long>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Long, /*1*/ rangeEnd: kotlin.Long, /*2*/ step: kotlin.Long): kotlin.ranges.LongProgression
    }
}

internal final class LongProgressionIterator : kotlin.collections.LongIterator {
    /*primary*/ public constructor LongProgressionIterator(/*0*/ first: kotlin.Long, /*1*/ last: kotlin.Long, /*2*/ step: kotlin.Long)
    private final val finalElement: kotlin.Long
        private final fun `<get-finalElement>`(): kotlin.Long
    private final var hasNext: kotlin.Boolean
        private final fun `<get-hasNext>`(): kotlin.Boolean
        private final fun `<set-hasNext>`(/*0*/ `<set-?>`: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Long
        private final fun `<get-next>`(): kotlin.Long
        private final fun `<set-next>`(/*0*/ `<set-?>`: kotlin.Long): kotlin.Unit
    public final val step: kotlin.Long
        public final fun `<get-step>`(): kotlin.Long
    public open override /*1*/ /*fake_override*/ fun forEachRemaining(/*0*/ p0: java.util.function.Consumer<in kotlin.Long>): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Long
    public open override /*1*/ fun nextLong(): kotlin.Long
}

public final class LongRange : kotlin.ranges.LongProgression, kotlin.ranges.ClosedRange<kotlin.Long>, kotlin.ranges.OpenEndRange<kotlin.Long> {
    /*primary*/ public constructor LongRange(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long)
    @kotlin.Deprecated(message = "Can throw an exception when it's impossible to represent the value with Long type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.") @kotlin.SinceKotlin(version = "1.9") @kotlin.WasExperimental(markerClass = {kotlin.ExperimentalStdlibApi::class}) public open override /*1*/ val endExclusive: kotlin.Long
        public open override /*1*/ fun `<get-endExclusive>`(): kotlin.Long
    public open override /*1*/ val endInclusive: kotlin.Long
        public open override /*1*/ fun `<get-endInclusive>`(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val first: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun `<get-first>`(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val last: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun `<get-last>`(): kotlin.Long
    public open override /*2*/ val start: kotlin.Long
        public open override /*2*/ fun `<get-start>`(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val step: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun `<get-step>`(): kotlin.Long
    public open override /*2*/ fun contains(/*0*/ value: kotlin.Long): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun forEach(/*0*/ p0: java.util.function.Consumer<in kotlin.Long!>!): kotlin.Unit
    public open override /*3*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.LongIterator
    public open override /*1*/ /*fake_override*/ fun spliterator(): java.util.Spliterator<kotlin.Long>

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.LongRange
            public final fun `<get-EMPTY>`(): kotlin.ranges.LongRange
    }
}

@kotlin.SinceKotlin(version = "1.9") @kotlin.WasExperimental(markerClass = {kotlin.ExperimentalStdlibApi::class}) public interface OpenEndRange</*0*/ T : kotlin.Comparable<T>> {
    public abstract val endExclusive: T
        public abstract fun `<get-endExclusive>`(): T
    public abstract val start: T
        public abstract fun `<get-start>`(): T
    public open operator fun contains(/*0*/ value: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}
