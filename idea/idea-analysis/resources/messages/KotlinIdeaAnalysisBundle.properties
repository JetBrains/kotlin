found.space=found:\u0020
html.0.has.no.corresponding.expected.declaration.1.html=<html>{0} has no corresponding expected declaration{1}</html>
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html=<html>{0} is not abstract and does not implement abstract base class member<br/>{1}</html>
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html=<html>{0} is not abstract and does not implement abstract member<br/>{1}</html>
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=<html>''{0}'' method may be missing. None of the following functions will be called: <ul>{1}</ul></html>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=<html>Expected {0} has no actual declaration in module {1}{2}</html>
html.accidental.override.0.html=<html>Accidental override: {0}</html>
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=<html>Method ''contains'' from ConcurrentHashMap may have unexpected semantics: it calls ''containsValue'' instead of ''containsKey''.<br/>Use explicit form of the call to ''containsKey''/''containsValue''/''contains'' or cast the value to kotlin.collections.Map instead.<br/>See https://youtrack.jetbrains.com/issue/KT-18053 for more details</html>
html.javascript.0.html=<html>JavaScript: {0}</html>
html.platform.declaration.clash.0.html=<html>Platform declaration clash: {0}</html>
html.internal.error.occurred.while.analyzing.this.expression.br.table.cellspacing.0.cellpadding.0.tr.td.strong.please.use.the.strong.td.td.img.src.0.td.td.strong.icon.in.the.bottom.right.corner.to.report.this.error.strong.td.tr.table.br.pre.0.pre.html=<html>Internal Error occurred while analyzing this expression <br/><table cellspacing="0" cellpadding="0"><tr><td>(<strong>Please use the "</strong></td><td><img src="{0}"/></td><td><strong>" icon in the bottom-right corner to report this error</strong>):</td></tr></table><br/><pre>{0}</pre></html>
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.is.suitable.ul.1.ul.html=<html>Property delegate must have a ''{0}'' method. None of the following functions is suitable. <ul>{1}</ul></html>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=<html>Overload resolution ambiguity on method ''{0}''. All these functions match. <ul>{1}</ul></html>
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=<html>Unresolved reference. <br/> None of the following candidates is applicable because of receiver type mismatch: <ul>{0}</ul></html>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=<html>Cannot choose among the following candidates without completing type inference: <ul>{0}</ul></html>
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=<html>None of the following functions can be called with the arguments supplied. <ul>{0}</ul></html>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=<html>Overload resolution ambiguity. All these functions match. <ul>{0}</ul></html>
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=<html>Function return type mismatch.<table><tr><td>Expected:</td><td>{1}</td></tr><tr><td>Found:</td><td>{2}</td></tr></table></html>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html=<html>{0} must override {1}<br />because it inherits many implementations of it</html>
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=<html>Types of inherited var-properties do not match:<br/>{0},<br/>{1}</html>
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=<html>Types of inherited properties are incompatible:<br/>{0},<br/>{1}</html>
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=<html>Actual class ''{0}'' has no corresponding members for expected class members:{1}</html>
html.val.property.cannot.override.var.property.br.1.html=<html>Val-property cannot override var-property<br />{1}</html>
html.val.property.cannot.override.var.property.br.1.html2=<html>Val-property cannot override var-property<br />{1}</html>
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=<html>Var-property type is {0}, which is not a type of overridden<br/>{1}</html>
required.space=required:\u0020
type.inference.failed.expected.type.mismatch=Type inference failed. Expected type mismatch:\u0020
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=<html>Setter parameter type must be equal to the type of the property.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table></html>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=<html>Property type is {0}, which is not a subtype type of overridden<br/>{1}</html>
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=<html>Return types of inherited members are incompatible:<br/>{0},<br/>{1}</html>
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=<html>Return type is ''{0}'', which is not a subtype of overridden<br/>{1}</html>
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=<html>Loop parameter type mismatch.<table><tr><td>Iterated values:</td><td>{0}</td></tr><tr><td>Parameter:</td><td>{1}</td></tr></table></html>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=<html>Type argument is not within its bounds.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table></html>
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=<html>Method ''iterator()'' is ambiguous for this expression.<ul>{0}</ul></html>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=<html>Getter return type must be equal to the type of the property.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table></html>
html.type.inference.failed.0.html=<html>Type inference failed: {0}</html>
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=<html>Assignment operators ambiguity. All these functions match.<ul>{0}</ul></table></html>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=<html>Type mismatch.<table><tr><td>Required:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table><br />\nProjected type {2} restricts use of <br />\n{3}\n</html>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=<html>Type mismatch.<table><tr><td>Required:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table></html>

intention.suppress.family=Suppress Warnings
intention.suppress.text=Suppress ''{0}'' for {1} {2}
special.module.for.files.not.under.source.root=<special module for files not under source root>
sdk.0=<sdk {0}>
sources.for.library.0=<sources for library {0}>
library.0=<library {0}>
test.sources.for.module.0=<test sources for module {0}>
production.sources.for.module.0=<production sources for module {0}>
source.for.script.dependencies=<Source for script dependencies>
script.dependencies=<Script dependencies>
script.0.1=<script {0} {1}>
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=The following declarations have the same JVM signature (<code>{0}{1}</code>):<br/>\n<ul>\n{2}</ul>
object=object
companion.object=companion object
initializer=initializer
statement=statement
0.of.1={0} of {1}
where=where
cannot.be.inferred=cannot be inferred
i.for.i.br.0=<i> for </i><br/>{0}
defined.in=defined in
root.package=root package
automatically.declared.based.on.the.expected.type=Automatically declared based on the expected type
0.smart.cast.to.1={0} smart cast to {1}
unknown.receiver=Unknown receiver
implicit.receiver=Implicit receiver
extension.implicit.receiver=Extension implicit receiver
always.null=Always null
value.captured.in.a.closure=Value captured in a closure
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=Wrapped into a reference object to be modified when captured in a closure
smart.cast.to.0.for.1.call=Smart cast to {0} (for {1} call)
smart.cast.to.0=Smart cast to {0}
replace.overloaded.operator.with.function.call=Replace overloaded operator with function call
searching.for.implicit.usages=Searching for implicit usages...
class.initializer=<class initializer>
object.0=object{0}
show.non.public=Show non-public