cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.not.expression.to.extract=Cannot find an expression to extract
expressions.title=Expressions
introduce.variable=Introduce Variable
introduce.property=Introduce Property
introduce.parameter=Introduce Parameter
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.package.expression=Cannot introduce package reference
extract.function=Extract Function
cannot.extract.method=Cannot find statements to extract
cannot.find.class.to.extract=Cannot find class to extract method
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
cannot.extract.super.call=Cannot extract super-call
cannot.refactor.expression.should.have.inferred.type=Expression should have inferred type
cannot.refactor.synthesized.function=Cannot refactor synthesized function ''{0}''
error.types.in.generated.function=Cannot generate function with erroneous return type
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''

0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.declaration={0} has detected {1} code {1,choice,1#fragment|2#fragments} in this file that can be replaced with a call to extracted declaration. Would you like to review and replace {1,choice,1#it|2#them}?

error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
function.name.is.invalid=Function name is invalid
return.type.is.invalid=Return type is invalid
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
column.name.val.var=Val/Var

refactoring.move.specifc.element=Move {0} {1}
refactoring.move.selected.elements=Move selected elements
refactoring.move.non.kotlin.file=Target must be a Kotlin file

package.private.0.will.no.longer.be.accessible.from.1=Package-private {0} will no longer be accessible from {1}
0.uses.package.private.1={0} uses package-private {1}
0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
0.will.become.invisible.after.extraction={0} will become invisible after extraction
setter.of.0.will.become.invisible.after.extraction = Setter of {0} will become invisible after extraction

naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename

file.does.not.exist=File {0} does not exist.\nDo you want to create it?