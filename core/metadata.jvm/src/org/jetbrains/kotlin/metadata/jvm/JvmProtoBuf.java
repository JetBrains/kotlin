// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: core/metadata.jvm/src/jvm_metadata.proto
// Protobuf Java Version: 4.29.3

package org.jetbrains.kotlin.metadata.jvm;

public final class JvmProtoBuf {
  private JvmProtoBuf() {}
  public static void registerAllExtensions(
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite registry) {
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.constructorSignature);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.methodSignature);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.lambdaClassOriginName);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.propertySignature);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.flags);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.typeAnnotation);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.isRaw);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.typeParameterAnnotation);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.classModuleName);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.classLocalVariable);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.anonymousObjectOriginName);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.jvmClassFlags);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.packageModuleName);
    registry.add(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.packageLocalVariable);
  }
  public interface StringTableTypesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.jetbrains.kotlin.metadata.jvm.StringTableTypes)
      org.jetbrains.kotlin.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    java.util.List<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> 
        getRecordList();
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record getRecord(int index);
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    int getRecordCount();

    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @return A list containing the localName.
     */
    java.util.List<java.lang.Integer> getLocalNameList();
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @return The count of localName.
     */
    int getLocalNameCount();
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @param index The index of the element to return.
     * @return The localName at the given index.
     */
    int getLocalName(int index);
  }
  /**
   * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.StringTableTypes}
   */
  public  static final class StringTableTypes extends
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
          StringTableTypes, StringTableTypes.Builder> implements
      // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.metadata.jvm.StringTableTypes)
      StringTableTypesOrBuilder {
    private StringTableTypes() {
      record_ = emptyProtobufList();
      localName_ = emptyIntList();
    }
    public interface RecordOrBuilder extends
        // @@protoc_insertion_point(interface_extends:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record)
        org.jetbrains.kotlin.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       * @return Whether the range field is set.
       */
      boolean hasRange();
      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       * @return The range.
       */
      int getRange();

      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       * @return Whether the predefinedIndex field is set.
       */
      boolean hasPredefinedIndex();
      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       * @return The predefinedIndex.
       */
      int getPredefinedIndex();

      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return Whether the string field is set.
       */
      boolean hasString();
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return The string.
       */
      java.lang.String getString();
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return The bytes for string.
       */
      org.jetbrains.kotlin.protobuf.ByteString
          getStringBytes();

      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return Whether the operation field is set.
       */
      boolean hasOperation();
      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return The operation.
       */
      org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation getOperation();

      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @return A list containing the substringIndex.
       */
      java.util.List<java.lang.Integer> getSubstringIndexList();
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @return The count of substringIndex.
       */
      int getSubstringIndexCount();
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @param index The index of the element to return.
       * @return The substringIndex at the given index.
       */
      int getSubstringIndex(int index);

      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @return A list containing the replaceChar.
       */
      java.util.List<java.lang.Integer> getReplaceCharList();
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @return The count of replaceChar.
       */
      int getReplaceCharCount();
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @param index The index of the element to return.
       * @return The replaceChar at the given index.
       */
      int getReplaceChar(int index);
    }
    /**
     * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record}
     */
    public  static final class Record extends
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
            Record, Record.Builder> implements
        // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record)
        RecordOrBuilder {
      private Record() {
        range_ = 1;
        string_ = "";
        substringIndex_ = emptyIntList();
        replaceChar_ = emptyIntList();
      }
      /**
       * Protobuf enum {@code org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation}
       */
      public enum Operation
          implements org.jetbrains.kotlin.protobuf.Internal.EnumLite {
        /**
         * <code>NONE = 0;</code>
         */
        NONE(0),
        /**
         * <pre>
         * replaceAll('$', '.')
         * java/util/Map$Entry -&gt; java/util/Map.Entry;
         * </pre>
         *
         * <code>INTERNAL_TO_CLASS_ID = 1;</code>
         */
        INTERNAL_TO_CLASS_ID(1),
        /**
         * <pre>
         * substring(1, length - 1) and then replaceAll('$', '.')
         * Ljava/util/Map$Entry; -&gt; java/util/Map.Entry
         * </pre>
         *
         * <code>DESC_TO_CLASS_ID = 2;</code>
         */
        DESC_TO_CLASS_ID(2),
        ;

        /**
         * <code>NONE = 0;</code>
         */
        public static final int NONE_VALUE = 0;
        /**
         * <pre>
         * replaceAll('$', '.')
         * java/util/Map$Entry -&gt; java/util/Map.Entry;
         * </pre>
         *
         * <code>INTERNAL_TO_CLASS_ID = 1;</code>
         */
        public static final int INTERNAL_TO_CLASS_ID_VALUE = 1;
        /**
         * <pre>
         * substring(1, length - 1) and then replaceAll('$', '.')
         * Ljava/util/Map$Entry; -&gt; java/util/Map.Entry
         * </pre>
         *
         * <code>DESC_TO_CLASS_ID = 2;</code>
         */
        public static final int DESC_TO_CLASS_ID_VALUE = 2;


        @java.lang.Override
        public final int getNumber() {
          return value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Operation valueOf(int value) {
          return forNumber(value);
        }

        public static Operation forNumber(int value) {
          switch (value) {
            case 0: return NONE;
            case 1: return INTERNAL_TO_CLASS_ID;
            case 2: return DESC_TO_CLASS_ID;
            default: return null;
          }
        }

        public static org.jetbrains.kotlin.protobuf.Internal.EnumLiteMap<Operation>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final org.jetbrains.kotlin.protobuf.Internal.EnumLiteMap<
            Operation> internalValueMap =
              new org.jetbrains.kotlin.protobuf.Internal.EnumLiteMap<Operation>() {
                @java.lang.Override
                public Operation findValueByNumber(int number) {
                  return Operation.forNumber(number);
                }
              };

        public static org.jetbrains.kotlin.protobuf.Internal.EnumVerifier 
            internalGetVerifier() {
          return OperationVerifier.INSTANCE;
        }

        private static final class OperationVerifier implements 
             org.jetbrains.kotlin.protobuf.Internal.EnumVerifier { 
                static final org.jetbrains.kotlin.protobuf.Internal.EnumVerifier           INSTANCE = new OperationVerifier();
                @java.lang.Override
                public boolean isInRange(int number) {
                  return Operation.forNumber(number) != null;
                }
              };

        private final int value;

        private Operation(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation)
      }

      private int bitField0_;
      public static final int RANGE_FIELD_NUMBER = 1;
      private int range_;
      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       * @return Whether the range field is set.
       */
      @java.lang.Override
      public boolean hasRange() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       * @return The range.
       */
      @java.lang.Override
      public int getRange() {
        return range_;
      }
      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       * @param value The range to set.
       */
      private void setRange(int value) {
        bitField0_ |= 0x00000001;
        range_ = value;
      }
      /**
       * <pre>
       * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
       * </pre>
       *
       * <code>int32 range = 1 [default = 1];</code>
       */
      private void clearRange() {
        bitField0_ = (bitField0_ & ~0x00000001);
        range_ = 1;
      }

      public static final int PREDEFINED_INDEX_FIELD_NUMBER = 2;
      private int predefinedIndex_;
      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       * @return Whether the predefinedIndex field is set.
       */
      @java.lang.Override
      public boolean hasPredefinedIndex() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       * @return The predefinedIndex.
       */
      @java.lang.Override
      public int getPredefinedIndex() {
        return predefinedIndex_;
      }
      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       * @param value The predefinedIndex to set.
       */
      private void setPredefinedIndex(int value) {
        bitField0_ |= 0x00000002;
        predefinedIndex_ = value;
      }
      /**
       * <pre>
       * Index of the predefined constant. If this field is present, the associated string is ignored
       * </pre>
       *
       * <code>int32 predefined_index = 2;</code>
       */
      private void clearPredefinedIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        predefinedIndex_ = 0;
      }

      public static final int STRING_FIELD_NUMBER = 6;
      private java.lang.String string_;
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return Whether the string field is set.
       */
      @java.lang.Override
      public boolean hasString() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return The string.
       */
      @java.lang.Override
      public java.lang.String getString() {
        return string_;
      }
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @return The bytes for string.
       */
      @java.lang.Override
      public org.jetbrains.kotlin.protobuf.ByteString
          getStringBytes() {
        return org.jetbrains.kotlin.protobuf.ByteString.copyFromUtf8(string_);
      }
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @param value The string to set.
       */
      @java.lang.SuppressWarnings("ReturnValueIgnored")
      private void setString(
          java.lang.String value) {
        value.getClass();  // minimal bytecode null check
        bitField0_ |= 0x00000004;
        string_ = value;
      }
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       */
      private void clearString() {
        bitField0_ = (bitField0_ & ~0x00000004);
        string_ = getDefaultInstance().getString();
      }
      /**
       * <pre>
       * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
       * </pre>
       *
       * <code>string string = 6;</code>
       * @param value The bytes for string to set.
       */
      private void setStringBytes(
          org.jetbrains.kotlin.protobuf.ByteString value) {
        string_ = value.toStringUtf8();
        bitField0_ |= 0x00000004;
      }

      public static final int OPERATION_FIELD_NUMBER = 3;
      private int operation_;
      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return Whether the operation field is set.
       */
      @java.lang.Override
      public boolean hasOperation() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @return The operation.
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation getOperation() {
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation result = org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation.forNumber(operation_);
        return result == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation.NONE : result;
      }
      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       * @param value The operation to set.
       */
      private void setOperation(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation value) {
        operation_ = value.getNumber();
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * Perform a described operation on the string
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
       */
      private void clearOperation() {
        bitField0_ = (bitField0_ & ~0x00000008);
        operation_ = 0;
      }

      public static final int SUBSTRING_INDEX_FIELD_NUMBER = 4;
      private org.jetbrains.kotlin.protobuf.Internal.IntList substringIndex_;
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @return A list containing the substringIndex.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getSubstringIndexList() {
        return substringIndex_;
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @return The count of substringIndex.
       */
      @java.lang.Override
      public int getSubstringIndexCount() {
        return substringIndex_.size();
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @param index The index of the element to return.
       * @return The substringIndex at the given index.
       */
      @java.lang.Override
      public int getSubstringIndex(int index) {
        return substringIndex_.getInt(index);
      }
      private int substringIndexMemoizedSerializedSize = -1;
      private void ensureSubstringIndexIsMutable() {
        org.jetbrains.kotlin.protobuf.Internal.IntList tmp = substringIndex_;
        if (!tmp.isModifiable()) {
          substringIndex_ =
              org.jetbrains.kotlin.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @param index The index to set the value at.
       * @param value The substringIndex to set.
       */
      private void setSubstringIndex(
          int index, int value) {
        ensureSubstringIndexIsMutable();
        substringIndex_.setInt(index, value);
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @param value The substringIndex to add.
       */
      private void addSubstringIndex(int value) {
        ensureSubstringIndexIsMutable();
        substringIndex_.addInt(value);
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       * @param values The substringIndex to add.
       */
      private void addAllSubstringIndex(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureSubstringIndexIsMutable();
        org.jetbrains.kotlin.protobuf.AbstractMessageLite.addAll(
            values, substringIndex_);
      }
      /**
       * <pre>
       * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
       * and the second element as the end index.
       * If an operation is not NONE, it's applied _after_ this substring operation
       * </pre>
       *
       * <code>repeated int32 substring_index = 4;</code>
       */
      private void clearSubstringIndex() {
        substringIndex_ = emptyIntList();
      }

      public static final int REPLACE_CHAR_FIELD_NUMBER = 5;
      private org.jetbrains.kotlin.protobuf.Internal.IntList replaceChar_;
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @return A list containing the replaceChar.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getReplaceCharList() {
        return replaceChar_;
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @return The count of replaceChar.
       */
      @java.lang.Override
      public int getReplaceCharCount() {
        return replaceChar_.size();
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @param index The index of the element to return.
       * @return The replaceChar at the given index.
       */
      @java.lang.Override
      public int getReplaceChar(int index) {
        return replaceChar_.getInt(index);
      }
      private int replaceCharMemoizedSerializedSize = -1;
      private void ensureReplaceCharIsMutable() {
        org.jetbrains.kotlin.protobuf.Internal.IntList tmp = replaceChar_;
        if (!tmp.isModifiable()) {
          replaceChar_ =
              org.jetbrains.kotlin.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @param index The index to set the value at.
       * @param value The replaceChar to set.
       */
      private void setReplaceChar(
          int index, int value) {
        ensureReplaceCharIsMutable();
        replaceChar_.setInt(index, value);
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @param value The replaceChar to add.
       */
      private void addReplaceChar(int value) {
        ensureReplaceCharIsMutable();
        replaceChar_.addInt(value);
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       * @param values The replaceChar to add.
       */
      private void addAllReplaceChar(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureReplaceCharIsMutable();
        org.jetbrains.kotlin.protobuf.AbstractMessageLite.addAll(
            values, replaceChar_);
      }
      /**
       * <pre>
       * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
       * of the character to replace, and the second element as the code point of the replacement character
       * </pre>
       *
       * <code>repeated int32 replace_char = 5;</code>
       */
      private void clearReplaceChar() {
        replaceChar_ = emptyIntList();
      }

      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          java.nio.ByteBuffer data)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          java.nio.ByteBuffer data,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          org.jetbrains.kotlin.protobuf.ByteString data)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          org.jetbrains.kotlin.protobuf.ByteString data,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(byte[] data)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          byte[] data,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          java.io.InputStream input,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }

      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseDelimitedFrom(
          java.io.InputStream input,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          org.jetbrains.kotlin.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record parseFrom(
          org.jetbrains.kotlin.protobuf.CodedInputStream input,
          org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record prototype) {
        return DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record}
       */
      public static final class Builder extends
          org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
            org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record, Builder> implements
          // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record)
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.RecordOrBuilder {
        // Construct using org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
         * </pre>
         *
         * <code>int32 range = 1 [default = 1];</code>
         * @return Whether the range field is set.
         */
        @java.lang.Override
        public boolean hasRange() {
          return instance.hasRange();
        }
        /**
         * <pre>
         * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
         * </pre>
         *
         * <code>int32 range = 1 [default = 1];</code>
         * @return The range.
         */
        @java.lang.Override
        public int getRange() {
          return instance.getRange();
        }
        /**
         * <pre>
         * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
         * </pre>
         *
         * <code>int32 range = 1 [default = 1];</code>
         * @param value The range to set.
         * @return This builder for chaining.
         */
        public Builder setRange(int value) {
          copyOnWrite();
          instance.setRange(value);
          return this;
        }
        /**
         * <pre>
         * The number of times this record should be repeated; this is used to collapse identical subsequent records in the list
         * </pre>
         *
         * <code>int32 range = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearRange() {
          copyOnWrite();
          instance.clearRange();
          return this;
        }

        /**
         * <pre>
         * Index of the predefined constant. If this field is present, the associated string is ignored
         * </pre>
         *
         * <code>int32 predefined_index = 2;</code>
         * @return Whether the predefinedIndex field is set.
         */
        @java.lang.Override
        public boolean hasPredefinedIndex() {
          return instance.hasPredefinedIndex();
        }
        /**
         * <pre>
         * Index of the predefined constant. If this field is present, the associated string is ignored
         * </pre>
         *
         * <code>int32 predefined_index = 2;</code>
         * @return The predefinedIndex.
         */
        @java.lang.Override
        public int getPredefinedIndex() {
          return instance.getPredefinedIndex();
        }
        /**
         * <pre>
         * Index of the predefined constant. If this field is present, the associated string is ignored
         * </pre>
         *
         * <code>int32 predefined_index = 2;</code>
         * @param value The predefinedIndex to set.
         * @return This builder for chaining.
         */
        public Builder setPredefinedIndex(int value) {
          copyOnWrite();
          instance.setPredefinedIndex(value);
          return this;
        }
        /**
         * <pre>
         * Index of the predefined constant. If this field is present, the associated string is ignored
         * </pre>
         *
         * <code>int32 predefined_index = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearPredefinedIndex() {
          copyOnWrite();
          instance.clearPredefinedIndex();
          return this;
        }

        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @return Whether the string field is set.
         */
        @java.lang.Override
        public boolean hasString() {
          return instance.hasString();
        }
        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @return The string.
         */
        @java.lang.Override
        public java.lang.String getString() {
          return instance.getString();
        }
        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @return The bytes for string.
         */
        @java.lang.Override
        public org.jetbrains.kotlin.protobuf.ByteString
            getStringBytes() {
          return instance.getStringBytes();
        }
        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @param value The string to set.
         * @return This builder for chaining.
         */
        public Builder setString(
            java.lang.String value) {
          copyOnWrite();
          instance.setString(value);
          return this;
        }
        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearString() {
          copyOnWrite();
          instance.clearString();
          return this;
        }
        /**
         * <pre>
         * A string which should be used. If this field is present, both the associated string and the predefined string index are ignored
         * </pre>
         *
         * <code>string string = 6;</code>
         * @param value The bytes for string to set.
         * @return This builder for chaining.
         */
        public Builder setStringBytes(
            org.jetbrains.kotlin.protobuf.ByteString value) {
          copyOnWrite();
          instance.setStringBytes(value);
          return this;
        }

        /**
         * <pre>
         * Perform a described operation on the string
         * </pre>
         *
         * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
         * @return Whether the operation field is set.
         */
        @java.lang.Override
        public boolean hasOperation() {
          return instance.hasOperation();
        }
        /**
         * <pre>
         * Perform a described operation on the string
         * </pre>
         *
         * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
         * @return The operation.
         */
        @java.lang.Override
        public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation getOperation() {
          return instance.getOperation();
        }
        /**
         * <pre>
         * Perform a described operation on the string
         * </pre>
         *
         * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
         * @param value The enum numeric value on the wire for operation to set.
         * @return This builder for chaining.
         */
        public Builder setOperation(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation value) {
          copyOnWrite();
          instance.setOperation(value);
          return this;
        }
        /**
         * <pre>
         * Perform a described operation on the string
         * </pre>
         *
         * <code>.org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record.Operation operation = 3 [default = NONE];</code>
         * @return This builder for chaining.
         */
        public Builder clearOperation() {
          copyOnWrite();
          instance.clearOperation();
          return this;
        }

        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @return A list containing the substringIndex.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getSubstringIndexList() {
          return java.util.Collections.unmodifiableList(
              instance.getSubstringIndexList());
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @return The count of substringIndex.
         */
        @java.lang.Override
        public int getSubstringIndexCount() {
          return instance.getSubstringIndexCount();
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @param index The index of the element to return.
         * @return The substringIndex at the given index.
         */
        @java.lang.Override
        public int getSubstringIndex(int index) {
          return instance.getSubstringIndex(index);
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @param value The substringIndex to set.
         * @return This builder for chaining.
         */
        public Builder setSubstringIndex(
            int index, int value) {
          copyOnWrite();
          instance.setSubstringIndex(index, value);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @param value The substringIndex to add.
         * @return This builder for chaining.
         */
        public Builder addSubstringIndex(int value) {
          copyOnWrite();
          instance.addSubstringIndex(value);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @param values The substringIndex to add.
         * @return This builder for chaining.
         */
        public Builder addAllSubstringIndex(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllSubstringIndex(values);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "substring" operation must be performed with the first element of this list as the start index,
         * and the second element as the end index.
         * If an operation is not NONE, it's applied _after_ this substring operation
         * </pre>
         *
         * <code>repeated int32 substring_index = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearSubstringIndex() {
          copyOnWrite();
          instance.clearSubstringIndex();
          return this;
        }

        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @return A list containing the replaceChar.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getReplaceCharList() {
          return java.util.Collections.unmodifiableList(
              instance.getReplaceCharList());
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @return The count of replaceChar.
         */
        @java.lang.Override
        public int getReplaceCharCount() {
          return instance.getReplaceCharCount();
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @param index The index of the element to return.
         * @return The replaceChar at the given index.
         */
        @java.lang.Override
        public int getReplaceChar(int index) {
          return instance.getReplaceChar(index);
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @param value The replaceChar to set.
         * @return This builder for chaining.
         */
        public Builder setReplaceChar(
            int index, int value) {
          copyOnWrite();
          instance.setReplaceChar(index, value);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @param value The replaceChar to add.
         * @return This builder for chaining.
         */
        public Builder addReplaceChar(int value) {
          copyOnWrite();
          instance.addReplaceChar(value);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @param values The replaceChar to add.
         * @return This builder for chaining.
         */
        public Builder addAllReplaceChar(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllReplaceChar(values);
          return this;
        }
        /**
         * <pre>
         * If this field is present, the "replaceAll" operation must be performed with the first element of this list as the code point
         * of the character to replace, and the second element as the code point of the replacement character
         * </pre>
         *
         * <code>repeated int32 replace_char = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearReplaceChar() {
          copyOnWrite();
          instance.clearReplaceChar();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "range_",
                "predefinedIndex_",
                "operation_",
                org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Operation.internalGetVerifier(),
                "substringIndex_",
                "replaceChar_",
                "string_",
              };
              java.lang.String info =
                  "\u0004\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0002\u0000\u0001\u1004\u0000\u0002" +
                  "\u1004\u0001\u0003\u180c\u0003\u0004\'\u0005\'\u0006\u1008\u0002";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> parser = PARSER;
            if (parser == null) {
              synchronized (org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record)
      private static final org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record DEFAULT_INSTANCE;
      static {
        Record defaultInstance = new Record();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Record.class, defaultInstance);
      }

      public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile org.jetbrains.kotlin.protobuf.Parser<Record> PARSER;

      public static org.jetbrains.kotlin.protobuf.Parser<Record> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int RECORD_FIELD_NUMBER = 1;
    private org.jetbrains.kotlin.protobuf.Internal.ProtobufList<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> record_;
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> getRecordList() {
      return record_;
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    public java.util.List<? extends org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.RecordOrBuilder> 
        getRecordOrBuilderList() {
      return record_;
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.Override
    public int getRecordCount() {
      return record_.size();
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record getRecord(int index) {
      return record_.get(index);
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.RecordOrBuilder getRecordOrBuilder(
        int index) {
      return record_.get(index);
    }
    private void ensureRecordIsMutable() {
      org.jetbrains.kotlin.protobuf.Internal.ProtobufList<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> tmp = record_;
      if (!tmp.isModifiable()) {
        record_ =
            org.jetbrains.kotlin.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setRecord(
        int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
      value.getClass();  // minimal bytecode null check
      ensureRecordIsMutable();
      record_.set(index, value);
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void addRecord(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
      value.getClass();  // minimal bytecode null check
      ensureRecordIsMutable();
      record_.add(value);
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void addRecord(
        int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
      value.getClass();  // minimal bytecode null check
      ensureRecordIsMutable();
      record_.add(index, value);
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    private void addAllRecord(
        java.lang.Iterable<? extends org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> values) {
      ensureRecordIsMutable();
      org.jetbrains.kotlin.protobuf.AbstractMessageLite.addAll(
          values, record_);
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    private void clearRecord() {
      record_ = emptyProtobufList();
    }
    /**
     * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
     */
    private void removeRecord(int index) {
      ensureRecordIsMutable();
      record_.remove(index);
    }

    public static final int LOCAL_NAME_FIELD_NUMBER = 5;
    private org.jetbrains.kotlin.protobuf.Internal.IntList localName_;
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @return A list containing the localName.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getLocalNameList() {
      return localName_;
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @return The count of localName.
     */
    @java.lang.Override
    public int getLocalNameCount() {
      return localName_.size();
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @param index The index of the element to return.
     * @return The localName at the given index.
     */
    @java.lang.Override
    public int getLocalName(int index) {
      return localName_.getInt(index);
    }
    private int localNameMemoizedSerializedSize = -1;
    private void ensureLocalNameIsMutable() {
      org.jetbrains.kotlin.protobuf.Internal.IntList tmp = localName_;
      if (!tmp.isModifiable()) {
        localName_ =
            org.jetbrains.kotlin.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @param index The index to set the value at.
     * @param value The localName to set.
     */
    private void setLocalName(
        int index, int value) {
      ensureLocalNameIsMutable();
      localName_.setInt(index, value);
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @param value The localName to add.
     */
    private void addLocalName(int value) {
      ensureLocalNameIsMutable();
      localName_.addInt(value);
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     * @param values The localName to add.
     */
    private void addAllLocalName(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureLocalNameIsMutable();
      org.jetbrains.kotlin.protobuf.AbstractMessageLite.addAll(
          values, localName_);
    }
    /**
     * <pre>
     * Indices of strings which are names of local classes or anonymous objects
     * </pre>
     *
     * <code>repeated int32 local_name = 5;</code>
     */
    private void clearLocalName() {
      localName_ = emptyIntList();
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        java.nio.ByteBuffer data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        java.nio.ByteBuffer data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(byte[] data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        byte[] data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseDelimitedFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes prototype) {
      return DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.StringTableTypes}
     */
    public static final class Builder extends
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes, Builder> implements
        // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.metadata.jvm.StringTableTypes)
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypesOrBuilder {
      // Construct using org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      @java.lang.Override
      public java.util.List<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> getRecordList() {
        return java.util.Collections.unmodifiableList(
            instance.getRecordList());
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      @java.lang.Override
      public int getRecordCount() {
        return instance.getRecordCount();
      }/**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record getRecord(int index) {
        return instance.getRecord(index);
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder setRecord(
          int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
        copyOnWrite();
        instance.setRecord(index, value);
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder setRecord(
          int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Builder builderForValue) {
        copyOnWrite();
        instance.setRecord(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder addRecord(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
        copyOnWrite();
        instance.addRecord(value);
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder addRecord(
          int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record value) {
        copyOnWrite();
        instance.addRecord(index, value);
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder addRecord(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Builder builderForValue) {
        copyOnWrite();
        instance.addRecord(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder addRecord(
          int index, org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.Builder builderForValue) {
        copyOnWrite();
        instance.addRecord(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder addAllRecord(
          java.lang.Iterable<? extends org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record> values) {
        copyOnWrite();
        instance.addAllRecord(values);
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder clearRecord() {
        copyOnWrite();
        instance.clearRecord();
        return this;
      }
      /**
       * <code>repeated .org.jetbrains.kotlin.metadata.jvm.StringTableTypes.Record record = 1;</code>
       */
      public Builder removeRecord(int index) {
        copyOnWrite();
        instance.removeRecord(index);
        return this;
      }

      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @return A list containing the localName.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getLocalNameList() {
        return java.util.Collections.unmodifiableList(
            instance.getLocalNameList());
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @return The count of localName.
       */
      @java.lang.Override
      public int getLocalNameCount() {
        return instance.getLocalNameCount();
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @param index The index of the element to return.
       * @return The localName at the given index.
       */
      @java.lang.Override
      public int getLocalName(int index) {
        return instance.getLocalName(index);
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @param value The localName to set.
       * @return This builder for chaining.
       */
      public Builder setLocalName(
          int index, int value) {
        copyOnWrite();
        instance.setLocalName(index, value);
        return this;
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @param value The localName to add.
       * @return This builder for chaining.
       */
      public Builder addLocalName(int value) {
        copyOnWrite();
        instance.addLocalName(value);
        return this;
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @param values The localName to add.
       * @return This builder for chaining.
       */
      public Builder addAllLocalName(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllLocalName(values);
        return this;
      }
      /**
       * <pre>
       * Indices of strings which are names of local classes or anonymous objects
       * </pre>
       *
       * <code>repeated int32 local_name = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalName() {
        copyOnWrite();
        instance.clearLocalName();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.metadata.jvm.StringTableTypes)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "record_",
              org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.Record.class,
              "localName_",
            };
            java.lang.String info =
                "\u0004\u0002\u0000\u0000\u0001\u0005\u0002\u0000\u0002\u0000\u0001\u001b\u0005\'" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes> parser = PARSER;
          if (parser == null) {
            synchronized (org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.metadata.jvm.StringTableTypes)
    private static final org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes DEFAULT_INSTANCE;
    static {
      StringTableTypes defaultInstance = new StringTableTypes();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
        StringTableTypes.class, defaultInstance);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.StringTableTypes getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile org.jetbrains.kotlin.protobuf.Parser<StringTableTypes> PARSER;

    public static org.jetbrains.kotlin.protobuf.Parser<StringTableTypes> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface JvmMethodSignatureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature)
      org.jetbrains.kotlin.protobuf.MessageLiteOrBuilder {

    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The name.
     */
    int getName();

    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the desc field is set.
     */
    boolean hasDesc();
    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The desc.
     */
    int getDesc();
  }
  /**
   * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature}
   */
  public  static final class JvmMethodSignature extends
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
          JvmMethodSignature, JvmMethodSignature.Builder> implements
      // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature)
      JvmMethodSignatureOrBuilder {
    private JvmMethodSignature() {
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private int name_;
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The name.
     */
    @java.lang.Override
    public int getName() {
      return name_;
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @param value The name to set.
     */
    private void setName(int value) {
      bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = 0;
    }

    public static final int DESC_FIELD_NUMBER = 2;
    private int desc_;
    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the desc field is set.
     */
    @java.lang.Override
    public boolean hasDesc() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The desc.
     */
    @java.lang.Override
    public int getDesc() {
      return desc_;
    }
    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @param value The desc to set.
     */
    private void setDesc(int value) {
      bitField0_ |= 0x00000002;
      desc_ = value;
    }
    /**
     * <pre>
     * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     */
    private void clearDesc() {
      bitField0_ = (bitField0_ & ~0x00000002);
      desc_ = 0;
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        java.nio.ByteBuffer data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        java.nio.ByteBuffer data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(byte[] data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        byte[] data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseDelimitedFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature prototype) {
      return DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature}
     */
    public static final class Builder extends
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature, Builder> implements
        // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature)
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignatureOrBuilder {
      // Construct using org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return The name.
       */
      @java.lang.Override
      public int getName() {
        return instance.getName();
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(int value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }

      /**
       * <pre>
       * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return Whether the desc field is set.
       */
      @java.lang.Override
      public boolean hasDesc() {
        return instance.hasDesc();
      }
      /**
       * <pre>
       * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return The desc.
       */
      @java.lang.Override
      public int getDesc() {
        return instance.getDesc();
      }
      /**
       * <pre>
       * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @param value The desc to set.
       * @return This builder for chaining.
       */
      public Builder setDesc(int value) {
        copyOnWrite();
        instance.setDesc(value);
        return this;
      }
      /**
       * <pre>
       * JVM descriptor of the method, e.g. '(Ljava/util/List;)[Ljava/lang/Object;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearDesc() {
        copyOnWrite();
        instance.clearDesc();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "desc_",
            };
            java.lang.String info =
                "\u0004\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                "\u1004\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature> parser = PARSER;
          if (parser == null) {
            synchronized (org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature)
    private static final org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature DEFAULT_INSTANCE;
    static {
      JvmMethodSignature defaultInstance = new JvmMethodSignature();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
        JvmMethodSignature.class, defaultInstance);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile org.jetbrains.kotlin.protobuf.Parser<JvmMethodSignature> PARSER;

    public static org.jetbrains.kotlin.protobuf.Parser<JvmMethodSignature> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface JvmFieldSignatureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature)
      org.jetbrains.kotlin.protobuf.MessageLiteOrBuilder {

    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The name.
     */
    int getName();

    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the desc field is set.
     */
    boolean hasDesc();
    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The desc.
     */
    int getDesc();
  }
  /**
   * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature}
   */
  public  static final class JvmFieldSignature extends
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
          JvmFieldSignature, JvmFieldSignature.Builder> implements
      // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature)
      JvmFieldSignatureOrBuilder {
    private JvmFieldSignature() {
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private int name_;
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The name.
     */
    @java.lang.Override
    public int getName() {
      return name_;
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @param value The name to set.
     */
    private void setName(int value) {
      bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = 0;
    }

    public static final int DESC_FIELD_NUMBER = 2;
    private int desc_;
    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return Whether the desc field is set.
     */
    @java.lang.Override
    public boolean hasDesc() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @return The desc.
     */
    @java.lang.Override
    public int getDesc() {
      return desc_;
    }
    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     * @param value The desc to set.
     */
    private void setDesc(int value) {
      bitField0_ |= 0x00000002;
      desc_ = value;
    }
    /**
     * <pre>
     * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
     * </pre>
     *
     * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
     */
    private void clearDesc() {
      bitField0_ = (bitField0_ & ~0x00000002);
      desc_ = 0;
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        java.nio.ByteBuffer data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        java.nio.ByteBuffer data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(byte[] data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        byte[] data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseDelimitedFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature prototype) {
      return DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature}
     */
    public static final class Builder extends
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature, Builder> implements
        // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature)
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignatureOrBuilder {
      // Construct using org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return The name.
       */
      @java.lang.Override
      public int getName() {
        return instance.getName();
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(int value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>int32 name = 1 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }

      /**
       * <pre>
       * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return Whether the desc field is set.
       */
      @java.lang.Override
      public boolean hasDesc() {
        return instance.hasDesc();
      }
      /**
       * <pre>
       * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return The desc.
       */
      @java.lang.Override
      public int getDesc() {
        return instance.getDesc();
      }
      /**
       * <pre>
       * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @param value The desc to set.
       * @return This builder for chaining.
       */
      public Builder setDesc(int value) {
        copyOnWrite();
        instance.setDesc(value);
        return this;
      }
      /**
       * <pre>
       * JVM descriptor of the field type, e.g. 'Ljava/lang/String;'
       * </pre>
       *
       * <code>int32 desc = 2 [(.org.jetbrains.kotlin.metadata.string_id_in_table) = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearDesc() {
        copyOnWrite();
        instance.clearDesc();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "desc_",
            };
            java.lang.String info =
                "\u0004\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                "\u1004\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature> parser = PARSER;
          if (parser == null) {
            synchronized (org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature)
    private static final org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature DEFAULT_INSTANCE;
    static {
      JvmFieldSignature defaultInstance = new JvmFieldSignature();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
        JvmFieldSignature.class, defaultInstance);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile org.jetbrains.kotlin.protobuf.Parser<JvmFieldSignature> PARSER;

    public static org.jetbrains.kotlin.protobuf.Parser<JvmFieldSignature> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface JvmPropertySignatureOrBuilder extends
      // @@protoc_insertion_point(interface_extends:org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature)
      org.jetbrains.kotlin.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     * @return Whether the field field is set.
     */
    boolean hasField();
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     * @return The field.
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature getField();

    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     * @return Whether the syntheticMethod field is set.
     */
    boolean hasSyntheticMethod();
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     * @return The syntheticMethod.
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSyntheticMethod();

    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     * @return Whether the getter field is set.
     */
    boolean hasGetter();
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     * @return The getter.
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getGetter();

    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     * @return Whether the setter field is set.
     */
    boolean hasSetter();
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     * @return The setter.
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSetter();

    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     * @return Whether the delegateMethod field is set.
     */
    boolean hasDelegateMethod();
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     * @return The delegateMethod.
     */
    org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getDelegateMethod();
  }
  /**
   * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature}
   */
  public  static final class JvmPropertySignature extends
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
          JvmPropertySignature, JvmPropertySignature.Builder> implements
      // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature)
      JvmPropertySignatureOrBuilder {
    private JvmPropertySignature() {
    }
    private int bitField0_;
    public static final int FIELD_FIELD_NUMBER = 1;
    private org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature field_;
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    @java.lang.Override
    public boolean hasField() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature getField() {
      return field_ == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.getDefaultInstance() : field_;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setField(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature value) {
      value.getClass();  // minimal bytecode null check
      field_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality", "ReturnValueIgnored"})
    private void mergeField(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature value) {
      value.getClass();  // minimal bytecode null check
      if (field_ != null &&
          field_ != org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.getDefaultInstance()) {
        field_ =
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.newBuilder(field_).mergeFrom(value).buildPartial();
      } else {
        field_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
     */
    private void clearField() {  field_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int SYNTHETIC_METHOD_FIELD_NUMBER = 2;
    private org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature syntheticMethod_;
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    @java.lang.Override
    public boolean hasSyntheticMethod() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSyntheticMethod() {
      return syntheticMethod_ == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance() : syntheticMethod_;
    }
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setSyntheticMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      syntheticMethod_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality", "ReturnValueIgnored"})
    private void mergeSyntheticMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      if (syntheticMethod_ != null &&
          syntheticMethod_ != org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance()) {
        syntheticMethod_ =
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.newBuilder(syntheticMethod_).mergeFrom(value).buildPartial();
      } else {
        syntheticMethod_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Annotations on properties are written on a synthetic method with this signature
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
     */
    private void clearSyntheticMethod() {  syntheticMethod_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int GETTER_FIELD_NUMBER = 3;
    private org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getter_;
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    @java.lang.Override
    public boolean hasGetter() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getGetter() {
      return getter_ == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance() : getter_;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setGetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      getter_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality", "ReturnValueIgnored"})
    private void mergeGetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      if (getter_ != null &&
          getter_ != org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance()) {
        getter_ =
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.newBuilder(getter_).mergeFrom(value).buildPartial();
      } else {
        getter_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
     */
    private void clearGetter() {  getter_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int SETTER_FIELD_NUMBER = 4;
    private org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature setter_;
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    @java.lang.Override
    public boolean hasSetter() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSetter() {
      return setter_ == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance() : setter_;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setSetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      setter_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality", "ReturnValueIgnored"})
    private void mergeSetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      if (setter_ != null &&
          setter_ != org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance()) {
        setter_ =
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.newBuilder(setter_).mergeFrom(value).buildPartial();
      } else {
        setter_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
     */
    private void clearSetter() {  setter_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int DELEGATE_METHOD_FIELD_NUMBER = 5;
    private org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature delegateMethod_;
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    @java.lang.Override
    public boolean hasDelegateMethod() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    @java.lang.Override
    public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getDelegateMethod() {
      return delegateMethod_ == null ? org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance() : delegateMethod_;
    }
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    @java.lang.SuppressWarnings("ReturnValueIgnored")
    private void setDelegateMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      delegateMethod_ = value;
      bitField0_ |= 0x00000010;
      }
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality", "ReturnValueIgnored"})
    private void mergeDelegateMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
      value.getClass();  // minimal bytecode null check
      if (delegateMethod_ != null &&
          delegateMethod_ != org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance()) {
        delegateMethod_ =
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.newBuilder(delegateMethod_).mergeFrom(value).buildPartial();
      } else {
        delegateMethod_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * The delegate field of delegated properties may be optimized out; `getDelegate` should
     * then call this method instead
     * </pre>
     *
     * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
     */
    private void clearDelegateMethod() {  delegateMethod_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        java.nio.ByteBuffer data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        java.nio.ByteBuffer data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        org.jetbrains.kotlin.protobuf.ByteString data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(byte[] data)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        byte[] data,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseDelimitedFrom(
        java.io.InputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature parseFrom(
        org.jetbrains.kotlin.protobuf.CodedInputStream input,
        org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature prototype) {
      return DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature}
     */
    public static final class Builder extends
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature, Builder> implements
        // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature)
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignatureOrBuilder {
      // Construct using org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      @java.lang.Override
      public boolean hasField() {
        return instance.hasField();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature getField() {
        return instance.getField();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      public Builder setField(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature value) {
        copyOnWrite();
        instance.setField(value);
        return this;
        }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      public Builder setField(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setField(builderForValue.build());
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      public Builder mergeField(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmFieldSignature value) {
        copyOnWrite();
        instance.mergeField(value);
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmFieldSignature field = 1;</code>
       */
      public Builder clearField() {  copyOnWrite();
        instance.clearField();
        return this;
      }

      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      @java.lang.Override
      public boolean hasSyntheticMethod() {
        return instance.hasSyntheticMethod();
      }
      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSyntheticMethod() {
        return instance.getSyntheticMethod();
      }
      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      public Builder setSyntheticMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.setSyntheticMethod(value);
        return this;
        }
      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      public Builder setSyntheticMethod(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setSyntheticMethod(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      public Builder mergeSyntheticMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.mergeSyntheticMethod(value);
        return this;
      }
      /**
       * <pre>
       * Annotations on properties are written on a synthetic method with this signature
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature synthetic_method = 2;</code>
       */
      public Builder clearSyntheticMethod() {  copyOnWrite();
        instance.clearSyntheticMethod();
        return this;
      }

      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      @java.lang.Override
      public boolean hasGetter() {
        return instance.hasGetter();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getGetter() {
        return instance.getGetter();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      public Builder setGetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.setGetter(value);
        return this;
        }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      public Builder setGetter(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setGetter(builderForValue.build());
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      public Builder mergeGetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.mergeGetter(value);
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature getter = 3;</code>
       */
      public Builder clearGetter() {  copyOnWrite();
        instance.clearGetter();
        return this;
      }

      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      @java.lang.Override
      public boolean hasSetter() {
        return instance.hasSetter();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getSetter() {
        return instance.getSetter();
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      public Builder setSetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.setSetter(value);
        return this;
        }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      public Builder setSetter(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setSetter(builderForValue.build());
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      public Builder mergeSetter(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.mergeSetter(value);
        return this;
      }
      /**
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature setter = 4;</code>
       */
      public Builder clearSetter() {  copyOnWrite();
        instance.clearSetter();
        return this;
      }

      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      @java.lang.Override
      public boolean hasDelegateMethod() {
        return instance.hasDelegateMethod();
      }
      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      @java.lang.Override
      public org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature getDelegateMethod() {
        return instance.getDelegateMethod();
      }
      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      public Builder setDelegateMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.setDelegateMethod(value);
        return this;
        }
      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      public Builder setDelegateMethod(
          org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.Builder builderForValue) {
        copyOnWrite();
        instance.setDelegateMethod(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      public Builder mergeDelegateMethod(org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature value) {
        copyOnWrite();
        instance.mergeDelegateMethod(value);
        return this;
      }
      /**
       * <pre>
       * The delegate field of delegated properties may be optimized out; `getDelegate` should
       * then call this method instead
       * </pre>
       *
       * <code>.org.jetbrains.kotlin.metadata.jvm.JvmMethodSignature delegate_method = 5;</code>
       */
      public Builder clearDelegateMethod() {  copyOnWrite();
        instance.clearDelegateMethod();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "field_",
              "syntheticMethod_",
              "getter_",
              "setter_",
              "delegateMethod_",
            };
            java.lang.String info =
                "\u0004\u0005\u0000\u0001\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u1009\u0000\u0002" +
                "\u1009\u0001\u0003\u1009\u0002\u0004\u1009\u0003\u0005\u1009\u0004";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature> parser = PARSER;
          if (parser == null) {
            synchronized (org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.metadata.jvm.JvmPropertySignature)
    private static final org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature DEFAULT_INSTANCE;
    static {
      JvmPropertySignature defaultInstance = new JvmPropertySignature();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
        JvmPropertySignature.class, defaultInstance);
    }

    public static org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile org.jetbrains.kotlin.protobuf.Parser<JvmPropertySignature> PARSER;

    public static org.jetbrains.kotlin.protobuf.Parser<JvmPropertySignature> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public static final int CONSTRUCTOR_SIGNATURE_FIELD_NUMBER = 100;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Constructor { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Constructor,
      org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature> constructorSignature = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Constructor.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance(),
        null,
        100,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.class);
  public static final int METHOD_SIGNATURE_FIELD_NUMBER = 100;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Function { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Function,
      org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature> methodSignature = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Function.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.getDefaultInstance(),
        null,
        100,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmMethodSignature.class);
  public static final int LAMBDA_CLASS_ORIGIN_NAME_FIELD_NUMBER = 101;
  /**
   * <pre>
   * For lambdas from bodies of inline functions copied to the use site, the JVM internal name of the original
   * lambda class this class is copied from
   * </pre>
   *
   * <code>extend .org.jetbrains.kotlin.metadata.Function { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Function,
      java.lang.Integer> lambdaClassOriginName = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Function.getDefaultInstance(),
        0,
        null,
        null,
        101,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int PROPERTY_SIGNATURE_FIELD_NUMBER = 100;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Property { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Property,
      org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature> propertySignature = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature.getDefaultInstance(),
        null,
        100,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf.JvmPropertySignature.class);
  public static final int FLAGS_FIELD_NUMBER = 101;
  /**
   * <pre>
   * *
   * isMovedFromInterfaceCompanion   true if this property is declared in an interface companion, and the field is stored in the interface
   * </pre>
   *
   * <code>extend .org.jetbrains.kotlin.metadata.Property { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Property,
      java.lang.Integer> flags = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.getDefaultInstance(),
        0,
        null,
        null,
        101,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int TYPE_ANNOTATION_FIELD_NUMBER = 100;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Type { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Type,
      java.util.List<org.jetbrains.kotlin.metadata.ProtoBuf.Annotation>> typeAnnotation = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newRepeatedGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Type.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.ProtoBuf.Annotation.getDefaultInstance(),
        null,
        100,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        false,
        org.jetbrains.kotlin.metadata.ProtoBuf.Annotation.class);
  public static final int IS_RAW_FIELD_NUMBER = 101;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Type { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Type,
      java.lang.Boolean> isRaw = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Type.getDefaultInstance(),
        false,
        null,
        null,
        101,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.BOOL,
        java.lang.Boolean.class);
  public static final int TYPE_PARAMETER_ANNOTATION_FIELD_NUMBER = 100;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.TypeParameter { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.TypeParameter,
      java.util.List<org.jetbrains.kotlin.metadata.ProtoBuf.Annotation>> typeParameterAnnotation = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newRepeatedGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.TypeParameter.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.ProtoBuf.Annotation.getDefaultInstance(),
        null,
        100,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        false,
        org.jetbrains.kotlin.metadata.ProtoBuf.Annotation.class);
  public static final int CLASS_MODULE_NAME_FIELD_NUMBER = 101;
  /**
   * <pre>
   * If absent, assumed to be "main" (JvmProtoBufUtil.DEFAULT_MODULE_NAME)
   * </pre>
   *
   * <code>extend .org.jetbrains.kotlin.metadata.Class { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Class,
      java.lang.Integer> classModuleName = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Class.getDefaultInstance(),
        0,
        null,
        null,
        101,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int CLASS_LOCAL_VARIABLE_FIELD_NUMBER = 102;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Class { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Class,
      java.util.List<org.jetbrains.kotlin.metadata.ProtoBuf.Property>> classLocalVariable = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newRepeatedGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Class.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.getDefaultInstance(),
        null,
        102,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        false,
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.class);
  public static final int ANONYMOUS_OBJECT_ORIGIN_NAME_FIELD_NUMBER = 103;
  /**
   * <pre>
   * For anonymous objects from bodies of inline functions copied to the use site, the JVM internal name of the original
   * anonymous object this class is copied from
   * </pre>
   *
   * <code>extend .org.jetbrains.kotlin.metadata.Class { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Class,
      java.lang.Integer> anonymousObjectOriginName = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Class.getDefaultInstance(),
        0,
        null,
        null,
        103,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int JVM_CLASS_FLAGS_FIELD_NUMBER = 104;
  /**
   * <pre>
   * first bit: isFunctionBodyInInterface: 0 if actual body generated in DefaultImpl, 1 - otherwise (in interface default method)
   * second bit: is all-compatibility mode or not, 1 - yes, 0 - no
   * </pre>
   *
   * <code>extend .org.jetbrains.kotlin.metadata.Class { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Class,
      java.lang.Integer> jvmClassFlags = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Class.getDefaultInstance(),
        0,
        null,
        null,
        104,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int PACKAGE_MODULE_NAME_FIELD_NUMBER = 101;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Package { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Package,
      java.lang.Integer> packageModuleName = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newSingularGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Package.getDefaultInstance(),
        0,
        null,
        null,
        101,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.INT32,
        java.lang.Integer.class);
  public static final int PACKAGE_LOCAL_VARIABLE_FIELD_NUMBER = 102;
  /**
   * <code>extend .org.jetbrains.kotlin.metadata.Package { ... }</code>
   */
  public static final
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.GeneratedExtension<
      org.jetbrains.kotlin.metadata.ProtoBuf.Package,
      java.util.List<org.jetbrains.kotlin.metadata.ProtoBuf.Property>> packageLocalVariable = org.jetbrains.kotlin.protobuf.GeneratedMessageLite
          .newRepeatedGeneratedExtension(
        org.jetbrains.kotlin.metadata.ProtoBuf.Package.getDefaultInstance(),
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.getDefaultInstance(),
        null,
        102,
        org.jetbrains.kotlin.protobuf.WireFormat.FieldType.MESSAGE,
        false,
        org.jetbrains.kotlin.metadata.ProtoBuf.Property.class);

  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}