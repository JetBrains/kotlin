KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.Array<out ERROR_TYPE>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (ERROR_TYPE),
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.Array<out ERROR_TYPE>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.Array<out T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (ERROR_TYPE),
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.BooleanArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>, valueTransform: kotlin.Function1<kotlin.Boolean, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Boolean, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.BooleanArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Boolean>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.BooleanArray, keySelector: kotlin.Function1<kotlin.Boolean, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Boolean>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Boolean, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Boolean, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ByteArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>, valueTransform: kotlin.Function1<kotlin.Byte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Byte, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ByteArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Byte>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ByteArray, keySelector: kotlin.Function1<kotlin.Byte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Byte>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Byte, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Byte, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Char>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.CharArray, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharSequence
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>, valueTransform: kotlin.Function1<kotlin.Char, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/text/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Char, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> defined in kotlin.text>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.CharSequence
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Char>>
        symbol = kotlin/text/groupBy(<extension receiver>: kotlin.CharSequence, keySelector: kotlin.Function1<kotlin.Char, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Char>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Char, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/text/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Char, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Char, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.DoubleArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>, valueTransform: kotlin.Function1<kotlin.Double, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Double, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Double, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Double, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.DoubleArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Double>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.DoubleArray, keySelector: kotlin.Function1<kotlin.Double, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Double>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Double, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Double, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Double, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.FloatArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>, valueTransform: kotlin.Function1<kotlin.Float, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Float, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Float, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Float, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.FloatArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Float>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.FloatArray, keySelector: kotlin.Function1<kotlin.Float, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Float>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Float, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Float, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Float, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.IntArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>, valueTransform: kotlin.Function1<kotlin.Int, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Int, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Int, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Int, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.IntArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Int>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.IntArray, keySelector: kotlin.Function1<kotlin.Int, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Int, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Int, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Int, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.LongArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>, valueTransform: kotlin.Function1<kotlin.Long, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Long, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Long, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Long, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.LongArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Long>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.LongArray, keySelector: kotlin.Function1<kotlin.Long, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Long>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Long, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Long, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Long, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ShortArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>, valueTransform: kotlin.Function1<kotlin.Short, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Short, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Short, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.Short, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ShortArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Short>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ShortArray, keySelector: kotlin.Function1<kotlin.Short, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Short>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Short, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Short, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Short, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UByteArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>, valueTransform: kotlin.Function1<kotlin.UByte, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.UByte, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UByteArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UByte>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UByteArray, keySelector: kotlin.Function1<kotlin.UByte, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UByte>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UByte, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UByte, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UIntArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>, valueTransform: kotlin.Function1<kotlin.UInt, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.UInt, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UIntArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UInt>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UIntArray, keySelector: kotlin.Function1<kotlin.UInt, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UInt>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UInt, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UInt, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ULongArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>, valueTransform: kotlin.Function1<kotlin.ULong, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.ULong, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.ULongArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.ULong>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.ULongArray, keySelector: kotlin.Function1<kotlin.ULong, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.ULong>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.ULong, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.ULong, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UShortArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>, valueTransform: kotlin.Function1<kotlin.UShort, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<kotlin.UShort, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.UShortArray
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.UShort>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.UShortArray, keySelector: kotlin.Function1<kotlin.UShort, K>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.UShort>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.UShort, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.UShort, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: OTHER_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = true

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.collections>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.collections.IndexedValue<kotlin.Int>>>
        symbol = kotlin/collections/groupBy(<extension receiver>: kotlin.collections.Iterable<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/collections/groupBy
    typeArgumentsMapping = {
      T -> (kotlin.collections.IndexedValue<kotlin.Int>),
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.collections.IndexedValue<kotlin.Int>, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<kotlin.Int>>
        symbol = /groupBy(<extension receiver>: kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>, keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>, valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>): kotlin.collections.Map<K, kotlin.collections.List<kotlin.Int>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
            symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = /groupBy
    typeArgumentsMapping = {
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
        symbol = valueTransform: kotlin.Function1<kotlin.Pair<kotlin.Int, kotlin.Int>, kotlin.Int>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<TOO_MANY_ARGUMENTS: Too many arguments for public inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> defined in kotlin.sequences>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.sequences.Sequence<ERROR_TYPE>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>): kotlin.collections.Map<K, kotlin.collections.List<T>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/sequences/groupBy
    typeArgumentsMapping = {
      T -> (ERROR_TYPE),
      K -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false

KtInapplicableCallCandidateInfo:
  diagnostic = ERROR<null: RECEIVER_TYPE_ERROR with groupBy>
  candidate = KtSimpleFunctionCall:
    isImplicitInvoke = false
    partiallyAppliedSymbol = KtPartiallyAppliedSymbol:
      dispatchReceiver = null
      extensionReceiver = KtExplicitReceiverValue:
        expression = nums.withIndex()
        isSafeNavigation = false
        type = kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
      signature = KtFunctionLikeSignature:
        receiverType = kotlin.sequences.Sequence<ERROR_TYPE>
        returnType = kotlin.collections.Map<ERROR_TYPE, kotlin.collections.List<ERROR_TYPE>>
        symbol = kotlin/sequences/groupBy(<extension receiver>: kotlin.sequences.Sequence<T>, keySelector: kotlin.Function1<T, K>, valueTransform: kotlin.Function1<T, V>): kotlin.collections.Map<K, kotlin.collections.List<V>>
        valueParameters = [
          KtVariableLikeSignature:
            name = keySelector
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = keySelector: kotlin.Function1<T, K>
            callableIdIfNonLocal = null,
          KtVariableLikeSignature:
            name = valueTransform
            receiverType = null
            returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
            symbol = valueTransform: kotlin.Function1<T, V>
            callableIdIfNonLocal = null
        ]
        callableIdIfNonLocal = kotlin/sequences/groupBy
    typeArgumentsMapping = {
      T -> (ERROR_TYPE),
      K -> (ERROR_TYPE),
      V -> (ERROR_TYPE)
    }
    argumentMapping = {
      { (_, value) -> value } -> (KtVariableLikeSignature:
        name = keySelector
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = keySelector: kotlin.Function1<T, K>
        callableIdIfNonLocal = null),
      { (idx, _) -> idx } -> (KtVariableLikeSignature:
        name = valueTransform
        receiverType = null
        returnType = kotlin.Function1<ERROR_TYPE, ERROR_TYPE>
        symbol = valueTransform: kotlin.Function1<T, V>
        callableIdIfNonLocal = null)
    }
  isInBestCandidates = false