package-fragment kotlin

public fun </*0*/ reified T> arrayOfNulls(/*0*/ size: kotlin.Int): kotlin.Array<T?>
@kotlin.Deprecated(message = "This function is deprecated, use === instead", replaceWith = kotlin.ReplaceWith(expression = "this === other", imports = {})) public fun kotlin.Any?.identityEquals(/*0*/ other: kotlin.Any?): kotlin.Boolean
public operator fun kotlin.String?.plus(/*0*/ other: kotlin.Any?): kotlin.String
public fun kotlin.Any?.toString(): kotlin.String

public interface Annotation {
}

public open class Any {
    /*primary*/ public constructor Any()
}

public final class Array</*0*/ T> : kotlin.Cloneable {
    /*primary*/ private constructor Array</*0*/ T>()
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.Array<T>
    public final operator fun get(/*0*/ index: kotlin.Int): T
    public final operator fun iterator(): kotlin.Iterator<T>
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: T): kotlin.Unit
}

public final class Boolean : kotlin.Comparable<kotlin.Boolean> {
    /*primary*/ private constructor Boolean()
    public final infix fun and(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Boolean): kotlin.Int
    public final operator fun not(): kotlin.Boolean
    public final infix fun or(/*0*/ other: kotlin.Boolean): kotlin.Boolean
    public final infix fun xor(/*0*/ other: kotlin.Boolean): kotlin.Boolean
}

public final class BooleanArray : kotlin.Cloneable {
    /*primary*/ public constructor BooleanArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.BooleanArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Boolean
    public final operator fun iterator(): kotlin.BooleanIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Boolean): kotlin.Unit
}

public abstract class BooleanIterator : kotlin.Iterator<kotlin.Boolean> {
    /*primary*/ public constructor BooleanIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Boolean
    public abstract fun nextBoolean(): kotlin.Boolean
}

public final class Byte : kotlin.Number, kotlin.Comparable<kotlin.Byte> {
    /*primary*/ private constructor Byte()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Byte
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Byte
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.IntRange
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int

    public companion object Companion : kotlin.IntegerConstants<kotlin.Byte> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Byte
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Byte
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Byte
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Byte
    }
}

public final class ByteArray : kotlin.Cloneable {
    /*primary*/ public constructor ByteArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.ByteArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Byte
    public final operator fun iterator(): kotlin.ByteIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Byte): kotlin.Unit
}

public abstract class ByteIterator : kotlin.Iterator<kotlin.Byte> {
    /*primary*/ public constructor ByteIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Byte
    public abstract fun nextByte(): kotlin.Byte
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntProgression instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression", imports = {})) public open class ByteProgression : kotlin.Progression<kotlin.Byte> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use ByteProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "ByteProgression.fromClosedRange(start, end, increment)", imports = {})) public constructor ByteProgression(/*0*/ start: kotlin.Byte, /*1*/ endInclusive: kotlin.Byte, /*2*/ increment: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Byte
        public open override /*1*/ fun <get-end>(): kotlin.Byte
    public final val first: kotlin.Byte
        public final fun <get-first>(): kotlin.Byte
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Byte
        public final fun <get-last>(): kotlin.Byte
    @kotlin.Deprecated(message = "Use first instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Byte
        public open override /*1*/ fun <get-start>(): kotlin.Byte
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ByteIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Byte, /*1*/ rangeEnd: kotlin.Byte, /*2*/ step: kotlin.Int): kotlin.ByteProgression
    }
}

internal final class ByteProgressionIterator : kotlin.ByteIterator {
    /*primary*/ public constructor ByteProgressionIterator(/*0*/ start: kotlin.Byte, /*1*/ end: kotlin.Byte, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Byte
        private final fun <get-finalElement>(): kotlin.Byte
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    public final val increment: kotlin.Int
        public final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Byte
    public open override /*1*/ fun nextByte(): kotlin.Byte
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntRange instead.", replaceWith = kotlin.ReplaceWith(expression = "IntRange", imports = {})) public final class ByteRange : kotlin.ByteProgression, kotlin.ClosedRange<kotlin.Byte> {
    /*primary*/ public constructor ByteRange(/*0*/ start: kotlin.Byte, /*1*/ endInclusive: kotlin.Byte)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Byte
        public open override /*2*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val endInclusive: kotlin.Byte
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Byte
    public final override /*1*/ /*fake_override*/ val first: kotlin.Byte
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Byte
    public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Byte
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Byte
    public open override /*2*/ val start: kotlin.Byte
        public open override /*2*/ fun <get-start>(): kotlin.Byte
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Byte): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.ByteIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ByteRange
            public final fun <get-EMPTY>(): kotlin.ByteRange
    }
}

public final class Char : kotlin.Comparable<kotlin.Char> {
    /*primary*/ private constructor Char()
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Char): kotlin.Int
    public final operator fun dec(): kotlin.Char
    public final operator fun inc(): kotlin.Char
    public final operator fun minus(/*0*/ other: kotlin.Char): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Char
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Char
    public final operator fun rangeTo(/*0*/ other: kotlin.Char): kotlin.CharRange
    public open fun toByte(): kotlin.Byte
    public open fun toChar(): kotlin.Char
    public open fun toDouble(): kotlin.Double
    public open fun toFloat(): kotlin.Float
    public open fun toInt(): kotlin.Int
    public open fun toLong(): kotlin.Long
    public open fun toShort(): kotlin.Short

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

public final class CharArray : kotlin.Cloneable {
    /*primary*/ public constructor CharArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.CharArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final operator fun iterator(): kotlin.CharIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Char): kotlin.Unit
}

public abstract class CharIterator : kotlin.Iterator<kotlin.Char> {
    /*primary*/ public constructor CharIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Char
    public abstract fun nextChar(): kotlin.Char
}

public open class CharProgression : kotlin.Progression<kotlin.Char> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use CharProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "CharProgression.fromClosedRange(start, end, increment)", imports = {})) public constructor CharProgression(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char, /*2*/ increment: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Char
        public open override /*1*/ fun <get-end>(): kotlin.Char
    public final val first: kotlin.Char
        public final fun <get-first>(): kotlin.Char
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Char
        public final fun <get-last>(): kotlin.Char
    @kotlin.Deprecated(message = "Use first instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Char
        public open override /*1*/ fun <get-start>(): kotlin.Char
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.CharIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Char, /*1*/ rangeEnd: kotlin.Char, /*2*/ step: kotlin.Int): kotlin.CharProgression
    }
}

internal final class CharProgressionIterator : kotlin.CharIterator {
    /*primary*/ public constructor CharProgressionIterator(/*0*/ start: kotlin.Char, /*1*/ end: kotlin.Char, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Char
        private final fun <get-finalElement>(): kotlin.Char
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    public final val increment: kotlin.Int
        public final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Char
    public open override /*1*/ fun nextChar(): kotlin.Char
}

public final class CharRange : kotlin.CharProgression, kotlin.ClosedRange<kotlin.Char> {
    /*primary*/ public constructor CharRange(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Char
        public open override /*2*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val endInclusive: kotlin.Char
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val first: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Char
    public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Char
    public open override /*2*/ val start: kotlin.Char
        public open override /*2*/ fun <get-start>(): kotlin.Char
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Char): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.CharIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.CharRange
            public final fun <get-EMPTY>(): kotlin.CharRange
    }
}

public interface CharSequence {
    public abstract val length: kotlin.Int
        public abstract fun <get-length>(): kotlin.Int
    public abstract operator fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public abstract fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence
}

public interface Cloneable {
    protected open fun clone(): kotlin.Any
}

public interface ClosedRange</*0*/ T : kotlin.Comparable<T>> : kotlin.Range<T> {
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*1*/ val end: T
        public open override /*1*/ fun <get-end>(): T
    public abstract val endInclusive: T
        public abstract fun <get-endInclusive>(): T
    public abstract override /*1*/ val start: T
        public abstract override /*1*/ fun <get-start>(): T
    public open override /*1*/ fun contains(/*0*/ item: T): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
}

public interface Collection</*0*/ out E> : kotlin.Iterable<E> {
    public abstract val size: kotlin.Int
        public abstract fun <get-size>(): kotlin.Int
    public abstract operator fun contains(/*0*/ element: @kotlin.UnsafeVariance() E): kotlin.Boolean
    public abstract fun containsAll(/*0*/ elements: kotlin.Collection<@kotlin.UnsafeVariance() E>): kotlin.Boolean
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
}

public interface Comparable</*0*/ in T> {
    public abstract operator fun compareTo(/*0*/ other: T): kotlin.Int
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.PROPERTY_GETTER}) @kotlin.annotation.MustBeDocumented() public final annotation class Deprecated : kotlin.Annotation {
    /*primary*/ public constructor Deprecated(/*0*/ message: kotlin.String, /*1*/ replaceWith: kotlin.ReplaceWith = ..., /*2*/ level: kotlin.DeprecationLevel = ...)
    public final val level: kotlin.DeprecationLevel
        public final fun <get-level>(): kotlin.DeprecationLevel
    public final val message: kotlin.String
        public final fun <get-message>(): kotlin.String
    public final val replaceWith: kotlin.ReplaceWith
        public final fun <get-replaceWith>(): kotlin.ReplaceWith
}

public final enum class DeprecationLevel : kotlin.Enum<kotlin.DeprecationLevel> {
    enum entry WARNING

    enum entry ERROR

    enum entry HIDDEN

    /*primary*/ private constructor DeprecationLevel()
    public final override /*1*/ /*fake_override*/ val name: kotlin.String
        public final override /*1*/ /*fake_override*/ fun <get-name>(): kotlin.String
    public final override /*1*/ /*fake_override*/ val ordinal: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-ordinal>(): kotlin.Int
    protected final override /*1*/ /*fake_override*/ fun clone(): kotlin.Any
    public final override /*1*/ /*fake_override*/ fun compareTo(/*0*/ other: kotlin.DeprecationLevel): kotlin.Int

    // Static members
    public final /*synthesized*/ val values: kotlin.Array<kotlin.DeprecationLevel>
        public final fun <get-values>(): kotlin.Array<kotlin.DeprecationLevel>
    public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): kotlin.DeprecationLevel
    @kotlin.Deprecated(message = "Use 'values' property instead", replaceWith = kotlin.ReplaceWith(expression = "this.values", imports = {})) public final /*synthesized*/ fun values(): kotlin.Array<kotlin.DeprecationLevel>
}

public final class Double : kotlin.Number, kotlin.Comparable<kotlin.Double> {
    /*primary*/ private constructor Double()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun inc(): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Double
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Double
    public final operator fun unaryPlus(): kotlin.Double

    public companion object Companion : kotlin.FloatingPointConstants<kotlin.Double> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Double
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Double
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Double
    }
}

public final class DoubleArray : kotlin.Cloneable {
    /*primary*/ public constructor DoubleArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.DoubleArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Double
    public final operator fun iterator(): kotlin.DoubleIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Double): kotlin.Unit
}

public abstract class DoubleIterator : kotlin.Iterator<kotlin.Double> {
    /*primary*/ public constructor DoubleIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Double
    public abstract fun nextDouble(): kotlin.Double
}

public abstract class Enum</*0*/ E : kotlin.Enum<E>> : kotlin.Comparable<E> {
    /*primary*/ public constructor Enum</*0*/ E : kotlin.Enum<E>>(/*0*/ name: kotlin.String, /*1*/ ordinal: kotlin.Int)
    public final val name: kotlin.String
        public final fun <get-name>(): kotlin.String
    public final val ordinal: kotlin.Int
        public final fun <get-ordinal>(): kotlin.Int
    protected final fun clone(): kotlin.Any
    public final override /*1*/ fun compareTo(/*0*/ other: E): kotlin.Int

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.MustBeDocumented() public final annotation class Extension : kotlin.Annotation {
    /*primary*/ public constructor Extension()
}

public final class Float : kotlin.Number, kotlin.Comparable<kotlin.Float> {
    /*primary*/ private constructor Float()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun inc(): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Float
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Float
    public final operator fun unaryPlus(): kotlin.Float

    public companion object Companion : kotlin.FloatingPointConstants<kotlin.Float> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val NEGATIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NEGATIVE_INFINITY>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val NaN: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-NaN>(): kotlin.Float
        public abstract override /*1*/ /*fake_override*/ val POSITIVE_INFINITY: kotlin.Float
            public abstract override /*1*/ /*fake_override*/ fun <get-POSITIVE_INFINITY>(): kotlin.Float
    }
}

public final class FloatArray : kotlin.Cloneable {
    /*primary*/ public constructor FloatArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.FloatArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Float
    public final operator fun iterator(): kotlin.FloatIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Float): kotlin.Unit
}

public abstract class FloatIterator : kotlin.Iterator<kotlin.Float> {
    /*primary*/ public constructor FloatIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Float
    public abstract fun nextFloat(): kotlin.Float
}

public interface FloatingPointConstants</*0*/ T> {
    public abstract val MAX_VALUE: T
        public abstract fun <get-MAX_VALUE>(): T
    public abstract val MIN_VALUE: T
        public abstract fun <get-MIN_VALUE>(): T
    public abstract val NEGATIVE_INFINITY: T
        public abstract fun <get-NEGATIVE_INFINITY>(): T
    public abstract val NaN: T
        public abstract fun <get-NaN>(): T
    public abstract val POSITIVE_INFINITY: T
        public abstract fun <get-POSITIVE_INFINITY>(): T
}

public interface Function</*0*/ out R> {
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.CONSTRUCTOR}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented() @kotlin.Deprecated(message = "Use @Deprecated("...", level = DeprecationLevel.HIDDEN) instead", replaceWith = kotlin.ReplaceWith(expression = "@Deprecated(, level = DeprecationLevel.HIDDEN)", imports = {})) public final annotation class HiddenDeclaration : kotlin.Annotation {
    /*primary*/ public constructor HiddenDeclaration()
}

public final class Int : kotlin.Number, kotlin.Comparable<kotlin.Int> {
    /*primary*/ private constructor Int()
    public final infix fun and(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Int
    public final fun inv(): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final infix fun or(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.IntRange
    public final infix fun shl(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final infix fun shr(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int
    public final infix fun ushr(/*0*/ bitCount: kotlin.Int): kotlin.Int
    public final infix fun xor(/*0*/ other: kotlin.Int): kotlin.Int

    public companion object Companion : kotlin.IntegerConstants<kotlin.Int> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Int
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Int
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Int
    }
}

public final class IntArray : kotlin.Cloneable {
    /*primary*/ public constructor IntArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.IntArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Int
    public final operator fun iterator(): kotlin.IntIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Int): kotlin.Unit
}

public abstract class IntIterator : kotlin.Iterator<kotlin.Int> {
    /*primary*/ public constructor IntIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Int
    public abstract fun nextInt(): kotlin.Int
}

public open class IntProgression : kotlin.Progression<kotlin.Int> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use IntProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression.fromClosedRange(start, end, increment)", imports = {})) public constructor IntProgression(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int, /*2*/ increment: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Int
        public open override /*1*/ fun <get-end>(): kotlin.Int
    public final val first: kotlin.Int
        public final fun <get-first>(): kotlin.Int
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Int
        public final fun <get-last>(): kotlin.Int
    @kotlin.Deprecated(message = "Use first instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Int
        public open override /*1*/ fun <get-start>(): kotlin.Int
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.IntIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Int, /*1*/ rangeEnd: kotlin.Int, /*2*/ step: kotlin.Int): kotlin.IntProgression
    }
}

internal final class IntProgressionIterator : kotlin.IntIterator {
    /*primary*/ public constructor IntProgressionIterator(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    public final val increment: kotlin.Int
        public final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Int
    public open override /*1*/ fun nextInt(): kotlin.Int
}

public final class IntRange : kotlin.IntProgression, kotlin.ClosedRange<kotlin.Int> {
    /*primary*/ public constructor IntRange(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Int
        public open override /*2*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val endInclusive: kotlin.Int
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val first: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Int
    public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Int
        public open override /*2*/ fun <get-start>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Int): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.IntIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.IntRange
            public final fun <get-EMPTY>(): kotlin.IntRange
    }
}

public interface IntegerConstants</*0*/ T> {
    public abstract val MAX_VALUE: T
        public abstract fun <get-MAX_VALUE>(): T
    public abstract val MIN_VALUE: T
        public abstract fun <get-MIN_VALUE>(): T
}

public interface Iterable</*0*/ out T> {
    public abstract operator fun iterator(): kotlin.Iterator<T>
}

public interface Iterator</*0*/ out T> {
    public abstract operator fun hasNext(): kotlin.Boolean
    public abstract operator fun next(): T
}

public interface List</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ val size: kotlin.Int
        public abstract override /*1*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ fun contains(/*0*/ element: @kotlin.UnsafeVariance() E): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ elements: kotlin.Collection<@kotlin.UnsafeVariance() E>): kotlin.Boolean
    public abstract operator fun get(/*0*/ index: kotlin.Int): E
    public abstract fun indexOf(/*0*/ element: @kotlin.UnsafeVariance() E): kotlin.Int
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
    public abstract fun lastIndexOf(/*0*/ element: @kotlin.UnsafeVariance() E): kotlin.Int
    public abstract fun listIterator(): kotlin.ListIterator<E>
    public abstract fun listIterator(/*0*/ index: kotlin.Int): kotlin.ListIterator<E>
    public abstract fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.List<E>
}

public interface ListIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ fun hasNext(): kotlin.Boolean
    public abstract fun hasPrevious(): kotlin.Boolean
    public abstract override /*1*/ fun next(): T
    public abstract fun nextIndex(): kotlin.Int
    public abstract fun previous(): T
    public abstract fun previousIndex(): kotlin.Int
}

public final class Long : kotlin.Number, kotlin.Comparable<kotlin.Long> {
    /*primary*/ private constructor Long()
    public final infix fun and(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Long
    public final operator fun inc(): kotlin.Long
    public final fun inv(): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Long
    public final infix fun or(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Long
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.LongRange
    public final infix fun shl(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final infix fun shr(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Long
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Long
    public final operator fun unaryPlus(): kotlin.Long
    public final infix fun ushr(/*0*/ bitCount: kotlin.Int): kotlin.Long
    public final infix fun xor(/*0*/ other: kotlin.Long): kotlin.Long

    public companion object Companion : kotlin.IntegerConstants<kotlin.Long> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Long
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Long
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Long
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Long
    }
}

public final class LongArray : kotlin.Cloneable {
    /*primary*/ public constructor LongArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.LongArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Long
    public final operator fun iterator(): kotlin.LongIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Long): kotlin.Unit
}

public abstract class LongIterator : kotlin.Iterator<kotlin.Long> {
    /*primary*/ public constructor LongIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Long
    public abstract fun nextLong(): kotlin.Long
}

public open class LongProgression : kotlin.Progression<kotlin.Long> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use LongProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "LongProgression.fromClosedRange(start, end, increment)", imports = {})) public constructor LongProgression(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long, /*2*/ increment: kotlin.Long)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Long
        public open override /*1*/ fun <get-end>(): kotlin.Long
    public final val first: kotlin.Long
        public final fun <get-first>(): kotlin.Long
    public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public final val last: kotlin.Long
        public final fun <get-last>(): kotlin.Long
    @kotlin.Deprecated(message = "Use first instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Long
        public open override /*1*/ fun <get-start>(): kotlin.Long
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.LongIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Long, /*1*/ rangeEnd: kotlin.Long, /*2*/ step: kotlin.Long): kotlin.LongProgression
    }
}

internal final class LongProgressionIterator : kotlin.LongIterator {
    /*primary*/ public constructor LongProgressionIterator(/*0*/ start: kotlin.Long, /*1*/ end: kotlin.Long, /*2*/ increment: kotlin.Long)
    private final val finalElement: kotlin.Long
        private final fun <get-finalElement>(): kotlin.Long
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    public final val increment: kotlin.Long
        public final fun <get-increment>(): kotlin.Long
    private final var next: kotlin.Long
        private final fun <get-next>(): kotlin.Long
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Long): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Long
    public open override /*1*/ fun nextLong(): kotlin.Long
}

public final class LongRange : kotlin.LongProgression, kotlin.ClosedRange<kotlin.Long> {
    /*primary*/ public constructor LongRange(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Long
        public open override /*2*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val endInclusive: kotlin.Long
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val first: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Long
    public open override /*1*/ /*fake_override*/ val increment: kotlin.Long
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val last: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Long
    public open override /*2*/ val start: kotlin.Long
        public open override /*2*/ fun <get-start>(): kotlin.Long
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Long): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.LongIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.LongRange
            public final fun <get-EMPTY>(): kotlin.LongRange
    }
}

public interface Map</*0*/ K, /*1*/ out V> {
    public abstract val entries: kotlin.Set<kotlin.Map.Entry<K, V>>
        public abstract fun <get-entries>(): kotlin.Set<kotlin.Map.Entry<K, V>>
    public abstract val keys: kotlin.Set<K>
        public abstract fun <get-keys>(): kotlin.Set<K>
    public abstract val size: kotlin.Int
        public abstract fun <get-size>(): kotlin.Int
    public abstract val values: kotlin.Collection<V>
        public abstract fun <get-values>(): kotlin.Collection<V>
    public abstract fun containsKey(/*0*/ key: K): kotlin.Boolean
    public abstract fun containsValue(/*0*/ value: @kotlin.UnsafeVariance() V): kotlin.Boolean
    public abstract operator fun get(/*0*/ key: K): V?
    public abstract fun isEmpty(): kotlin.Boolean

    public interface Entry</*0*/ out K, /*1*/ out V> {
        public abstract val key: K
            public abstract fun <get-key>(): K
        public abstract val value: V
            public abstract fun <get-value>(): V
    }
}

public interface MutableCollection</*0*/ E> : kotlin.Collection<E>, kotlin.MutableIterable<E> {
    public abstract override /*1*/ /*fake_override*/ val size: kotlin.Int
        public abstract override /*1*/ /*fake_override*/ fun <get-size>(): kotlin.Int
    public abstract fun add(/*0*/ element: E): kotlin.Boolean
    public abstract fun addAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract fun remove(/*0*/ element: E): kotlin.Boolean
    public abstract fun removeAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun retainAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
}

public interface MutableIterable</*0*/ out T> : kotlin.Iterable<T> {
    public abstract override /*1*/ fun iterator(): kotlin.MutableIterator<T>
}

public interface MutableIterator</*0*/ out T> : kotlin.Iterator<T> {
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun next(): T
    public abstract fun remove(): kotlin.Unit
}

public interface MutableList</*0*/ E> : kotlin.List<E>, kotlin.MutableCollection<E> {
    public abstract override /*2*/ /*fake_override*/ val size: kotlin.Int
        public abstract override /*2*/ /*fake_override*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public abstract fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public abstract override /*1*/ fun addAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun addAll(/*0*/ index: kotlin.Int, /*1*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ /*fake_override*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ /*fake_override*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public abstract override /*1*/ fun listIterator(): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.MutableListIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun removeAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract fun removeAt(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ fun retainAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract operator fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    public abstract override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.MutableList<E>
}

public interface MutableListIterator</*0*/ T> : kotlin.ListIterator<T>, kotlin.MutableIterator<T> {
    public abstract fun add(/*0*/ element: T): kotlin.Unit
    public abstract override /*2*/ fun hasNext(): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun hasPrevious(): kotlin.Boolean
    public abstract override /*2*/ fun next(): T
    public abstract override /*1*/ /*fake_override*/ fun nextIndex(): kotlin.Int
    public abstract override /*1*/ /*fake_override*/ fun previous(): T
    public abstract override /*1*/ /*fake_override*/ fun previousIndex(): kotlin.Int
    public abstract override /*1*/ fun remove(): kotlin.Unit
    public abstract fun set(/*0*/ element: T): kotlin.Unit
}

public interface MutableMap</*0*/ K, /*1*/ V> : kotlin.Map<K, V> {
    public abstract override /*1*/ val entries: kotlin.MutableSet<kotlin.MutableMap.MutableEntry<K, V>>
        public abstract override /*1*/ fun <get-entries>(): kotlin.MutableSet<kotlin.MutableMap.MutableEntry<K, V>>
    public abstract override /*1*/ val keys: kotlin.MutableSet<K>
        public abstract override /*1*/ fun <get-keys>(): kotlin.MutableSet<K>
    public abstract override /*1*/ /*fake_override*/ val size: kotlin.Int
        public abstract override /*1*/ /*fake_override*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ val values: kotlin.MutableCollection<V>
        public abstract override /*1*/ fun <get-values>(): kotlin.MutableCollection<V>
    public abstract fun clear(): kotlin.Unit
    public abstract override /*1*/ /*fake_override*/ fun containsKey(/*0*/ key: K): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun containsValue(/*0*/ value: V): kotlin.Boolean
    public abstract override /*1*/ /*fake_override*/ fun get(/*0*/ key: K): V?
    public abstract override /*1*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract fun put(/*0*/ key: K, /*1*/ value: V): V?
    public abstract fun putAll(/*0*/ from: kotlin.Map<out K, V>): kotlin.Unit
    public abstract fun remove(/*0*/ key: K): V?

    public interface MutableEntry</*0*/ K, /*1*/ V> : kotlin.Map.Entry<K, V> {
        public abstract override /*1*/ /*fake_override*/ val key: K
            public abstract override /*1*/ /*fake_override*/ fun <get-key>(): K
        public abstract override /*1*/ /*fake_override*/ val value: V
            public abstract override /*1*/ /*fake_override*/ fun <get-value>(): V
        public abstract fun setValue(/*0*/ newValue: V): V
    }
}

public interface MutableSet</*0*/ E> : kotlin.Set<E>, kotlin.MutableCollection<E> {
    public abstract override /*2*/ /*fake_override*/ val size: kotlin.Int
        public abstract override /*2*/ /*fake_override*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun addAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*2*/ /*fake_override*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun containsAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*2*/ /*fake_override*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*2*/ fun iterator(): kotlin.MutableIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun removeAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun retainAll(/*0*/ elements: kotlin.Collection<E>): kotlin.Boolean
}

public final class Nothing {
    /*primary*/ private constructor Nothing()
}

public abstract class Number {
    /*primary*/ public constructor Number()
    public abstract fun toByte(): kotlin.Byte
    public abstract fun toChar(): kotlin.Char
    public abstract fun toDouble(): kotlin.Double
    public abstract fun toFloat(): kotlin.Float
    public abstract fun toInt(): kotlin.Int
    public abstract fun toLong(): kotlin.Long
    public abstract fun toShort(): kotlin.Short
}

@kotlin.Deprecated(message = "This generic progression interface is not of much use and will be removed soon. Use concrete progression implementation instead: IntProgression, LongProgression or CharProgression.") public interface Progression</*0*/ out N : kotlin.Any> : kotlin.Iterable<N> {
    public abstract val end: N
        public abstract fun <get-end>(): N
    public abstract val increment: kotlin.Number
        public abstract fun <get-increment>(): kotlin.Number
    public abstract val start: N
        public abstract fun <get-start>(): N
    public abstract override /*1*/ /*fake_override*/ fun iterator(): kotlin.Iterator<N>
}

@kotlin.Deprecated(message = "Please use KProperty instead.", replaceWith = kotlin.ReplaceWith(expression = "KProperty<*>", imports = {"kotlin.reflect.KProperty"})) public interface PropertyMetadata {
    public abstract val name: kotlin.String
        public abstract fun <get-name>(): kotlin.String
}

@kotlin.Deprecated(message = "This range has unclear inclusiveness of end value. Use ClosedRange instead.", replaceWith = kotlin.ReplaceWith(expression = "ClosedRange<T>", imports = {})) public interface Range</*0*/ T : kotlin.Comparable<T>> {
    public abstract val end: T
        public abstract fun <get-end>(): T
    public abstract val start: T
        public abstract fun <get-start>(): T
    public abstract operator fun contains(/*0*/ item: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}

@kotlin.annotation.Target(allowedTargets = {}) @kotlin.annotation.Retention(value = AnnotationRetention.BINARY) @kotlin.annotation.MustBeDocumented() public final annotation class ReplaceWith : kotlin.Annotation {
    /*primary*/ public constructor ReplaceWith(/*0*/ expression: kotlin.String, /*1*/ vararg imports: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    public final val expression: kotlin.String
        public final fun <get-expression>(): kotlin.String
    public final val imports: kotlin.Array<out kotlin.String>
        public final fun <get-imports>(): kotlin.Array<out kotlin.String>
}

public interface Set</*0*/ out E> : kotlin.Collection<E> {
    public abstract override /*1*/ val size: kotlin.Int
        public abstract override /*1*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ fun contains(/*0*/ element: @kotlin.UnsafeVariance() E): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ elements: kotlin.Collection<@kotlin.UnsafeVariance() E>): kotlin.Boolean
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.Iterator<E>
}

public final class Short : kotlin.Number, kotlin.Comparable<kotlin.Short> {
    /*primary*/ private constructor Short()
    public final operator fun compareTo(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Double): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Float): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun compareTo(/*0*/ other: kotlin.Long): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun dec(): kotlin.Short
    public final operator fun div(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun div(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun div(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun div(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun div(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun inc(): kotlin.Short
    public final operator fun minus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun minus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun minus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun minus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun minus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun mod(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun mod(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun mod(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun mod(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun plus(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun plus(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun plus(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun plus(/*0*/ other: kotlin.Short): kotlin.Int
    public final operator fun rangeTo(/*0*/ other: kotlin.Byte): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Int): kotlin.IntRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Long): kotlin.LongRange
    public final operator fun rangeTo(/*0*/ other: kotlin.Short): kotlin.IntRange
    public final operator fun times(/*0*/ other: kotlin.Byte): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Double): kotlin.Double
    public final operator fun times(/*0*/ other: kotlin.Float): kotlin.Float
    public final operator fun times(/*0*/ other: kotlin.Int): kotlin.Int
    public final operator fun times(/*0*/ other: kotlin.Long): kotlin.Long
    public final operator fun times(/*0*/ other: kotlin.Short): kotlin.Int
    public open override /*1*/ fun toByte(): kotlin.Byte
    public open override /*1*/ fun toChar(): kotlin.Char
    public open override /*1*/ fun toDouble(): kotlin.Double
    public open override /*1*/ fun toFloat(): kotlin.Float
    public open override /*1*/ fun toInt(): kotlin.Int
    public open override /*1*/ fun toLong(): kotlin.Long
    public open override /*1*/ fun toShort(): kotlin.Short
    public final operator fun unaryMinus(): kotlin.Int
    public final operator fun unaryPlus(): kotlin.Int

    public companion object Companion : kotlin.IntegerConstants<kotlin.Short> {
        /*primary*/ private constructor Companion()
        public abstract override /*1*/ /*fake_override*/ val MAX_VALUE: kotlin.Short
            public abstract override /*1*/ /*fake_override*/ fun <get-MAX_VALUE>(): kotlin.Short
        public abstract override /*1*/ /*fake_override*/ val MIN_VALUE: kotlin.Short
            public abstract override /*1*/ /*fake_override*/ fun <get-MIN_VALUE>(): kotlin.Short
    }
}

public final class ShortArray : kotlin.Cloneable {
    /*primary*/ public constructor ShortArray(/*0*/ size: kotlin.Int)
    public final val size: kotlin.Int
        public final fun <get-size>(): kotlin.Int
    public open override /*1*/ fun clone(): kotlin.ShortArray
    public final operator fun get(/*0*/ index: kotlin.Int): kotlin.Short
    public final operator fun iterator(): kotlin.ShortIterator
    public final operator fun set(/*0*/ index: kotlin.Int, /*1*/ value: kotlin.Short): kotlin.Unit
}

public abstract class ShortIterator : kotlin.Iterator<kotlin.Short> {
    /*primary*/ public constructor ShortIterator()
    public abstract override /*1*/ /*fake_override*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ fun next(): kotlin.Short
    public abstract fun nextShort(): kotlin.Short
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntProgression instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression", imports = {})) public open class ShortProgression : kotlin.Progression<kotlin.Short> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use ShortProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "ShortProgression.fromClosedRange(start, end, increment)", imports = {})) public constructor ShortProgression(/*0*/ start: kotlin.Short, /*1*/ endInclusive: kotlin.Short, /*2*/ increment: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Short
        public open override /*1*/ fun <get-end>(): kotlin.Short
    public final val first: kotlin.Short
        public final fun <get-first>(): kotlin.Short
    public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Short
        public final fun <get-last>(): kotlin.Short
    @kotlin.Deprecated(message = "Use first instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Short
        public open override /*1*/ fun <get-start>(): kotlin.Short
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.ShortIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Short, /*1*/ rangeEnd: kotlin.Short, /*2*/ step: kotlin.Int): kotlin.ShortProgression
    }
}

internal final class ShortProgressionIterator : kotlin.ShortIterator {
    /*primary*/ public constructor ShortProgressionIterator(/*0*/ start: kotlin.Short, /*1*/ end: kotlin.Short, /*2*/ increment: kotlin.Int)
    private final val finalElement: kotlin.Short
        private final fun <get-finalElement>(): kotlin.Short
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    public final val increment: kotlin.Int
        public final fun <get-increment>(): kotlin.Int
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Short
    public open override /*1*/ fun nextShort(): kotlin.Short
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntRange instead.", replaceWith = kotlin.ReplaceWith(expression = "IntRange", imports = {})) public final class ShortRange : kotlin.ShortProgression, kotlin.ClosedRange<kotlin.Short> {
    /*primary*/ public constructor ShortRange(/*0*/ start: kotlin.Short, /*1*/ endInclusive: kotlin.Short)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Short
        public open override /*2*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val endInclusive: kotlin.Short
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Short
    public final override /*1*/ /*fake_override*/ val first: kotlin.Short
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Short
    public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Short
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Short
    public open override /*2*/ val start: kotlin.Short
        public open override /*2*/ fun <get-start>(): kotlin.Short
    public open override /*1*/ fun contains(/*0*/ item: kotlin.Short): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.ShortIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ShortRange
            public final fun <get-EMPTY>(): kotlin.ShortRange
    }
}

public final class String : kotlin.Comparable<kotlin.String>, kotlin.CharSequence {
    /*primary*/ public constructor String()
    public open override /*1*/ val length: kotlin.Int
        public open override /*1*/ fun <get-length>(): kotlin.Int
    public open override /*1*/ fun compareTo(/*0*/ other: kotlin.String): kotlin.Int
    public open override /*1*/ fun get(/*0*/ index: kotlin.Int): kotlin.Char
    public final operator fun plus(/*0*/ other: kotlin.Any?): kotlin.String
    public open override /*1*/ fun subSequence(/*0*/ start: kotlin.Int, /*1*/ end: kotlin.Int): kotlin.CharSequence

    public companion object Companion {
        /*primary*/ private constructor Companion()
    }
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.CLASS, AnnotationTarget.ANNOTATION_CLASS, AnnotationTarget.PROPERTY, AnnotationTarget.FIELD, AnnotationTarget.LOCAL_VARIABLE, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER, AnnotationTarget.TYPE, AnnotationTarget.EXPRESSION, AnnotationTarget.FILE}) @kotlin.annotation.Retention(value = AnnotationRetention.SOURCE) public final annotation class Suppress : kotlin.Annotation {
    /*primary*/ public constructor Suppress(/*0*/ vararg names: kotlin.String /*kotlin.Array<out kotlin.String>*/)
    public final val names: kotlin.Array<out kotlin.String>
        public final fun <get-names>(): kotlin.Array<out kotlin.String>
}

public open class Throwable {
    /*primary*/ public constructor Throwable(/*0*/ message: kotlin.String? = ..., /*1*/ cause: kotlin.Throwable? = ...)
    public final val cause: kotlin.Throwable?
        public final fun <get-cause>(): kotlin.Throwable?
    public final val message: kotlin.String?
        public final fun <get-message>(): kotlin.String?
    public final fun printStackTrace(): kotlin.Unit
}

public object Unit {
    /*primary*/ private constructor Unit()
}

@kotlin.annotation.Target(allowedTargets = {AnnotationTarget.TYPE}) @kotlin.annotation.Retention(value = AnnotationRetention.SOURCE) @kotlin.annotation.MustBeDocumented() public final annotation class UnsafeVariance : kotlin.Annotation {
    /*primary*/ public constructor UnsafeVariance()
}
