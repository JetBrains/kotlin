// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: compiler/ir/serialization.common/src/KotlinIr.proto
// Protobuf Java Version: 4.29.3

package org.jetbrains.kotlin.backend.common.serialization.proto;

/**
 * Protobuf type {@code org.jetbrains.kotlin.backend.common.serialization.proto.IrConst}
 */
public  final class IrConst extends
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite<
        IrConst, IrConst.Builder> implements
    // @@protoc_insertion_point(message_implements:org.jetbrains.kotlin.backend.common.serialization.proto.IrConst)
    IrConstOrBuilder {
  private IrConst() {
  }
  private int valueCase_ = 0;
  private java.lang.Object value_;
  public enum ValueCase {
    NULL(1),
    BOOLEAN(2),
    CHAR(3),
    BYTE(4),
    SHORT(5),
    INT(6),
    LONG(7),
    FLOAT_BITS(8),
    DOUBLE_BITS(9),
    STRING(10),
    VALUE_NOT_SET(0);
    private final int value;
    private ValueCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ValueCase valueOf(int value) {
      return forNumber(value);
    }

    public static ValueCase forNumber(int value) {
      switch (value) {
        case 1: return NULL;
        case 2: return BOOLEAN;
        case 3: return CHAR;
        case 4: return BYTE;
        case 5: return SHORT;
        case 6: return INT;
        case 7: return LONG;
        case 8: return FLOAT_BITS;
        case 9: return DOUBLE_BITS;
        case 10: return STRING;
        case 0: return VALUE_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  @java.lang.Override
  public ValueCase
  getValueCase() {
    return ValueCase.forNumber(
        valueCase_);
  }

  private void clearValue() {
    valueCase_ = 0;
    value_ = null;
  }

  public static final int NULL_FIELD_NUMBER = 1;
  /**
   * <code>bool null = 1;</code>
   * @return Whether the null field is set.
   */
  @java.lang.Override
  public boolean hasNull() {
    return valueCase_ == 1;
  }
  /**
   * <code>bool null = 1;</code>
   * @return The null.
   */
  @java.lang.Override
  public boolean getNull() {
    if (valueCase_ == 1) {
      return (java.lang.Boolean) value_;
    }
    return false;
  }
  /**
   * <code>bool null = 1;</code>
   * @param value The null to set.
   */
  private void setNull(boolean value) {
    valueCase_ = 1;
    value_ = value;
  }
  /**
   * <code>bool null = 1;</code>
   */
  private void clearNull() {
    if (valueCase_ == 1) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int BOOLEAN_FIELD_NUMBER = 2;
  /**
   * <code>bool boolean = 2;</code>
   * @return Whether the boolean field is set.
   */
  @java.lang.Override
  public boolean hasBoolean() {
    return valueCase_ == 2;
  }
  /**
   * <code>bool boolean = 2;</code>
   * @return The boolean.
   */
  @java.lang.Override
  public boolean getBoolean() {
    if (valueCase_ == 2) {
      return (java.lang.Boolean) value_;
    }
    return false;
  }
  /**
   * <code>bool boolean = 2;</code>
   * @param value The boolean to set.
   */
  private void setBoolean(boolean value) {
    valueCase_ = 2;
    value_ = value;
  }
  /**
   * <code>bool boolean = 2;</code>
   */
  private void clearBoolean() {
    if (valueCase_ == 2) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int CHAR_FIELD_NUMBER = 3;
  /**
   * <code>int32 char = 3;</code>
   * @return Whether the char field is set.
   */
  @java.lang.Override
  public boolean hasChar() {
    return valueCase_ == 3;
  }
  /**
   * <code>int32 char = 3;</code>
   * @return The char.
   */
  @java.lang.Override
  public int getChar() {
    if (valueCase_ == 3) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <code>int32 char = 3;</code>
   * @param value The char to set.
   */
  private void setChar(int value) {
    valueCase_ = 3;
    value_ = value;
  }
  /**
   * <code>int32 char = 3;</code>
   */
  private void clearChar() {
    if (valueCase_ == 3) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int BYTE_FIELD_NUMBER = 4;
  /**
   * <code>int32 byte = 4;</code>
   * @return Whether the byte field is set.
   */
  @java.lang.Override
  public boolean hasByte() {
    return valueCase_ == 4;
  }
  /**
   * <code>int32 byte = 4;</code>
   * @return The byte.
   */
  @java.lang.Override
  public int getByte() {
    if (valueCase_ == 4) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <code>int32 byte = 4;</code>
   * @param value The byte to set.
   */
  private void setByte(int value) {
    valueCase_ = 4;
    value_ = value;
  }
  /**
   * <code>int32 byte = 4;</code>
   */
  private void clearByte() {
    if (valueCase_ == 4) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int SHORT_FIELD_NUMBER = 5;
  /**
   * <code>int32 short = 5;</code>
   * @return Whether the short field is set.
   */
  @java.lang.Override
  public boolean hasShort() {
    return valueCase_ == 5;
  }
  /**
   * <code>int32 short = 5;</code>
   * @return The short.
   */
  @java.lang.Override
  public int getShort() {
    if (valueCase_ == 5) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <code>int32 short = 5;</code>
   * @param value The short to set.
   */
  private void setShort(int value) {
    valueCase_ = 5;
    value_ = value;
  }
  /**
   * <code>int32 short = 5;</code>
   */
  private void clearShort() {
    if (valueCase_ == 5) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int INT_FIELD_NUMBER = 6;
  /**
   * <code>int32 int = 6;</code>
   * @return Whether the int field is set.
   */
  @java.lang.Override
  public boolean hasInt() {
    return valueCase_ == 6;
  }
  /**
   * <code>int32 int = 6;</code>
   * @return The int.
   */
  @java.lang.Override
  public int getInt() {
    if (valueCase_ == 6) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <code>int32 int = 6;</code>
   * @param value The int to set.
   */
  private void setInt(int value) {
    valueCase_ = 6;
    value_ = value;
  }
  /**
   * <code>int32 int = 6;</code>
   */
  private void clearInt() {
    if (valueCase_ == 6) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int LONG_FIELD_NUMBER = 7;
  /**
   * <code>int64 long = 7;</code>
   * @return Whether the long field is set.
   */
  @java.lang.Override
  public boolean hasLong() {
    return valueCase_ == 7;
  }
  /**
   * <code>int64 long = 7;</code>
   * @return The long.
   */
  @java.lang.Override
  public long getLong() {
    if (valueCase_ == 7) {
      return (java.lang.Long) value_;
    }
    return 0L;
  }
  /**
   * <code>int64 long = 7;</code>
   * @param value The long to set.
   */
  private void setLong(long value) {
    valueCase_ = 7;
    value_ = value;
  }
  /**
   * <code>int64 long = 7;</code>
   */
  private void clearLong() {
    if (valueCase_ == 7) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int FLOAT_BITS_FIELD_NUMBER = 8;
  /**
   * <pre>
   * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
   * </pre>
   *
   * <code>fixed32 float_bits = 8;</code>
   * @return Whether the floatBits field is set.
   */
  @java.lang.Override
  public boolean hasFloatBits() {
    return valueCase_ == 8;
  }
  /**
   * <pre>
   * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
   * </pre>
   *
   * <code>fixed32 float_bits = 8;</code>
   * @return The floatBits.
   */
  @java.lang.Override
  public int getFloatBits() {
    if (valueCase_ == 8) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <pre>
   * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
   * </pre>
   *
   * <code>fixed32 float_bits = 8;</code>
   * @param value The floatBits to set.
   */
  private void setFloatBits(int value) {
    valueCase_ = 8;
    value_ = value;
  }
  /**
   * <pre>
   * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
   * </pre>
   *
   * <code>fixed32 float_bits = 8;</code>
   */
  private void clearFloatBits() {
    if (valueCase_ == 8) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int DOUBLE_BITS_FIELD_NUMBER = 9;
  /**
   * <code>fixed64 double_bits = 9;</code>
   * @return Whether the doubleBits field is set.
   */
  @java.lang.Override
  public boolean hasDoubleBits() {
    return valueCase_ == 9;
  }
  /**
   * <code>fixed64 double_bits = 9;</code>
   * @return The doubleBits.
   */
  @java.lang.Override
  public long getDoubleBits() {
    if (valueCase_ == 9) {
      return (java.lang.Long) value_;
    }
    return 0L;
  }
  /**
   * <code>fixed64 double_bits = 9;</code>
   * @param value The doubleBits to set.
   */
  private void setDoubleBits(long value) {
    valueCase_ = 9;
    value_ = value;
  }
  /**
   * <code>fixed64 double_bits = 9;</code>
   */
  private void clearDoubleBits() {
    if (valueCase_ == 9) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static final int STRING_FIELD_NUMBER = 10;
  /**
   * <code>int32 string = 10;</code>
   * @return Whether the string field is set.
   */
  @java.lang.Override
  public boolean hasString() {
    return valueCase_ == 10;
  }
  /**
   * <code>int32 string = 10;</code>
   * @return The string.
   */
  @java.lang.Override
  public int getString() {
    if (valueCase_ == 10) {
      return (java.lang.Integer) value_;
    }
    return 0;
  }
  /**
   * <code>int32 string = 10;</code>
   * @param value The string to set.
   */
  private void setString(int value) {
    valueCase_ = 10;
    value_ = value;
  }
  /**
   * <code>int32 string = 10;</code>
   */
  private void clearString() {
    if (valueCase_ == 10) {
      valueCase_ = 0;
      value_ = null;
    }
  }

  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      java.nio.ByteBuffer data)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      java.nio.ByteBuffer data,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      org.jetbrains.kotlin.protobuf.ByteString data)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      org.jetbrains.kotlin.protobuf.ByteString data,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(byte[] data)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      byte[] data,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      java.io.InputStream input,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }

  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseDelimitedFrom(
      java.io.InputStream input,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      org.jetbrains.kotlin.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst parseFrom(
      org.jetbrains.kotlin.protobuf.CodedInputStream input,
      org.jetbrains.kotlin.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return org.jetbrains.kotlin.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.jetbrains.kotlin.backend.common.serialization.proto.IrConst prototype) {
    return DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * Protobuf type {@code org.jetbrains.kotlin.backend.common.serialization.proto.IrConst}
   */
  public static final class Builder extends
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.Builder<
        org.jetbrains.kotlin.backend.common.serialization.proto.IrConst, Builder> implements
      // @@protoc_insertion_point(builder_implements:org.jetbrains.kotlin.backend.common.serialization.proto.IrConst)
      org.jetbrains.kotlin.backend.common.serialization.proto.IrConstOrBuilder {
    // Construct using org.jetbrains.kotlin.backend.common.serialization.proto.IrConst.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }

    @java.lang.Override
    public ValueCase
        getValueCase() {
      return instance.getValueCase();
    }

    public Builder clearValue() {
      copyOnWrite();
      instance.clearValue();
      return this;
    }


    /**
     * <code>bool null = 1;</code>
     * @return Whether the null field is set.
     */
    @java.lang.Override
    public boolean hasNull() {
      return instance.hasNull();
    }
    /**
     * <code>bool null = 1;</code>
     * @return The null.
     */
    @java.lang.Override
    public boolean getNull() {
      return instance.getNull();
    }
    /**
     * <code>bool null = 1;</code>
     * @param value The null to set.
     * @return This builder for chaining.
     */
    public Builder setNull(boolean value) {
      copyOnWrite();
      instance.setNull(value);
      return this;
    }
    /**
     * <code>bool null = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearNull() {
      copyOnWrite();
      instance.clearNull();
      return this;
    }

    /**
     * <code>bool boolean = 2;</code>
     * @return Whether the boolean field is set.
     */
    @java.lang.Override
    public boolean hasBoolean() {
      return instance.hasBoolean();
    }
    /**
     * <code>bool boolean = 2;</code>
     * @return The boolean.
     */
    @java.lang.Override
    public boolean getBoolean() {
      return instance.getBoolean();
    }
    /**
     * <code>bool boolean = 2;</code>
     * @param value The boolean to set.
     * @return This builder for chaining.
     */
    public Builder setBoolean(boolean value) {
      copyOnWrite();
      instance.setBoolean(value);
      return this;
    }
    /**
     * <code>bool boolean = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearBoolean() {
      copyOnWrite();
      instance.clearBoolean();
      return this;
    }

    /**
     * <code>int32 char = 3;</code>
     * @return Whether the char field is set.
     */
    @java.lang.Override
    public boolean hasChar() {
      return instance.hasChar();
    }
    /**
     * <code>int32 char = 3;</code>
     * @return The char.
     */
    @java.lang.Override
    public int getChar() {
      return instance.getChar();
    }
    /**
     * <code>int32 char = 3;</code>
     * @param value The char to set.
     * @return This builder for chaining.
     */
    public Builder setChar(int value) {
      copyOnWrite();
      instance.setChar(value);
      return this;
    }
    /**
     * <code>int32 char = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearChar() {
      copyOnWrite();
      instance.clearChar();
      return this;
    }

    /**
     * <code>int32 byte = 4;</code>
     * @return Whether the byte field is set.
     */
    @java.lang.Override
    public boolean hasByte() {
      return instance.hasByte();
    }
    /**
     * <code>int32 byte = 4;</code>
     * @return The byte.
     */
    @java.lang.Override
    public int getByte() {
      return instance.getByte();
    }
    /**
     * <code>int32 byte = 4;</code>
     * @param value The byte to set.
     * @return This builder for chaining.
     */
    public Builder setByte(int value) {
      copyOnWrite();
      instance.setByte(value);
      return this;
    }
    /**
     * <code>int32 byte = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearByte() {
      copyOnWrite();
      instance.clearByte();
      return this;
    }

    /**
     * <code>int32 short = 5;</code>
     * @return Whether the short field is set.
     */
    @java.lang.Override
    public boolean hasShort() {
      return instance.hasShort();
    }
    /**
     * <code>int32 short = 5;</code>
     * @return The short.
     */
    @java.lang.Override
    public int getShort() {
      return instance.getShort();
    }
    /**
     * <code>int32 short = 5;</code>
     * @param value The short to set.
     * @return This builder for chaining.
     */
    public Builder setShort(int value) {
      copyOnWrite();
      instance.setShort(value);
      return this;
    }
    /**
     * <code>int32 short = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearShort() {
      copyOnWrite();
      instance.clearShort();
      return this;
    }

    /**
     * <code>int32 int = 6;</code>
     * @return Whether the int field is set.
     */
    @java.lang.Override
    public boolean hasInt() {
      return instance.hasInt();
    }
    /**
     * <code>int32 int = 6;</code>
     * @return The int.
     */
    @java.lang.Override
    public int getInt() {
      return instance.getInt();
    }
    /**
     * <code>int32 int = 6;</code>
     * @param value The int to set.
     * @return This builder for chaining.
     */
    public Builder setInt(int value) {
      copyOnWrite();
      instance.setInt(value);
      return this;
    }
    /**
     * <code>int32 int = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearInt() {
      copyOnWrite();
      instance.clearInt();
      return this;
    }

    /**
     * <code>int64 long = 7;</code>
     * @return Whether the long field is set.
     */
    @java.lang.Override
    public boolean hasLong() {
      return instance.hasLong();
    }
    /**
     * <code>int64 long = 7;</code>
     * @return The long.
     */
    @java.lang.Override
    public long getLong() {
      return instance.getLong();
    }
    /**
     * <code>int64 long = 7;</code>
     * @param value The long to set.
     * @return This builder for chaining.
     */
    public Builder setLong(long value) {
      copyOnWrite();
      instance.setLong(value);
      return this;
    }
    /**
     * <code>int64 long = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearLong() {
      copyOnWrite();
      instance.clearLong();
      return this;
    }

    /**
     * <pre>
     * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
     * </pre>
     *
     * <code>fixed32 float_bits = 8;</code>
     * @return Whether the floatBits field is set.
     */
    @java.lang.Override
    public boolean hasFloatBits() {
      return instance.hasFloatBits();
    }
    /**
     * <pre>
     * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
     * </pre>
     *
     * <code>fixed32 float_bits = 8;</code>
     * @return The floatBits.
     */
    @java.lang.Override
    public int getFloatBits() {
      return instance.getFloatBits();
    }
    /**
     * <pre>
     * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
     * </pre>
     *
     * <code>fixed32 float_bits = 8;</code>
     * @param value The floatBits to set.
     * @return This builder for chaining.
     */
    public Builder setFloatBits(int value) {
      copyOnWrite();
      instance.setFloatBits(value);
      return this;
    }
    /**
     * <pre>
     * float/double is stored via fixed 32/64 bit value to avoid raw bit conversion
     * </pre>
     *
     * <code>fixed32 float_bits = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearFloatBits() {
      copyOnWrite();
      instance.clearFloatBits();
      return this;
    }

    /**
     * <code>fixed64 double_bits = 9;</code>
     * @return Whether the doubleBits field is set.
     */
    @java.lang.Override
    public boolean hasDoubleBits() {
      return instance.hasDoubleBits();
    }
    /**
     * <code>fixed64 double_bits = 9;</code>
     * @return The doubleBits.
     */
    @java.lang.Override
    public long getDoubleBits() {
      return instance.getDoubleBits();
    }
    /**
     * <code>fixed64 double_bits = 9;</code>
     * @param value The doubleBits to set.
     * @return This builder for chaining.
     */
    public Builder setDoubleBits(long value) {
      copyOnWrite();
      instance.setDoubleBits(value);
      return this;
    }
    /**
     * <code>fixed64 double_bits = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearDoubleBits() {
      copyOnWrite();
      instance.clearDoubleBits();
      return this;
    }

    /**
     * <code>int32 string = 10;</code>
     * @return Whether the string field is set.
     */
    @java.lang.Override
    public boolean hasString() {
      return instance.hasString();
    }
    /**
     * <code>int32 string = 10;</code>
     * @return The string.
     */
    @java.lang.Override
    public int getString() {
      return instance.getString();
    }
    /**
     * <code>int32 string = 10;</code>
     * @param value The string to set.
     * @return This builder for chaining.
     */
    public Builder setString(int value) {
      copyOnWrite();
      instance.setString(value);
      return this;
    }
    /**
     * <code>int32 string = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearString() {
      copyOnWrite();
      instance.clearString();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:org.jetbrains.kotlin.backend.common.serialization.proto.IrConst)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      org.jetbrains.kotlin.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.jetbrains.kotlin.backend.common.serialization.proto.IrConst();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "value_",
            "valueCase_",
          };
          java.lang.String info =
              "\u0004\n\u0001\u0000\u0001\n\n\u0000\u0000\u0000\u0001:\u0000\u0002:\u0000\u0003" +
              "7\u0000\u00047\u0000\u00057\u0000\u00067\u0000\u00075\u0000\b9\u0000\t8\u0000\n7" +
              "\u0000";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        org.jetbrains.kotlin.protobuf.Parser<org.jetbrains.kotlin.backend.common.serialization.proto.IrConst> parser = PARSER;
        if (parser == null) {
          synchronized (org.jetbrains.kotlin.backend.common.serialization.proto.IrConst.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.jetbrains.kotlin.backend.common.serialization.proto.IrConst>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:org.jetbrains.kotlin.backend.common.serialization.proto.IrConst)
  private static final org.jetbrains.kotlin.backend.common.serialization.proto.IrConst DEFAULT_INSTANCE;
  static {
    IrConst defaultInstance = new IrConst();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    org.jetbrains.kotlin.protobuf.GeneratedMessageLite.registerDefaultInstance(
      IrConst.class, defaultInstance);
  }

  public static org.jetbrains.kotlin.backend.common.serialization.proto.IrConst getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile org.jetbrains.kotlin.protobuf.Parser<IrConst> PARSER;

  public static org.jetbrains.kotlin.protobuf.Parser<IrConst> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}
