== t1 ==
fun t1() {
  try {
    1
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 } finally { 2 } })
    mark(try { 1 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])           NEXT:[mark({ 2 }), mark({ 1 })]
  3 mark({ 1 })
    r(1) -> <v0>
  2 jmp(L3 [skipFinallyToErrorBlock])              NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L4 [start finally]:
  3 mark({ 2 })                                    PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v1>
L5 [finish finally]:
  2 jmp(error)                                     NEXT:[<ERROR>]
L3 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                    PREV:[jmp(L3 [skipFinallyToErrorBlock])]
    r(2) -> <v1>
  2 merge(try { 1 } finally { 2 }|<v0>) -> <v2>
L1:
  1 <END>                                          NEXT:[<SINK>]
error:
    <ERROR>                                        PREV:[jmp(error)]
sink:
    <SINK>                                         PREV:[<ERROR>, <END>]
=====================
== t2 ==
fun t2() {
  try {
    1
    if (2 > 3) {
      return
    }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 if (2 > 3) { return } } finally { 2 } })
    mark(try { 1 if (2 > 3) { return } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                 NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { return } })]
  3 mark({ 1 if (2 > 3) { return } })
    r(1) -> <v0>
    mark(if (2 > 3) { return })
    r(2) -> <v1>
    r(3) -> <v2>
    mark(2 > 3)
    call(2 > 3, compareTo|<v1>, <v2>) -> <v3>
    jf(L3|<v3>)                                                          NEXT:[read (Unit), mark({ return })]
  4 mark({ return })
L4 [start finally]:
  5 mark({ 2 })
    r(2) -> <v4>
L5 [finish finally]:
  4 ret L1                                                               NEXT:[<END>]
- 3 jmp(L6)                                                              NEXT:[merge(if (2 > 3) { return }|!<v5>) -> <v6>]                           PREV:[]
L3:
    read (Unit)                                                          PREV:[jf(L3|<v3>)]
L6:
    merge(if (2 > 3) { return }|!<v5>) -> <v6>
  2 jmp(L7 [skipFinallyToErrorBlock])                                    NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
  5 mark({ 2 })                                                          PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v4>
  2 jmp(error)                                                           NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  5 mark({ 2 })                                                          PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(2) -> <v4>
  2 merge(try { 1 if (2 > 3) { return } } finally { 2 }|<v6>) -> <v7>
L1:
  1 <END>                                                                NEXT:[<SINK>]                                                               PREV:[ret L1, merge(try { 1 if (2 > 3) { return } } finally { 2 }|<v6>) -> <v7>]
error:
    <ERROR>                                                              PREV:[jmp(error)]
sink:
    <SINK>                                                               PREV:[<ERROR>, <END>]
=====================
== t3 ==
fun t3() {
  try {
    1
    @l{ () ->
        if (2 > 3) {
          return@l
        }
    }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 @l{ () -> if (2 > 3) { return@l } } } finally { 2 } })
    mark(try { 1 @l{ () -> if (2 > 3) { return@l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                               NEXT:[mark({ 2 }), mark({ 1 @l{ () -> if (2 > 3) { return@l } } })]
  3 mark({ 1 @l{ () -> if (2 > 3) { return@l } } })
    r(1) -> <v0>
    mark(@l{ () -> if (2 > 3) { return@l } })
    mark({ () -> if (2 > 3) { return@l } })
    jmp?(L3)                                                                           NEXT:[r({ () -> if (2 > 3) { return@l } }) -> <v1>, d({ () -> if (2 > 3) { return@l } })]
    d({ () -> if (2 > 3) { return@l } })                                               NEXT:[<SINK>]
L3:
    r({ () -> if (2 > 3) { return@l } }) -> <v1>                                       PREV:[jmp?(L3)]
  2 jmp(L8 [skipFinallyToErrorBlock])                                                  NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L9 [start finally]:
  3 mark({ 2 })                                                                        PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v2>
L10 [finish finally]:
  2 jmp(error)                                                                         NEXT:[<ERROR>]
L8 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                        PREV:[jmp(L8 [skipFinallyToErrorBlock])]
    r(2) -> <v2>
  2 merge(try { 1 @l{ () -> if (2 > 3) { return@l } } } finally { 2 }|<v1>) -> <v3>
L1:
  1 <END>                                                                              NEXT:[<SINK>]
error:
    <ERROR>                                                                            PREV:[jmp(error)]
sink:
    <SINK>                                                                             PREV:[<ERROR>, <END>, d({ () -> if (2 > 3) { return@l } })]
=====================
== anonymous_0 ==
{ () ->
        if (2 > 3) {
          return@l
        }
    }
---------------------
L4:
  4 <START>
  5 mark(if (2 > 3) { return@l })
    mark(if (2 > 3) { return@l })
    r(2) -> <v0>
    r(3) -> <v1>
    mark(2 > 3)
    call(2 > 3, compareTo|<v0>, <v1>) -> <v2>
    jf(L6|<v2>)                                     NEXT:[read (Unit), mark({ return@l })]
  6 mark({ return@l })
    ret L5                                          NEXT:[<END>]
- 5 jmp(L7)                                         NEXT:[merge(if (2 > 3) { return@l }|!<v3>) -> <v4>]    PREV:[]
L6:
    read (Unit)                                     PREV:[jf(L6|<v2>)]
L7:
    merge(if (2 > 3) { return@l }|!<v3>) -> <v4>
  4 ret(*|<v4>) L5
L5:
    <END>                                           NEXT:[<SINK>]                                          PREV:[ret L5, ret(*|<v4>) L5]
error:
    <ERROR>                                         PREV:[]
sink:
    <SINK>                                          PREV:[<ERROR>, <END>]
=====================
== t4 ==
fun t4() {
  @l{ () ->
    try {
      1
      if (2 > 3) {
        return@l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
  2 mark({ @l{ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } } })
    mark(@l{ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })
    mark({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })
    jmp?(L2)                                                                 NEXT:[r({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } }) -> <v0>, d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })]
    d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })             NEXT:[<SINK>]
L2:
    r({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } }) -> <v0>     PREV:[jmp?(L2)]
L1:
  1 <END>                                                                    NEXT:[<SINK>]
error:
    <ERROR>                                                                  PREV:[]
sink:
    <SINK>                                                                   PREV:[<ERROR>, <END>, d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })]
=====================
== anonymous_1 ==
{ () ->
    try {
      1
      if (2 > 3) {
        return@l
      }
    } finally {
      2
    }
  }
---------------------
L3:
  3 <START>
  4 mark(try { 1 if (2 > 3) { return@l } } finally { 2 })
    mark(try { 1 if (2 > 3) { return@l } } finally { 2 })
    jmp?(L5 [onExceptionToFinallyBlock])                                   NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { return@l } })]
  5 mark({ 1 if (2 > 3) { return@l } })
    r(1) -> <v0>
    mark(if (2 > 3) { return@l })
    r(2) -> <v1>
    r(3) -> <v2>
    mark(2 > 3)
    call(2 > 3, compareTo|<v1>, <v2>) -> <v3>
    jf(L6|<v3>)                                                            NEXT:[read (Unit), mark({ return@l })]
  6 mark({ return@l })
L7 [start finally]:
  7 mark({ 2 })
    r(2) -> <v4>
L8 [finish finally]:
  6 ret L4                                                                 NEXT:[<END>]
- 5 jmp(L9)                                                                NEXT:[merge(if (2 > 3) { return@l }|!<v5>) -> <v6>]                           PREV:[]
L6:
    read (Unit)                                                            PREV:[jf(L6|<v3>)]
L9:
    merge(if (2 > 3) { return@l }|!<v5>) -> <v6>
  4 jmp(L10 [skipFinallyToErrorBlock])                                     NEXT:[mark({ 2 })]
L5 [onExceptionToFinallyBlock]:
  7 mark({ 2 })                                                            PREV:[jmp?(L5 [onExceptionToFinallyBlock])]
    r(2) -> <v4>
  4 jmp(error)                                                             NEXT:[<ERROR>]
L10 [skipFinallyToErrorBlock]:
  7 mark({ 2 })                                                            PREV:[jmp(L10 [skipFinallyToErrorBlock])]
    r(2) -> <v4>
  4 merge(try { 1 if (2 > 3) { return@l } } finally { 2 }|<v6>) -> <v7>
  3 ret(*|<v7>) L4
L4:
    <END>                                                                  NEXT:[<SINK>]                                                                 PREV:[ret L4, ret(*|<v7>) L4]
error:
    <ERROR>                                                                PREV:[jmp(error)]
sink:
    <SINK>                                                                 PREV:[<ERROR>, <END>]
=====================
== t5 ==
fun t5() {
  @l while(true) {
    try {
      1
      if (2 > 3) {
        break @l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
  2 mark({ @l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } } })
    mark(@l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } })
L2 [loop entry point]:
L5 [condition entry point]:
    r(true) -> <v0>                                                                 PREV:[mark(@l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } }), jmp(L2 [loop entry point])]
    mark(while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } })
    magic[VALUE_CONSUMER](true|<v0>) -> <v1>
L4 [body entry point]:
  3 mark({ try { 1 if (2 > 3) { break @l } } finally { 2 } })
    mark(try { 1 if (2 > 3) { break @l } } finally { 2 })
    jmp?(L6 [onExceptionToFinallyBlock])                                            NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { break @l } })]
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v2>
    mark(if (2 > 3) { break @l })
    r(2) -> <v3>
    r(3) -> <v4>
    mark(2 > 3)
    call(2 > 3, compareTo|<v3>, <v4>) -> <v5>
    jf(L7|<v5>)                                                                     NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
L8 [start finally]:
  6 mark({ 2 })
    r(2) -> <v6>
L9 [finish finally]:
  5 jmp(L3 [loop exit point])                                                       NEXT:[read (Unit)]
- 4 jmp(L10)                                                                        NEXT:[merge(if (2 > 3) { break @l }|!<v7>) -> <v8>]                                    PREV:[]
L7:
    read (Unit)                                                                     PREV:[jf(L7|<v5>)]
L10:
    merge(if (2 > 3) { break @l }|!<v7>) -> <v8>
  3 jmp(L11 [skipFinallyToErrorBlock])                                              NEXT:[mark({ 2 })]
L6 [onExceptionToFinallyBlock]:
  6 mark({ 2 })                                                                     PREV:[jmp?(L6 [onExceptionToFinallyBlock])]
    r(2) -> <v6>
  3 jmp(error)                                                                      NEXT:[<ERROR>]
L11 [skipFinallyToErrorBlock]:
  6 mark({ 2 })                                                                     PREV:[jmp(L11 [skipFinallyToErrorBlock])]
    r(2) -> <v6>
  3 merge(try { 1 if (2 > 3) { break @l } } finally { 2 }|<v8>) -> <v9>
  2 jmp(L2 [loop entry point])                                                      NEXT:[r(true) -> <v0>]
L3 [loop exit point]:
    read (Unit)                                                                     PREV:[jmp(L3 [loop exit point])]
L1:
  1 <END>                                                                           NEXT:[<SINK>]
error:
    <ERROR>                                                                         PREV:[jmp(error)]
sink:
    <SINK>                                                                          PREV:[<ERROR>, <END>]
=====================
== t6 ==
fun t6() {
  try {
    @l while(true) {
        1
        if (2 > 3) {
          break @l
        }
      }
      5
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { @l while(true) { 1 if (2 > 3) { break @l } } 5 } finally { 2 } })
    mark(try { @l while(true) { 1 if (2 > 3) { break @l } } 5 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                         NEXT:[mark({ 2 }), mark({ @l while(true) { 1 if (2 > 3) { break @l } } 5 })]
  3 mark({ @l while(true) { 1 if (2 > 3) { break @l } } 5 })
    mark(@l while(true) { 1 if (2 > 3) { break @l } })
L3 [loop entry point]:
L6 [condition entry point]:
    r(true) -> <v0>                                                                              PREV:[mark(@l while(true) { 1 if (2 > 3) { break @l } }), jmp(L3 [loop entry point])]
    mark(while(true) { 1 if (2 > 3) { break @l } })
    magic[VALUE_CONSUMER](true|<v0>) -> <v1>
L5 [body entry point]:
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v2>
    mark(if (2 > 3) { break @l })
    r(2) -> <v3>
    r(3) -> <v4>
    mark(2 > 3)
    call(2 > 3, compareTo|<v3>, <v4>) -> <v5>
    jf(L7|<v5>)                                                                                  NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
    jmp(L4 [loop exit point])                                                                    NEXT:[read (Unit)]
- 4 jmp(L8)                                                                                      NEXT:[merge(if (2 > 3) { break @l }|!<v6>) -> <v7>]                                                 PREV:[]
L7:
    read (Unit)                                                                                  PREV:[jf(L7|<v5>)]
L8:
    merge(if (2 > 3) { break @l }|!<v6>) -> <v7>
  3 jmp(L3 [loop entry point])                                                                   NEXT:[r(true) -> <v0>]
L4 [loop exit point]:
    read (Unit)                                                                                  PREV:[jmp(L4 [loop exit point])]
    r(5) -> <v9>
  2 jmp(L9 [skipFinallyToErrorBlock])                                                            NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                                  PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v10>
L11 [finish finally]:
  2 jmp(error)                                                                                   NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                                  PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v10>
  2 merge(try { @l while(true) { 1 if (2 > 3) { break @l } } 5 } finally { 2 }|<v9>) -> <v11>
L1:
  1 <END>                                                                                        NEXT:[<SINK>]
error:
    <ERROR>                                                                                      PREV:[jmp(error)]
sink:
    <SINK>                                                                                       PREV:[<ERROR>, <END>]
=====================
== t7 ==
fun t7() {
  try {
    @l while(true) {
        1
        if (2 > 3) {
          break @l
        }
      }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { @l while(true) { 1 if (2 > 3) { break @l } } } finally { 2 } })
    mark(try { @l while(true) { 1 if (2 > 3) { break @l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                        NEXT:[mark({ 2 }), mark({ @l while(true) { 1 if (2 > 3) { break @l } } })]
  3 mark({ @l while(true) { 1 if (2 > 3) { break @l } } })
    mark(@l while(true) { 1 if (2 > 3) { break @l } })
L3 [loop entry point]:
L6 [condition entry point]:
    r(true) -> <v0>                                                                             PREV:[mark(@l while(true) { 1 if (2 > 3) { break @l } }), jmp(L3 [loop entry point])]
    mark(while(true) { 1 if (2 > 3) { break @l } })
    magic[VALUE_CONSUMER](true|<v0>) -> <v1>
L5 [body entry point]:
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v2>
    mark(if (2 > 3) { break @l })
    r(2) -> <v3>
    r(3) -> <v4>
    mark(2 > 3)
    call(2 > 3, compareTo|<v3>, <v4>) -> <v5>
    jf(L7|<v5>)                                                                                 NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
    jmp(L4 [loop exit point])                                                                   NEXT:[read (Unit)]
- 4 jmp(L8)                                                                                     NEXT:[merge(if (2 > 3) { break @l }|!<v6>) -> <v7>]                                                PREV:[]
L7:
    read (Unit)                                                                                 PREV:[jf(L7|<v5>)]
L8:
    merge(if (2 > 3) { break @l }|!<v6>) -> <v7>
  3 jmp(L3 [loop entry point])                                                                  NEXT:[r(true) -> <v0>]
L4 [loop exit point]:
    read (Unit)                                                                                 PREV:[jmp(L4 [loop exit point])]
  2 jmp(L9 [skipFinallyToErrorBlock])                                                           NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                                 PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v9>
L11 [finish finally]:
  2 jmp(error)                                                                                  NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                                 PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v9>
  2 merge(try { @l while(true) { 1 if (2 > 3) { break @l } } } finally { 2 }|!<v8>) -> <v10>
L1:
  1 <END>                                                                                       NEXT:[<SINK>]
error:
    <ERROR>                                                                                     PREV:[jmp(error)]
sink:
    <SINK>                                                                                      PREV:[<ERROR>, <END>]
=====================
== t8 ==
fun t8(a : Int) {
  @l for (i in 1..a) {
    try {
      1
      if (2 > 3) {
        continue @l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic[FAKE_INITIALIZER](a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ @l for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } } })
    mark(@l for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } })
  3 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(1..a, rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L3:
    jmp?(L2)                                                                               NEXT:[read (Unit), magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
L4 [loop entry point]:
L5 [body entry point]:
    magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>                                         PREV:[jmp?(L2), jmp(L4 [loop entry point]), jmp?(L4 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } })
  4 mark({ try { 1 if (2 > 3) { continue @l } } finally { 2 } })
    mark(try { 1 if (2 > 3) { continue @l } } finally { 2 })
    jmp?(L6 [onExceptionToFinallyBlock])                                                   NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { continue @l } })]
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(2 > 3, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                            NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
L8 [start finally]:
  7 mark({ 2 })
    r(2) -> <v9>
L9 [finish finally]:
  6 jmp(L4 [loop entry point])                                                             NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
- 5 jmp(L10)                                                                               NEXT:[merge(if (2 > 3) { continue @l }|!<v10>) -> <v11>]                                      PREV:[]
L7:
    read (Unit)                                                                            PREV:[jf(L7|<v8>)]
L10:
    merge(if (2 > 3) { continue @l }|!<v10>) -> <v11>
  4 jmp(L11 [skipFinallyToErrorBlock])                                                     NEXT:[mark({ 2 })]
L6 [onExceptionToFinallyBlock]:
  7 mark({ 2 })                                                                            PREV:[jmp?(L6 [onExceptionToFinallyBlock])]
    r(2) -> <v9>
  4 jmp(error)                                                                             NEXT:[<ERROR>]
L11 [skipFinallyToErrorBlock]:
  7 mark({ 2 })                                                                            PREV:[jmp(L11 [skipFinallyToErrorBlock])]
    r(2) -> <v9>
  4 merge(try { 1 if (2 > 3) { continue @l } } finally { 2 }|<v11>) -> <v12>
  3 jmp?(L4 [loop entry point])                                                            NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>, read (Unit)]
L2:
    read (Unit)                                                                            PREV:[jmp?(L2), jmp?(L4 [loop entry point])]
L1:
  1 <END>                                                                                  NEXT:[<SINK>]
error:
    <ERROR>                                                                                PREV:[jmp(error)]
sink:
    <SINK>                                                                                 PREV:[<ERROR>, <END>]
=====================
== t9 ==
fun t9(a : Int) {
  try {
    @l for (i in 1..a) {
        1
        if (2 > 3) {
          continue @l
        }
      }
      5
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic[FAKE_INITIALIZER](a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 } finally { 2 } })
    mark(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                                 NEXT:[mark({ 2 }), mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 })]
  3 mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 })
    mark(@l for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  4 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(1..a, rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L4:
    jmp?(L3)                                                                                             NEXT:[read (Unit), magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
L5 [loop entry point]:
L6 [body entry point]:
    magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>                                                       PREV:[jmp?(L3), jmp(L5 [loop entry point]), jmp?(L5 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(2 > 3, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                                          NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
    jmp(L5 [loop entry point])                                                                           NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
- 5 jmp(L8)                                                                                              NEXT:[merge(if (2 > 3) { continue @l }|!<v9>) -> <v10>]                                                     PREV:[]
L7:
    read (Unit)                                                                                          PREV:[jf(L7|<v8>)]
L8:
    merge(if (2 > 3) { continue @l }|!<v9>) -> <v10>
  4 jmp?(L5 [loop entry point])                                                                          NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>, read (Unit)]
L3:
    read (Unit)                                                                                          PREV:[jmp?(L3), jmp?(L5 [loop entry point])]
  3 r(5) -> <v12>
  2 jmp(L9 [skipFinallyToErrorBlock])                                                                    NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                                          PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v13>
L11 [finish finally]:
  2 jmp(error)                                                                                           NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                                          PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v13>
  2 merge(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 } finally { 2 }|<v12>) -> <v14>
L1:
  1 <END>                                                                                                NEXT:[<SINK>]
error:
    <ERROR>                                                                                              PREV:[jmp(error)]
sink:
    <SINK>                                                                                               PREV:[<ERROR>, <END>]
=====================
== t10 ==
fun t10(a : Int) {
  try {
    @l for (i in 1..a) {
        1
        if (2 > 3) {
          continue @l
        }
      }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic[FAKE_INITIALIZER](a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } } finally { 2 } })
    mark(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                                NEXT:[mark({ 2 }), mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } })]
  3 mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } })
    mark(@l for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  4 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(1..a, rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L4:
    jmp?(L3)                                                                                            NEXT:[read (Unit), magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
L5 [loop entry point]:
L6 [body entry point]:
    magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>                                                      PREV:[jmp?(L3), jmp(L5 [loop entry point]), jmp?(L5 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(2 > 3, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                                         NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
    jmp(L5 [loop entry point])                                                                          NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>]
- 5 jmp(L8)                                                                                             NEXT:[merge(if (2 > 3) { continue @l }|!<v9>) -> <v10>]                                                    PREV:[]
L7:
    read (Unit)                                                                                         PREV:[jf(L7|<v8>)]
L8:
    merge(if (2 > 3) { continue @l }|!<v9>) -> <v10>
  4 jmp?(L5 [loop entry point])                                                                         NEXT:[magic[LOOP_RANGE_ITERATION](1..a|<v3>) -> <v4>, read (Unit)]
L3:
    read (Unit)                                                                                         PREV:[jmp?(L3), jmp?(L5 [loop entry point])]
  2 jmp(L9 [skipFinallyToErrorBlock])                                                                   NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                                         PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v12>
L11 [finish finally]:
  2 jmp(error)                                                                                          NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                                         PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v12>
  2 merge(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } } finally { 2 }|!<v11>) -> <v13>
L1:
  1 <END>                                                                                               NEXT:[<SINK>]
error:
    <ERROR>                                                                                             PREV:[jmp(error)]
sink:
    <SINK>                                                                                              PREV:[<ERROR>, <END>]
=====================
== t11 ==
fun t11() {
  try {
    return 1
  }
  finally {
    return 2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } finally { return 2 } })
    mark(try { return 1 } finally { return 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                          NEXT:[mark({ return 2 }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L3 [start finally]:
  4 mark({ return 2 })
    r(2) -> <v1>
    ret(*|<v1>) L1                                                NEXT:[<END>]
L4 [finish finally]:
- 3 ret(*|<v0>) L1                                                NEXT:[<END>]                                              PREV:[]
- 2 jmp(L5 [skipFinallyToErrorBlock])                             NEXT:[mark({ return 2 })]                                 PREV:[]
L2 [onExceptionToFinallyBlock]:
  4 mark({ return 2 })                                            PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v1>
    ret(*|<v1>) L1                                                NEXT:[<END>]
- 2 jmp(error)                                                    NEXT:[<ERROR>]                                            PREV:[]
L5 [skipFinallyToErrorBlock]:
- 4 mark({ return 2 })                                            PREV:[]
-   r(2) -> <v1>                                                  PREV:[]
-   ret(*|<v1>) L1                                                NEXT:[<END>]                                              PREV:[]
- 2 merge(try { return 1 } finally { return 2 }|!<v3>) -> <v4>    PREV:[]
L1:
  1 <END>                                                         NEXT:[<SINK>]                                             PREV:[ret(*|<v1>) L1, ret(*|<v1>) L1]
error:
    <ERROR>                                                       PREV:[]
sink:
    <SINK>                                                        PREV:[<ERROR>, <END>]
=====================
== t12 ==
fun t12() : Int {
    try {
        return 1
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } finally { doSmth(3) } })
    mark(try { return 1 } finally { doSmth(3) })
    jmp?(L2 [onExceptionToFinallyBlock])                           NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L3 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
L4 [finish finally]:
  3 ret(*|<v0>) L1                                                 NEXT:[<END>]
- 2 jmp(L5 [skipFinallyToErrorBlock])                              NEXT:[mark({ doSmth(3) })]                                            PREV:[]
L2 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                            PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
  2 jmp(error)                                                     NEXT:[<ERROR>]
L5 [skipFinallyToErrorBlock]:
- 4 mark({ doSmth(3) })                                            PREV:[]
-   r(3) -> <v1>                                                   PREV:[]
-   mark(doSmth(3))                                                PREV:[]
-   call(doSmth(3), doSmth|<v1>) -> <v2>                           PREV:[]
- 2 merge(try { return 1 } finally { doSmth(3) }|!<v3>) -> <v4>    PREV:[]
L1:
  1 <END>                                                          NEXT:[<SINK>]                                                         PREV:[ret(*|<v0>) L1]
error:
    <ERROR>                                                        PREV:[jmp(error)]
sink:
    <SINK>                                                         PREV:[<ERROR>, <END>]
=====================
== t13 ==
fun t13() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        doSmth(2)
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                                      NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                                        NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L4 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
L5 [finish finally]:
  3 ret(*|<v0>) L1                                                                                                              NEXT:[<END>]
- 2 jmp(L6 [afterCatches])                                                                                                      NEXT:[jmp(L7 [skipFinallyToErrorBlock])]                                                                                           PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                                         PREV:[jmp?(L2 [onException])]
    magic[FAKE_INITIALIZER](e: UnsupportedOperationException) -> <v4>
    w(e|<v4>)
  4 mark({ doSmth(2) })
    r(2) -> <v5>
    mark(doSmth(2))
    call(doSmth(2), doSmth|<v5>) -> <v6>
  3 jmp(L6 [afterCatches])
L6 [afterCatches]:
  2 jmp(L7 [skipFinallyToErrorBlock])                                                                                           NEXT:[mark({ doSmth(3) })]
L3 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                                                                                         PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
  2 jmp(error)                                                                                                                  NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  4 mark({ doSmth(3) })                                                                                                         PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
  2 merge(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) }|!<v3>, <v6>) -> <v7>
L1:
  1 <END>                                                                                                                       NEXT:[<SINK>]                                                                                                                      PREV:[ret(*|<v0>) L1, merge(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) }|!<v3>, <v6>) -> <v7>]
error:
    <ERROR>                                                                                                                     PREV:[jmp(error)]
sink:
    <SINK>                                                                                                                      PREV:[<ERROR>, <END>]
=====================
== t14 ==
fun t14() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        doSmth(2)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) })
    jmp?(L2 [onException])                                                                                NEXT:[v(e: UnsupportedOperationException), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
    ret(*|<v0>) L1                                                                                        NEXT:[<END>]
- 2 jmp(L3 [afterCatches])                                                                                NEXT:[merge(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) }|!<v1>, <v4>) -> <v5>]    PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                   PREV:[jmp?(L2 [onException])]
    magic[FAKE_INITIALIZER](e: UnsupportedOperationException) -> <v2>
    w(e|<v2>)
  4 mark({ doSmth(2) })
    r(2) -> <v3>
    mark(doSmth(2))
    call(doSmth(2), doSmth|<v3>) -> <v4>
  3 jmp(L3 [afterCatches])
L3 [afterCatches]:
  2 merge(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) }|!<v1>, <v4>) -> <v5>
L1:
  1 <END>                                                                                                 NEXT:[<SINK>]                                                                                                PREV:[ret(*|<v0>) L1, merge(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) }|!<v1>, <v4>) -> <v5>]
error:
    <ERROR>                                                                                               PREV:[]
sink:
    <SINK>                                                                                                PREV:[<ERROR>, <END>]
=====================
== t15 ==
fun t15() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        return 2
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                                      NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                                        NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L4 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
L5 [finish finally]:
  3 ret(*|<v0>) L1                                                                                                              NEXT:[<END>]
- 2 jmp(L6 [afterCatches])                                                                                                      NEXT:[jmp(L7 [skipFinallyToErrorBlock])]                                                                                           PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                                         PREV:[jmp?(L2 [onException])]
    magic[FAKE_INITIALIZER](e: UnsupportedOperationException) -> <v4>
    w(e|<v4>)
  4 mark({ return 2 })
    r(2) -> <v5>
    mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
    ret(*|<v5>) L1                                                                                                              NEXT:[<END>]
- 3 jmp(L6 [afterCatches])                                                                                                      PREV:[]
L6 [afterCatches]:
- 2 jmp(L7 [skipFinallyToErrorBlock])                                                                                           NEXT:[mark({ doSmth(3) })]                                                                                                         PREV:[]
L3 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                                                                                         PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v1>) -> <v2>
  2 jmp(error)                                                                                                                  NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
- 4 mark({ doSmth(3) })                                                                                                         PREV:[]
-   r(3) -> <v1>                                                                                                                PREV:[]
-   mark(doSmth(3))                                                                                                             PREV:[]
-   call(doSmth(3), doSmth|<v1>) -> <v2>                                                                                        PREV:[]
- 2 merge(try { return 1 } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) }|!<v3>, !<v6>) -> <v7>    PREV:[]
L1:
  1 <END>                                                                                                                       NEXT:[<SINK>]                                                                                                                      PREV:[ret(*|<v0>) L1, ret(*|<v5>) L1]
error:
    <ERROR>                                                                                                                     PREV:[jmp(error)]
sink:
    <SINK>                                                                                                                      PREV:[<ERROR>, <END>]
=====================
== t16 ==
fun t16() : Int {
    try {
        doSmth(1)
    }
    catch (e: UnsupportedOperationException) {
        return 2
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) } })
    mark(try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                                      NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                                        NEXT:[mark({ doSmth(3) }), mark({ doSmth(1) })]
  3 mark({ doSmth(1) })
    r(1) -> <v0>
    mark(doSmth(1))
    call(doSmth(1), doSmth|<v0>) -> <v1>
  2 jmp(L4 [afterCatches])                                                                                                      NEXT:[jmp(L7 [skipFinallyToErrorBlock])]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                                         PREV:[jmp?(L2 [onException])]
    magic[FAKE_INITIALIZER](e: UnsupportedOperationException) -> <v2>
    w(e|<v2>)
  4 mark({ return 2 })
    r(2) -> <v3>
L5 [start finally]:
  5 mark({ doSmth(3) })
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v4>) -> <v5>
L6 [finish finally]:
  4 ret(*|<v3>) L1                                                                                                              NEXT:[<END>]
- 3 jmp(L4 [afterCatches])                                                                                                      PREV:[]
L4 [afterCatches]:
  2 jmp(L7 [skipFinallyToErrorBlock])                                                                                           NEXT:[mark({ doSmth(3) })]                                                                                                         PREV:[jmp(L4 [afterCatches])]
L3 [onExceptionToFinallyBlock]:
  5 mark({ doSmth(3) })                                                                                                         PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v4>) -> <v5>
  2 jmp(error)                                                                                                                  NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  5 mark({ doSmth(3) })                                                                                                         PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth(3), doSmth|<v4>) -> <v5>
  2 merge(try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) }|<v1>, !<v6>) -> <v7>
L1:
  1 <END>                                                                                                                       NEXT:[<SINK>]                                                                                                                      PREV:[ret(*|<v3>) L1, merge(try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) }|<v1>, !<v6>) -> <v7>]
error:
    <ERROR>                                                                                                                     PREV:[jmp(error)]
sink:
    <SINK>                                                                                                                      PREV:[<ERROR>, <END>]
=====================
== doSmth ==
fun doSmth(i: Int) {
}
---------------------
L0:
  1 <START>
    v(i: Int)
    magic[FAKE_INITIALIZER](i: Int) -> <v0>
    w(i|<v0>)
  2 mark({ })
    read (Unit)
L1:
  1 <END>                                      NEXT:[<SINK>]
error:
    <ERROR>                                    PREV:[]
sink:
    <SINK>                                     PREV:[<ERROR>, <END>]
=====================
