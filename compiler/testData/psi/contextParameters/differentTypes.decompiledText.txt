Anno.class:
  // IntelliJ API Decompiler stub source generated from a class file
  // Implementation of methods is not available

  @kotlin.annotation.Target public final annotation class Anno public constructor() : kotlin.Annotation {
  }

Foo.class:
  // IntelliJ API Decompiler stub source generated from a class file
  // Implementation of methods is not available

  public final class Foo public constructor() {
      context((@Anno suspend () -> kotlin.Unit), suspend kotlin.String.() -> kotlin.Int) public final val contextParameter2: kotlin.Int /* compiled code */ /* hasBackingField: false */
          public final get() { /* compiled code */ }

      context(A & Any, B & Any) public final val <A, B, C> (C & Any).dnnP: kotlin.Int /* compiled code */ /* hasBackingField: false */
          public final get() { /* compiled code */ }

      context((@Anno suspend context(kotlin.Int) () -> kotlin.Unit), suspend context(kotlin.String) () -> kotlin.Boolean) public final val contextParameter3: kotlin.Int /* compiled code */ /* hasBackingField: false */
          public final get() { /* compiled code */ }

      public final val returnType: @Anno suspend context(kotlin.Int) () -> kotlin.Unit /* compiled code */ /* hasBackingField: false */
          public final get() { /* compiled code */ }

      context((@Anno suspend () -> kotlin.Unit), suspend kotlin.String.() -> kotlin.Int) public final fun contextParameter(): kotlin.Unit { /* compiled code */ }

      context(A & Any, B & Any) public final fun <A, B, C> (C & Any).dnnF(): kotlin.Unit { /* compiled code */ }

      context((@Anno suspend context(kotlin.Int) () -> kotlin.Unit), suspend context(kotlin.String) () -> kotlin.Boolean) public final fun contextParameter4(): kotlin.Unit { /* compiled code */ }
  }
