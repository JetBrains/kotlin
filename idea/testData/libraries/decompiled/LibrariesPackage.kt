// IntelliJ API Decompiler stub source generated from a class file
// Implementation of methods is not available

package testData.libraries

[public val globalVal: testData.libraries.Pair<jet.Int, jet.String>] /* compiled code */

[public val globalValWithGetter: jet.Long] /* compiled code */

[public val jet.Int.exProp: jet.Int] /* compiled code */

[public val jet.String.exProp: jet.String] /* compiled code */

[public val <T> testData.libraries.Pair<T, T>.exProp: jet.String] /* compiled code */

[public fun <T : jet.CharSequence> funWithTypeParam(t: T): jet.Unit { /* compiled code */ }]

[public fun <T : jet.Number> funWithTypeParam(t: T): jet.Unit { /* compiled code */ }]

[public fun func(): jet.Unit { /* compiled code */ }]

[public fun func(cs: jet.CharSequence): jet.Unit { /* compiled code */ }]

[public fun func(a: jet.Int, b: jet.Int): jet.Unit { /* compiled code */ }]

[public fun func(a: jet.Int, b: jet.String = /* compiled code */): jet.Unit { /* compiled code */ }]

[public fun func(str: jet.String): jet.Unit { /* compiled code */ }]

[public fun main(args: jet.Array<jet.String>): jet.Unit { /* compiled code */ }]

[public fun processDouble(d: jet.Double): jet.Unit { /* compiled code */ }]

[public fun processDouble(d: testData.libraries.Double): jet.Unit { /* compiled code */ }]

[public fun <T> T.filter(predicate: (T) -> jet.Boolean): T? { /* compiled code */ }]