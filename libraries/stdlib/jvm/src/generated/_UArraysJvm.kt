/*
 * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license 
 * that can be found in the license/LICENSE.txt file.
 */

@file:kotlin.jvm.JvmMultifileClass
@file:kotlin.jvm.JvmName("UArraysKt")

package kotlin.collections

//
// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//


/**
 * Searches the array or the range of the array for the provided [element] using the binary search algorithm.
 * The array is expected to be sorted, otherwise the result is undefined.
 *
 * If the array contains multiple elements equal to the specified [element], there is no guarantee which one will be found.
 *
 * @return the index of the element, if it is contained in the array within the specified range;
 * otherwise, the inverted insertion point `(-insertion point - 1)`.
 * The insertion point is defined as the index at which the element should be inserted,
 * so that the array (or the specified subrange of array) still remains sorted.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UIntArray.binarySearch(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Int {
    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)
    val signedElement = element.toInt()
    var low = fromIndex
    var high = toIndex - 1
    while (low <= high) {
        val mid = (low + high).ushr(1) // safe from overflows
        val midVal = storage[mid]
        val cmp = uintCompare(midVal, signedElement)
        if (cmp < 0)
            low = mid + 1
        else if (cmp > 0)
            high = mid - 1
        else
            return mid // key found
    }
    return -(low + 1)  // key not found
}

/**
 * Searches the array or the range of the array for the provided [element] using the binary search algorithm.
 * The array is expected to be sorted, otherwise the result is undefined.
 *
 * If the array contains multiple elements equal to the specified [element], there is no guarantee which one will be found.
 *
 * @return the index of the element, if it is contained in the array within the specified range;
 * otherwise, the inverted insertion point `(-insertion point - 1)`.
 * The insertion point is defined as the index at which the element should be inserted,
 * so that the array (or the specified subrange of array) still remains sorted.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun ULongArray.binarySearch(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Int {
    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)
    val signedElement = element.toLong()
    var low = fromIndex
    var high = toIndex - 1
    while (low <= high) {
        val mid = (low + high).ushr(1) // safe from overflows
        val midVal = storage[mid]
        val cmp = ulongCompare(midVal, signedElement)
        if (cmp < 0)
            low = mid + 1
        else if (cmp > 0)
            high = mid - 1
        else
            return mid // key found
    }
    return -(low + 1)  // key not found
}

/**
 * Searches the array or the range of the array for the provided [element] using the binary search algorithm.
 * The array is expected to be sorted, otherwise the result is undefined.
 *
 * If the array contains multiple elements equal to the specified [element], there is no guarantee which one will be found.
 *
 * @return the index of the element, if it is contained in the array within the specified range;
 * otherwise, the inverted insertion point `(-insertion point - 1)`.
 * The insertion point is defined as the index at which the element should be inserted,
 * so that the array (or the specified subrange of array) still remains sorted.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UByteArray.binarySearch(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Int {
    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)
    val signedElement = element.toInt()
    var low = fromIndex
    var high = toIndex - 1
    while (low <= high) {
        val mid = (low + high).ushr(1) // safe from overflows
        val midVal = storage[mid]
        val cmp = uintCompare(midVal.toInt(), signedElement)
        if (cmp < 0)
            low = mid + 1
        else if (cmp > 0)
            high = mid - 1
        else
            return mid // key found
    }
    return -(low + 1)  // key not found
}

/**
 * Searches the array or the range of the array for the provided [element] using the binary search algorithm.
 * The array is expected to be sorted, otherwise the result is undefined.
 *
 * If the array contains multiple elements equal to the specified [element], there is no guarantee which one will be found.
 *
 * @return the index of the element, if it is contained in the array within the specified range;
 * otherwise, the inverted insertion point `(-insertion point - 1)`.
 * The insertion point is defined as the index at which the element should be inserted,
 * so that the array (or the specified subrange of array) still remains sorted.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UShortArray.binarySearch(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Int {
    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)
    val signedElement = element.toInt()
    var low = fromIndex
    var high = toIndex - 1
    while (low <= high) {
        val mid = (low + high).ushr(1) // safe from overflows
        val midVal = storage[mid]
        val cmp = uintCompare(midVal.toInt(), signedElement)
        if (cmp < 0)
            low = mid + 1
        else if (cmp > 0)
            high = mid - 1
        else
            return mid // key found
    }
    return -(low + 1)  // key not found
}

/**
 * Fills original array with the provided value.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {
    storage.fill(element.toInt(), fromIndex, toIndex)
}

/**
 * Fills original array with the provided value.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {
    storage.fill(element.toLong(), fromIndex, toIndex)
}

/**
 * Fills original array with the provided value.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {
    storage.fill(element.toByte(), fromIndex, toIndex)
}

/**
 * Fills original array with the provided value.
 */
@SinceKotlin("1.3")
@ExperimentalUnsignedTypes
public fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {
    storage.fill(element.toShort(), fromIndex, toIndex)
}