/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve;

import com.intellij.testFramework.TestDataPath;
import org.jetbrains.kotlin.test.JUnit3RunnerWithInners;
import org.jetbrains.kotlin.test.KotlinTestUtils;
import org.jetbrains.kotlin.test.util.KtTestUtil;
import org.jetbrains.kotlin.test.TestMetadata;
import org.junit.runner.RunWith;

import java.io.File;
import java.util.regex.Pattern;

/** This class is generated by {@link org.jetbrains.kotlin.test.generators.GenerateCompilerTestsKt}. DO NOT MODIFY MANUALLY */
@SuppressWarnings("all")
@TestMetadata("compiler/testData/resolve")
@TestDataPath("$PROJECT_ROOT")
@RunWith(JUnit3RunnerWithInners.class)
public class ResolveTestGenerated extends AbstractResolveTest {
  private void runTest(String testDataFilePath) {
    KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
  }

  public void testAllFilesPresentInResolve() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve"), Pattern.compile("^(.+)\\.resolve$"), null, true);
  }

  @TestMetadata("Basic.resolve")
  public void testBasic() {
    runTest("compiler/testData/resolve/Basic.resolve");
  }

  @TestMetadata("ClassObjects.resolve")
  public void testClassObjects() {
    runTest("compiler/testData/resolve/ClassObjects.resolve");
  }

  @TestMetadata("Classifiers.resolve")
  public void testClassifiers() {
    runTest("compiler/testData/resolve/Classifiers.resolve");
  }

  @TestMetadata("DefaultParamsOfLocalFunctions.resolve")
  public void testDefaultParamsOfLocalFunctions() {
    runTest("compiler/testData/resolve/DefaultParamsOfLocalFunctions.resolve");
  }

  @TestMetadata("ErrorSupertype.resolve")
  public void testErrorSupertype() {
    runTest("compiler/testData/resolve/ErrorSupertype.resolve");
  }

  @TestMetadata("ExtensionFunctions.resolve")
  public void testExtensionFunctions() {
    runTest("compiler/testData/resolve/ExtensionFunctions.resolve");
  }

  @TestMetadata("FunctionVariable.resolve")
  public void testFunctionVariable() {
    runTest("compiler/testData/resolve/FunctionVariable.resolve");
  }

  @TestMetadata("ImportFromRootScope.resolve")
  public void testImportFromRootScope() {
    runTest("compiler/testData/resolve/ImportFromRootScope.resolve");
  }

  @TestMetadata("ImportingRootScopeWhenProcessingImports.resolve")
  public void testImportingRootScopeWhenProcessingImports() {
    runTest("compiler/testData/resolve/ImportingRootScopeWhenProcessingImports.resolve");
  }

  @TestMetadata("kt304.resolve")
  public void testKt304() {
    runTest("compiler/testData/resolve/kt304.resolve");
  }

  @TestMetadata("LocalObjects.resolve")
  public void testLocalObjects() {
    runTest("compiler/testData/resolve/LocalObjects.resolve");
  }

  @TestMetadata("NestedObjects.resolve")
  public void testNestedObjects() {
    runTest("compiler/testData/resolve/NestedObjects.resolve");
  }

  @TestMetadata("NoReferenceForErrorAnnotation.resolve")
  public void testNoReferenceForErrorAnnotation() {
    runTest("compiler/testData/resolve/NoReferenceForErrorAnnotation.resolve");
  }

  @TestMetadata("Objects.resolve")
  public void testObjects() {
    runTest("compiler/testData/resolve/Objects.resolve");
  }

  @TestMetadata("Packages.resolve")
  public void testPackages() {
    runTest("compiler/testData/resolve/Packages.resolve");
  }

  @TestMetadata("PrimaryConstructorParameters.resolve")
  public void testPrimaryConstructorParameters() {
    runTest("compiler/testData/resolve/PrimaryConstructorParameters.resolve");
  }

  @TestMetadata("PrimaryConstructors.resolve")
  public void testPrimaryConstructors() {
    runTest("compiler/testData/resolve/PrimaryConstructors.resolve");
  }

  @TestMetadata("Projections.resolve")
  public void testProjections() {
    runTest("compiler/testData/resolve/Projections.resolve");
  }

  @TestMetadata("PropertyAndFunctionNameClash.resolve")
  public void testPropertyAndFunctionNameClash() {
    runTest("compiler/testData/resolve/PropertyAndFunctionNameClash.resolve");
  }

  @TestMetadata("ResolveOfInfixExpressions.resolve")
  public void testResolveOfInfixExpressions() {
    runTest("compiler/testData/resolve/ResolveOfInfixExpressions.resolve");
  }

  @TestMetadata("ResolveToJava.resolve")
  public void testResolveToJava() {
    runTest("compiler/testData/resolve/ResolveToJava.resolve");
  }

  @TestMetadata("ResolveToJava2.resolve")
  public void testResolveToJava2() {
    runTest("compiler/testData/resolve/ResolveToJava2.resolve");
  }

  @TestMetadata("ResolveToJava3.resolve")
  public void testResolveToJava3() {
    runTest("compiler/testData/resolve/ResolveToJava3.resolve");
  }

  @TestMetadata("ResolveToJavaTypeTransform.resolve")
  public void testResolveToJavaTypeTransform() {
    runTest("compiler/testData/resolve/ResolveToJavaTypeTransform.resolve");
  }

  @TestMetadata("ScopeInteraction.resolve")
  public void testScopeInteraction() {
    runTest("compiler/testData/resolve/ScopeInteraction.resolve");
  }

  @TestMetadata("StringTemplates.resolve")
  public void testStringTemplates() {
    runTest("compiler/testData/resolve/StringTemplates.resolve");
  }

  @TestMetadata("Super.resolve")
  public void testSuper() {
    runTest("compiler/testData/resolve/Super.resolve");
  }

  @TestMetadata("TryCatch.resolve")
  public void testTryCatch() {
    runTest("compiler/testData/resolve/TryCatch.resolve");
  }

  @TestMetadata("compiler/testData/resolve/candidatesPriority")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class CandidatesPriority extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInCandidatesPriority() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/candidatesPriority"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("classObjectOuterResolve.resolve")
    public void testClassObjectOuterResolve() {
      runTest("compiler/testData/resolve/candidatesPriority/classObjectOuterResolve.resolve");
    }

    @TestMetadata("closerReceiver1.resolve")
    public void testCloserReceiver1() {
      runTest("compiler/testData/resolve/candidatesPriority/closerReceiver1.resolve");
    }

    @TestMetadata("closerReceiver2.resolve")
    public void testCloserReceiver2() {
      runTest("compiler/testData/resolve/candidatesPriority/closerReceiver2.resolve");
    }

    @TestMetadata("closerReceiver3.resolve")
    public void testCloserReceiver3() {
      runTest("compiler/testData/resolve/candidatesPriority/closerReceiver3.resolve");
    }

    @TestMetadata("closerScope.resolve")
    public void testCloserScope() {
      runTest("compiler/testData/resolve/candidatesPriority/closerScope.resolve");
    }

    @TestMetadata("dispatchReceiverVsExtensionReceiver.resolve")
    public void testDispatchReceiverVsExtensionReceiver() {
      runTest("compiler/testData/resolve/candidatesPriority/dispatchReceiverVsExtensionReceiver.resolve");
    }

    @TestMetadata("dispatchReceiverVsExtensionReceiver2.resolve")
    public void testDispatchReceiverVsExtensionReceiver2() {
      runTest("compiler/testData/resolve/candidatesPriority/dispatchReceiverVsExtensionReceiver2.resolve");
    }

    @TestMetadata("extensionToCloserReceiverVsMember.resolve")
    public void testExtensionToCloserReceiverVsMember() {
      runTest("compiler/testData/resolve/candidatesPriority/extensionToCloserReceiverVsMember.resolve");
    }

    @TestMetadata("implicitThisVsNoReceiver.resolve")
    public void testImplicitThisVsNoReceiver() {
      runTest("compiler/testData/resolve/candidatesPriority/implicitThisVsNoReceiver.resolve");
    }

    @TestMetadata("implicitThisVsNoReceiver2.resolve")
    public void testImplicitThisVsNoReceiver2() {
      runTest("compiler/testData/resolve/candidatesPriority/implicitThisVsNoReceiver2.resolve");
    }

    @TestMetadata("localVsImplicitThis.resolve")
    public void testLocalVsImplicitThis() {
      runTest("compiler/testData/resolve/candidatesPriority/localVsImplicitThis.resolve");
    }

    @TestMetadata("memberVsExtension1.resolve")
    public void testMemberVsExtension1() {
      runTest("compiler/testData/resolve/candidatesPriority/memberVsExtension1.resolve");
    }

    @TestMetadata("memberVsExtension2.resolve")
    public void testMemberVsExtension2() {
      runTest("compiler/testData/resolve/candidatesPriority/memberVsExtension2.resolve");
    }

    @TestMetadata("memberVsExtension3.resolve")
    public void testMemberVsExtension3() {
      runTest("compiler/testData/resolve/candidatesPriority/memberVsExtension3.resolve");
    }

    @TestMetadata("memberVsLocalExtension.resolve")
    public void testMemberVsLocalExtension() {
      runTest("compiler/testData/resolve/candidatesPriority/memberVsLocalExtension.resolve");
    }

    @TestMetadata("memberWithInvokeVsNonLocal.resolve")
    public void testMemberWithInvokeVsNonLocal() {
      runTest("compiler/testData/resolve/candidatesPriority/memberWithInvokeVsNonLocal.resolve");
    }

    @TestMetadata("wrongReceiverVsOtherError.resolve")
    public void testWrongReceiverVsOtherError() {
      runTest("compiler/testData/resolve/candidatesPriority/wrongReceiverVsOtherError.resolve");
    }
  }

  @TestMetadata("compiler/testData/resolve/delegatedProperty")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class DelegatedProperty extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInDelegatedProperty() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/delegatedProperty"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("delegationByCall.resolve")
    public void testDelegationByCall() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationByCall.resolve");
    }

    @TestMetadata("delegationByConstructor.resolve")
    public void testDelegationByConstructor() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationByConstructor.resolve");
    }

    @TestMetadata("delegationByFun.resolve")
    public void testDelegationByFun() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationByFun.resolve");
    }

    @TestMetadata("delegationByObject.resolve")
    public void testDelegationByObject() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationByObject.resolve");
    }

    @TestMetadata("delegationByProperty.resolve")
    public void testDelegationByProperty() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationByProperty.resolve");
    }

    @TestMetadata("delegationInClass.resolve")
    public void testDelegationInClass() {
      runTest("compiler/testData/resolve/delegatedProperty/delegationInClass.resolve");
    }

    @TestMetadata("localDelegation.resolve")
    public void testLocalDelegation() {
      runTest("compiler/testData/resolve/delegatedProperty/localDelegation.resolve");
    }
  }

  @TestMetadata("compiler/testData/resolve/imports")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Imports extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInImports() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/imports"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("ImportConflictAllPackage.resolve")
    public void testImportConflictAllPackage() {
      runTest("compiler/testData/resolve/imports/ImportConflictAllPackage.resolve");
    }

    @TestMetadata("ImportConflictBetweenImportedAndRootPackage.resolve")
    public void testImportConflictBetweenImportedAndRootPackage() {
      runTest("compiler/testData/resolve/imports/ImportConflictBetweenImportedAndRootPackage.resolve");
    }

    @TestMetadata("ImportConflictBetweenImportedAndSamePackage.resolve")
    public void testImportConflictBetweenImportedAndSamePackage() {
      runTest("compiler/testData/resolve/imports/ImportConflictBetweenImportedAndSamePackage.resolve");
    }

    @TestMetadata("ImportConflictForFunctions.resolve")
    public void testImportConflictForFunctions() {
      runTest("compiler/testData/resolve/imports/ImportConflictForFunctions.resolve");
    }

    @TestMetadata("ImportConflictPackageAndClass.resolve")
    public void testImportConflictPackageAndClass() {
      runTest("compiler/testData/resolve/imports/ImportConflictPackageAndClass.resolve");
    }

    @TestMetadata("ImportConflictSameNameClass.resolve")
    public void testImportConflictSameNameClass() {
      runTest("compiler/testData/resolve/imports/ImportConflictSameNameClass.resolve");
    }

    @TestMetadata("ImportConflictWithClassObject.resolve")
    public void testImportConflictWithClassObject() {
      runTest("compiler/testData/resolve/imports/ImportConflictWithClassObject.resolve");
    }

    @TestMetadata("ImportConflictWithInFileClass.resolve")
    public void testImportConflictWithInFileClass() {
      runTest("compiler/testData/resolve/imports/ImportConflictWithInFileClass.resolve");
    }

    @TestMetadata("ImportConflictWithInnerClass.resolve")
    public void testImportConflictWithInnerClass() {
      runTest("compiler/testData/resolve/imports/ImportConflictWithInnerClass.resolve");
    }

    @TestMetadata("ImportConflictsWithMappedToJava.resolve")
    public void testImportConflictsWithMappedToJava() {
      runTest("compiler/testData/resolve/imports/ImportConflictsWithMappedToJava.resolve");
    }

    @TestMetadata("ImportNonBlockingAnalysis.resolve")
    public void testImportNonBlockingAnalysis() {
      runTest("compiler/testData/resolve/imports/ImportNonBlockingAnalysis.resolve");
    }

    @TestMetadata("ImportResolveOrderStable.resolve")
    public void testImportResolveOrderStable() {
      runTest("compiler/testData/resolve/imports/ImportResolveOrderStable.resolve");
    }
  }

  @TestMetadata("compiler/testData/resolve/labels")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Labels extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInLabels() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/labels"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("labelForPropertyInGetter.resolve")
    public void testLabelForPropertyInGetter() {
      runTest("compiler/testData/resolve/labels/labelForPropertyInGetter.resolve");
    }

    @TestMetadata("labelForPropertyInSetter.resolve")
    public void testLabelForPropertyInSetter() {
      runTest("compiler/testData/resolve/labels/labelForPropertyInSetter.resolve");
    }
  }

  @TestMetadata("compiler/testData/resolve/regressions")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Regressions extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInRegressions() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/regressions"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("kt300.resolve")
    public void testKt300() {
      runTest("compiler/testData/resolve/regressions/kt300.resolve");
    }

    @TestMetadata("kt45676.resolve")
    public void testKt45676() {
      runTest("compiler/testData/resolve/regressions/kt45676.resolve");
    }

    @TestMetadata("objectInsideFun.resolve")
    public void testObjectInsideFun() {
      runTest("compiler/testData/resolve/regressions/objectInsideFun.resolve");
    }
  }

  @TestMetadata("compiler/testData/resolve/varargs")
  @TestDataPath("$PROJECT_ROOT")
  @RunWith(JUnit3RunnerWithInners.class)
  public static class Varargs extends AbstractResolveTest {
    private void runTest(String testDataFilePath) {
      KotlinTestUtils.runTest(this::doTest, this, testDataFilePath);
    }

    public void testAllFilesPresentInVarargs() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File("compiler/testData/resolve/varargs"), Pattern.compile("^(.+)\\.resolve$"), null, true);
    }

    @TestMetadata("MoreSpecificVarargsOfEqualLength.resolve")
    public void testMoreSpecificVarargsOfEqualLength() {
      runTest("compiler/testData/resolve/varargs/MoreSpecificVarargsOfEqualLength.resolve");
    }

    @TestMetadata("NilaryVsVararg.resolve")
    public void testNilaryVsVararg() {
      runTest("compiler/testData/resolve/varargs/NilaryVsVararg.resolve");
    }

    @TestMetadata("UnaryVsVararg.resolve")
    public void testUnaryVsVararg() {
      runTest("compiler/testData/resolve/varargs/UnaryVsVararg.resolve");
    }
  }
}
