/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.script.experimental.typeProviders.generatedCode.impl

import kotlin.reflect.*
import kotlin.reflect.full.memberProperties

/**
 * Receiver type that will be used when the type of is generated by a type provider
 * and is therefore not known at compile time of the type provider.
 */
class GeneratedTypeReceiver(
    val instance: Any,
    val receiverType: KClass<*>
) {
    /**
     * Property delegate that enables using a proxy inside a method to refer to a property of a generated type.
     *
     * See [GeneratedTypeReceiver.property] for more usage information.
     */
    class Property<T> internal constructor(private val parent: GeneratedTypeReceiver) {
        private lateinit var propertyContainer: KProperty1<Any, T>

        private fun initialize(property: KProperty<*>) {
            if (!this::propertyContainer.isInitialized) {
                @Suppress("unchecked_cast")
                propertyContainer = parent.receiverType.memberProperties.first { it.name == property.name } as KProperty1<Any, T>
            }
        }

        operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
            initialize(property)
            return propertyContainer.get(parent.instance)
        }

        operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
            initialize(property)
            require(propertyContainer is KMutableProperty1<Any, T>) { "Property ${property.name} is not immutable" }
            (propertyContainer as? KMutableProperty1<Any, T>)?.set(parent.instance, value)
        }
    }

    private val members = mapOf(*receiverType.members.map { it.name to it }.toTypedArray())

    /**
     * Property delegate that enables using a proxy inside a method to refer to a property of the generated type.
     *
     * Example:
     * ```
     * makeDataClass("Foo") {
     *  property<Int>("bar")
     *
     *  method("baz") { arg: Int ->
     *      val bar by property<Int>()
     *      return bar + arg
     *  }
     * }
     * ```
     */
    fun <T> property(): Property<T> {
        return Property(this)
    }

    /**
     * Read the value of a property
     *
     * Example:
     * ```
     * makeDataClass("Foo") {
     *  property<Int>("bar")
     *
     *  method("baz") { arg: Int ->
     *      val bar = this["bar"]
     *      return bar + arg
     *  }
     * }
     * ```
     */
    operator fun <T> get(property: String): T {
        val member = members.getValue(property)
        require(member is KProperty<*>) { "Member $property of type ${member::class} is not a property" }

        @Suppress("unchecked_cast")
        return member.getter.call(instance) as T
    }

    /**
     * Set the value of a property
     */
    operator fun <T> set(property: String, value: T) {
        val member = members.getValue(property)
        require(member is KMutableProperty<*>) { "Member $property of type ${member::class} is not a property" }
        member.setter.call(instance, value)
    }

    /**
     * Call a method with a set of arguments
     *
     * Example:
     * ```
     * dataClass("Foo") {
     *  property<Int>("bar")
     *
     *  method("doSomething", "a", "b") { a: Int, b: Int ->
     *      a + b
     *  }
     *
     *  method("baz") { ->
     *      val something = "doSomething"("a" to 1, "b" to 2) as Int
     *      print(something)
     *  }
     * }
     * ```
     */
    operator fun <T : Any> String.invoke(vararg arguments: Pair<String, Any?>): T {
        val member = members.getValue(this)
        val parameters = mapOf(*member.parameters.map { it.name to it }.toTypedArray())

        val receiverParameter = parameters.getValue(null)
        require(receiverParameter.kind == KParameter.Kind.INSTANCE) { "Failed to find receiver parameter to method $this" }

        val map = mapOf(receiverParameter to instance, *arguments.map { parameters.getValue(it.first) to it.second }.toTypedArray())
        @Suppress("unchecked_cast")
        return member.callBy(map) as T
    }

    /**
     * Call a method with a set of arguments
     *
     * Example:
     * ```
     * makeDataClass("Foo") {
     *  property<Int>("bar")
     *
     *  method("doSomething") { a: Int, b: Int ->
     *      a + b
     *  }
     *
     *  method("baz") { ->
     *      val something = "doSomething"(1, 2) as Int
     *      print(something)
     *
     *  }
     * }
     * ```
     */
    operator fun <T : Any> String.invoke(firstArgument: Any?, vararg arguments: Any?): T {
        @Suppress("unchecked_cast")
        return members.getValue(this).call(instance, firstArgument, *arguments) as T
    }
}

// String Builder

private val indentFirstLineOn = setOf(null, '\n')

internal fun StringBuilder.append(string: String?, indent: Int) {
    append(string?.prependIndent(indent, indentFirstLine = indentFirstLineOn.contains(lastOrNull())))
}

internal fun StringBuilder.appendLine(string: String?, indent: Int) {
    appendLine(string?.prependIndent(indent, indentFirstLine = indentFirstLineOn.contains(lastOrNull())))
}

internal fun String.prependIndent(indent: Int, indentFirstLine: Boolean = false): String {
    val indentString = buildString { repeat(indent) { append("    ") } }

    return lineSequence()
        .mapIndexed { index, line ->
            when {
                !indentFirstLine && index == 0 -> line
                line.isBlank() -> {
                    when {
                        line.length < indentString.length -> indentString
                        else -> line
                    }
                }
                else -> indentString + line
            }
        }
        .joinToString("\n")
}

internal fun <T> StringBuilder.appendJoined(items: Iterable<T>, separator: String, block: StringBuilder.(T) -> Unit) {
    val count = items.count()
    for ((index, item) in items.withIndex()) {
        block(item)
        if (index < count - 1) {
            append(separator)
        }
    }
}
