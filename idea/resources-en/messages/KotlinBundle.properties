fix.insert.delegation.call=Insert ''{0}()'' call
fix.introduce.non.null.assertion=Add non-null asserted (!!) call
fix.remove.non.null.assertion=Remove unnecessary non-null assertion (!!)
fix.add.annotation.target=Add annotation target
fix.add.const.modifier=Add 'const' modifier
fix.add.constructor.parameter=Add constructor parameter ''{0}''
fix.make.data.class=Make ''{0}'' data class
fix.add.default.constructor=Add default constructor to 'expect' class
fix.add.explicit.import=Add explicit import
fix.add.function.body=Add function body
fix.add.is.to.when=Add ''is'' before ''{0}''
fix.add.new.line.after.annotations=Add new line after annotations
fix.make.type.parameter.reified=Make {0} reified and {1} inline
fix.add.return.last.expression=Add 'return' to last expression
fix.add.return.before.expression=Add 'return' before the expression
fix.add.return.before.lambda.expression=Add 'run' before the lambda expression
fix.add.semicolon.lambda.expression=Terminate preceding call with semicolon
fix.add.spread.operator.after.sam=Add a spread operator before an array passing as 'vararg'
fix.add.else.branch.when=Add else branch
fix.replace.with.assign.function.call=Replace with ''{0}'' call
fix.assign.to.property=Assign to property
fix.change.mutability.change.to.val=Change ''{0}'' to val
fix.change.type.argument=Change type argument to {0}
fix.change.to.function.invocation=Change to function invocation
fix.change.to.mutable.type=Change type to {0}

fix.change.to.property.access.family.remove=Remove invocation
fix.change.to.property.access.family.change=Change to property access

fix.change.to.labeled.return.family=Change to return with label
fix.change.to.labeled.return.text=Change to ''{0}''

fix.change.suspend.hierarchy.add=Add 'suspend' modifier to all functions in hierarchy
fix.change.suspend.hierarchy.remove=Remove 'suspend' modifier from all functions in hierarchy
fix.change.progress.looking.inheritors=Looking for class {0} inheritors…
fix.change.progress.analyzing.class.hierarchy=Analyzing class hierarchy…

fix.change.return.type.family=Change type
fix.change.return.type.text.primary.constructor=Change parameter ''{0}'' type of primary constructor of class ''{1}'' to ''{2}''
fix.change.return.type.text.function=Change parameter ''{0}'' type of function ''{1}'' to ''{2}''
fix.change.return.type.lambda=Change lambda expression return type to {0}
fix.change.return.type.remove.explicit.return.type=Remove explicitly specified return type
fix.change.return.type.remove.explicit.return.type.of=Remove explicitly specified return type of {0}
fix.change.return.type.return.type.text=Change return type to ''{0}''
fix.change.return.type.return.type.text.of=Change return type of {0} to ''{1}''
fix.change.return.type.type.text=Change type to ''{0}''
fix.change.return.type.type.text.of=Change type of {0} to ''{1}''
fix.change.return.type.presentation.property=property {0}
fix.change.return.type.presentation.function=function {0}
fix.change.return.type.presentation.enclosing.function=enclosing function
fix.change.return.type.presentation.enclosing=enclosing {0}
fix.change.return.type.presentation.called.function=called function
fix.change.return.type.presentation.accessed=accessed {0}
fix.change.return.type.presentation.called=called {0}
fix.change.return.type.presentation.base=base {0}

fix.cast.expression.family=Cast expression
fix.cast.expression.text=Cast expression ''{0}'' to ''{1}''

fix.change.accessor.family=Change accessor type
fix.change.accessor.getter=Change getter type to {0}
fix.change.accessor.setter.parameter=Change setter parameter type to {0}

fix.create.from.usage.dialog.title=Create from usage

fix.add.remaining.branches=Add remaining branches
fix.add.remaining.branches.with.star.import=Add remaining branches with * import

fix.add.type.annnotation.family=Add type annotation
fix.add.type.annnotation.text=Add type ''{0}'' to parameter ''{1}''

fix.add.tostring.call.family=Add 'toString()' call
fix.add.tostring.call.text=Add 'toString()' call
fix.add.tostring.call.text.safe=Add safe '?.toString()' call

fix.add.star.projection.family=Add star projections
fix.add.star.projection.text=Add ''{0}''

fix.change.to.star.projection.family=Change to star projection
fix.change.to.star.projection.text=Change type arguments to {0}

fix.change.to.use.spread.operator.family=Change to use spread operator
fix.change.to.use.spread.operator.text=Change ''{0}'' to ''{1}''

fix.change.type.family=Change type
fix.change.type.text=Change type from ''{0}'' to ''{1}''

fix.add.suspend.modifier.function=Make {0} suspend
fix.add.suspend.modifier.function.generic=Make containing function suspend
fix.add.suspend.modifier.receiver=Make {0} type suspend
fix.add.suspend.modifier.receiver.generic=Make receiver type suspend

fix.add.property.to.supertype.family=Add property to supertype
fix.add.property.to.supertype.text=Add ''{0}'' to ''{1}''
fix.add.property.to.supertype.text.generic=Add property to supertype…
fix.add.property.to.supertype.progress=Add property to type
fix.add.property.to.supertype.choose.type=Choose Type

fix.add.function.parameters.change.signature.constructor=Change the signature of constructor ''{0}''
fix.add.function.parameters.change.signature.function=Change the signature of function ''{0}''
fix.add.function.parameters.add.parameter.constructor=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to function ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Add {0,choice,1#parameter|2#parameters} to constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Add {0,choice,1#parameter|2#parameters} to function ''{1}''

fix.change.signature.family=Change signature of function/constructor
fix.change.signature.function.family=Change function signature
fix.change.signature.function.text=Change function signature to ''{0}''
fix.change.signature.function.text.generic=Change function signature...
fix.change.signature.function.popup.title=Choose Signature
fix.change.signature.lambda=Change the signature of lambda expression
fix.change.signature.remove.parameter=Remove parameter ''{0}''
fix.change.signature.unavailable=<not available>
fix.change.signature.error=<error>
fix.change.signature.unnamed.parameter=parameter

fix.change.object.to.class=Change 'object' to 'class'

fix.add.function.supertype.family=Add function to supertype
fix.add.function.supertype.text=Add function to supertype...
fix.add.function.supertype.progress=Add Function to Type
fix.add.function.supertype.choose.type=Choose Type
fix.add.function.supertype.add.to=Add ''{0}'' to ''{1}''

fix.add.generic.upperbound.text=Add ''{0}'' as upper bound for {1}
fix.add.generic.upperbound.family=Add generic upper bound

fix.add.modifier.inline.parameter.family=Add ''{0}'' to parameter
fix.add.modifier.inline.parameter.text=Add ''{0}'' to parameter ''{1}''

fix.add.modifier.inline.function.family=Add 'inline' to function
fix.add.modifier.inline.function.text=Add ''inline'' to function ''{0}''

fix.add.array.of.type.text=Add {0} wrapper
fix.add.array.of.type.family=Add 'arrayOf' wrapper

fix.add.loop.label.text.generic=Add label to loop
fix.add.loop.label.text=Add ''{0}'' to {1}

fix.add.modifier.family=Add modifier
fix.add.modifier.text=Make {0} ''{1}''
fix.add.modifier.text.generic=Add ''{0}'' modifier

fix.add.argument.name.family=Add name to argument
fix.add.argument.name.text.generic=Add name to argument...
fix.add.argument.name.text=Add name to argument: ''{0}''
fix.add.argument.name.step.choose.parameter.name=Choose parameter name

fix.change.feature.support.family=Enable/Disable {0} support
fix.change.feature.support.enabled=Enable {0} support
fix.change.feature.support.enabled.warning=Enable {0} support (with warning)
fix.change.feature.support.disabled=Disable {0} support

fix.create.expect.actual=Create expect / actual declaration
fix.create.missing.actual.members=Add missing actual members

fix.create.declaration.error=Cannot generate {0}: {1}
fix.create.declaration.error.inaccessible.type=Inaccessible type
fix.create.declaration.error.some.types.inaccessible=Some types are not accessible:

fix.add.annotation.family=Add annotation
fix.add.annotation.text.self=Add ''@{0}'' annotation
fix.add.annotation.text.declaration=Add ''@{0}'' annotation to ''{1}''
fix.add.annotation.text.containing.class=Add ''@{0}'' annotation to containing class ''{1}''

fix.import=Import
fix.import.kind.delegate.accessors=Delegate accessors
fix.import.kind.component.functions=Component functions
fix.import.exclude=Exclude ''{0}'' from auto-import

fix.move.file.to.package.family=Move file to package-matching directory
fix.move.file.to.package.text=Move file to {0}

fix.change.package.family=Change file's package to match directory
fix.change.package.text=Change file''s package to {0}

action.add.import.chooser.title=Imports

goto.super.chooser.function.title=Choose super function
goto.super.chooser.property.title=Choose super property
goto.super.chooser.class.title=Choose super class or interface

inspection.unused.receiver.parameter=Receiver parameter is never used
fix.unused.receiver.parameter.remove=Remove redundant receiver parameter

inspection.migration.title=Code Migration
inspection.migration.profile.name=Migration

fix.create.from.usage.family=Create from usage
fix.create.from.usage.local.variable=Create local variable ''{0}''

overridden.marker.implementations.multiple=Has implementations
overridden.marker.implementation=Is implemented in <br/>
overridden.marker.overrides.multiple=Is overridden in subclasses
overridden.marker.overrides=Is overridden in <br/>

overridden.marker.implementations.choose.implementation.title=Choose Implementation of {0}
overridden.marker.implementations.choose.implementation.find.usages=Overriding properties of {0}
overridden.marker.overrides.choose.implementation.title=Choose Super Implementation of {0}
overridden.marker.overrides.choose.implementation.find.usages=Super Implementations of {0}

remove.expression=Remove ''{0}''
unwrap.expression=Unwrap ''{0}''
remove.else=Remove else in ''{0}''
unwrap.else=Unwrap else in ''{0}''

override.declaration.x.in.y={0} in {1}
override.declaration.x.implements.y={0} in {1} implements {2} in {3}.
override.declaration.x.overrides.y.in.class.list={0} overrides declarations in the following classes/interfaces: {1} Do you want to {2} the base declarations?

override.declaration.unused.overriding.methods.title=Unused Overriding Members
override.declaration.unused.overriding.methods.description=There are unused members that override methods you delete.
override.declaration.choose.to.delete=Choose the ones you want to be deleted.
override.declaration.member=Member
override.declaration.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?

hierarchy.legend.member.is.defined.in.class=Member is defined in the class
hierarchy.legend.member.defined.in.superclass=Member is not defined in the class but defined in superclass
hierarchy.legend.member.should.be.defined=Member should be defined since the class is not abstract

intention.change.package.text=Change package

intention.extract.declarations.from.file.text=Extract declaration from current file
intention.extract.declarations.from.file.text.details=Extract ''{0}'' {1, choice, 0#|1#and subclasses }from current file

kotlin.compiler.option.generate.no.warnings=Report compiler &warnings
kotlin.compiler.option.additional.command.line.parameters=&Additional command line parameters:

kotlin.compiler.jvm.option.panel.title=Kotlin to JVM

kotlin.compiler.js.option.panel.title=Kotlin to JavaScript
kotlin.compiler.js.option.generate.sourcemaps=Generate &source maps
kotlin.compiler.js.option.output.prefix=File to &prepend to generated code:
kotlin.compiler.js.option.output.postfix=File to append to generated c&ode:
kotlin.compiler.js.option.output.copy.files=&Copy library runtime files

# Android Lint
android.klint.inspections.group.name=Android Lint for Kotlin

# Scratch Files
scratch.run.button=Run Scratch File
scratch.run.from.here.button=Run Scratch From Here
scratch.stop.button=Stop scratch execution
scratch.clear.button=Clear results
scratch.module.combobox=Use classpath of module
scratch.is.repl.checkbox=Use REPL
scratch.is.repl.checkbox.description=Runs in the Kotlin REPL. Executes only the new expressions added to the end of the scratch
scratch.is.interactive.checkbox=Interactive mode
scratch.is.interactive.checkbox.description=Runs after you stop typing for {0} seconds
scratch.make.before.run.checkbox=Make module before Run
scratch.make.before.run.checkbox.description=Make module {0} before running scratch. Only compiled code is reachable from this scope
scratch.inlay.output.mode=Inlay output mode\n\nThe output is shown in the code editor right next to the expression. Well suited for a short single-line output.
scratch.side.panel.output.mode.description=Side panel output mode
scratch.side.panel.output.mode=Side panel output mode\n\nThe output is shown in the separate panel. Useful if the output is long or multi-line.
scratch.inlay.output.mode.description=Inlay output mode

# Code insight
dialog.import.on.paste.title3=Select Import to Remove
copy.paste.reference.notification={0} {0, choice, 1#import was|2#imports were} added<p><span><a href=''show''>Review Added Imports...</a></span>

# Experimental features
experimental.ml.completion=ML Completion for Kotlin


plugin.verifier.compatibility.issue.title=Compatibility issue
plugin.verifier.compatibility.issue.message=Installed Kotlin plugin version ({0}) is not compatible with {1}.\nSome functionality may be broken.\n\nPlease reinstall the Kotlin plugin.

plugin.updater.notification.group=Kotlin plugin updates
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=A new version {0} of the Kotlin plugin is available. <b><a href="#">Install</a></b>
plugin.updater.downloading=Downloading plugins
plugin.updater.not.installed=Plugin update was not installed. <a href="#">See the log for more information</a>
plugin.updater.not.installed.misc=Plugin update was not installed: {0}. <a href="#">See the log for more information</a>
plugin.updater.error.check.failed=Kotlin plugin update check failed
plugin.updater.error.unexpected.repository.response=Unexpected plugin repository response
plugin.updater.error.cant.find.plugin.version=Couldn't find plugin version in repository response
plugin.updater.error.custom.repository=Checking custom plugin repository {0} failed

quick.doc.text.enum.ordinal=Enum constant ordinal: {0}
quick.doc.text.tailrec='tailrec' marks a function as <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">tail-recursive</a> (allowing the compiler to replace recursion with iteration)
quick.doc.text.lateinit='lateinit' allows initializing a <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">not-null property outside of a constructor</a>
quick.doc.no.documentation=No documentation available
quick.doc.section.deprecated=Deprecated:
quick.doc.section.replace.with=Replace with:
quick.doc.section.java.declaration=Java declaration:

action.decompile.java.name=Decompile to Java
action.decompile.busy.text=Kotlin Classfile

action.j2k.name=Convert Java to Kotlin
action.j2k.task.name=Convert files from Java to Kotlin
action.j2k.correction.investigate=Investigate Errors
action.j2k.correction.proceed=Proceed with Conversion
action.j2k.correction.required=Some code in the rest of your project may require corrections after performing this conversion. Do you want to find such code and correct it too?
action.j2k.correction.errors.single=''{0}'' contains syntax errors, the conversion result may be incorrect
action.j2k.correction.errors.multiple=''{0}'' and {1} other Java files contain syntax errors, the conversion result may be incorrect
action.j2k.error.cant.save.result=Failed to save conversion result: {0}
action.j2k.error.cant.find.document=couldn''t find document for ''{0}''
action.j2k.error.read.only=file ''{0}'' is read-only
action.j2k.errornothing.to.convert=Nothing to convert:<br>No writable Java files found

formatter.settings.title=Kotlin Formatter Settings

action.generate.functions.already.defined=Functions {0} are already defined for class {1}. Do you want to delete them and proceed?

action.generate.equals.choose.equals=Choose properties to be included in 'equals()'
action.generate.equals.choose.hashcode=Choose properties to be included in 'hashCode()'

action.generate.secondary.constructor.choose.properties=Choose Properties to Initialize by Constructor
action.generate.secondary.constructor.error.already.exists=Constructor already exists

action.generate.test.support.choose.framework=Choose Framework
action.generate.test.support.generate.test.function=Generate test function
action.generate.test.support.choose.test.name=Choose test name:
action.generate.test.support.edit.template=Edit Template
action.generate.test.support.error.no.template.found=No template found for {0}:{1}
action.generate.test.support.error.cant.convert.java.template=Couldn't convert Java template to Kotlin
action.generate.test.support.error.cant.generate.method=Cannot generate method: {0}

action.generate.tostring.name=Generate toString()
action.generate.tostring.template.single=Single template
action.generate.tostring.template.multiple=Multiple templates with concatenation
action.generate.tostring.choose.implementation=Choose implementation:
action.generate.tostring.generate.super.call=Generate call to super.toString()

action.new.file.text=Kotlin Class/File
action.new.file.description=Creates new Kotlin class or file
action.new.file.dialog.title=New Kotlin Class/File
action.new.file.dialog.file.title=File
action.new.file.dialog.class.title=Class
action.new.file.dialog.data.class.title=Data Class
action.new.file.dialog.sealed.class.title=Sealed Class
action.new.file.dialog.annotation.title=Annotation
action.new.file.dialog.interface.title=Interface
action.new.file.dialog.enum.title=Enum class
action.new.file.dialog.object.title=Object
action.new.file.error.empty.name=Name can't be empty
action.new.file.error.empty.name.part=Name can't have empty parts

action.new.script.name=Kotlin Script
action.new.script.description=Creates new Kotlin script
action.new.script.dialog.title=New Kotlin Script

action.new.worksheet.name=Kotlin Worksheet
action.new.worksheet.description=Creates new Kotlin Worksheet
action.new.worksheet.dialog.title=New Kotlin Worksheet

breadcrumbs.tooltip.indexing=Indexing…

copy.paste.resolve.references=Resolve pasted references

type.provider.anonymous.object=anonymous object
type.provider.unknown.type=Type is unknown
type.provider.smart.cast.from=(smart cast from {0})
type.provider.no.expression.found=No expression found

optimize.imports.collect.unused.imports=Collect unused imports
optimize.imports.task.removing.redundant.imports=Removing redundant imports

kdoc.section.title.receiver=Receiver
kdoc.section.title.parameters=Params
kdoc.section.title.returns=Returns
kdoc.section.title.throws=Throws
kdoc.section.title.author=Author
kdoc.section.title.properties=Properties
kdoc.section.title.constructor=Constructor
kdoc.section.title.since=Since
kdoc.section.title.suppress=Suppress
kdoc.section.title.samples=Samples
kdoc.section.title.see.also=See Also
kdoc.comment.unresolved=Unresolved

livetemplate.description.main=main() function
livetemplate.description.soutp=Prints function parameter names and values to System.out
livetemplate.description.iter=Iterate over elements of iterable (for-in loop)
livetemplate.description.ifn=Inserts 'if null' expression
livetemplate.description.inn=Inserts 'if not null' expression
livetemplate.description.void=Function returning nothing
livetemplate.description.fun0=Function with no parameters
livetemplate.description.fun1=Function with one parameter
livetemplate.description.fun2=Function with two parameters
livetemplate.description.interface=Interface
livetemplate.description.singleton=Singleton
livetemplate.description.closure=Closure (function without name)
livetemplate.description.anonymous=Anonymous class
livetemplate.description.exfun=Extension function
livetemplate.description.exval=Extension read-only property
livetemplate.description.exvar=Extension read-write property

hints.progress.calculating.parameter.info=Calculating parameter info

hints.settings.common.items=Show hints for:
hints.settings.types=Types
hints.settings.types.property=Property types
hints.settings.types.variable=Local variable types
hints.settings.types.return=Function return types
hints.settings.types.parameter=Function parameter types

hints.settings.lambdas=Lambdas
hints.settings.lambda.return=Return expressions
hints.settings.lambda.receivers.parameters=Implicit receivers and parameters

hints.settings.suspending=Suspending calls

hints.title.argument.name.enabled=Argument name

presentation.text.paren=({0})
presentation.text.in.container.paren=(in {0})
presentation.text.in.container={0} in {1}
presentation.text.for.receiver.in.container.paren=(for {0} in {1})
presentation.text.object.in.container=object in {0}

project.view.class.initializer=class initializer
project.view.class.error.name=no name provided

copy.text.adding.imports=Adding imports ...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=Clipboard content seems to be Java code. Do you want to convert it to Kotlin?
copy.text.convert.java.to.kotlin=Convert Java to Kotlin
copy.text.copied.kotlin.code=Copied kotlin code
copy.text.resolving.references=Resolving references ...
copy.title.convert.code.from.java=Convert Code From Java

editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=Auto add val keyword to data/inline class constructor parameters
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convert pasted Java code to Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=Don't show Java to Kotlin conversion dialog on paste
editor.title.kotlin=Kotlin

facet.checkbox.text.use.project.settings=Use project settings
facet.column.name.options=Options
facet.column.name.plugin=Plugin
facet.error.text.at.least.one.target.platform.should.be.selected=At least one target platform should be selected
facet.label.text.selected.target.platforms=Selected target platforms:
facet.label.text.target.platform=Target platform:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=The project is imported from external build system and could not be edited
facet.link.text.edit.project.settings=Edit project settings
facet.name.compiler.plugins=Compiler Plugins
facet.name.general=General
facet.text.following.arguments.are.redundant=Following arguments are redundant: {0}
facet.text.following.arguments.override.facet.settings=Following arguments override facet settings: {0}
facet.text.following.options.are.not.correct=Following options are not correct:
facet.text.multiplatform=Multiplatform

filters.text.inline.function.body=inline function body
filters.text.inline.function.call.site=inline function call site
filters.title.navigate.to=Navigate to

find.usages.type.named.argument=Named argument
find.usages.type.type.alias=Type alias
find.usages.type.callable.reference=Callable reference
find.usages.type.type.constraint=Type constraint
find.usages.type.value.parameter.type=Parameter type
find.usages.type.nonLocal.property.type=Class/object property type
find.usages.type.function.return.type=Function return types
find.usages.type.superType=Supertype
find.usages.type.is=Target type of 'is' operation
find.usages.type.class.object=Nested class/object
find.usages.type.companion.object=Companion object
find.usages.type.function.call=Function call
find.usages.type.implicit.get=Implicit 'get'
find.usages.type.implicit.set=Implicit 'set'
find.usages.type.implicit.invoke=Implicit 'invoke'
find.usages.type.implicit.iteration=Implicit iteration
find.usages.type.property.delegation=Property delegation
find.usages.type.extension.receiver.type=Extension receiver type
find.usages.type.super.type.qualifier=Super type qualifier
find.usages.type.receiver=Receiver
find.usages.type.delegate=Delegate
find.usages.type.packageDirective=Package directive
find.usages.type.packageMemberAccess=Package member access
find.usages.progress.text.declaration.superMethods=Resolving super methods...

formatter.button.text.use.import.with.when.at.least=Use import with '*' when at least
formatter.button.text.use.import.with=Use import with '*'
formatter.button.text.use.single.name.import=Use single name import
formatter.checkbox.text.insert.imports.for.nested.classes=Insert imports for nested classes
formatter.checkbox.text.use.trailing.comma=Use trailing comma
formatter.text.names.used=\ names used
formatter.text.use.defaults.from=Use defaults from:
formatter.title.after.colon.before.declaration.type=After colon, before declaration type
formatter.title.after.colon.in.new.type.definition=After colon in new type definition
formatter.title.align.when.branches.in.columns=Align 'when' branches in columns
formatter.title.around.arrow.in.function.types=Around arrow in function types
formatter.title.around.arrow.in=Around arrow in "when" clause
formatter.title.around.when.branches.with=Around 'when' branches with {}
formatter.title.before.declaration.with.comment.or.annotation=Before declaration with comment or annotation
formatter.title.before.colon.after.declaration.name=Before colon, after declaration name
formatter.title.before.colon.in.new.type.definition=Before colon in new type definition
formatter.title.before.lambda.arrow=Before lambda arrow
formatter.title.chained.function.calls=Chained function calls
formatter.title.elvis.expressions=Elvis expressions
formatter.title.expression.body.functions=Expression body functions
formatter.title.function.annotations=Function annotations
formatter.title.function.call.arguments=Function call arguments
formatter.title.function.declaration.parameters=Function declaration parameters
formatter.title.function.parentheses=Function parentheses
formatter.title.in.simple.one.line.methods=In simple one line methods
formatter.title.java.statics.and.enum.members=Java Statics and Enum Members
formatter.title.load.save=Load/Save
formatter.title.other=Other
formatter.title.trailing.comma=Trailing comma
formatter.title.property.annotations=Property annotations
formatter.title.put.left.brace.on.new.line=Put left brace on new line
formatter.title.range.operator=Range operator (..)
formatter.title.top.level.symbols=Top-level Symbols
formatter.title.use.continuation.indent.in.conditions=Use continuation indent in conditions
formatter.title.use.continuation.indent=Use continuation indent
formatter.title.when.parentheses='when' parentheses
formatter.title.when.statements='when' statements

framework.name.kotlin.sdk=Kotlin SDK

hierarchy.text.anonymous=[anonymous]
hierarchy.text.in=\ in {0}

highlighter.action.text.go.to.actual.declarations=Go to actual declarations
highlighter.action.text.go.to.expected.declaration=Go to expected declaration
highlighter.action.text.go.to.implementations=Go to implementations
highlighter.action.text.go.to.overridden.methods=Go to overridden methods
highlighter.action.text.go.to.overridden.properties=Go to overridden properties
highlighter.action.text.go.to.subclasses=Go to subclasses
highlighter.action.text.go.to.super.method=Go to super method
highlighter.action.text.go.to.super.property=Go to super property
highlighter.descriptor.text.android.extensions.property=Properties and Variables//Android Extensions synthetic properties
highlighter.descriptor.text.annotation=Annotation//Annotation name
highlighter.descriptor.text.annotation.attribute.name=Annotation//Annotation attribute name
highlighter.descriptor.text.arrow=Braces and Operators//Arrow
highlighter.descriptor.text.builtin.annotation=Keywords//Modifier
highlighter.descriptor.text.builtin.keyword.val=Keywords//'val'
highlighter.descriptor.text.builtin.keyword.var=Keywords//'var'
highlighter.descriptor.text.builtin.keyword=Keywords//Keyword
highlighter.descriptor.text.captured.variable=Properties and Variables//Variables and values captured in a closure
highlighter.descriptor.text.closure.braces=Braces and Operators//Lambda expression braces and arrow
highlighter.descriptor.text.colon=Braces and Operators//Colon
highlighter.descriptor.text.constructor.call=Functions//Constructor call
highlighter.descriptor.text.double.colon=Braces and Operators//Double colon
highlighter.descriptor.text.dynamic.fun.call=Functions//Dynamic function call
highlighter.descriptor.text.dynamic.property=Properties and Variables//Dynamic property
highlighter.descriptor.text.enumEntry=Classes and Interfaces//Enum entry
highlighter.descriptor.text.exclexcl=Braces and Operators//Non-null assertion
highlighter.descriptor.text.extension.fun.call=Functions//Extension function call
highlighter.descriptor.text.extension.property=Properties and Variables//Extension property
highlighter.descriptor.text.field=Properties and Variables//Backing field variable
highlighter.descriptor.text.fun.call=Functions//Function call
highlighter.descriptor.text.fun=Functions//Function declaration
highlighter.descriptor.text.instance.property.custom.property.declaration=Properties and Variables//Instance property with custom property declarations
highlighter.descriptor.text.instance.property=Properties and Variables//Instance property
highlighter.descriptor.text.it=Parameters//Lambda expression default parameter
highlighter.descriptor.text.kdoc.comment=Comments//KDoc//KDoc comment
highlighter.descriptor.text.kdoc.tag=Comments//KDoc//KDoc tag
highlighter.descriptor.text.kdoc.value=Comments//KDoc//Link in KDoc tag
highlighter.descriptor.text.label=Label
highlighter.descriptor.text.local.variable=Properties and Variables//Local variable or value
highlighter.descriptor.text.named.argument=Named argument
highlighter.descriptor.text.object=Classes and Interfaces//Object
highlighter.descriptor.text.enum=Classes and Interfaces//Enum
highlighter.descriptor.text.package.fun.call=Functions//Package-level function call
highlighter.descriptor.text.package.property.custom.property.declaration=Properties and Variables//Package-level property with custom property declarations
highlighter.descriptor.text.package.property=Properties and Variables//Package-level property
highlighter.descriptor.text.quest=Braces and Operators//Type nullability marker
highlighter.descriptor.text.safe.access=Braces and Operators//Safe access dot
highlighter.descriptor.text.smart.cast.receiver=Smart-casts//Smart-cast implicit receiver
highlighter.descriptor.text.smart.cast=Smart-casts//Smart-cast value
highlighter.descriptor.text.smart.constant=Smart-casts//Smart constant
highlighter.descriptor.text.string.escape=String//Escape in string and template braces
highlighter.descriptor.text.suspend.fun.call=Functions//Suspend function call
highlighter.descriptor.text.synthetic.extension.property=Properties and Variables//Synthetic extension property
highlighter.descriptor.text.typeAlias=Classes and Interfaces//Type alias
highlighter.descriptor.text.var=Properties and Variables//Var (mutable variable, parameter or property)
highlighter.descriptor.text.variable.as.function.call=Properties and Variables//Variable as function call
highlighter.descriptor.text.variable.as.function.like.call=Properties and Variables//Variable as function-like call
highlighter.message.suspend.function.call=Suspend function call
highlighter.message.suspending.iteration=Suspending iteration
highlighter.name.dsl.markers=DSL markers
highlighter.name.dsl=Dsl//
highlighter.name.implemented.declaration=Implemented declaration
highlighter.name.implementing.declaration=Implementing declaration
highlighter.name.kotlin.line.markers=Kotlin line markers
highlighter.name.multiplatform.actual.declaration=Multiplatform actual declaration
highlighter.name.multiplatform.expect.declaration=Multiplatform expect declaration
highlighter.name.overridden.declaration=Overridden declaration
highlighter.name.overriding.declaration=Overriding declaration
highlighter.name.style=Style
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=Navigation to overriding classes is not possible during index update
highlighter.prefix.text.has.actuals.in=Has actuals in
highlighter.text.click.for.navigate=Click {0}to navigate
highlighter.text.has.functional.implementations=Has functional implementations
highlighter.text.implements=Implements
highlighter.text.in={0} in ''{1}''
highlighter.text.modules=\ ({0} modules)
highlighter.text.or.press=\ or press {0}
highlighter.text.overrides=Overrides
highlighter.title.actuals.for=Actuals for {0}
highlighter.title.choose.actual.for=Choose actual for {0}
highlighter.title.choose.expected.for=Choose expected for {0}
highlighter.title.expected.for=Expected for {0}
highlighter.title.overriding.declarations.of=Overriding declarations of {0}
highlighter.title.searching.for.overriding.declarations=Searching for overriding declarations
highlighter.title.searching.for.overriding.methods=Searching for overriding methods
highlighter.tool.tip.has.declaration.in.common.module=Has declaration in common module
highlighter.tool.tip.marker.annotation.for.dsl=Marker annotation for DSL
highlighter.tool.tip.text.function=function
highlighter.tool.tip.text.property=property
highlighter.tool.tip.text.recursive.call=Recursive call
highlighter.tool.tip.text.run.test=Run Test

import.optimizer.notification.text.unused.imports.not.found=Unused imports not found
import.optimizer.progress.indicator.text.collect.imports.for=Collect imports for {0}
import.optimizer.text.import={0, choice, 0#import|2#imports}
import.optimizer.text.non.zero=Removed {0} {1}{2, choice, 0#|1#, added {2} {3}}
import.optimizer.text.zero=Rearranged imports

internal.action.text.decompile.kotlin.bytecode=Decompile kotlin bytecode
internal.error.text.cannot.decompile=Cannot decompile {0}
internal.indicator.text.decompiling=Decompiling {0}
internal.title.decompiler.error=Decompiler error

version.title.no.runtime.found=No Runtime Found
version.dialog.message.is.not.found.make.sure.plugin.is.properly.installed={0} is not found. Make sure plugin is properly installed.
version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} is deprecated since 1.2.0 and should be replaced with {1}

update.name.android.studio=Android Studio
update.reason.text.exception.during.verification=exception during verification {0}
update.reason.text.no.verified.versions.for.this.build=No verified versions for this build.
update.reason.text.unable.to.connect.to.compatibility.verification.repository=unable to connect to compatibility verification repository
update.reason.text.unable.to.parse.compatibility.verification.metadata=unable to parse compatibility verification metadata
update.reason.text.version.to.be.verified=Version to be verified.

test.integration.button.text.cancel=Cancel
test.integration.button.text.rewrite=Rewrite
test.integration.message.text.create.test.in.the.same.source.root=Create test in the same source root?
test.integration.message.text.kotlin.class=Kotlin class ''{0}'' already exists. Do you want to update it?
test.integration.title.no.test.roots.found=No Test Roots Found

slicer.text.in=in
slicer.text.tracking.enclosing.lambda=\ (Tracking enclosing lambda)
slicer.text.tracking.lambda.calls=\ (Tracking lambda calls)
slicer.text.tracking.lambda.argument=\ (Tracking lambda parameter)
slicer.text.tracking.lambda.receiver=\ (Tracking lambda receiver)
slicer.title.dataflow.from.here=Dataflow from Here
slicer.title.dataflow.to.here=Dataflow to Here
slicer.tool.tip.text.variable.dereferenced=Variable dereferenced

script.action.text.ignore=Ignore
script.action.text.open.settings=Open Settings
script.action.text.show.all=Show all
script.name.kotlin.scripting=Kotlin Scripting
script.progress.text.kotlin.scanning.dependencies.for.script.definitions=Kotlin: scanning dependencies for script definitions...
script.text.multiple.script.definitions.are.applicable.for.this.script=Multiple script definitions are applicable for this script. {0} is used

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Update source roots for non-JVM modules in Kotlin project

reporter.button.text.ignore=Ignore
reporter.button.text.update=Update
reporter.message.text.you.re.running.kotlin.plugin.version=You''re running Kotlin plugin version {0}, while the latest version is {1}
reporter.text.can.t.report.exception.from.patched.plugin=Can't report exception from patched plugin
reporter.title.update.kotlin.plugin=Update Kotlin Plugin

configuration.action.text.ignore=Ignore
configuration.action.text.update=Update
configuration.description.always=Always
configuration.description.amd=AMD
configuration.description.commonjs=CommonJS
configuration.description.never=Never
configuration.description.plain.put.to.global.scope=Plain (put to global scope)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD (detect AMD or CommonJS if available, fallback to plain)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=When inlining a function from other module with embedded sources
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=Shouldn't add null urls to custom repositories
configuration.feature.text.new.experimental.project.wizard=New Experimental Project Wizard
configuration.feature.text.new.java.to.kotlin.converter=New Java to Kotlin Converter
configuration.message.enter.fully.qualified.method.name=Enter fully-qualified method name:
configuration.message.text.a.new.version.is.available=A new version {0} is available
configuration.message.text.a.new.version.is.found=A new version {0} is found but it''s not verified by {1}.
configuration.message.text.update.check.failed=Update check failed: {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=You have the latest version of the plugin installed.
configuration.message.verifier.disabled=(verifier disabled)
configuration.migration.text.api.version=API version: {0} -> {1}
configuration.migration.text.detected.migration=Detected migration:
configuration.migration.text.language.version=Language version: {0} -> {1}
configuration.migration.text.migrations.for.kotlin.code.are.available=Migrations for Kotlin code are available
configuration.migration.text.run.migrations=Run migrations
configuration.migration.text.standard.library=Standard library: {0} -> {1}
configuration.migration.title.kotlin.migration=Kotlin Migration
configuration.name.kotlin.compiler=Kotlin Compiler
configuration.name.kotlin=Kotlin
configuration.name.method=Method
configuration.status.text.installation.failed=Installation failed
configuration.status.text.installing=Installing...
configuration.text.add.exclusion=Add exclusion
configuration.text.and=and
configuration.text.other.s=other(s)
configuration.text.patched.original={0} (Patched! Original: {1})
configuration.text.the.compiler.bundled.to.kotlin.plugin=The compiler bundled to Kotlin plugin ({0}) is older than external compiler used for building modules:
configuration.text.this.may.cause.different.set.of.errors.and.warnings.reported.in.ide.p=This may cause different set of errors and warnings reported in IDE.
configuration.title.choose.output.directory=Choose Output Directory
configuration.title.early.access.preview.1.4.x=Early Access Preview 1.4.x
configuration.title.early.access.preview.1.5.x=Early Access Preview 1.5.x
configuration.title.edit.exclusion=Edit exclusion
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=Choose file to append to generated code
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=Choose file to prepend to generated code
configuration.title.outdated.bundled.kotlin.compiler=Outdated Bundled Kotlin Compiler
configuration.title.stable=Stable
configuration.warning.text.following.modules.override.project.settings=Following modules override project settings:
configuration.warning.text.modules.override.project.settings={0} modules override project settings
configuration.warning.text.language.version.unsupported=Language version {0} is no longer supported
configuration.warning.text.api.version.unsupported=API version {0} is no longer supported

#Refactoring
0.1.is.never.used={0} ''{1}'' is never used
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} has detected {1} code {1,choice,1#fragment|2#fragments} in {2} that can be replaced with {3}. Would you like to review and replace {1,choice,1#it|2#them}?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed={0} usages are not supported by the Inline refactoring. They won''t be processed.
0.will.become.invisible.after.extraction={0} will become invisible after extraction
0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
action.text.append=Append
action.text.cancel=Cancel
action.text.overwrite=Overwrite
button.text.move.nested.class.0.to.upper.level=Move &nested class {0} to upper level
button.text.move.nested.class.0.to.another.class=&Move nested class {0} to another class
cannot.extract.method=Cannot find statements to extract
cannot.extract.super.call=Cannot extract super-call
cannot.inline.property.with.accessor.s.and.backing.field=Cannot inline property with accessor(s) and backing field
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.no.type=Cannot perform refactoring without a type
cannot.refactor.not.expression.to.extract=Cannot find an expression to extract
cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.package.expression=Cannot introduce package reference
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.synthesized.function=Cannot refactor synthesized function ''{0}''
checkbox.text.declare.with.var=Declare with &var
checkbox.text.delete.empty.source.files=&Delete empty source files
checkbox.text.extension.property=E&xtension property:\u0020
checkbox.text.introduce.default.value=Introduce &default value
checkbox.text.open.moved.files.in.editor=Open moved member in editor
checkbox.text.replace.all.occurrences.0=&Replace all occurrences ({0})
checkbox.text.search.references=Search &references
checkbox.text.specify.type.explicitly=Specify &type explicitly
checkbox.text.update.package.directive=Update package directive (Kotlin files)
column.name.receiver=Receiver:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
description.a.reference.to.extracted.type.parameter=a reference to extracted type parameter
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
error.hint.text.cannot.inline.0.from.a.decompiled.file=Cannot inline ''{0}'' from a decompiled file
error.text.can.t.change.signature.of.method=Can''t change signature of {0} method
error.text.can.t.copy.class.to.the.containing.file=Can't copy class to the containing file
error.text.can.t.generate.0.1=Can''t generate {0}: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=Can't introduce lambda parameter for this expression
error.text.can.t.introduce.property.for.this.expression=Can't introduce property for this expression
error.text.different.name.expected=Different name expected
error.text.expression.has.no.type=Expression has no type
error.text.extraction.from.expect.class.is.not.yet.supported=Extraction from expect class is not yet supported
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Extraction from non-JVM class is not yet supported
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=Inline Function is not supported for functions with multiple return statements.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=Inline Function is not supported for functions with return statements not at the end of the body.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Interface cannot be extracted from an annotation class
error.text.introduce.parameter.is.not.available.for.default.value=Introduce Parameter is not available for default value
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introduce Parameter is not available inside of annotation entries
error.text.invalid.default.receiver.value=Invalid default receiver value
error.text.invalid.name=Invalid name
error.text.invalid.parameter.name=Invalid parameter name
error.text.invalid.parameter.type=Invalid parameter type
error.text.invalid.receiver.type=Invalid receiver type
error.text.invalid.return.type=Invalid return type
error.text.no.type.to.refactor=No type to refactor
error.text.refactoring.is.not.applicable.in.the.current.context=Refactoring is not applicable in the current context
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Superclass cannot be extracted from an annotation class
error.text.type.reference.is.expected=Type reference is expected
error.types.in.generated.function=Cannot generate function with erroneous return type
error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
extract.function=Extract Function
family.name.update.usages.on.declarations.cut.paste=Update usages on declarations cut/paste
file.does.not.exist=File {0} does not exist.\nDo you want to create it?
function.name.is.invalid=Function name is invalid
introduce.parameter=Introduce Parameter
introduce.property=Introduce Property
introduce.type.parameter.to.declaration=Introduce type parameter to declaration
introduce.type.parameter=Introduce Type Parameter
introduce.variable=Introduce Variable
label.text.default.receiver.value=&Default receiver value:\u0020
label.text.destination.directory=&Destination directory:
label.text.file.name=File &name:
label.text.introduce.as=&Introduce as:\u0020
label.text.name=&Name:\u0020
label.text.package.name=Packa&ge name:
label.text.receiver.type=Receiver &type:\u0020
label.text.target.file.name=Target file name:
label.text.to.file=To &file:
label.text.to.package=To p&ackage:
label.text.to.class=To class:
label.text.to.object=To object:
class.name.prompt=Class &name:
search.for.text.occurrences=Search for &text occurrences
search.in.comments.and.strings=Search in &comments and strings
parameter.name.prompt=Parameter na&me:
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
label.text.type=&Type:\u0020
label.text.move.expect.actual.counterparts=&Move expect/actual counterparts
label.text.visibility=&Visibility:\u0020
member.info.abstract.0=abstract {0}
member.info.companion.0=companion {0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Change signature is not applicable to dynamically invoked functions
message.do.not.show.for.local.variables.in.future=Do not show for local variables in future
message.text.return.type.cannot.be.resolved=Return type ''{0}'' cannot be resolved.\nContinue?
message.text.type.alias.0.is.never.used=Type alias ''{0}'' is never used
message.type.for.cannot.be.resolved=Type ''{0}'' for {1} cannot be resolved.\nContinue?
name.extract.interface=Extract Interface
name.inline.type.alias=Inline Type Alias
name.introduce.import.alias=Introduce Import Alias
name.introduce.lambda.parameter=Introduce Lambda Parameter
name.introduce.parameter1=Introduce Parameter
name.introduce.type.alias=Introduce Type Alias
name.kdoc.for.abstracts=KDoc for abstracts
naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename
non.kotlin.usage.0=Non-Kotlin usage: {0}
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
refactoring.move.non.kotlin.file=Target must be a Kotlin file
return.type.is.invalid=Return type is invalid
searching.usages.of.0.parameter=Searching usages of ''{0}''parameter
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
setter.of.0.will.become.invisible.after.extraction=Setter of {0} will become invisible after extraction
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' must be moved with sealed parent class and all its subclasses
text.0.already.contains.1={0} already contains {1}
text.0.already.contains.nested.class.1={0} already contains nested class named {1}
text.0.already.declared.in.1={0} is already declared in {1}
text.0.have.no.inheritors.warning={0} doesn''t have inheritors\nPushing members down will result in them being deleted. Would you like to proceed?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} in {1} will override corresponding member of {2} after refactoring
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} inherits from {1}.\nIt won''t be affected by the refactoring
text.0.is.invalid.destination.package=''{0}'' is invalid destination package name
text.0.is.not.allowed.in.the.target.context=''{0}'' is not allowed in the target context
text.0.is.not.valid.package.name={0} is not a valid package name
text.0.to.inline={0} to inline
text.0.uses.1.which.is.not.accessible.from.2={0} uses {1}, which is not accessible from the {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} uses {1} which will be inaccessible after move
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} uses {1} which won''t be accessible from the subclass.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} uses internal {1} which will be inaccessible after move
text.0.will.be.shadowed.by.1={0} will be shadowed by {1}
text.0.will.clash.with.existing.1.in.2={0} after rename will clash with existing {1} in {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} will no longer be accessible after signature change
text.all.declarations.must.belong.to.the.same.directory.or.class=All declarations must belong to the same directory or class
text.all=All
text.anonymous=[Anonymous]
text.at.least.one.file.must.be.selected=At least one member must be selected
text.callee.text.would.be.shown.here=Callee text would be shown here
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Caller text\nwith highlighted callee call would be shown here
text.cannot.create.target.directory.0=Cannot create target directory {0}
text.cannot.determine.source.directory=Can't determine sources directory
text.cannot.find.package.corresponding.to.0=Could not find package corresponding to {0}
text.cannot.find.target.package.name=Cannot find target package name
text.cannot.inline.0.1.usages=Cannot inline {0}/{1} usages
text.cannot.move.for.current.project=Can't move for current project
text.cannot.move.inner.class.0.into.itself=Cannot move nested class {0} to itself
text.cannot.move.to.original.file=Can't move to the original file
text.cannot.move.expect.actual.declaration.to.file=Could't move expect/actual declaration to file
text.change.file.package.to.0=Change file''s package to ''{0}''
text.choose.containing.file=Choose Containing File
text.class.0.already.contains.member.1={0} already contains {1}
text.class.0.already.exists.in.package.1=Class {0} already exists in package {1}
text.class.0.already.exists.in.the.target.scope=Class {0} already exists in the target scope 
text.class.0.is.final={0} is final
text.constructor=constructor
text.convert._it_.to.explicit.lambda.parameter=Convert 'it' to explicit lambda parameter
text.create.destructuring.declaration=Create destructuring declaration
text.create.single.variable=Create single variable
text.declaration=declaration
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Following declarations would clash: to move {0} and destination {1} declared in scope {2}
text.default.value=\ // default value = {0}
text.destination.class.should.be.kotlin.class=Destination class must be a Kotlin class
text.do.you.want.to.rename.0.as.well=Do you want to rename {0}() as well?
text.do.you.want.to.rename.base.property.from.0=Do you want to rename base property from \n{0}
text.do.you.want.to.rename.base.property=Do you want to rename base property
text.duplicating.local.variable=Duplicating local variable ''{0}''
text.duplicating.parameter=Duplicating parameter ''{0}''
text.duplicating.property=Duplicating property ''{0}''
text.explicit.receiver.is.already.present.in.call.element.0=Explicit receiver is already present in call element: {0}
text.extract.superclass=Extract Superclass
text.file.0.already.exists.in.1=File {0} already exists in {1}
text.file.name.cannot.be.empty=File name may not be empty
text.function.already.exists=Function already exists: ''{0}''
text.function.in.ticks.0=function ''{0}''
text.function=function
text.implicit.companion.object.will.be.inaccessible.0=Implicit companion object will be inaccessible: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Incorrect target path. Directory {0} does not belong to current project.
text.indirect.outer.instances.will.not.be.extracted.0=Indirect outer instances won''t be extracted: {0}
text.inline.0.1.2=Inline {0} ''{1}''? {2}
text.inline.0=Inline {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inline all references and {0} the {1} {2}
text.inline.recursive.function.is.supported.only.on.references=Inline recursive function is supported only on references
text.inline.this.reference.and.keep.the.0=Inline this reference and keep the {0}
text.inlining.0.1=Inlining {0} {1}
text.inner.class.0.cannot.be.moved.to.intefrace={0} is an inner class. It can not be moved to the interface
text.introduce.default.value=Intro&duce default value
text.invalid.target.path.0=Invalid target path {0}
text.invalid.target.specified=Invalid target specified
text.keep=keep
text.lambda.parameter=lambda parameter
text.lambda.parameters=Lambda &parameters:\u0020
text.lambda.return.type=Lambda return &type
text.lazy.property=lazy property
text.local.property=property
text.local.variable=local variable
text.looking.for.usages=Looking for Usages
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} in super class would clash with existing member of {1}
text.member.extension.call.will.not.be.processed.0=Member extension call won''t be processed: {0}
text.move.declaration.no.support.for.companion.objects=Move declaration is not supported for companion objects
text.move.declaration.no.support.for.enums=Move declaration is not supported for enum entries
text.move.declaration.supports.only.top.levels.and.nested.classes=Move declaration is only supported for top-level declarations and nested classes
text.move.declaration.proceed.move.without.mpp.counterparts.text=This refactoring will move selected declaration without it's expect/actual counterparts that may lead to compilation errors.\nDo you wish to proceed?
text.move.declaration.proceed.move.without.mpp.counterparts.title=MPP declarations does not supported by this refactoring.
text.move.declarations=Move declarations
text.no.destination.object.specified=No destination object specified
text.select.a.name.for.this.parameter=Select a name for ''this@{0}'' parameter
text.move.method.is.not.supported.for.non.project.methods=Move method is not supported for non-project methods
text.move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
text.references.to.outer.classes.have.to.be.added.manually=References to outer classes will have to be added manually after move
text.move.method=Move method
text.move.file.0=Move {0}
text.move.refactoring.not.available.during.indexing=Move refactoring is not available while indexing is in progress
text.moving.multiple.nested.classes.to.top.level.not.supported=Moving multiple nested classes to top-level is not supported
text.Name=Name
text.nested.classes.to.upper.level=Nested Classes to Upper Level
text.no.elements.to.move.are.selected=No elements to move are selected
text.no.files.to.move=There is no given files to move
text.no.name.provided.for.type.alias=No name provided for type alias
text.no.package.corresponds.to.directory=No package corresponds to this directory
text.non.kotlin.0.will.not.be.affected.by.refactoring=Non-Kotlin {0} won''t be affected by the refactoring
text.overload=Overload
text.package.directive.dont.match.file.location=Package directive doesn't match file location
text.parameter.0=parameter ''{0}''
text.parameter.name=Parameter &name:\u0020
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Parameter reference can''t be safely replaced with {0} since {1} is ambiguous in this context
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Parameter reference can''t be safely replaced with {0} since target function can''t be referenced in this context
text.parameter.type=Parameter &type:\u0020
text.parameter=Parameter
text.parameters=&Parameters
text.proceed.with.extraction=Proceed with extraction
text.process.duplicates=Process Duplicates
text.processing.file.0=Processing {0}
text.property.in.ticks.0=property ''{0}''
text.property.with.getter=property with getter
text.property.with.initializer=property with initializer
text.property=property
text.pushed.member.will.not.be.available.in.0=Pushed member won''t be available in ''{0}''
text.qualified.call.will.not.be.processed.0=Qualified call won''t be processed: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=Receiver can''t be safely transformed to value argument: {0}
text.receiver=receiver
text.refactoring.can.t.be.performed.on.the.selected.code.element=Refactoring can't be performed on the selected code element
text.refactoring.is.not.applicable.to.this.code.fragment=Refactoring is not applicable to this code fragment
text.references.in.code.to.0.1.and.its.declarations=References in code to {0} {1} and its declarations
text.remove.0.no.longer.used=Remove {0} no longer used
text.remove.question=Remove '?'
text.remove=remove
text.rename.as.part.of.phrase=rename
text.rename.is.not.applicable.to.secondary.constructors=Rename is not applicable to secondary constructors
text.rename.is.not.applicable.to.synthetic.declarations=Rename is not applicable to synthetic declaration
text.rename.not.applicable.to.backing.field.reference=Rename is not applicable to backing field reference
text.rename.not.applicable.to.dynamically.invoked.methods=Rename is not applicable to dynamically invoked members
text.rename.overloads.title=Rename Overloads
text.rename.overloads.to=Rename overloads to:
text.rename.parameters.in.hierarchy.to=Rename parameter in hierarchy to:
text.rename.parameters.title=Rename Parameters
text.rename.warning=Rename warning
text.sealed.class.0.must.be.moved.with.all.its.subclasses=Sealed class ''{0}'' must be moved with all its subclasses
text.select.target.code.block.file=Select target code block / file
text.select.target.code.block=Select target code block
text.select.target.file=Select target file
text.the.following=The following
text.there.is.already.a.parameter=There is already a parameter ''{0}'' in {1}. It will conflict with the new parameter.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=There is already a variable ''{0}'' in {1}. It will conflict with the new parameter.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Type alias cannot refer to types which aren't accessible in the scope where it's defined
text.type.alias.name.must.be.a.valid.identifier.0=Type alias name must be a valid identifier: {0}
text.type.alias=type alias
text.type.already.exists.in.the.target.scope=Type {0} already exists in the target scope
text.type.parameter.names.must.be.distinct=Type parameter names must be distinct
text.type.parameters=Type &Parameters
text.type=Type
text.unexpected.element.type.0=Unexpected element type: {0}
text.update.usages.to.reflect.declaration.0.move=Update usages to reflect {0, choice, 0#declaration|1#declarations} move
text.updating.usages.progress=Updating usages...
text.variable=variable
title.change.signature=Change Signature
title.inline.function=Inline Function
title.introduce.parameter.to.declaration=Introduce parameter to declaration
title.move.nested.classes.to.upper.level=Move Nested Classes to Upper Level
title.move.method=Move Method
title.choose.destination.object=Choose Destination Object
title.select.target.code.block=Select target code block
unsupported.usage.0=Unsupported usage: {0}

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=Do you want to delete this parameter in expected declaration and all related actual ones?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=Do you want to delete expected declaration together with all related actual ones?
delete.with.usage.search=delete (with usage search)

destination.not.found.for.package.0=Destination not found for package ''{0}''
leave.in.same.source.root=Leave in same source root
test.root.is.selected.while.the.source.root.is.expected=Test root is selected while the source root is expected
source.root.is.selected.while.the.test.root.is.expected=Source root is selected while the test root is expected
premature.end.of.template=Premature end of template
choose.target.class.or.interface=Choose target class or interface
text.abstract=abstract
text.secondary.constructor=secondary constructor
text.create=Create
text.member=member
text.extension=extension
text.object=object
text.interface=interface
text.enum.constant=enum constant
text.enum=enum
text.annotation=annotation
create.0.1=Create {0} ''{1}''
choose.class.container=Choose class container
file.0.already.exists.but.does.not.correspond.to.kotlin.file=File {0} already exists but does not correspond to Kotlin file
create.file=Create file
create.0=Create {0}
create.package.0=Create package ''{0}''
text.type.parameter=type {0, choice, 0#parameter|2#parameters}
create.0.in.1=Create {0} in {1}
searching.0=Searching {0}...
create.property.0.as.constructor.parameter=Create property ''{0}'' as constructor parameter
create.parameter.0=Create parameter ''{0}''
add.property=Add property
text.add=Add '
property.0.to.1='' property ''{0}'' to ''{1}''
add.method=Add method
add.0.constructor.to.1=Add {0} constructor to ''{1}''
text.secondary=secondary
text.primary=primary
add.method.0.to.1=Add method ''{0}'' to ''{1}''
create.actual.0.for.module.1.2=Create actual {0} for module {1} ({2})
create.expected.0.in.common.module.1=Create expected {0} in common module {1}
repair.actual.members=Repair actual members
these.declarations.cannot.be.transformed=These declarations cannot be transformed:
unknown.types=Unknown types
choose.actual.members=Choose actual members
text.annotation.class=annotation class
text.enum.class=enum class
text.class=class
type.0.1.is.not.accessible.from.target.module={0, choice, 0#Type|2#Types} {1} is not accessible from target module
the.function.declaration.shouldn.t.have.a.default.implementation=The function declaration shouldn't have a default implementation
some.types.are.not.accessible.from.0.1=Some types are not accessible from {0}:\n{1}
the.declaration.has.0.modifier=The declaration has `{0}` modifier
inaccessible.declaration=Inaccessible declaration
fix.with.asdynamic=Fix with 'asDynamic'
migrate.type.parameter.list.syntax=Migrate type parameter list syntax
replace.deprecated.symbol.usage=Replace deprecated symbol usage
replace.with.0=Replace with ''{0}''
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=There is own ''ReplaceWith'' on ''{0}'' that is used through this alias. Please replace usages first.
replace.deprecated.symbol.usage.in.whole.project=Replace deprecated symbol usage in whole project
applying.0=Applying ''{0}''
replace.usages.of.0.in.whole.project=Replace usages of ''{0}'' in whole project
replace.with.publishedapi.bridge.call=Replace with @PublishedApi bridge call
replace.with.generated.publishedapi.bridge.call.0=Replace with generated @PublishedApi bridge call ''{0}''
convert.sealed.sub.class.to.object.fix.family.name=Convert sealed sub-class to object
generate.identity.equals.fix.family.name=Generate equals \\& hashCode by identity
and.delete.initializer=\ and delete initializer
change.to.val=Change to val
change.to.var=Change to var
change.type.of.0.to.1=Change type of {0} to ''{1}''
change.type.to.0=Change type to ''{0}''
base.property.0=base property {0}
make.0=Make {0}
make.0.1.explicitly=Make ''{0}'' {1} explicitly
make.0.explicitly=Make {0} explicitly
use.inherited.visibility=Use inherited visibility
replace.with.in.when=Replace ',' with '||' in when
remove.0=Remove ''.{0}''
remove.conversion.from.kclass.to.class=Remove conversion from 'KClass' to 'Class'
convert.to.0=Convert to {0}
convert.expression.to.0.by.inserting.1=Convert expression to ''{0}'' by inserting ''.{1}''
convert.extension.property.initializer.to.getter=Convert extension property initializer to getter
convert.supertype.to.0=Convert supertype to ''{0}''
convert.extension.function.type.to.regular.function.type=Convert extension function type to regular function type
convert.to.notnull.delegate=Convert to notNull delegate
convert.to.anonymous.object=Convert to anonymous object
select.loop.statement.to.label=Select loop statement to label
select.lambda.to.label=Select lambda to label
create.label=Create label
create.label.0=Create label {0}@
convert.member.to.extension=Convert member to extension
replace.annotation=Replace Annotation
replace.annotation.with.0=Replace annotation with {0}
add.initializer=Add initializer
move.to.constructor.parameters=Move to constructor parameters
initialize.with.constructor.parameter=Initialize with constructor parameter
inline.type.parameter=Inline type parameter
insert.explicit.delegation.call=Insert explicit delegation call
kotlin.add.required.module.fix.family.name=Add 'requires' directive to module-info.java
the.anonymous.object=the anonymous object
text.implement=implement
text.extend=extend
let.0.1=Let {0} {1}
let.type.implement.interface=Let type implement interface
0.interface.1={0} interface ''{1}''
lift.assignment.out.of.try.expression=Lift assignment out of 'try' expression
make.class.an.annotation.class=Make class an annotation class
make.0.an.annotation.class=Make ''{0}'' an annotation class
make.constructor.parameter.a.property.0=Make constructor parameter a property{0}
in.class.0=\ in class ''{0}''
add.0.to.module.1.compiler.arguments=Add ''{0}'' to module {1} compiler arguments
add.an.opt.in.requirement.marker.compiler.argument=Add an opt-in requirement marker compiler argument
make.0.in.1.open=Make ''{0}'' in {1} open
add.modifier=Add Modifier
make.private.and.0.1=Make private and {0} ''{1}''
text.overrides=overrides
text.implements=implements
make.type.parameter.reified.and.function.inline=Make type parameter reified and function inline
change.all.usages.of.0.in.this.file.to.1=Change all usages of ''{0}'' in this file to ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Change all usages of ''{0}'' in this file to a Kotlin class
change.to.kotlin.class=Change to Kotlin class
choose.an.appropriate.kotlin.class=Choose an appropriate Kotlin class
add.empty.brackets.after.primary.constructor=Add empty brackets after primary constructor
add.constructor.keyword=Add 'constructor' keyword
move.annotation.to.receiver.type=Move annotation to receiver type
move.type.parameter.constraint.to.where.clause=Move type parameter constraint to 'where' clause
move.else.branch.to.the.end=Move else branch to the end
insert.number.conversion=Insert number conversion
convert.expression.to.0=Convert expression to ''{0}''
remove.from.annotation.argument=Remove @ from annotation argument
remove.default.parameter.value=Remove default parameter value
remove.final.upper.bound=Remove final upper bound
remove.function.body=Remove function body
remove.redundant.0.modifier=Remove redundant ''{0}'' modifier
make.0.not.1=Make {0} not {1}
remove.0.modifier=Remove ''{0}'' modifier
remove.modifier=Remove modifier
remove.identifier.from.anonymous.function=Remove identifier from anonymous function
remove.constructor.call=Remove constructor call
make.not.nullable=Make not-nullable
remove.useless=Remove useless '?'
remove.redundant=Remove redundant '?'
remove.0.from.property=Remove {0} from property
remove.parts.from.property=Remove parts from property
text.initializer=initializer
text.setter=setter
text.getter=getter
remove.element=Remove element
for.0=for ''{0}''
remove.conflicting.import.0=Remove conflicting import {0}
remove.type.parameters=Remove type parameters
remove.type.arguments=Remove type arguments
remove.star=Remove '*'
remove.variable.0=Remove variable ''{0}''
remove.redundant.initializer=Remove redundant initializer
remove.redundant.label=Remove redundant label
remove.single.lambda.parameter.declaration=Remove single lambda parameter declaration
remove.supertype=Remove supertype
remove.0.variance.from.1=Remove ''{0}'' variance from ''{1}''
remove.parameter.0=Remove parameter ''{0}''
remove.redundant.assignment=Remove redundant assignment
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=There are possible side effects found in expressions assigned to the variable ''{0}''<br>You can:<br>-\\&nbsp;<b>Remove</b> the entire assignment, or<br>-\\&nbsp;<b>Transform</b> assignment right-hand side into the statement on its own.<br>
remove.useless.cast=Remove useless cast
remove.useless.elvis.operator=Remove useless elvis operator
remove.useless.is.check=Remove useless is check
remove.val.var.from.parameter=Remove 'val/var' from parameter
remove.0.from.parameter=Remove ''{0}'' from parameter
remove.else.branch=Remove else branch
rename.identifier.fix.text=Rename
rename.to.0=Rename to ''{0}''
rename.parameter.to.match.overridden.method=Rename parameter to match overridden method
rename.to.underscore=Rename to _
replace.with.safe.this.call=Replace with safe (this?.) call
replace.with.safe.call=Replace with safe (?.) call
replace.scope.function.with.safe.call=Replace scope function with safe (?.) call
replace.with.dot.call=Replace with dot call
replace.with.safe.call1=Replace with safe (?.) call
replace.invalid.positioned.arguments.for.annotation=Replace invalid positioned arguments for annotation
replace.jvmfield.with.const=Replace '@JvmField' with 'const'
replace.modifier=Replace modifier
update.obsolete.label.syntax=Update obsolete label syntax
replace.with.label.0.at=Replace with label {0}@
replace.cast.with.call.to.to.0=Replace cast with call to ''to{0}()''
replace.cast.with.primitive.conversion.method=Replace cast with primitive conversion method
replace.with.array.call=Replace with array call
remove.expression.target=Remove EXPRESSION target
change.existent.retention.to.source=Change existent retention to SOURCE
add.source.retention=Add SOURCE retention
round.using.0=Round using {0}()
simplify.0.to.1=Simplify {0} to ''{1}''
simplify.comparison=Simplify comparison
specify.override.for.0.explicitly=Specify override for ''{0}'' explicitly
specify.override.explicitly=Specify override explicitly
specify.return.type.explicitly=Specify return type explicitly
specify.type.explicitly=Specify type explicitly
add.constructor.parameters.from.0.1=Add constructor parameters from {0}{1}
change.to.constructor.invocation=Change to constructor invocation
add.constructor.parameters.from.superclass=Add constructor parameters from superclass
surround.with.star.0=Surround with *{0}(...)
surround.with.lambda=Surround with lambda
surround.with.null.check=Surround with null check
convert.too.long.character.literal.to.string=Convert too long character literal to string
replace.array.of.boxed.with.array.of.primitive=Replace array of boxed with array of primitive
migrate.unsupported.yield.syntax=Migrate unsupported yield syntax
wrap.with=Wrap with []
wrap.with.array.literal=Wrap with array literal
wrap.with.collection.literal.call=Wrap with collection literal call
wrap.element.with.0.call=Wrap element with ''{0}()'' call
replace.with.0.call=Replace with ''{0}()'' call
wrap.with.let.call=Wrap with '?.let { ... }' call
change.to.0=Change to ''{0}''
change.to.correct.long.suffix.l=Change to correct long suffix 'L'
change.to.correct.primitive.type=Change to correct primitive type
0.from.1={0} from {1}
checking.data.classes=Checking Data Classes
checking.data.class.0.of.1=Checking data class {0} of {1}...
difference.found.for.data.class.0.found.1.2=Difference found for data class {0}. Found {1} usage(s) but {2} expected
title.error=Error
analyzed.0.classes.no.difference.found=Analyzed {0} classes. No difference found.
title.success=Success
can.t.finish.while.indexing.is.in.progress=Can't finish while indexing is in progress
enable.tremble.dumb.mode=Enable Tremble Dumb Mode
disable.tremble.dumb.mode=Disable Tremble Dumb Mode
finding.implicit.nothing.s=Finding Implicit Nothing's
scanning.files.0.fo.1.file.2.occurrences.found=Scanning files: {0} of {1} file. {2} occurrences found
implicit.nothing.s=Implicit Nothing's
not.found.in.0.files=Not found in {0} file(s)
titile.not.found=Not Found
search.for.not.property.candidates=Search for Not Property candidates
enter.package.fqname=Enter package FqName
searching.for.not.property.candidates=Searching for Not Property candidates
step.1.collecting.0.1.2=Step 1: Collecting {0}:{1}:{2}
step.2.0.of.1=Step 2: {0} of {1}
step.3.0.of.1=Step 3: {0} of {1}
title.done=Done
revert.applied.imports=revert applied imports
delete.0=delete {0}
replace.if.expression.with.elvis.expression=Replace 'if' expression with elvis expression
report.also.on.statement=Report also on statement
if.then.foldable.to=If-Then foldable to '?:'
replace.if.expression.with.safe.access.expression=Replace 'if' expression with safe access expression
remove.redundant.if.expression=Remove redundant 'if' expression
replace.if.expression.with.safe.cast.expression=Replace 'if' expression with safe cast expression
simplify.foldable.if.then=Simplify foldable if-then
foldable.if.then=Foldable if-then
introduce.when.subject=Introduce 'when' subject
when.with.subject.should.be.used='when' with subject should be used
introduce.0.as.subject.0.when=Introduce ''{0}'' as subject of ''when''
convert.call.chain.into.sequence.fix.text=Convert call chain into 'Sequence'
call.chain.length.to.transform=Call chain length to transform:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=Call chain on collection could be converted into 'Sequence' to improve performance
remove.useless.call.fix.text=Remove useless call
rename.useless.call.fix.text=Change call to ''{0}''
call.chain.on.collection.type.may.be.simplified=Call chain on collection type may be simplified
0.call.could.be.simplified.to.1={0} call could be simplified to {1}
simplify.call.fix.text=Convert ''{0}'' call to ''{1}''
simplify.call.chain.fix.text=Merge call chain to ''{0}''
call.on.collection.type.may.be.reduced=Call on collection type may be reduced
useless.call.on.collection.type=Useless call on collection type
this.call.is.useless.with=This call is useless with ?.
useless.call.on.not.null.type=Useless call on not-null type
call.on.not.null.type.may.be.reduced=Call on not-null type may be reduced
replace.total.order.equality.with.ieee.754.equality=Replace total order equality with IEEE 754 equality
replace.with.binary.operator=Replace with binary operator
call.replaceable.with.binary.operator=Call replaceable with binary operator
replace.get.or.set.call.with.indexing.operator=Replace get or set call with indexing operator
should.be.replaced.with.indexing=Should be replaced with indexing
replace.0.call.with.indexing.operator=Replace ''{0}'' call with indexing operator
function.returning.0.with.a.name.that.does.not.end.with.1=Function returning {0} with a name that does not end with {1}
add.call.or.unwrap.type.fix.text=Add ''.{0}()'' to function result (breaks use-sites!)
add.call.or.unwrap.type.fix.text1=Unwrap ''{0}'' return type (breaks use-sites!)
reports.only.function.calls.from.kotlinx.coroutines=Reports only function calls from kotlinx.coroutines
deferred.result.is.never.used=Deferred result is never used
function.0.returning.1.without.the.corresponding=Function ''{0}'' returning ''{1}'' without the corresponding function ''{2}'' returning ''{3}''
redundant.async.call.may.be.reduced.to.0=Redundant ''async'' call may be reduced to ''{0}''
redundant.runcatching.call.may.be.reduced.to.0=Redundant 'runCatching' call may be reduced to ''{0}''
rename.to.fix.text=Rename to ''{0}''
wrap.with.coroutine.scope.fix.text=Wrap function body with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text2=Wrap call with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text3=Remove receiver \\& wrap with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.family.name=Wrap with coroutineScope
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=Ambiguous coroutineContext due to CoroutineScope receiver of suspend function
replace.with.kotlin.analog.function.family.name=Replace with Kotlin analog
should.be.replaced.with.kotlin.function=Should be replaced with Kotlin function
replace.with.kotlin.analog.function.text=Replace with `{0}` function
add.documentation.fix.text=Add documentation
missing.documentation=Missing documentation
0.is.missing.documentation={0} is missing documentation
library.should.be.updated.to.be.compatible.with.kotlin.1.3=Library should be updated to be compatible with Kotlin 1.3
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=It''s prohibited to call {0} with MIN_VALUE step since 1.3
obsolete.coroutine.usage.in.whole.fix.family.name=Fix experimental coroutines usages in the project
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Fix 'kotlin.dom' and 'kotlin.browser' packages usages in the project
apply.in.the.project.0=Apply in the project: {0}
obsolete.coroutine.usage.fix.family.name=Fix experimental coroutines usage
obsolete.package.usage.fix.family.name=Fix ''{0}'' package usage
0.is.expected.to.be.used.since.kotlin.1.3=`{0}` is expected to be used since Kotlin 1.3
methods.are.absent.in.coroutines.class.since.1.3=Methods are absent in coroutines class since 1.3
experimental.coroutines.usages.are.obsolete.since.1.3=Experimental coroutines usages are obsolete since 1.3
package.usages.are.obsolete.since.1.4=''{0}'' package usages are obsolete since 1.4
replace.substring.call.with.droplast.call=Replace 'substring' call with 'dropLast' call
replace.substring.call.with.indexing.operation.call=Replace 'substring' call with indexing operation call
replace.substring.call.with.substringbefore.call=Replace 'substring' call with 'substringBefore' call
replace.substring.call.with.substringafter.call=Replace 'substring' call with 'substringAfter' call
replace.substring.call.with.take.call=Replace 'substring' call with 'take' call
add.operator.modifier=Add 'operator' modifier
function.should.have.operator.modifier=Function should have 'operator' modifier
type.parameter.can.have.0.variance=Type parameter can have {0} variance
add.variance.fix.text=Add ''{0}'' variance
add.variance.fix.family.name=Add variance
generate.equals.and.hashcode.fix.text=Generate equals() and hashCode()
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Array property in data class: it's recommended to override equals() / hashCode()
report.also.on.call.with.single.boolean.literal.argument=Report also on call with single boolean literal argument
boolean.literal.argument.without.parameter.name=Boolean literal argument without parameter name
constructor.parameter.is.never.used.as.a.property=Constructor parameter is never used as a property
property.is.explicitly.assigned.to.parameter.0.can=Property is explicitly assigned to parameter {0}, can be declared directly in constructor
variable.is.never.modified.and.can.be.declared.immutable.using.val=Variable is never modified and can be declared immutable using 'val'
sealed.sub.class.has.no.state.and.no.overridden.equals=Sealed sub-class has no state and no overridden equals
cascade.if.should.be.replaced.with.when=Cascade if should be replaced with when
mark.as.deprecated.level.deprecationlevel.hidden=Mark as @Deprecated(..., level = DeprecationLevel.HIDDEN)
searching.for.imports.to.delete=Searching for imports to delete
delete.redundant.extension.property=Delete redundant extension property
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=This property conflicts with synthetic extension and should be removed or renamed to avoid breaking code by future changes in the compiler
condition.is.always.0=Condition is always ''{0}''
remove.fix.text=Delete expression
simplify.fix.text=Simplify expression
0.has.empty.body=''{0}'' has empty body
convert.na.n.equality.quick.fix.text=Replace with 'isNaN()'
equality.check.with.nan.should.be.replaced.with.isnan=Equality check with NaN should be replaced with 'isNaN()'
convert.pair.constructor.to.to.fix.text=Convert to 'to'
can.be.converted.to.to=Can be converted to 'to'
convert.to.a.range.check=Convert to a range check
two.comparisons.should.be.converted.to.a.range.check=Two comparisons should be converted to a range check
copy.method.of.data.class.is.called.without.named.arguments='copy' method of data class is called without named arguments
private.data.class.constructor.is.exposed.via.the.generated.copy.method=Private data class constructor is exposed via the generated 'copy' method.
remove.var.keyword.text=Remove var
delegating.to.var.property.does.not.take.its.changes.into.account=Delegating to 'var' property does not take its changes into account
add.replacewith.argument.to.specify.replacement.pattern=Add 'replaceWith' argument to specify replacement pattern
deprecated.annotation.without.replacewith.argument=@Deprecated annotation without 'replaceWith' argument
variable.name.0.matches.the.name.of.a.different.component=Variable name ''{0}'' matches the name of a different component
replace.with.down.to.fix.text=Replace with 'downTo'
this.range.is.empty.did.you.mean.to.use.downto=This range is empty. Did you mean to use 'downTo'?
equals.hashcode.in.object.declaration=equals()/hashCode() in object declaration
hash.code.text=Generate 'hashCode()'
equals.text=Generate 'equals()'
delete.equals.and.hash.code.fix.text=Delete equals()/hashCode()
redundant.explicit.this=Redundant explicit this
explicit.this.expression.fix.family.name=Remove redundant ''{0}''
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=Use of non-const Kotlin property as Java constant is incorrect. Will be forbidden in 1.4
replace.if.with.elvis.operator=Replace 'if' with elvis operator
if.null.return.break.foldable.to=If-Null return/break/... foldable to '?:'
loop.parameter.0.is.unused=Loop parameter ''{0}'' is unused
replace.with.repeat.fix.family.name=Replace with 'repeat()'
introduce.anonymous.parameter.fix.family.name=Introduce anonymous parameter
wrap.run.fix.text=Convert to run { ... }
remove.braces.fix.text=Remove braces
function.with.and.inferred.return.type=Function with `= { ... }` and inferred return type
report.for.types.with.platform.arguments=Report for types with platform arguments
apply.only.to.public.or.protected.members=Apply only to public or protected members
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.
callable.reference.fix.family.name=Add explicit ''{0}''
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java Collections static method call should be replaced with Kotlin stdlib
replace.with.std.lib.fix.text=Replace with {0}.{1}
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Call of Java mutator ''{0}'' on immutable Kotlin collection ''{1}''
replace.with.kotlin.s.foreach=Replace with Kotlin's forEach
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach method call should be replaced with Kotlin's forEach
remove.deprecated.symbol.import=Remove deprecated symbol import
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Usage of redundant or deprecated syntax or deprecated symbols
equals.should.take.any.as.its.argument='equals' should take 'Any?' as its argument
double.negation.fix.text=Remove redundant negations
redundant.double.negation=Redundant double negation
equals.between.objects.of.inconvertible.types='equals()' between objects of inconvertible types
usage.of.kotlin.internal.declaration.from.different.module=Usage of Kotlin internal declaration from different module
junit.static.methods=JUnit static methods
redundant.override.fix.text=Remove redundant overriding method
redundant.overriding.method=Redundant overriding method
throwable.instance.0.is.not.thrown=Throwable instance ''{0}'' is not thrown
result.of.0.call.is.not.thrown=Result of ''{0}'' call is not thrown
optimize.imports=Optimize imports
unused.import.directive=Unused import directive
lateinit.var.overrides.lateinit.var=lateinit var overrides lateinit var
leaking.this.in.constructor.of.non.final.class.0=Leaking ''this'' in constructor of non-final class {0}
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Leaking ''this'' in constructor of enum class {0} (with overridable members)
accessing.non.final.property.0.in.constructor=Accessing non-final property {0} in constructor
calling.non.final.function.0.in.constructor=Calling non-final function {0} in constructor
text.can=can
text.should=should
text.Assignment=Assignment
text.Return=Return
text.return=return
0.1.be.lifted.out.of.2={0} {1} be lifted out of ''{2}''
lift.assignment.out.fix.text.0=Lift assignment out of ''{0}''
lift.return.out.fix.text.0=Lift return out of ''{0}''
change.main.function.return.type.to.unit.fix.text=Add explicit Unit return type
change.main.function.return.type.to.unit.fix.text2=Change return type to Unit
0.should.return.unit={0} should return Unit
junit.test=JUnit test
map.get.with.not.null.assertion.operator=map.get() with not-null assertion operator (!!)
replace.with.get.or.else.fix.text=Replace with 'getOrElse' call
replace.with.get.value.call.fix.text=Replace with 'getValue' call
replace.with.elvis.error.fix.text=Replace with '?: error("")'
might.be.const=Might be 'const'
const.might.be.used.instead.of.jvmfield='const' might be used instead of '@JvmField'
text.Function=Function
text.Property=Property
0.1.could.be.private={0} ''{1}'' could be private
diagnostic.name.should.be.replaced.by.the.new.one=Diagnostic name should be replaced by the new one
replace.diagnostic.name.fix.text={0} with {1}
replace.diagnostic.name.fix.family.name=Replace diagnostic name
lambda.argument.0.be.moved.out=Lambda argument {0} be moved out of parentheses
move.lambda.argument.out.of.parentheses=Move lambda argument out of parentheses
suspicious.callable.reference.as.the.only.lambda.element=Suspicious callable reference as the only lambda element
inline.variable=Inline variable
move.variable.declaration.into.when=Move variable declaration into `when`
nothing.to.do=Nothing to do
variable.declaration.could.be.inlined=Variable declaration could be inlined
variable.declaration.could.be.moved.into.when=Variable declaration could be moved into `when`
may.contain.only.letters.digits.or.underscores=may contain only letters, digits or underscores
may.contain.only.letters.and.digits=may contain only letters and digits
should.not.contain.underscores.in.the.middle.or.the.end=should not contain underscores in the middle or the end
should.not.start.with.an.underscore=should not start with an underscore
should.not.start.with.an.uppercase.letter=should not start with an uppercase letter
should.not.contain.underscores=should not contain underscores
should.start.with.a.lowercase.letter=should start with a lowercase letter
should.start.with.an.uppercase.letter=should start with an uppercase letter
doesn.t.match.regex.0=doesn''t match regex ''{0}''
text.pattern=Pattern:
package.name=Package name
text.part=part
text.name=name
text.Package=Package
add.explicit.parameter.to.outer.lambda.fix.text=Add explicit parameter name to outer lambda
implicit.parameter.it.of.enclosing.lambda.is.shadowed=Implicit parameter 'it' of enclosing lambda is shadowed
equality.cehck.0.be.used.instead.of.elvis.for.nullable.boolean.check=Equality check {0} be used instead of elvis for nullable boolean check
replace.with.equality.check.fix.text=Replace with equality check
null.checks.to.safe.call.check.fix.text=Replace chained null-checks with safe-calls
null.checks.replaceable.with.safe.calls=Null-checks replaceable with safe-calls
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=Optionally expected annotation has no actual annotation in module {0} for platform {1}
call.of.inline.function.with.nullable.extension.receiver.can.provoke.npe.in.kotlin.1.2=Call of inline function with nullable extension receiver can provoke NPE in Kotlin 1.2+
make.open.fix.text=Make class open
make.private.fix.text=Make private
protected.visibility.is.effectively.private.in.a.final.class='protected' visibility is effectively 'private' in a final class
apply.also.to.private.members=Apply also to private members
apply.also.to.internal.members=Apply also to internal members
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=For API stability, it's recommended to specify explicitly declaration types
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=For API stability, it's recommended to specify explicitly public \\& protected declaration types
recursive.equals.call=Recursive equals call
replace.with.field.fix.text=Replace with 'field'
recursive.synthetic.property.accessor=Recursive synthetic property accessor
recursive.property.accessor=Recursive property accessor
remove.redundant.companion.reference.fix.text=Remove redundant Companion reference
redundant.companion.reference=Redundant Companion reference
remove.redundant.else.fix.text=Remove redundant 'else'
redundant.else=Redundant 'else'
remove.initializer.block.fix.text=Remove initializer block
redundant.empty.initializer.block=Redundant empty initializer block
remove.enum.constructor.invocation.fix.text=Remove enum constructor invocation
redundant.enum.constructor.invocation=Redundant enum constructor invocation
explicitly.given.type.is.redundant.here=Explicitly given type is redundant here
remove.redundant.getter.fix.text=Remove redundant getter
redundant.getter=Redundant getter
remove.redundant.if.text=Remove redundant 'if' statement
redundant.if.statement=Redundant 'if' statement
delete.fix.family.name=Remove arrow
redundant.lambda.arrow=Redundant lambda arrow
remove.let.call=Remove `let` call
redundant.let.call.could.be.removed=Redundant `let` call could be removed
redundant.modality.modifier=Redundant modality modifier
this.type.probably.can.be.changed.to.nullable=This type probably can be changed to nullable
redundant.type.checks.for.object=Redundant type checks for object
replace.with.equality.fix.text=Replace ''{0}'' with ''{1}''
redundant.0.call=Redundant ''{0}'' call
remove.require.not.null.call.fix.text=Remove ''{0}'' call
remove.return.label.fix.text=Remove redundant ''@{0}''
remove.return.label.fix.family=Remove redundant label
redundant.0=Redundant ''@{0}''
remove.redundant.sam.constructors=Remove redundant SAM-constructors
remove.redundant.sam.constructor=Remove redundant SAM-constructor
redundant.sam.constructors=Redundant SAM-constructors
redundant.sam.constructor=Redundant SAM-constructor
fix.text=Remove redundant semicolon
redundant.semicolon=Redundant semicolon
remove.redundant.setter.fix.text=Remove redundant setter
redundant.setter=Redundant setter
redundant.suspend.modifier=Redundant 'suspend' modifier
redundant.unit.return.type=Redundant 'Unit' return type
redundant.visibility.modifier=Redundant visibility modifier
remove.redundant.unit.fix.text=Remove redundant 'Unit'
redundant.unit=Redundant 'Unit'
remove.redundant.with.fix.text=Remove redundant 'with' call
redundant.with.call=Redundant 'with' call
reformat.quick.fix.family.name=Reformat File
apply.only.to.modified.files.for.projects.under.a.version.control=Apply only to modified files (for projects under a version control)
file.is.not.properly.formatted=File is not properly formatted
remove.jvmoverloads.annotation=Remove @JvmOverloads annotation
report.also.for.a.variables.without.a.whitespace.around=Report also for a variables without a whitespace around
remove.curly.braces=Remove curly braces
redundant.curly.braces.in.string.template=Redundant curly braces in string template
remove.empty.parentheses.from.annotation.entry.fix.text=Remove unnecessary parentheses
parentheses.should.be.removed=Parentheses should be removed
remove.redundant.qualifier.name.quick.fix.text=Remove redundant qualifier name
redundant.qualifier.name=Redundant qualifier name
remove.redundant.backticks.quick.fix.text=Remove redundant backticks
remove.redundant.spread.operator.quickfix.text=Remove redundant spread operator
remove.to.string.fix.text=Remove 'toString()' call
redundant.tostring.call.in.string.template=Redundant 'toString()' call in string template
redundant.setter.parameter.type=Redundant setter parameter type
replace.with.contentequals=Replace '!=' with 'contentEquals'
replace.with.contentequals2=Replace '==' with 'contentEquals'
replace.with.contentequals3=Replace with 'contentEquals'
dangerous.array.comparison=Dangerous array comparison
replace.with.array.literal.fix.family.name=Replace with [...]
0.call.should.be.replaced.with.array.literal=''{0}'' call should be replaced with array literal [...]
replace.assert.boolean.with.assert.equality=Replace assert boolean with assert equality
replace.0.with.1=Replace ''{0}'' with ''{1}''
replace.collection.count.with.size.quick.fix.text=Replace 'count' with 'size'
could.be.replaced.with.size=Could be replaced with `size`
replace.with.kotlin.s.function.call=Replace with kotlin's function call
replace.guard.clause.with.kotlin.s.function.call=Replace guard clause with kotlin's function call
replace.index.loop.with.collection.loop.quick.fix.text=Replace with loop over elements
replace.manual.range.with.indices.call.quick.fix.text=Replace with indices
range.could.be.replaced.with.indices.call=Range could be replaced with '.indices' call
for.loop.over.indices.could.be.replaced.with.loop.over.elements=For loop over indices could be replaced with loop over elements
replace.negated.0.with.1=Replace negated ''{0}'' with ''{1}''
replace.with.elvis.return.fix.text=Replace with ''?: return{0}''
replace.with.return=Replace '!!' with '?: return'
convert.put.to.assignment=Convert put to assignment
map.put.should.be.converted.to.assignment=map.put() should be converted to assignment
replace.int.range.end.inclusive.with.last.quick.fix.text=Replace 'endInclusive' with 'last'
replace.int.range.start.with.first.quick.fix.text=Replace 'start' with 'first'
could.be.replaced.with.unboxed.last=Could be replaced with unboxed `last`
could.be.replaced.with.unboxed.first=Could be replaced with unboxed `first`
replace.with.until.quick.fix.text=Replace with until
rangeto.or.the.call.should.be.replaced.with.until='rangeTo' or the '..' call should be replaced with 'until'
replace.with.string.literal.fix.family.name=Replace with string templates
string.format.call.can.be.replaced.with.string.templates=String.format call can be replaced with string templates
replace.tostring.with.string.template=Replace 'toString' with string template
call.of.tostring.could.be.replaced.with.string.template=Call of 'toString' could be replaced with string template
replace.to.with.infix.form.quickfix.text=Replace 'to' with infix form
replace.with.enum.map.fix.text=Replace with EnumMap
replaceable.with.enummap=Replaceable with EnumMap
replace.with.operator.assignment=Replace with operator-assignment
replaceable.with.operator.assignment=Replaceable with operator-assignment
replace.with.0.eq=Replace with ''{0}=''
replace.with.if.fix.text=Replace with 'if' type check
should.be.replaced.with.if.type.check=Should be replaced with 'if' type check
call.is.replaceable.with.another.scope.function=Call is replaceable with another scope function
convert.scope.function.fix.family.name=Convert to ''{0}''
variable.0.is.assigned.to.itself=Variable ''{0}'' is assigned to itself
remove.self.assignment.fix.text=Remove self assignment
convert.to.nullable.type.fix.text=Convert to nullable type
constructor.has.non.null.self.reference.parameter=Constructor has non-null self reference parameter
assign.backing.field.fix.text=Assign backing field
existing.backing.field.is.not.assigned.by.the.setter=Existing backing field is not assigned by the setter
replace.with.error=Replace with '?: error(...)'
replace.assert.with.operator=Replace assert with operator
assert.should.be.replaced.with.operator=assert should be replaced with operator
simplify.negated.operation=Simplify negated operation
negated.operation.should.be.simplified=Negated operation should be simplified
replace.negated.0.operation.with.1=Replace negated ''{0}'' operation with ''{1}''
simplify.when.fix.text=Simplify 'when'
this.when.is.simplifiable=This 'when' is simplifiable
sort.modifiers=Sort modifiers
non.canonical.modifiers.order=Non-canonical modifiers order
modifiers.should.follow.annotations=Modifiers should follow annotations
remove.as.dynamic.call.fix.text=Remove 'asDynamic' invocation
suspicious.asdynamic.member.invocation=Suspicious 'asDynamic' member invocation
0.creates.new.1.under.the.hood=''{0}'' creates new {1} under the hood
replace.with.filter.fix.text=Replace with filter
change.type.to.mutable.fix.text=Change type to mutable
replace.with.assignment.fix.text=Replace with assignment (original is empty)
join.with.initializer.fix.text=Join with initializer
suspicious.combination.of.and=Suspicious combination of == and ===
unlabeled.return.inside.lambda=Unlabeled return inside lambda
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Suspicious 'var' property: its setter does not influence its getter result
variable.used.only.in.following.return.and.should.be.inlined=Variable used only in following return and should be inlined
variable.is.same.as.0.and.should.be.inlined=Variable is same as ''{0}'' and should be inlined
implicit.unsafe.cast.from.dynamic.to.0=Implicit (unsafe) cast from dynamic to {0}
cast.explicitly.fix.text=Cast explicitly
unused.equals.expression=Unused equals expression
since.kotlin.1.3.main.parameter.is.not.necessary=Since Kotlin 1.3 main parameter is not necessary
remove.token.from.function.declaration=Remove '=' token from function declaration
unused.return.value.of.a.function.with.lambda.expression.body=Unused return value of a function with lambda expression body
safe.delete.constructor=Safe delete constructor
remove.unary.operator.fix.text=Remove unused unary operator
unused.unary.operator=Unused unary operator
one.line.return=one-line return
return.when='return when'
block.body=block body
use.expression.body.instead.of.0=Use expression body instead of {0}
convert.to.expression.body.fix.text=Convert to expression body
when.has.only.else.branch.and.should.be.simplified='when' has only 'else' branch and should be simplified
wrap.unary.operator.quickfix.text=Wrap unary operator and value with ()
make.0.1=Make ''{0}'' {1}
replace.with.0.operator=Replace with ''{0}'' operator
do.you.want.to.make.new.extension.an.expected.declaration=Do you want to make new extension an expected declaration?
loop.to.call.fix.family.name=Replace with stdlib operations
loop.to.call.fix.family.name2=Replace with stdlib operations with use of 'asSequence()'
loop.can.be.replaced.with.stdlib.operations=Loop can be replaced with stdlib operations
text.add.setter=Add setter
text.add.getter=Add getter
text.add.getter.and.setter=Add getter and setter
text.add.use.site.target.0=Add use-site target ''{0}''
choose.use.site.target=Choose use-site target
add.use.site.target=Add use-site target
add.braces.to.0.statement=Add braces to ''{0}'' statement
add.braces.to.when.entry=Add braces to 'when' entry
add.jvmoverloads.annotation.to.0=Add ''@JvmOverloads'' annotation to {0}
text.primary.constructor=primary constructor
function.0=function ''{0}''
looking.for.usages.in.java.files=Looking for usages in Java files...
add.return.at.0=Add return@{0}
add.0.to.argument=Add ''{0} ='' to argument
add.val.var.to.parameter.0=Add val/var to parameter ''{0}''
add.val.var.to.primary.constructor.parameter=Add val/var to primary constructor parameter
make.primary.constructor.0=Make primary constructor {0}
change.visibility.modifier=Change visibility modifier
0.may.break.code={0} (may break code)
convert.to.vararg.parameter=Convert to vararg parameter
replace.with=Replace '||' with '\\&\\&'
replace.with2=Replace '\\&\\&' with '||'
can.t.modify.0=Can''t modify {0}
0.already.exists={0} already exists
type.arguments.will.be.lost.after.conversion.0=Type arguments will be lost after conversion: {0}
call.with.arguments.will.be.skipped.0=Call with arguments will be skipped: {0}
looking.for.usages.and.conflicts=Looking for usages and conflicts...
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=Following expression won''t be processed since refactoring can''t preserve its semantics: {0}
callable.reference.transformation.is.not.supported.0=Callable reference transformation is not supported: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Can''t replace non-Kotlin reference with call expression: {0}
convert.0.to.1=Convert ''{0}'' to ''{1}''
convert.lambda.to.reference=Convert lambda to reference
select.target.code.block.file=Select target code block / file
select.target.file=Select target file
replace.expression.with.if.expression=Replace '!!' expression with 'if' expression
eliminate.argument.of.when=Eliminate argument of 'when'
replace.elvis.expression.with.if.expression=Replace elvis expression with 'if' expression
flatten.when.expression=Flatten 'when' expression
replace.if.expression.with.return=Replace 'if' expression with return
lift.return.out.of.if.expression=Lift return out of 'if' expression
replace.if.with.when=Replace 'if' with 'when'
replace.safe.access.expression.with.if.expression=Replace safe access expression with 'if' expression
replace.assignment.with.if.expression=Replace assignment with 'if' expression
replace.assignment.with.when.expression=Replace assignment with 'when' expression
replace.property.initializer.with.if.expression=Replace property initializer with 'if' expression
replace.property.initializer.with.when.expression=Replace property initializer with 'when' expression
replace.return.with.if.expression=Replace return with 'if' expression
replace.return.with.when.expression=Replace return with 'when' expression
replace.when.with.if=Replace 'when' with 'if'
replace.call.with.unary.operator=Replace call with unary operator
replace.contains.call.with.in.operator=Replace 'contains' call with 'in' operator
replace.invoke.with.direct.call=Replace 'invoke' with direct call
copy.concatenation.text.to.clipboard=Copy concatenation text to clipboard
split.property.declaration=Split property declaration
replace.with.stdlib.operations.with.use.of.assequence=Replace with stdlib operations with use of 'asSequence()'
replace.with.stdlib.operations=Replace with stdlib operations
use.withindex.instead.of.manual.index.increment=Use withIndex() instead of manual index increment
add.braces=Add braces
add.indices.to.for.loop=Add indices to 'for' loop
add.jvmoverloads.annotation=Add '@JvmOverloads' annotation
add.jvmstatic.annotation=Add '@JvmStatic' annotation
add.labeled.return.to.last.expression.in.a.lambda=Add labeled return to last expression in a lambda
add.missing.component=Add missing component
add.names.to.call.arguments=Add names to call arguments
add.names.to.this.argument.and.following.arguments=Add names to this argument and following arguments
add.name.to.argument=Add name to argument
make.open=Make open
add.throws.annotation=Add '@Throws' annotation
add.remaining.branches=Add remaining branches
convert.anonymous.function.to.lambda.expression=Convert anonymous function to lambda expression
convert.to.lambda.expression=Convert to lambda expression
put.arguments.on.separate.lines=Put arguments on separate lines
put.parameters.on.separate.lines=Put parameters on separate lines
demorgan.law=DeMorgan Law
replace.with.end.of.line.comment=Replace with end of line comment
convert.collection.constructor.to.function=Convert Collection constructor to function
convert.to.sealed.class=Convert to sealed class
replace.with.a.for.loop=Replace with a 'for' loop
convert.function.to.property=Convert function to property
convert.function.type.parameter.to.receiver=Convert function type parameter to receiver
convert.function.type.receiver.to.parameter=Convert function type receiver to parameter
convert.to.nullable.var=Convert to nullable var
convert.to.ordinary.property=Convert to ordinary property
replace.with.block.comment=Replace with block comment
convert.to.lateinit.var=Convert to lateinit var
convert.object.literal.to.class=Convert object literal to class
convert.to.lazy.property=Convert to lazy property
convert.parameter.to.receiver=Convert parameter to receiver
convert.to.secondary.constructor=Convert to secondary constructor
convert.property.getter.to.initializer=Convert property getter to initializer
convert.property.initializer.to.getter=Convert property initializer to getter
convert.property.to.function=Convert property to function
can.t.replace.foreign.reference.with.call.expression.0=Can''t replace foreign reference with call expression: {0}
unrecognized.reference.will.be.skipped.0=Unrecognized reference will be skipped: {0}
property.overloaded.in.child.class.constructor=Property overloaded in child class constructor
property.has.an.actual.declaration.in.the.class.constructor=Property has an actual declaration in the class constructor
convert.to.comparisons=Convert to comparisons
convert.receiver.to.parameter=Convert receiver to parameter
convert.reference.to.lambda=Convert reference to lambda
following.problems.are.found=Following problems are found:\n
all.expected.and.actual.classes.must.be.sealed.classes=All expected and actual classes must be sealed classes.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=All inheritors must be nested objects of the class itself and may not inherit from other classes or interfaces.\n
searching.inheritors=Searching inheritors...
convert.to.enum.class=Convert to enum class
convert.to.primary.constructor=Convert to primary constructor
rename.to.01=Rename to {0}
replace.0.name.with.spaces=Replace {0} name with spaces
convert.to.block.body=Convert to block body
convert.template.to.concatenated.string=Convert template to concatenated string
replace.with.a.foreach.function.call=Replace with a 'forEach' function call
convert.concatenation.to.raw.string=Convert concatenation to raw string
convert.concatenation.to.template=Convert concatenation to template
convert.try.finally.to.use=Convert try-finally to .use()
convert.to.unsafe.cast=Convert to unsafe cast
convert.to.0.as.1=Convert to ''{0} as {1}''
convert.to.0.unsafecast.1=Convert to ''{0}.unsafeCast<{1}>()''
convert.to.unsafecast.call=Convert to unsafeCast() call
convert.to.array.parameter=Convert to array parameter
convert.to.assignment.expression=Convert assignment to assignment expression
create.kotlin.subclass=Create Kotlin subclass
use.destructuring.declaration=Use destructuring declaration
implement.as.constructor.parameter=Implement as constructor parameter
implement.abstract.member=Implement abstract member
import.members.from.0=Import members from ''{0}''
import.members.with=Import members with '*'
add.import.for.0=Add import for ''{0}''
add.import.for.member=Add import for member
indent.raw.string=Indent raw string
replace.infix.call.with.ordinary.call=Replace infix call with ordinary call
insert.curly.braces.around.variable=Insert curly braces around variable
add.explicit.type.arguments=Add explicit type arguments
introduce.backing.property=Introduce backing property
introduce.import.alias=Introduce import alias
invert.if.condition=Invert 'if' condition
iterate.over.0=Iterate over ''{0}''
iterate.over.collection=Iterate over collection
join.declaration.and.assignment=Join declaration and assignment
can.be.joined.with.assignment=Can be joined with assignment
put.arguments.on.one.line=Put arguments on one line
put.parameters.on.one.line=Put parameters on one line
convert.lambda.expression.to.anonymous.function=Convert lambda expression to anonymous function
convert.to.anonymous.function=Convert to anonymous function
merge.else.if=Merge 'else if'
merge.if.s=Merge 'if's
move.lambda.argument.into.parentheses=Move lambda argument into parentheses
class.0.already.contains.1=Class ''{0}'' already contains {1}
0.in.1.will.require.class.instance=''{0}'' in {1} will require class instance
searching.for.0=Searching for {0}
move.out.of.companion.object=Move out of companion object
calls.with.explicit.extension.receiver.won.t.be.processed.0=Calls with explicit extension receiver won''t be processed: {0}
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=Usages of outer class instance inside of property ''{0}'' won''t be processed
companion.object.already.contains.0=Companion object already contains {0}
0.references.type.parameters.of.the.containing.class={0} references type parameters of the containing class
0.is.overridden.by.declaration.s.in.a.subclass={0} is overridden by declaration(s) in a subclass
move.to.companion.object=Move to companion object
move.to.top.level=Move to top level
package.0.already.contains.1=Package ''{0}'' already contains {1}
move.to.class.body=Move to class body
move.to.constructor=Move to constructor
convert.boolean.const.to.elvis=Convert Boolean? == const to elvis
convert.object.literal.to.lambda=Convert object literal to lambda
convert.to.lambda=Convert to lambda
replace.by.0=Replace by ''{0}''
replace.by.reconstructed.type=Replace by reconstructed type
remove.argument.name=Remove argument name
remove.braces.from.when.entry=Remove braces from 'when' entry
remove.braces.from.0.statement=Remove braces from ''{0}'' statement
remove.braces=Remove braces
remove.constructor.keyword=Remove constructor keyword
redundant.empty.class.body=Redundant empty class body
remove.unnecessary.parentheses.from.function.call.with.lambda=Remove unnecessary parentheses from function call with lambda
remove.empty.primary.constructor=Remove empty primary constructor
remove.empty.constructor.body=Remove empty constructor body
remove.explicit.lambda.parameter.types.may.break.code=Remove explicit lambda parameter types (may break code)
remove.explicit.supertype.qualification=Remove explicit supertype qualification
remove.explicit.type.arguments=Remove explicit type arguments
remove.explicit.type.specification=Remove explicit type specification
remove.indices.in.for.loop=Remove indices in 'for' loop
index.is.not.used.in.the.loop.body=Index is not used in the loop body
remove.return.0=Remove return@{0}
remove.labeled.return.from.last.expression.in.a.lambda=Remove labeled return from last expression in a lambda
remove.redundant.calls.of.the.conversion.method=Remove redundant calls of the conversion method
remove.single.expression.string.template=Remove single-expression string template
redundant.string.template=Redundant string template
remove.unnecessary.parentheses=Remove unnecessary parentheses
rename.class.to.0=Rename class to {0}
rename.class.to.containing.file.name=Rename class to containing file name
rename.file.to.0.1=Rename file to {0}.{1}
rename.file.to.match.top.level.class.name=Rename file to match top-level class name
replace.0.with=Replace ''{0}()'' with ''+=''
replace.with1=Replace with '+='
replace.explicit.parameter.0.with.it=Replace explicit parameter ''{0}'' with ''it''
replace.it.with.explicit.parameter=Replace 'it' with explicit parameter
replace.with.0.1.2=Replace with {0}[{1}] ?: {2}
replace.with.indexing.and.elvis.operator=Replace with indexing and elvis operator
replace.size.check.with.isnotempty=Replace size check with 'isNotEmpty'
replace.size.zero.check.with.isempty=Replace size zero check with 'isEmpty'
replace.with.parameter.name=Replace '_' with parameter name
replace.with.ordinary.assignment=Replace with ordinary assignment
simplify.boolean.expression=Simplify boolean expression
specify.explicit.lambda.signature=Specify explicit lambda signature
specify.all.types.explicitly.in.destructuring.declaration=Specify all types explicitly in destructuring declaration
cannot.infer.type.for.this.declaration=Cannot infer type for this declaration
split.if.into.two=Split 'if' into two
flip.0=Flip ''{0}''
flip.binary.expression=Flip binary expression
flip.equals=Flip 'equals'
replace.with.infix.function.call=Replace with infix function call
to.ordinary.string.literal=To ordinary string literal
to.raw.string.literal=To raw string literal
remove.underscores=Remove underscores
add.underscores=Add underscores
excluded.methods=Excluded methods
use.of.0.method.instead.of.property.access.syntax=Use of {0} method instead of property access syntax
use.property.access.syntax=Use property access syntax
convert.to.object.declaration=Convert to object declaration
comment=Comment
expression=Expression
statement=Statement
class=Class
object.declaration=Object declaration
top.level=Top-level
analyse.modules.with.different.platforms.together=Analyse modules with different platforms together
toggle.composite.analysis.mode.for.multiplatform=Toggle composite analysis mode for multiplatform
rethrow.stored.pce.as.a.new.runtime.exception=Rethrow stored PCE as a new runtime exception
internal.toggle.throwing.cached.pce=Internal: toggle throwing cached PCE
minimal.line.count=Minimal line count
files.to.visit=Files to visit
random.seed=Random seed
number.of.attempts.then.files.in.project.0=Number of attempts > then files in project, {0}
text.done=Done
file.lines=File lines
max.functions.to.visit=Max functions to visit
move.refactoring.testing=Move refactoring testing
compiling.project=Compiling project...
saving.files=Saving files...
perform.refactoring=Perform refactoring ...
update.indices=Update indices...
reset.files=Reset files...
cannot.get.or.create.results.file=Cannot get or create results file
cannot.get.project.root.directory=Cannot get project root directory
0.try.1.with.2.fails.and.3.verifications={0} [Try {1} with {2} fails and {3} verifications]
test.result.log.file.will.be.placed.here=Test result log file will be placed here
maximum.count.of.applied.refactoring.before.validity.check=Maximum count of applied refactoring before validity check
move.refactoring.test=Move refactoring test
resolve.pasted.references=resolve pasted references
create.kotlin.file=Create Kotlin file
type.alias.0=Type alias "{0}"
type.parameter.0=Type parameter "{0}"
parameter.0=Parameter "{0}"
property.0=Property "{0}"
function.01=Function "{0}"
object.0=Object "{0}"
interface=Interface
constructor=Constructor
implicit.nothing.type=Implicit `Nothing?` type
move.suspicious.callable.reference.into.parentheses=Move suspicious callable reference into parentheses '()'
local.variable=Local variable
const.property=Const property
private.property=Private property
object.or.top.level.property=Object or top-level property
property=Property
test.function=Test function
function=Function
enum.entry=Enum entry
create.subclass=Create subclass
implement.sealed.class=Implement sealed class
implement.abstract.class=Implement abstract class
implement.interface=Implement interface
implement.abstract.function=Implement abstract function
implement.abstract.property=Implement abstract property
replace.explicit.lambda.parameter.with.it=Replace explicit lambda parameter with 'it'
create.test=Create test
convert.class.0.to.kotlin=Convert class ''{0}'' to Kotlin
destination.directory=&Destination directory
language.version=&Language version
add.prefix.to.paths.in.source.map=Add prefix to paths in source map:
api.version=AP&I version
compiler.coroutines=Coro&utines
embed.source.code.into.source.map=Embed source code into source map:
enable.incremental.compilation=Enable incremental compilation
keep.compiler.process.alive.between.invocations=Keep compiler process alive between invocations
script.templates.classpath=Script templates class&path:
module.kind=Module &kind:
script.template.classes=Script &template classes:
target.jvm.version=Target &JVM version
reload.script.dependencies.on.file.change=Reload script dependencies on file change
additional.command.line.parameters=Additional command line parameters
mnemonic.install=&Install
status=(status)
build.number.internal.mode=Build number (internal mode):
check.again=Chec&k again
current.kotlin.plugin.version=Current Kotlin plugin version:
experimental.features=Experimental Features
action.text.install=Install
update.channel=Update &channel:
version={version}
don.t.show.this.dialog.next.time=&Don't show this dialog next time
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Clipboard content copied from Java file. Do you want to convert it to Kotlin code?
name=&Name:
return.type=&Return type:
visibility=&Visibility:
title.parameters=Parameters
signature.preview=Signature Preview
move.members.from=Move members from:
open.moved.members.in.editor=Open moved members in editor
open.moved.method.in.editor=Open moved method in editor
to.fully.qualified.name=To (fully qualified name):
toggle.library.to.source.dependency.support=Toggle library to source dependency support
enable.components.for.library.to.source.analysis.in.kotlin=Enable components for analyzing libraries depending on project source files in Kotlin
incomplete.destructuring.declaration.text=Incomplete destructuring declaration
incomplete.destructuring.fix.family.name=Add missing variables to destructuring declaration

action.Kotlin.StopScratch.text=Stop Scratch Execution
action.Kotlin.StopScratch.description=Stop scratch execution
action.Kotlin.ClearScratch.text=Clear Kotlin Scratch
action.Kotlin.ClearScratch.description=Clear kotlin scratch
action.Kotlin.RunScratch.text=Run Kotlin Scratch
action.Kotlin.RunScratch.description=Run kotlin scratch
action.KotlinGenerateToString.text=toString()
action.KotlinGenerateEqualsAndHashCode.text=equals() and hashCode()
action.KotlinGenerateSecondaryConstructor.text=Secondary Constructor
action.KotlinGenerateDataMethod.text=Parameters Function
action.KotlinGenerateTearDownMethod.text=TearDown Function
action.KotlinGenerateSetUpMethod.text=SetUp Function
action.KotlinGenerateTestMethod.text=Test Function
action.KotlinShellExecute.text=Execute Kotlin Code
action.KotlinShellExecute.description=Execute Kotlin code in console
action.IntroduceTypeAlias.text=Type _Alias...
action.IntroduceTypeParameter.text=T_ype Parameter...
action.ExtractFunctionToScope.text=Function to _Scope...
action.KotlinThrowException.text=Drop an Error from Kotlin Plugin
action.KotlinFormattingSettingsStatusAction.text=Formatter Settings Info
action.CopyAsDiagnosticTest.text=Copy Current File As Diagnostic Test
action.MultiplatformCompositeAnalysisToggleAction.text=Toggle Composite Analysis
action.StoredExceptionsThrowToggleAction.text=Throw Cached PCE
action.PrintOutNotPropertyMatches.text=Search Not Property Candidates
action.FindImplicitNothingAction.text=Find Implicit Nothing Calls
action.CheckComponentsUsageSearchAction.text=Check Component Functions Usage Search
action.CacheResetOnProcessCanceledToggleAction.text=Reset Caches on ProcessCanceledException
action.HighlightingBenchmarkAction.text=Benchmark Highlighting
action.LocalCompletionBenchmarkAction.text=Local Scenario
action.TopLevelCompletionBenchmarkAction.text=Top-Level Scenario
group.KotlinCompletionBenchmarkGroup.text=Benchmark Completion
group.KotlinInternalGroup.text=Kotlin
action.TestMoveRefactiringAction.text=Test Move Refactoring on Opened Project
group.KotlinRefactoringTesting.text=Kotlin Refactoring Testing
action.DumbModeTremble.text=Tremble Dumb Mode
group.InternalKotlin.text=Kotlin Internal Actions
action.IntroduceProperty.text=P_roperty...
action.ExtractFunction.text=_Function...
action.KotlinCodeMigrationToggle.text=Enable Migrations Detection (Experimental)
action.KotlinCodeMigration.text=Run Code Migrations
action.CopyKotlinProjectInformation.text=Copy Kotlin Project Overview To Clipboard
action.DecompileKotlinToJava.text=Decompile Kotlin To Java
action.KotlinConfigureUpdates.text=Configure Kotlin Plugin Updates
action.KotlinConfigureUpdates.description=Configure automatic updates for the Kotlin plugin
group.KotlinToolsGroup.text=Kotlin
action.ConvertJavaToKotlin.text=Convert Java File to Kotlin File
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Show Kotlin Variables Only
action.InspectBreakpointApplicability.text=Inspect Breakpoint Applicability
action.Kotlin.XDebugger.CoroutinesDump.text=Get Coroutines Dump
action.AddToProblemApiInspection.text=Report as Incompatible API
action.ShowKotlinBytecode.text=Show Kotlin Bytecode
action.ConfigureKotlinJsInProject.text=Configure Kotlin (JavaScript) in Project
action.ConfigureKotlinInProject.text=Configure Kotlin in Project
action.KotlinConsoleREPL.text=Kotlin REPL
action.LibraryToSourceDependencySupportToggleAction.text=Toggle library to source dependency support

inspection.unused.unary.operator.display.name=Unused unary operator
inspection.incomplete.destructuring.declaration.display.name=Incomplete destructuring declaration
inspection.replace.guard.clause.with.function.call.display.name=Replace guard clause with kotlin's function call
inspection.lateinit.var.overrides.lateinit.var.display.name=lateinit var property overrides lateinit var property
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
inspection.redundant.empty.initializer.block.display.name=Redundant empty initializer block
inspection.add.operator.modifier.display.name=Function should have 'operator' modifier
inspection.control.flow.with.empty.body.display.name=Control flow with empty body
inspection.replace.java.static.method.with.kotlin.analog.display.name=Replace Java static method with Kotlin analog
inspection.self.reference.constructor.parameter.display.name=Constructor has non-null self reference parameter
inspection.replace.not.null.assertion.with.elvis.return.display.name=Replace '!!' with '?: return'
inspection.kotlin.covariant.equals.display.name=Covariant 'equals()'
inspection.replace.associate.function.display.name=Replace 'associate' with 'associateBy' or 'associateWith'
inspection.java.map.for.each.display.name=Java Map.forEach method call should be replaced with Kotlin's forEach
inspection.kotlin.throwable.not.thrown.display.name=Throwable not thrown
inspection.redundant.require.not.null.call.display.name=Redundant 'requireNotNull' or 'checkNotNull' call
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Replace Range 'start' or 'endInclusive' with 'first' or 'last'
inspection.redundant.enum.constructor.invocation.display.name=Redundant enum constructor invocation
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Replace negated 'isEmpty'/'isBlank' with 'isNotEmpty'/'isNotBlank'
inspection.function.with.lambda.expression.body.display.name=Function with `= { ... }` and inferred return type
inspection.suspend.function.on.coroutine.scope.display.name=Ambiguous coroutineContext due to CoroutineScope receiver of suspend function
inspection.boolean.literal.argument.display.name=Boolean literal argument without parameter name
inspection.suspicious.collection.reassignment.display.name=Augmented assignment creates a new collection under the hood
inspection.redundant.else.in.if.display.name=Redundant 'else' in 'if'
inspection.deferred.is.result.display.name=Function returning Deferred directly
inspection.map.get.with.not.null.assertion.operator.display.name=map.get() with not-null assertion operator (!!)
inspection.delegation.to.var.property.display.name=Delegating to 'var' property
inspection.unused.main.parameter.display.name=Main parameter is not necessary
inspection.suspicious.var.property.display.name=Suspicious 'var' property: its setter does not influence its getter result
inspection.setter.backing.field.assignment.display.name=Existing backing field is not assigned by the setter
inspection.unlabeled.return.inside.lambda.display.name=Unlabeled return inside lambda
inspection.optional.expectation.display.name=Optionally expected annotation has no actual annotation
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Remove unnecessary parentheses
inspection.safe.cast.with.return.display.name=Safe cast with 'return' should be replaced with 'if' type check
inspection.simplifiable.call.display.name=Library function call could be simplified
inspection.redundant.run.catching.display.name=Redundant 'runCatching' call
inspection.direct.use.of.result.type.display.name=Function returning Result directly
inspection.redundant.return.label.display.name=Redundant 'return' label
inspection.replace.assert.boolean.with.assert.equality.display.name=Replace assert boolean with assert equality
inspection.suspicious.as.dynamic.display.name=Suspicious 'asDynamic' member invocation
inspection.convert.call.chain.into.sequence.display.name=Call chain on collection could be converted into 'Sequence' to improve performance
inspection.redundant.with.display.name=Redundant 'with' call
inspection.obsolete.experimental.coroutines.display.name=Experimental coroutines usages are deprecated since 1.3
inspection.obsolete.kotlin.js.packages.display.name='kotlin.browser' and 'kotlin.dom' packages are deprecated since 1.4
inspection.warning.on.main.unused.parameter.migration.display.name=Unused `args` on `main` since 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Repeatable annotation without `@Repeatable` are not allowed since 1.4
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Annotations on superclass are meaningless since 1.4
inspection.redundant.label.migration.display.name=Redundant labels since 1.4
inspection.restrict.return.statement.target.migration.display.name=Target label does not denote a function since 1.4
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name='@JvmOverloads' annotation cannot be used on constructors of annotation classes since 1.4
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Local variables are not allowed to have type parameters since 1.4
inspection.from.closed.range.migration.display.name=MIN_VALUE step in fromClosedRange() since 1.3
inspection.replace.to.string.with.string.template.display.name=Replace 'toString' with string template
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Nested lambda has shadowed implicit parameter
inspection.for.each.parameter.not.used.display.name=Iterated elements are not used in forEach
inspection.replace.string.format.with.literal.display.name=Replace with string templates
inspection.deferred.result.unused.display.name=Deferred result is never used
inspection.redundant.async.display.name=Redundant 'async' call
inspection.main.function.return.unit.display.name=Entry point function should return Unit
inspection.move.variable.declaration.into.when.display.name=Variable declaration could be moved inside `when`
inspection.move.lambda.outside.parentheses.display.name=Lambda argument inside parentheses
inspection.can.sealed.sub.class.be.object.display.name=Sealed sub-class without state and overridden equals
inspection.public.api.implicit.type.display.name=Public API declaration has implicit return type
inspection.redundant.companion.reference.display.name=Redundant Companion reference
inspection.convert.pair.constructor.to.to.function.display.name=Convert Pair constructor to 'to' function
inspection.redundant.not.null.extension.receiver.of.inline.display.name=Not-null extension receiver of inline function can be made nullable
inspection.platform.extension.receiver.of.inline.display.name=Unsafe call of inline function with nullable extension receiver
inspection.scope.function.conversion.display.name=Scope function can be converted to another one
inspection.redundant.object.type.check.display.name=Redundant type checks for object
inspection.fake.jvm.field.constant.display.name=Kotlin non-const property used as Java constant
inspection.may.be.constant.display.name=Might be 'const'
inspection.sort.modifiers.display.name=Non-canonical modifier order
inspection.redundant.suspend.modifier.display.name=Redundant 'suspend' modifier
inspection.replace.put.with.assignment.display.name=map.put() can be converted to assignment
inspection.replace.to.with.infix.form.display.name=Replace ’to’ with infix form
inspection.recursive.equals.call.display.name=Recursive equals call
inspection.java.collections.static.method.on.immutable.list.display.name=Call of Java mutator method on immutable Kotlin collection
inspection.java.collections.static.method.display.name=Java Collections static method call can be replaced with Kotlin stdlib
inspection.simplify.when.with.boolean.constant.condition.display.name=Simplifiable 'when'
inspection.implicit.nullable.nothing.type.display.name=Implicit `Nothing?` type
inspection.self.assignment.display.name=Assignment of variable to itself
inspection.redundant.unit.expression.display.name=Redundant 'Unit'
inspection.implicit.this.display.name=Implicit 'this'
inspection.explicit.this.display.name=Redundant explicit 'this'
inspection.migrate.diagnostic.suppression.display.name=Diagnostic name should be replaced
inspection.redundant.setter.display.name=Redundant property setter
inspection.remove.redundant.qualifier.name.display.name=Remove redundant qualifier name
inspection.remove.redundant.backticks.display.name=Remove redundant backticks
inspection.redundant.getter.display.name=Redundant property getter
inspection.suspicious.equals.combination.display.name=Suspicious combination of == and ===
inspection.kotlin.redundant.override.display.name=Redundant overriding method
inspection.package.name.display.name=Package naming convention
inspection.local.variable.name.display.name=Local variable naming convention
inspection.const.property.name.display.name=Const property naming convention
inspection.private.property.name.display.name=Private property naming convention
inspection.object.property.name.display.name=Object property naming convention
inspection.property.name.display.name=Property naming convention
inspection.test.function.name.display.name=Test function naming convention
inspection.function.name.display.name=Function naming convention
inspection.enum.entry.name.display.name=Enum entry naming convention
inspection.class.name.display.name=Class naming convention
inspection.redundant.lambda.arrow.display.name=Redundant lambda arrow
inspection.when.with.only.else.display.name='when' has only 'else' branch and can be simplified
inspection.kotlin.double.negation.display.name=Redundant double negation
inspection.unnecessary.variable.display.name=Unnecessary local variable
inspection.constant.condition.if.display.name=Condition of 'if' expression is constant
inspection.null.checks.to.safe.call.display.name=Null-checks replaceable with safe-calls
inspection.cascade.if.display.name=Cascade if can be replaced with when
inspection.lift.return.or.assignment.display.name=Return or assignment can be lifted out
inspection.use.expression.body.display.name=Expression body syntax is preferable here
inspection.simplifiable.call.chain.display.name=Call chain on collection type can be simplified
inspection.useless.call.on.collection.display.name=Useless call on collection type
inspection.redundant.explicit.type.display.name=Explicitly given type is redundant here
inspection.useless.call.on.not.null.display.name=Useless call on not-null type
inspection.remove.redundant.spread.operator.display.name=Redundant spread operator
inspection.empty.range.display.name=Range with start greater than endInclusive is empty
inspection.wrap.unary.operator.display.name=Ambiguous unary operator use with number constant
inspection.nullable.boolean.elvis.display.name=Equality check can be used instead of elvis for nullable boolean check
inspection.member.visibility.can.be.private.display.name=Class member can have 'private' visibility
inspection.replace.range.to.with.until.display.name='rangeTo' or the '..' call can be replaced with 'until'
inspection.recursive.property.accessor.display.name=Recursive property accessor
inspection.replace.array.of.with.literal.display.name='arrayOf' call can be replaced with array literal [...]
inspection.copy.without.named.arguments.display.name='copy' method of data class is called without named arguments
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Suspicious callable reference used as lambda result
inspection.kotlin.internal.in.java.display.name=Usage of Kotlin internal declarations from Java
inspection.unused.lambda.expression.body.display.name=Unused return value of a function with lambda expression body
inspection.destructuring.wrong.name.display.name=Variable in destructuring declaration uses name of a wrong data class property
inspection.data.class.private.constructor.display.name=Private data class constructor is exposed via the 'copy' method
inspection.replace.with.enum.map.display.name=Replace with EnumMap
inspection.unused.equals.display.name=Unused equals expression
inspection.convert.na.n.equality.display.name=Convert equality check with 'NaN' to 'isNaN' call
inspection.convert.two.comparisons.to.range.check.display.name=Two comparisons should be converted to a range check
inspection.convert.try.finally.to.use.call.display.name=Convert try / finally to use() call
inspection.join.declaration.and.assignment.display.name=Join declaration and assignment
inspection.remove.empty.secondary.constructor.body.display.name=Remove empty constructor body
inspection.remove.empty.primary.constructor.display.name=Remove empty primary constructor
inspection.remove.redundant.calls.of.conversion.methods.display.name=Remove redundant calls of conversion methods
inspection.remove.empty.class.body.display.name=Replace empty class body
inspection.replace.size.zero.check.with.is.empty.display.name=Replace size zero check with 'isEmpty()'
inspection.replace.size.check.with.is.not.empty.display.name=Replace size check with 'isNotEmpty()'
inspection.convert.secondary.constructor.to.primary.display.name=Convert to primary constructor
inspection.complex.redundant.let.display.name=Redundant argument-based `let` call
inspection.simple.redundant.let.display.name=Redundant receiver-based `let` call
inspection.replace.array.equality.op.with.arrays.equals.display.name=Replace '==' with 'Arrays.equals'
inspection.remove.empty.parentheses.from.lambda.call.display.name=Remove unnecessary parentheses from function call with lambda
inspection.remove.to.string.in.string.template.display.name=Remove redundant call to 'toString()' in string template
inspection.remove.single.expression.string.template.display.name=Remove redundant string template
inspection.replace.call.with.binary.operator.display.name=Can be replaced with binary operator
inspection.remove.setter.parameter.type.display.name=Redundant setter parameter type
inspection.convert.reference.to.lambda.display.name=Can be replaced with lambda
inspection.convert.lambda.to.reference.display.name=Can be replaced with function reference
inspection.can.be.primary.constructor.property.display.name=Property is explicitly assigned to constructor parameter
inspection.has.platform.type.display.name=Function or property has platform type
inspection.leaking.this.display.name=Leaking 'this' in constructor
inspection.redundant.if.display.name=Redundant 'if' statement
inspection.redundant.unit.return.type.display.name=Redundant 'Unit' return type
inspection.redundant.semicolon.display.name=Redundant semicolon
inspection.redundant.modality.modifier.display.name=Redundant modality modifier
inspection.can.be.parameter.display.name=Constructor parameter is never used as a property
inspection.replace.substring.with.substring.before.display.name=Replace 'substring' call with 'substringBefore' call
inspection.replace.substring.with.substring.after.display.name=Replace 'substring' call with 'substringAfter' call
inspection.replace.substring.with.indexing.operation.display.name=Replace 'substring' call with indexing operation call
inspection.replace.substring.with.take.display.name=Replace 'substring' call with 'take' call
inspection.replace.substring.with.drop.last.display.name=Replace 'substring' call with 'dropLast' call
inspection.add.variance.modifier.display.name=Type parameter can have 'in' or 'out' variance
inspection.protected.in.final.display.name='protected' visibility is effectively 'private' in a final class
inspection.array.in.data.class.display.name=Array property in data class
inspection.can.be.val.display.name=Local 'var' is never modified and can be declared as 'val'
inspection.destructure.display.name=Use destructuring declaration
inspection.redundant.visibility.modifier.display.name=Redundant visibility modifier
inspection.equals.or.hash.code.display.name=equals() and hashCode() not paired
inspection.conflicting.extension.property.display.name=Extension property conflicting with synthetic one
inspection.use.with.index.display.name=Manually incremented index variable can be replaced with use of 'withIndex()'
inspection.loop.to.call.chain.display.name=Loop can be replaced with stdlib operations
inspection.remove.for.loop.indices.display.name=Unused loop index
inspection.kotlin.deprecation.display.name=Usage of redundant or deprecated syntax or deprecated symbols
inspection.package.directory.mismatch.display.name=Package name does not match containing directory
inspection.k.doc.missing.documentation.display.name=Missing KDoc comments for public declarations
inspection.k.doc.unresolved.reference.display.name=Unresolved reference in KDoc
inspection.overriding.deprecated.member.display.name=Overriding deprecated member
inspection.unsafe.cast.from.dynamic.display.name=Implicit (unsafe) cast from dynamic type
inspection.redundant.sam.constructor.display.name=Redundant SAM constructor
inspection.kotlin.unused.import.display.name=Unused import directive
inspection.unused.receiver.parameter.display.name=Unused receiver parameter
inspection.unused.symbol.display.name=Unused symbol
inspection.use.property.access.syntax.display.name=Accessor call that can be replaced with property access syntax
inspection.simplify.boolean.with.constants.display.name=Boolean expression that can be simplified
inspection.remove.curly.braces.from.template.display.name=Redundant curly braces in string template
inspection.introduce.when.subject.display.name='when' that can be simplified by introducing an argument
inspection.replace.with.operator.assignment.display.name=Assignment that can be replaced with operator assignment
inspection.simplify.negated.binary.expression.display.name=Negated boolean expression that can be simplified
inspection.remove.explicit.super.qualifier.display.name=Unnecessary supertype qualification
inspection.remove.explicit.type.arguments.display.name=Unnecessary type argument
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... foldable to '?:'
inspection.if.then.to.safe.access.display.name=If-Then foldable to '?.'
inspection.if.then.to.elvis.display.name=If-Then foldable to '?:'
inspection.replace.manual.range.with.indices.calls.display.name=Convert manual ranges to indices or iteration over collection
inspection.replace.get.or.set.display.name=Explicit 'get' or 'set' call
inspection.convert.to.string.template.display.name=String concatenation that can be converted to string template
inspection.deprecated.callable.add.replace.with.display.name=@Deprecated annotation without 'replaceWith' argument
inspection.replace.collection.count.with.size.display.name=Collection count can be converted to size
inspection.reformat.display.name=File is not formatted according to project settings
inspection.simplify.assert.not.null.display.name=‘assert’ call can be replaced with ‘!!’ or ‘?:'
inspection.object.literal.to.lambda.display.name=Object literal can be converted to lambda
remove.redundant.elvis.return.null.text=Remove redundant '?: return null'
inspection.redundant.elvis.return.null.descriptor=Redundant '?: return null'
inspection.redundant.elvis.return.null.display.name=Redundant '?: return null'
inspection.redundant.inner.class.modifier.descriptor=Redundant 'inner' modifier
inspection.redundant.inner.class.modifier.display.name=Redundant 'inner' modifier
fix.remove.annotation.text=Remove annotation
inspection.trailing.comma.display.name=Trailing comma recommendations
inspection.trailing.comma.report.also.a.missing.comma=Report also a missing comma or a line break
inspection.trailing.comma.add.line.break=Add line break
inspection.trailing.comma.missing.line.break=Missing line break
inspection.trailing.comma.remove.trailing.comma=Remove trailing comma
inspection.trailing.comma.useless.trailing.comma=Useless trailing comma
inspection.trailing.comma.add.trailing.comma=Add trailing comma
inspection.trailing.comma.missing.trailing.comma=Missing trailing comma
inspection.trailing.comma.fix.comma.position=Fix comma position
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=Comma loses the advantages in this position
inspection.redundant.label.text=Redundant label
intention.convert.lambda.line=Convert to {0,choice,0#single|1#multi}-line lambda
intention.trailing.comma.custom.text={0,choice,0#Enable|1#Disable} a trailing comma by default in the formatter
intention.trailing.comma.text=Enable/disable a trailing comma in the formatter
fix.remove.argument.text=Remove argument
fix.remove.redundant.star.text=Remove redundant *
refactoring.extract.to.separate.file.text=Extract to separate file
action.usage.update.text=Usage update
progress.title.analyze.extraction.data=Analyze extraction data...
fix.move.file.to.package.dir.name.text=source root
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=Cannot perform refactoring since the following files already exist:\n\n
kotlin.script.definitions.title=Manage Script Definitions
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Enable auto reload if you want to load script configurations automatically on file change
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Auto Reload
kotlin.script.definitions.model.name.is.enabled=Is Enabled
kotlin.script.definitions.model.name.pattern.extension=Pattern/Extension
kotlin.script.definitions.model.name.name=Name
codestyle.name.kotlin=Kotlin
add.missing.class.keyword=Add missing 'class' keyword
fix.move.typealias.to.top.level=Move typealias to top level
fix.change.jvm.name=Change JVM name
expand.boolean.expression.to.if.else=Expand boolean expression to 'if else'
inspection.logger.initialized.with.foreign.class.display.name=Logger initialized with foreign class
logger.initialized.with.foreign.class=Logger initialized with foreign class ''{0}''
logger.factory.method.name=Logger factory method name
logger.factory.class.name=Logger factory class name
choose.logger.factory.class=Choose logger factory class
inspection.redundant.assequence.call=Redundant 'asSequence' call
remove.assequence.call.fix.text=Remove 'asSequence' call
codestyle.layout.import.aliases.separately=Import aliases separately
button.add.package=Add Package
listbox.import.package=Package
listbox.import.with.subpackages=With Subpackages
title.import.layout=Import Layout
title.packages.to.use.import.with=Packages to Use Import with '*'
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Unnecessary non-direct parent classes qualifiers
fix.add.exception.to.throws=Add ''{0}''
fix.add.eq.eq.true=Add '== true'
inspection.replace.with.ignore.case.equals.display.name=Replace with 'equals(..., ignoreCase = true)'
inspection.redundant.nullable.return.type.display.name=Redundant nullable return type
0.always.returns.non.null.type=''{0}'' always returns non-null type
0.is.always.non.null.type=''{0}'' is always non-null type
inspection.simplifiable.scope.function.display.name=Scope function with nested forEach can be simplified
nested.1.call.in.0.could.be.simplified.to.2=Nested ''{1}'' call in ''{0}'' could be simplified to {2}
evaluate.compile.time.expression=Evaluate compile-time expression

hints.title.codevision=Code Vision
hints.title.codevision.show.hints.for=Show hints for:
hints.title.codevision.usages=Usages
hints.title.codevision.inheritors=Implementations/Inheritors/Overrides

hints.codevision.usages.format={0, choice, 1#1 Usage|2#{0,number} Usages}
hints.codevision.usages.too_many.format={0,number}+ Usages
hints.codevision.implementations.format={0, choice, 1#1 Implementation|2#{0,number} Implementations}
hints.codevision.implementations.too_many.format={0,number}+ Implementations
hints.codevision.inheritors.format={0, choice, 1#1 Inheritor|2#{0,number} Inheritors}
hints.codevision.inheritors.to_many.format={0,number}+ Inheritors
hints.codevision.overrides.format={0, choice, 1#1 Override|2#{0,number} Overrides}
hints.codevision.overrides.to_many.format={0,number}+ Overrides
hints.codevision.settings=Settings...