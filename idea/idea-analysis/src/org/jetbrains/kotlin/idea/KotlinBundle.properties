#quick fix messages
add.return.type=Add return type declaration
add.init.keyword=Add 'init' keyword
add.init.keyword.family=Add 'init' keyword
add.init.keyword.in.whole.project=Add 'init' keyword in whole project
add.init.keyword.in.whole.project.modal.title=Adding 'init' keyword in whole project
add.init.keyword.in.whole.project.family=Add 'init' keyword in whole project
insert.delegation.call=Insert ''{0}()'' call
remove.useless.nullable=Remove useless '?'
replace.operation.in.binary.expression=Replace operation in a binary expression
replace.cast.with.static.assert=Replace a cast with a static assert
introduce.non.null.assertion=Add non-null asserted (!!) call
remove.unnecessary.non.null.assertion=Remove unnecessary non-null assertion (!!)
change.to.backing.field=Change reference to backing field
implement.members=Implement members
import.fix=Import
imports.chooser.title=Imports
rename.kotlin.package.class.error=Can't rename Kotlin package facade class
add.semicolon.after.invocation=Add semicolon after invocation of ''{0}''
add.semicolon.family=Add Semicolon
change.type=Change type from ''{0}'' to ''{1}''
change.type.family=Change type
change.function.signature=Change the signature of function ''{0}''

replace.call.error.skipped.defaults=Cannot skip default arguments.
replace.call.error.undefined.returntype=Unable to determine the return type.
replace.call.error.duplicate.or.missing.arguments=Duplicate or missing arguments.
replace.call.error.invalid.arguments=Invalid arguments included.

replace.call.error.vararg.not.last=Cannot handle named arguments after a vararg.
replace.call.error.contains.returns_boolean=Contains must return a Boolean.

add.kotlin.signature.action.family.name=Specify Custom Kotlin Signature
add.kotlin.signature.action.text=Specify custom Kotlin signature
edit.kotlin.signature.action.text=Edit custom Kotlin signature
view.kotlin.signature.action.text=View custom Kotlin signature

goto.super.function.chooser.title=Choose super function
goto.super.property.chooser.title=Choose super property
goto.super.class.chooser.title=Choose super class or interface

unused.receiver.parameter=Receiver parameter is never used
unused.receiver.parameter.remove=Remove redundant receiver parameter

livetemplate.description.main=main() function
livetemplate.description.soutp=Prints function parameter names and values to System.out
livetemplate.description.iter=Iterate over elements of iterable (for-in loop)
livetemplate.description.ifn=Inserts ''if null'' expression
livetemplate.description.inn=Inserts ''if not null'' expression
livetemplate.description.void=Function returning nothing
livetemplate.description.fun0=Function with no parameters
livetemplate.description.fun1=Function with one parameter
livetemplate.description.fun2=Function with two parameters
livetemplate.description.interface=Interface
livetemplate.description.singleton=Singleton
livetemplate.description.closure=Closure (function without name)
livetemplate.description.anonymous=Anonymous class
livetemplate.description.exfun=Extension function
livetemplate.description.exval=Extension read-only property
livetemplate.description.exvar=Extension read-write property

options.kotlin.attribute.descriptor.annotation=Annotation
options.kotlin.attribute.descriptor.builtin.annotation=Modifier
options.kotlin.attribute.descriptor.string.escape=String//Escape in string and template braces
options.kotlin.attribute.descriptor.closure.braces=Braces and Operators//Lambda expression braces and arrow
options.kotlin.attribute.descriptor.safe.access=Braces and Operators//Safe access dot
options.kotlin.attribute.descriptor.arrow=Braces and Operators//Arrow
options.kotlin.attribute.descriptor.kdoc.comment=Comments//KDoc//KDoc comment
options.kotlin.attribute.descriptor.kdoc.tag=Comments//KDoc//KDoc tag
options.kotlin.attribute.descriptor.kdoc.value=Comments//KDoc//Link in KDoc tag
options.kotlin.attribute.descriptor.object=Classes and Interfaces//Object
options.kotlin.attribute.descriptor.enumEntry=Classes and Interfaces//Enum entry
options.kotlin.attribute.descriptor.var=Properties and Variables//Var (mutable variable, parameter or property)
options.kotlin.attribute.descriptor.local.variable=Properties and Variables//Local variable or value
options.kotlin.attribute.descriptor.captured.variable=Properties and Variables//Variables and values captured in a closure
options.kotlin.attribute.descriptor.instance.property=Properties and Variables//Instance property
options.kotlin.attribute.descriptor.package.property=Properties and Variables//Package-level property
options.kotlin.attribute.descriptor.field=Properties and Variables//Backing field variable
options.kotlin.attribute.descriptor.extension.property=Properties and Variables//Extension property
options.kotlin.attribute.descriptor.dynamic.property=Properties and Variables//Dynamic property
options.kotlin.attribute.descriptor.android.extensions.property=Properties and Variables//Android Extensions synthetic properties
options.kotlin.attribute.descriptor.it=Parameters//Lambda expression default parameter
options.kotlin.attribute.descriptor.fun=Functions//Function declaration
options.kotlin.attribute.descriptor.fun.call=Functions//Function call
options.kotlin.attribute.descriptor.dynamic.fun.call=Functions//Dynamic function call
options.kotlin.attribute.descriptor.package.fun.call=Functions//Package-level function call
options.kotlin.attribute.descriptor.extension.fun.call=Functions//Extension function call
options.kotlin.attribute.descriptor.constructor.call=Functions//Constructor call
options.kotlin.attribute.descriptor.variable.as.function.call=Properties and Variables//Variable as function call
options.kotlin.attribute.descriptor.variable.as.function.like.call=Properties and Variables//Variable as function-like call
options.kotlin.attribute.descriptor.smart.cast=Smart-casts//Smart-cast value
options.kotlin.attribute.descriptor.smart.constant=Smart-casts//Smart constant
options.kotlin.attribute.descriptor.smart.cast.receiver=Smart-casts//Smart-cast implicit receiver
options.kotlin.attribute.descriptor.label=Label

migrate.sure=Replace sure() calls by !! in project
migrate.class.object.to.companion=Replace 'class' keyword with 'companion' modifier
migrate.class.object.to.companion.family=Replace 'class' Keyword with 'companion' Modifier
migrate.class.object.to.companion.in.whole.project=Replace 'class' keyword with 'companion' modifier in whole project
migrate.class.object.to.companion.in.whole.project.modal.title=Replacing 'class' keyword with 'companion' modifier in whole project
migrate.class.object.to.companion.in.whole.project.family=Replace 'class' Keyword with 'companion' Modifier in Whole Project
migrate.lambda.syntax=Migrate lambda syntax
migrate.lambda.syntax.family=Migrate lambda syntax
change.to.property.name.family.name=Change to property name
change.to.property.name.action=Change ''{0}'' to ''{1}''
create.from.usage.family=Create from usage
create.local.variable.from.usage=Create local variable ''{0}''
create.parameter.from.usage=Create parameter ''{0}''
surround.with=Surround with
surround.with.string.template="${expr}"
surround.with.when.template=when (expr) {}
surround.with.runtime.type.cast.template=(expr as RuntimeType)
surround.with.function.template={ }
surround.with.cannot.perform.action=Cannot perform Surround With action to the current contextsurround.with.function.template={ }
kotlin.code.transformations=Kotlin Code Transformations
fold.if.to.call=Replace 'if' expression with method call
fold.if.to.call.family=Replace 'if' Expression with Method Call
fold.when.to.call=Replace 'when' expression with method call
fold.when.to.call.family=Replace 'when' Expression with Method Call
unfold.call.to.if=Replace method call with 'if' expression
unfold.call.to.if.family=Replace Method Call with 'if' Expression
unfold.call.to.when=Replace method call with 'when' expression
unfold.call.to.when.family=Replace Method Call with 'when' Expression
transform.if.statement.with.assignments.to.expression=Transform 'if' statement with assignments to expression
transform.assignment.with.if.expression.to.statement=Transform assignment with 'if' expression to statement
transform.if.statement.with.assignments.to.expression.family=Transform 'if' Statement with Assignments to Expression
transform.assignment.with.if.expression.to.statement.family=Transform Assignment with 'if' Expression to Statement

replace.java.class.argument=Replace javaClass<T>() with T::class
replace.java.class.argument.family=Replace javaClass<T>() with T::class

replace.java.class.parameter=Replace Class<T> with KClass<T> in whole annotation
replace.java.class.parameter.family=Replace Class<T> with KClass<T> in whole annotation

property.is.implemented.too.many=Has implementations
property.is.overridden.too.many=Is overridden in subclasses
property.is.implemented.header=Is implemented in <br/>
property.is.overridden.header=Is overridden in <br/>

navigation.title.overriding.property=Choose Implementation of {0}
navigation.findUsages.title.overriding.property=Overriding properties of {0}
navigation.title.super.declaration=Choose Super Implementation of {0}
navigation.findUsages.title.super.declaration=Super Implementations of {0}

remove.expression = Remove ''{0}''
unwrap.expression = Unwrap ''{0}''
remove.else = Remove else in ''{0}''
unwrap.else = Unwrap else in ''{0}''

usageType.annotation.type = Annotation
usageType.import = Import directive
usageType.callable.reference = Callable reference
usageType.type.constraint = Type constraint
usageType.type.argument = Type argument
usageType.value.parameter.type = Parameter type
usageType.nonLocal.property.type = Class/object property type
usageType.local.variable.type = Local variable type
usageType.function.return.type = Function return types
usageType.superType = Supertype
usageType.is = Target type of 'is' operation
usageType.as = Target type of 'as' operation
usageType.class.object = Nested class/object
usageType.companion.object = Companion object
usageType.instantiation = Instantiation
usageType.function.call = Function call
usageType.implicit.get = Implicit 'get'
usageType.implicit.set = Implicit 'set'
usageType.implicit.invoke = Implicit 'invoke'
usageType.implicit.iteration = Implicit iteration
usageType.property.delegation = Property delegation
usageType.extension.receiver.type = Extension receiver type
usageType.super.type.qualifier = Super type qualifier
usageType.receiver = Receiver
usageType.selector = Selector
usageType.delegate = Delegate
usageType.packageDirective = Package directive
usageType.packageMemberAccess = Package member access

x.in.y={0} in {1}
x.implements.y={0} in {1} implements {2} in {3}.
x.overrides.y.in.class.list={0} overrides declarations in the following classes/interfaces: {1} Do you want to {2} the base declarations?

unused.overriding.methods.title=Unused Overriding Members
there.are.unused.methods.that.override.methods.you.delete=There are unused members that override methods you delete.
choose.the.ones.you.want.to.be.deleted=Choose the ones you want to be deleted.
method.column=Member
delete.param.in.method.hierarchy={0} is a part of method hierarchy. Do you want to delete multiple parameters?

find.what.implementing.methods.checkbox=&Implementing functions
find.what.overriding.methods.checkbox=Over&riding functions
find.what.implementing.properties.checkbox=&Implementing properties
find.what.overriding.properties.checkbox=Over&riding properties
find.what.property.readers.checkbox=Readers
find.what.property.writers.checkbox=Writers
find.options.include.overloaded.methods.checkbox=Include o&verloaded functions and extensions
find.what.functions.usages.checkbox=Usages of &functions
find.what.properties.usages.checkbox=Usages of &properties
find.what.constructor.usages.checkbox=Usages of &constructor
find.what.derived.classes.checkbox=&Derived classes
find.what.derived.interfaces.checkbox=Derived &interfaces

hierarchy.legend.member.is.defined.in.class=Member is defined in the class
hierarchy.legend.member.defined.in.superclass=Member is not defined in the class but defined in superclass
hierarchy.legend.member.should.be.defined=Member should be defined since the class is not abstract

suppress.warnings.family=Suppress Warnings
suppress.warning.for=Suppress ''{0}'' for {1} {2}

reflection.not.found=Reflection not found in the classpath
add.reflection.to.classpath=Add kotlin-reflect.jar to the classpath
add.test.to.classpath=Add kotlin-test.jar to the classpath

# Kotlin Compiler Settings Tab

#Common
kotlin.compiler.option.generate.no.warnings=Report compiler &warnings
kotlin.compiler.option.additional.command.line.parameters=&Additional command line parameters:
kotlin.compiler.option.additional.command.line.parameters.dialog.title=Additional command line parameters

# Kotlin to JVM
kotlin.compiler.jvm.option.panel.title=Kotlin to JVM

# Kotlin to JavaScript
kotlin.compiler.js.option.panel.title=Kotlin to JavaScript
kotlin.compiler.js.option.generate.sourcemaps=Generate &source maps
kotlin.compiler.js.option.output.prefix=File to &prepend to generated code:
kotlin.compiler.js.option.output.postfix=File to append to generated c&ode:
kotlin.compiler.js.option.output.prefix.browse.title=Choose file to prepend to generated code
kotlin.compiler.js.option.output.postfix.browse.title=Choose file to append to generated code
kotlin.compiler.js.option.output.copy.files=&Copy library runtime files
kotlin.compiler.js.option.output.copy.dir=O&utput directory for library &runtime files:

# Debugger
debugger.filter.ignore.internal.classes=Do not step into Kotlin runtime library implementation classes
debugger.data.view.delegated.properties=Calculate values of delegated properties (may affect program execution)
debugger.field.watchpoints.tab.title=Kotlin Field Watchpoints
debugger.field.watchpoints.properties.panel.field.access.label=Field &access
debugger.field.watchpoints.properties.panel.field.modification.label=Field &modification
debugger.field.watchpoints.properties.panel.field.initialization.label=Field &initialization

# Android Lint
android.klint.inspections.group.name=Android Lint for Kotlin